{"patch": "diff --git a/icu4c/source/i18n/regexcmp.cpp b/icu4c/source/i18n/regexcmp.cpp\nindex a4c12804237..d320bf34bcb 100644\n--- a/icu4c/source/i18n/regexcmp.cpp\n+++ b/icu4c/source/i18n/regexcmp.cpp\n@@ -55,6 +55,7 @@ U_NAMESPACE_BEGIN\n RegexCompile::RegexCompile(RegexPattern *rxp, UErrorCode &status) :\n    fParenStack(status), fSetStack(status), fSetOpStack(status)\n {\n+    static const int32_t MAX_NEXTCHAR_RECURSION_DEPTH = 100;\n     // Lazy init of all shared global sets (needed for init()'s empty text)\n     RegexStaticSets::initGlobals(&status);\n \n@@ -71,6 +72,7 @@ RegexCompile::RegexCompile(RegexPattern *rxp, UErrorCode &status) :\n     fModeFlags        = fRXPat->fFlags | 0x80000000;\n     fEOLComments      = TRUE;\n \n+    fNextCharRecursionDepth = 0;\n     fMatchOpenParen   = -1;\n     fMatchCloseParen  = -1;\n     fCaptureName      = NULL;\n@@ -4009,8 +4011,18 @@ UChar32  RegexCompile::peekCharLL() {\n //                The rest of the pattern grammar is handled at the next level up.\n //\n //------------------------------------------------------------------------------\n+static const int32_t MAX_NEXTCHAR_RECURSION_DEPTH = 100;\n+\n void RegexCompile::nextChar(RegexPatternChar &c) {\n \n+    // Check for excessive recursion depth to prevent stack overflow\n+    if (fNextCharRecursionDepth >= MAX_NEXTCHAR_RECURSION_DEPTH) {\n+        error(U_REGEX_STACK_OVERFLOW);\n+        c.fChar = (UChar32)-1;  // Set to EOF to stop processing\n+        c.fQuoted = FALSE;\n+        return;\n+    }\n+\n     fScanIndex = UTEXT_GETNATIVEINDEX(fRXPat->fPattern);\n     c.fChar    = nextCharLL();\n     c.fQuoted  = FALSE;\n@@ -4021,7 +4033,9 @@ void RegexCompile::nextChar(RegexPatternChar &c) {\n             c.fChar == (UChar32)-1) {\n             fQuoteMode = FALSE;  //  Exit quote mode,\n             nextCharLL();        // discard the E\n+            fNextCharRecursionDepth++;\n             nextChar(c);         // recurse to get the real next char\n+            fNextCharRecursionDepth--;\n         }\n     }\n     else if (fInBackslashQuote) {\n@@ -4140,7 +4154,9 @@ void RegexCompile::nextChar(RegexPatternChar &c) {\n                 //  \"\\Q\"  enter quote mode, which will continue until \"\\E\"\n                 fQuoteMode = TRUE;\n                 nextCharLL();       // discard the 'Q'.\n+                fNextCharRecursionDepth++;\n                 nextChar(c);        // recurse to get the real next char.\n+                fNextCharRecursionDepth--;\n             }\n             else\n             {\ndiff --git a/icu4c/source/i18n/regexcmp.h b/icu4c/source/i18n/regexcmp.h\nindex f2aeea909e7..8e787d71dcb 100644\n--- a/icu4c/source/i18n/regexcmp.h\n+++ b/icu4c/source/i18n/regexcmp.h\n@@ -149,6 +149,7 @@ class U_I18N_API RegexCompile : public UMemory {\n     UChar32                       fLastChar;         // Previous char, needed to count CR-LF\n                                                      //   as a single line, not two.\n     UChar32                       fPeekChar;         // Saved char, if we've scanned ahead.\n+    int32_t                       fNextCharRecursionDepth; // Recursion depth counter for nextChar()\n \n \n     RegexPatternChar              fC;                // Current char for parse state machine\n", "result": true}