{"patch": "diff --git a/icu4c/source/i18n/regexcmp.cpp b/icu4c/source/i18n/regexcmp.cpp\nindex a4c12804237..2058a6a48e2 100644\n--- a/icu4c/source/i18n/regexcmp.cpp\n+++ b/icu4c/source/i18n/regexcmp.cpp\n@@ -4012,152 +4012,105 @@ UChar32  RegexCompile::peekCharLL() {\n void RegexCompile::nextChar(RegexPatternChar &c) {\n \n     fScanIndex = UTEXT_GETNATIVEINDEX(fRXPat->fPattern);\n-    c.fChar    = nextCharLL();\n-    c.fQuoted  = FALSE;\n-\n-    if (fQuoteMode) {\n-        c.fQuoted = TRUE;\n-        if ((c.fChar==chBackSlash && peekCharLL()==chE && ((fModeFlags & UREGEX_LITERAL) == 0)) ||\n-            c.fChar == (UChar32)-1) {\n-            fQuoteMode = FALSE;  //  Exit quote mode,\n-            nextCharLL();        // discard the E\n-            nextChar(c);         // recurse to get the real next char\n-        }\n-    }\n-    else if (fInBackslashQuote) {\n-        // The current character immediately follows a '\\'\n-        // Don't check for any further escapes, just return it as-is.\n-        // Don't set c.fQuoted, because that would prevent the state machine from\n-        //    dispatching on the character.\n-        fInBackslashQuote = FALSE;\n-    }\n-    else\n-    {\n-        // We are not in a \\Q quoted region \\E of the source.\n-        //\n-        if (fModeFlags & UREGEX_COMMENTS) {\n-            //\n-            // We are in free-spacing and comments mode.\n-            //  Scan through any white space and comments, until we\n-            //  reach a significant character or the end of inut.\n-            for (;;) {\n-                if (c.fChar == (UChar32)-1) {\n-                    break;     // End of Input\n-                }\n-                if  (c.fChar == chPound && fEOLComments == TRUE) {\n-                    // Start of a comment.  Consume the rest of it, until EOF or a new line\n-                    for (;;) {\n-                        c.fChar = nextCharLL();\n-                        if (c.fChar == (UChar32)-1 ||  // EOF\n-                            c.fChar == chCR        ||\n-                            c.fChar == chLF        ||\n-                            c.fChar == chNEL       ||\n-                            c.fChar == chLS)       {\n-                            break;\n-                        }\n-                    }\n-                }\n-                // TODO:  check what Java & Perl do with non-ASCII white spaces.  Ticket 6061.\n-                if (PatternProps::isWhiteSpace(c.fChar) == FALSE) {\n-                    break;\n-                }\n-                c.fChar = nextCharLL();\n+    for (;;) {\n+        fScanIndex = UTEXT_GETNATIVEINDEX(fRXPat->fPattern);\n+        c.fChar    = nextCharLL();\n+        c.fQuoted  = FALSE;\n+\n+        if (fQuoteMode) {\n+            c.fQuoted = TRUE;\n+            if ((c.fChar==chBackSlash && peekCharLL()==chE && ((fModeFlags & UREGEX_LITERAL) == 0)) ||\n+                c.fChar == (UChar32)-1) {\n+                fQuoteMode = FALSE;  //  Exit quote mode,\n+                nextCharLL();        // discard the E\n+                continue;            // loop to get the real next char\n             }\n-        }\n-\n-        //\n-        //  check for backslash escaped characters.\n-        //\n-        if (c.fChar == chBackSlash) {\n-            int64_t pos = UTEXT_GETNATIVEINDEX(fRXPat->fPattern);\n-            if (RegexStaticSets::gStaticSets->fUnescapeCharSet.contains(peekCharLL())) {\n-                //\n-                // A '\\' sequence that is handled by ICU's standard unescapeAt function.\n-                //   Includes \\uxxxx, \\n, \\r, many others.\n-                //   Return the single equivalent character.\n-                //\n-                nextCharLL();                 // get & discard the peeked char.\n-                c.fQuoted = TRUE;\n-\n-                if (UTEXT_FULL_TEXT_IN_CHUNK(fRXPat->fPattern, fPatternLength)) {\n-                    int32_t endIndex = (int32_t)pos;\n-                    c.fChar = u_unescapeAt(uregex_ucstr_unescape_charAt, &endIndex, (int32_t)fPatternLength, (void *)fRXPat->fPattern->chunkContents);\n-\n-                    if (endIndex == pos) {\n-                        error(U_REGEX_BAD_ESCAPE_SEQUENCE);\n+        } else if (fInBackslashQuote) {\n+            fInBackslashQuote = FALSE;\n+        } else {\n+            if (fModeFlags & UREGEX_COMMENTS) {\n+                for (;;) {\n+                    if (c.fChar == (UChar32)-1) {\n+                        break;\n                     }\n-                    fCharNum += endIndex - pos;\n-                    UTEXT_SETNATIVEINDEX(fRXPat->fPattern, endIndex);\n-                } else {\n-                    int32_t offset = 0;\n-                    struct URegexUTextUnescapeCharContext context = U_REGEX_UTEXT_UNESCAPE_CONTEXT(fRXPat->fPattern);\n-\n-                    UTEXT_SETNATIVEINDEX(fRXPat->fPattern, pos);\n-                    c.fChar = u_unescapeAt(uregex_utext_unescape_charAt, &offset, INT32_MAX, &context);\n-\n-                    if (offset == 0) {\n-                        error(U_REGEX_BAD_ESCAPE_SEQUENCE);\n-                    } else if (context.lastOffset == offset) {\n-                        UTEXT_PREVIOUS32(fRXPat->fPattern);\n-                    } else if (context.lastOffset != offset-1) {\n-                        utext_moveIndex32(fRXPat->fPattern, offset - context.lastOffset - 1);\n+                    if  (c.fChar == chPound && fEOLComments == TRUE) {\n+                        for (;;) {\n+                            c.fChar = nextCharLL();\n+                            if (c.fChar == (UChar32)-1 ||\n+                                c.fChar == chCR ||\n+                                c.fChar == chLF ||\n+                                c.fChar == chNEL ||\n+                                c.fChar == chLS) {\n+                                break;\n+                            }\n+                        }\n                     }\n-                    fCharNum += offset;\n+                    if (PatternProps::isWhiteSpace(c.fChar) == FALSE) {\n+                        break;\n+                    }\n+                    c.fChar = nextCharLL();\n                 }\n             }\n-            else if (peekCharLL() == chDigit0) {\n-                //  Octal Escape, using Java Regexp Conventions\n-                //    which are \\0 followed by 1-3 octal digits.\n-                //    Different from ICU Unescape handling of Octal, which does not\n-                //    require the leading 0.\n-                //  Java also has the convention of only consuming 2 octal digits if\n-                //    the three digit number would be > 0xff\n-                //\n-                c.fChar = 0;\n-                nextCharLL();    // Consume the initial 0.\n-                int index;\n-                for (index=0; index<3; index++) {\n-                    int32_t ch = peekCharLL();\n-                    if (ch<chDigit0 || ch>chDigit7) {\n-                        if (index==0) {\n-                           // \\0 is not followed by any octal digits.\n-                           error(U_REGEX_BAD_ESCAPE_SEQUENCE);\n+            if (c.fChar == chBackSlash) {\n+                int64_t pos = UTEXT_GETNATIVEINDEX(fRXPat->fPattern);\n+                if (RegexStaticSets::gStaticSets->fUnescapeCharSet.contains(peekCharLL())) {\n+                    nextCharLL();\n+                    c.fQuoted = TRUE;\n+                    if (UTEXT_FULL_TEXT_IN_CHUNK(fRXPat->fPattern, fPatternLength)) {\n+                        int32_t endIndex = (int32_t)pos;\n+                        c.fChar = u_unescapeAt(uregex_ucstr_unescape_charAt, &endIndex, (int32_t)fPatternLength, (void *)fRXPat->fPattern->chunkContents);\n+                        if (endIndex == pos) {\n+                            error(U_REGEX_BAD_ESCAPE_SEQUENCE);\n                         }\n-                        break;\n-                    }\n-                    c.fChar <<= 3;\n-                    c.fChar += ch&7;\n-                    if (c.fChar <= 255) {\n-                        nextCharLL();\n+                        fCharNum += endIndex - pos;\n+                        UTEXT_SETNATIVEINDEX(fRXPat->fPattern, endIndex);\n                     } else {\n-                        // The last digit made the number too big.  Forget we saw it.\n-                        c.fChar >>= 3;\n+                        int32_t offset = 0;\n+                        struct URegexUTextUnescapeCharContext context = U_REGEX_UTEXT_UNESCAPE_CONTEXT(fRXPat->fPattern);\n+                        UTEXT_SETNATIVEINDEX(fRXPat->fPattern, pos);\n+                        c.fChar = u_unescapeAt(uregex_utext_unescape_charAt, &offset, INT32_MAX, &context);\n+                        if (offset == 0) {\n+                            error(U_REGEX_BAD_ESCAPE_SEQUENCE);\n+                        } else if (context.lastOffset == offset) {\n+                            UTEXT_PREVIOUS32(fRXPat->fPattern);\n+                        } else if (context.lastOffset != offset-1) {\n+                            utext_moveIndex32(fRXPat->fPattern, offset - context.lastOffset - 1);\n+                        }\n+                        fCharNum += offset;\n                     }\n+                } else if (peekCharLL() == chDigit0) {\n+                    c.fChar = 0;\n+                    nextCharLL();\n+                    int index;\n+                    for (index=0; index<3; index++) {\n+                        int32_t ch = peekCharLL();\n+                        if (ch<chDigit0 || ch>chDigit7) {\n+                            if (index==0) {\n+                                error(U_REGEX_BAD_ESCAPE_SEQUENCE);\n+                            }\n+                            break;\n+                        }\n+                        c.fChar <<= 3;\n+                        c.fChar += ch&7;\n+                        if (c.fChar <= 255) {\n+                            nextCharLL();\n+                        } else {\n+                            c.fChar >>= 3;\n+                        }\n+                    }\n+                    c.fQuoted = TRUE;\n+                } else if (peekCharLL() == chQ) {\n+                    fQuoteMode = TRUE;\n+                    nextCharLL();\n+                    continue; // loop to get the real next char\n+                } else {\n+                    fInBackslashQuote = TRUE;\n                 }\n-                c.fQuoted = TRUE;\n-            }\n-            else if (peekCharLL() == chQ) {\n-                //  \"\\Q\"  enter quote mode, which will continue until \"\\E\"\n-                fQuoteMode = TRUE;\n-                nextCharLL();       // discard the 'Q'.\n-                nextChar(c);        // recurse to get the real next char.\n-            }\n-            else\n-            {\n-                // We are in a '\\' escape that will be handled by the state table scanner.\n-                // Just return the backslash, but remember that the following char is to\n-                //  be taken literally.\n-                fInBackslashQuote = TRUE;\n             }\n         }\n+        break;\n     }\n-\n-    // re-enable # to end-of-line comments, in case they were disabled.\n-    // They are disabled by the parser upon seeing '(?', but this lasts for\n-    //  the fetching of the next character only.\n     fEOLComments = TRUE;\n-\n-    // putc(c.fChar, stdout);\n }\n \n \n", "result": true}