{"patch": "diff --git a/icu4c/source/i18n/regexcmp.cpp b/icu4c/source/i18n/regexcmp.cpp\nindex a4c12804237..db07bf41200 100644\n--- a/icu4c/source/i18n/regexcmp.cpp\n+++ b/icu4c/source/i18n/regexcmp.cpp\n@@ -4011,29 +4011,29 @@ UChar32  RegexCompile::peekCharLL() {\n //------------------------------------------------------------------------------\n void RegexCompile::nextChar(RegexPatternChar &c) {\n \n-    fScanIndex = UTEXT_GETNATIVEINDEX(fRXPat->fPattern);\n-    c.fChar    = nextCharLL();\n-    c.fQuoted  = FALSE;\n-\n-    if (fQuoteMode) {\n-        c.fQuoted = TRUE;\n-        if ((c.fChar==chBackSlash && peekCharLL()==chE && ((fModeFlags & UREGEX_LITERAL) == 0)) ||\n-            c.fChar == (UChar32)-1) {\n-            fQuoteMode = FALSE;  //  Exit quote mode,\n-            nextCharLL();        // discard the E\n-            nextChar(c);         // recurse to get the real next char\n+    for (;;) {\n+        fScanIndex = UTEXT_GETNATIVEINDEX(fRXPat->fPattern);\n+        c.fChar    = nextCharLL();\n+        c.fQuoted  = FALSE;\n+\n+        if (fQuoteMode) {\n+            c.fQuoted = TRUE;\n+            if ((c.fChar==chBackSlash && peekCharLL()==chE && ((fModeFlags & UREGEX_LITERAL) == 0)) ||\n+                c.fChar == (UChar32)-1) {\n+                fQuoteMode = FALSE;  //  Exit quote mode,\n+                nextCharLL();        // discard the E\n+                continue;            // loop to get the real next char\n+            }\n         }\n-    }\n-    else if (fInBackslashQuote) {\n-        // The current character immediately follows a '\\'\n-        // Don't check for any further escapes, just return it as-is.\n-        // Don't set c.fQuoted, because that would prevent the state machine from\n-        //    dispatching on the character.\n-        fInBackslashQuote = FALSE;\n-    }\n-    else\n-    {\n-        // We are not in a \\Q quoted region \\E of the source.\n+        else if (fInBackslashQuote) {\n+            // The current character immediately follows a '\\'\n+            // Don't check for any further escapes, just return it as-is.\n+            // Don't set c.fQuoted, because that would prevent the state machine from\n+            //    dispatching on the character.\n+            fInBackslashQuote = FALSE;\n+        }\n+        else\n+        {\n         //\n         if (fModeFlags & UREGEX_COMMENTS) {\n             //\n@@ -4140,7 +4140,7 @@ void RegexCompile::nextChar(RegexPatternChar &c) {\n                 //  \"\\Q\"  enter quote mode, which will continue until \"\\E\"\n                 fQuoteMode = TRUE;\n                 nextCharLL();       // discard the 'Q'.\n-                nextChar(c);        // recurse to get the real next char.\n+                    continue;           // loop to get the real next char\n             }\n             else\n             {\n@@ -4151,13 +4151,14 @@ void RegexCompile::nextChar(RegexPatternChar &c) {\n             }\n         }\n     }\n+        // re-enable # to end-of-line comments, in case they were disabled.\n+        // They are disabled by the parser upon seeing '(?', but this lasts for\n+        //  the fetching of the next character only.\n+        fEOLComments = TRUE;\n \n-    // re-enable # to end-of-line comments, in case they were disabled.\n-    // They are disabled by the parser upon seeing '(?', but this lasts for\n-    //  the fetching of the next character only.\n-    fEOLComments = TRUE;\n-\n-    // putc(c.fChar, stdout);\n+        // putc(c.fChar, stdout);\n+        break;\n+    }\n }\n \n \n", "result": true}