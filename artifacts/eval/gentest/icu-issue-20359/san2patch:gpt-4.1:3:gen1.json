{"patch": "diff --git a/icu4c/source/i18n/regexcmp.cpp b/icu4c/source/i18n/regexcmp.cpp\nindex a4c12804237..66011c6b624 100644\n--- a/icu4c/source/i18n/regexcmp.cpp\n+++ b/icu4c/source/i18n/regexcmp.cpp\n@@ -4010,27 +4010,36 @@ UChar32  RegexCompile::peekCharLL() {\n //\n //------------------------------------------------------------------------------\n void RegexCompile::nextChar(RegexPatternChar &c) {\n+fScanIndex = UTEXT_GETNATIVEINDEX(fRXPat->fPattern);\n+c.fChar    = nextCharLL();\n+c.fQuoted  = FALSE;\n+\n+static const int kMaxNextCharRecursion = 32;\n+static thread_local int nextCharRecursionDepth = 0;\n+if (nextCharRecursionDepth > kMaxNextCharRecursion) {\n+    // Prevent infinite recursion by returning a special value.\n+    c.fChar = (UChar32)-1;\n+    return;\n+}\n \n-    fScanIndex = UTEXT_GETNATIVEINDEX(fRXPat->fPattern);\n-    c.fChar    = nextCharLL();\n-    c.fQuoted  = FALSE;\n-\n-    if (fQuoteMode) {\n-        c.fQuoted = TRUE;\n-        if ((c.fChar==chBackSlash && peekCharLL()==chE && ((fModeFlags & UREGEX_LITERAL) == 0)) ||\n-            c.fChar == (UChar32)-1) {\n-            fQuoteMode = FALSE;  //  Exit quote mode,\n-            nextCharLL();        // discard the E\n-            nextChar(c);         // recurse to get the real next char\n-        }\n-    }\n-    else if (fInBackslashQuote) {\n-        // The current character immediately follows a '\\'\n-        // Don't check for any further escapes, just return it as-is.\n-        // Don't set c.fQuoted, because that would prevent the state machine from\n-        //    dispatching on the character.\n-        fInBackslashQuote = FALSE;\n+if (fQuoteMode) {\n+    c.fQuoted = TRUE;\n+    if ((c.fChar==chBackSlash && peekCharLL()==chE && ((fModeFlags & UREGEX_LITERAL) == 0)) ||\n+         c.fChar == (UChar32)-1) {\n+        fQuoteMode = FALSE;  //  Exit quote mode,\n+        nextCharLL();        // discard the E\n+        ++nextCharRecursionDepth;\n+        nextChar(c);         // recurse to get the real next char\n+        --nextCharRecursionDepth;\n     }\n+}\n+else if (fInBackslashQuote) {\n+    // The current character immediately follows a '\\\\'\n+    // Don't check for any further escapes, just return it as-is.\n+    // Don't set c.fQuoted, because that would prevent the state machine from\n+    //    dispatching on the character.\n+    fInBackslashQuote = FALSE;\n+}\n     else\n     {\n         // We are not in a \\Q quoted region \\E of the source.\n", "result": true}