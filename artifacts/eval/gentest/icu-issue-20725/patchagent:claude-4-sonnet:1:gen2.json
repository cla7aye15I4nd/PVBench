{"patch": "diff --git a/icu4c/source/common/ustring.cpp b/icu4c/source/common/ustring.cpp\nindex 7ab2e1bf891..9e40852ab2d 100644\n--- a/icu4c/source/common/ustring.cpp\n+++ b/icu4c/source/common/ustring.cpp\n@@ -1206,6 +1206,14 @@ static int8_t _digit16(UChar c) {\n     return -1;\n }\n \n+/* Maximum recursion depth for escape sequence processing */\n+#define MAX_UNESCAPE_RECURSION_DEPTH 32\n+\n+/* Internal helper function with recursion depth tracking */\n+static UChar32 u_unescapeAtInternal(UNESCAPE_CHAR_AT charAt,\n+                                   int32_t *offset, int32_t length,\n+                                   void *context, int32_t depth);\n+\n /* Parse a single escape sequence.  Although this method deals in\n  * UChars, it does not use C++ or UnicodeString.  This allows it to\n  * be used from C contexts. */\n@@ -1215,6 +1223,13 @@ u_unescapeAt(UNESCAPE_CHAR_AT charAt,\n              int32_t length,\n              void *context) {\n \n+    return u_unescapeAtInternal(charAt, offset, length, context, 0);\n+}\n+\n+static UChar32 u_unescapeAtInternal(UNESCAPE_CHAR_AT charAt,\n+                                   int32_t *offset, int32_t length,\n+                                   void *context, int32_t depth) {\n+\n     int32_t start = *offset;\n     UChar c;\n     UChar32 result = 0;\n@@ -1226,6 +1241,11 @@ u_unescapeAt(UNESCAPE_CHAR_AT charAt,\n     int32_t i;\n     UBool braces = FALSE;\n \n+    /* Check recursion depth to prevent stack overflow */\n+    if (depth >= MAX_UNESCAPE_RECURSION_DEPTH) {\n+        goto err;\n+    }\n+\n     /* Check that offset is in range */\n     if (*offset < 0 || *offset >= length) {\n         goto err;\n@@ -1294,7 +1314,7 @@ u_unescapeAt(UNESCAPE_CHAR_AT charAt,\n             int32_t ahead = *offset + 1;\n             c = charAt(*offset, context);\n             if (c == 0x5C /*'\\\\'*/ && ahead < length) {\n-                c = (UChar) u_unescapeAt(charAt, &ahead, length, context);\n+                c = (UChar) u_unescapeAtInternal(charAt, &ahead, length, context, depth + 1);\n             }\n             if (U16_IS_TRAIL(c)) {\n                 *offset = ahead;\n", "result": true}