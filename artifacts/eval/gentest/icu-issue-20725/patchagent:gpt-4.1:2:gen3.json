{"patch": "diff --git a/icu4c/source/common/ustring.cpp b/icu4c/source/common/ustring.cpp\nindex 7ab2e1bf891..859441bcaa1 100644\n--- a/icu4c/source/common/ustring.cpp\n+++ b/icu4c/source/common/ustring.cpp\n@@ -1209,11 +1209,152 @@ static int8_t _digit16(UChar c) {\n /* Parse a single escape sequence.  Although this method deals in\n  * UChars, it does not use C++ or UnicodeString.  This allows it to\n  * be used from C contexts. */\n+\n+#define U_UNESCAPEAT_MAX_RECURSION 32\n+static UChar32 u_unescapeAt_internal(UNESCAPE_CHAR_AT charAt,\n+                                     int32_t *offset,\n+                                     int32_t length,\n+                                     void *context,\n+                                     int recursionDepth) {\n+    if (recursionDepth > U_UNESCAPEAT_MAX_RECURSION) {\n+        return (UChar32)0xFFFFFFFF;\n+    }\n+\n+    int32_t start = *offset;\n+    UChar c;\n+    UChar32 result = 0;\n+    int8_t n = 0;\n+    int8_t minDig = 0;\n+    int8_t maxDig = 0;\n+    int8_t bitsPerDigit = 4; \n+    int8_t dig;\n+    int32_t i;\n+    UBool braces = FALSE;\n+\n+    /* Check that offset is in range */\n+    if (*offset < 0 || *offset >= length) {\n+        goto err;\n+    }\n+\n+    /* Fetch first UChar after '\\\\' */\n+    c = charAt((*offset)++, context);\n+\n+    /* Convert hexadecimal and octal escapes */\n+    switch (c) {\n+    case 0x0075 /*'u'*/:\n+        minDig = maxDig = 4;\n+        break;\n+    case 0x0055 /*'U'*/:\n+        minDig = maxDig = 8;\n+        break;\n+    case 0x0078 /*'x'*/:\n+        minDig = 1;\n+        if (*offset < length && charAt(*offset, context) == 0x7B /*{*/) {\n+            ++(*offset);\n+            braces = TRUE;\n+            maxDig = 8;\n+        } else {\n+            maxDig = 2;\n+        }\n+        break;\n+    default:\n+        dig = _digit8(c);\n+        if (dig >= 0) {\n+            minDig = 1;\n+            maxDig = 3;\n+            n = 1; /* Already have first octal digit */\n+            bitsPerDigit = 3;\n+            result = dig;\n+        }\n+        break;\n+    }\n+    if (minDig != 0) {\n+        while (*offset < length && n < maxDig) {\n+            c = charAt(*offset, context);\n+            dig = (int8_t)((bitsPerDigit == 3) ? _digit8(c) : _digit16(c));\n+            if (dig < 0) {\n+                break;\n+            }\n+            result = (result << bitsPerDigit) | dig;\n+            ++(*offset);\n+            ++n;\n+        }\n+        if (n < minDig) {\n+            goto err;\n+        }\n+        if (braces) {\n+            if (c != 0x7D /*}*/) {\n+                goto err;\n+            }\n+            ++(*offset);\n+        }\n+        if (result < 0 || result >= 0x110000) {\n+            goto err;\n+        }\n+        /* If an escape sequence specifies a lead surrogate, see if\n+         * there is a trail surrogate after it, either as an escape or\n+         * as a literal.  If so, join them up into a supplementary.\n+         */\n+        if (*offset < length && U16_IS_LEAD(result)) {\n+            int32_t ahead = *offset + 1;\n+            c = charAt(*offset, context);\n+            if (c == 0x5C /*'\\\\'*/ && ahead < length) {\n+                c = (UChar) u_unescapeAt_internal(charAt, &ahead, length, context, recursionDepth + 1);\n+            }\n+            if (U16_IS_TRAIL(c)) {\n+                *offset = ahead;\n+                result = U16_GET_SUPPLEMENTARY(result, c);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /* Convert C-style escapes in table */\n+    for (i=0; i<UNESCAPE_MAP_LENGTH; i+=2) {\n+        if (c == UNESCAPE_MAP[i]) {\n+            return UNESCAPE_MAP[i+1];\n+        } else if (c < UNESCAPE_MAP[i]) {\n+            break;\n+        }\n+    }\n+\n+    /* Map \\cX to control-X: X & 0x1F */\n+    if (c == 0x0063 /*'c'*/ && *offset < length) {\n+        c = charAt((*offset)++, context);\n+        if (U16_IS_LEAD(c) && *offset < length) {\n+            UChar c2 = charAt(*offset, context);\n+            if (U16_IS_TRAIL(c2)) {\n+                ++(*offset);\n+                c = (UChar) U16_GET_SUPPLEMENTARY(c, c2); /* [sic] */\n+            }\n+        }\n+        return 0x1F & c;\n+    }\n+\n+    /* If no special forms are recognized, then consider\n+     * the backslash to generically escape the next character.\n+     * Deal with surrogate pairs. */\n+    if (U16_IS_LEAD(c) && *offset < length) {\n+        UChar c2 = charAt(*offset, context);\n+        if (U16_IS_TRAIL(c2)) {\n+            ++(*offset);\n+            c = (UChar) U16_GET_SUPPLEMENTARY(c, c2);\n+        }\n+    }\n+    return c;\n+\n+err:\n+    /* Invalid escape sequence */\n+    *offset = start; /* Reset to initial value */\n+    return (UChar32)0xFFFFFFFF;\n+}\n+\n U_CAPI UChar32 U_EXPORT2\n u_unescapeAt(UNESCAPE_CHAR_AT charAt,\n              int32_t *offset,\n              int32_t length,\n              void *context) {\n+    return u_unescapeAt_internal(charAt, offset, length, context, 0);\n \n     int32_t start = *offset;\n     UChar c;\n", "result": true}