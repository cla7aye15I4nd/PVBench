{"patch": "diff --git a/icu4c/source/common/ustring.cpp b/icu4c/source/common/ustring.cpp\nindex 7ab2e1bf891..a41488fd757 100644\n--- a/icu4c/source/common/ustring.cpp\n+++ b/icu4c/source/common/ustring.cpp\n@@ -1209,11 +1209,18 @@ static int8_t _digit16(UChar c) {\n /* Parse a single escape sequence.  Although this method deals in\n  * UChars, it does not use C++ or UnicodeString.  This allows it to\n  * be used from C contexts. */\n-U_CAPI UChar32 U_EXPORT2\n-u_unescapeAt(UNESCAPE_CHAR_AT charAt,\n+// Maximum recursion depth for u_unescapeAt to prevent stack overflow\n+#define U_UNESCAPEAT_MAX_DEPTH 16\n+\n+static UChar32\n+u_unescapeAt_internal(UNESCAPE_CHAR_AT charAt,\n              int32_t *offset,\n              int32_t length,\n-             void *context) {\n+             void *context,\n+             int depth) {\n+    if (depth > U_UNESCAPEAT_MAX_DEPTH) {\n+        return (UChar32)0xFFFFFFFF;\n+    }\n \n     int32_t start = *offset;\n     UChar c;\n@@ -1294,7 +1301,7 @@ u_unescapeAt(UNESCAPE_CHAR_AT charAt,\n             int32_t ahead = *offset + 1;\n             c = charAt(*offset, context);\n             if (c == 0x5C /*'\\\\'*/ && ahead < length) {\n-                c = (UChar) u_unescapeAt(charAt, &ahead, length, context);\n+                c = (UChar) u_unescapeAt_internal(charAt, &ahead, length, context, depth + 1);\n             }\n             if (U16_IS_TRAIL(c)) {\n                 *offset = ahead;\n@@ -1313,7 +1320,7 @@ u_unescapeAt(UNESCAPE_CHAR_AT charAt,\n         }\n     }\n \n-    /* Map \\cX to control-X: X & 0x1F */\n+    /* Map \\\\cX to control-X: X & 0x1F */\n     if (c == 0x0063 /*'c'*/ && *offset < length) {\n         c = charAt((*offset)++, context);\n         if (U16_IS_LEAD(c) && *offset < length) {\n@@ -1338,12 +1345,20 @@ u_unescapeAt(UNESCAPE_CHAR_AT charAt,\n     }\n     return c;\n \n- err:\n+err:\n     /* Invalid escape sequence */\n     *offset = start; /* Reset to initial value */\n     return (UChar32)0xFFFFFFFF;\n }\n \n+U_CAPI UChar32 U_EXPORT2\n+u_unescapeAt(UNESCAPE_CHAR_AT charAt,\n+             int32_t *offset,\n+             int32_t length,\n+             void *context) {\n+    return u_unescapeAt_internal(charAt, offset, length, context, 0);\n+}\n+\n /* u_unescapeAt() callback to return a UChar from a char* */\n static UChar U_CALLCONV\n _charPtr_charAt(int32_t offset, void *context) {\n", "result": true}