{"patch": "diff --git a/icu4c/source/common/messagepattern.cpp b/icu4c/source/common/messagepattern.cpp\nindex 9e318295f9a..7d2709c902c 100644\n--- a/icu4c/source/common/messagepattern.cpp\n+++ b/icu4c/source/common/messagepattern.cpp\n@@ -444,88 +444,103 @@ MessagePattern::parseMessage(int32_t index, int32_t msgStartLength,\n     int32_t msgStart=partsLength;\n     addPart(UMSGPAT_PART_TYPE_MSG_START, index, msgStartLength, nestingLevel, errorCode);\n     index+=msgStartLength;\n-    for(;;) {  // while(index<msg.length()) with U_FAILURE(errorCode) check\n-        if(U_FAILURE(errorCode)) {\n-            return 0;\n-        }\n-        if(index>=msg.length()) {\n-            break;\n-        }\n-        char16_t c=msg.charAt(index++);\n-        if(c==u_apos) {\n-            if(index==msg.length()) {\n-                // The apostrophe is the last character in the pattern. \n-                // Add a Part for auto-quoting.\n-                addPart(UMSGPAT_PART_TYPE_INSERT_CHAR, index, 0,\n-                        u_apos, errorCode);  // value=char to be inserted\n-                needsAutoQuoting=true;\n-            } else {\n-                c=msg.charAt(index);\n-                if(c==u_apos) {\n-                    // double apostrophe, skip the second one\n-                    addPart(UMSGPAT_PART_TYPE_SKIP_SYNTAX, index++, 1, 0, errorCode);\n-                } else if(\n-                    aposMode==UMSGPAT_APOS_DOUBLE_REQUIRED ||\n-                    c==u_leftCurlyBrace || c==u_rightCurlyBrace ||\n-                    (parentType==UMSGPAT_ARG_TYPE_CHOICE && c==u_pipe) ||\n-                    (UMSGPAT_ARG_TYPE_HAS_PLURAL_STYLE(parentType) && c==u_pound)\n-                ) {\n-                    // skip the quote-starting apostrophe\n-                    addPart(UMSGPAT_PART_TYPE_SKIP_SYNTAX, index-1, 1, 0, errorCode);\n-                    // find the end of the quoted literal text\n-                    for(;;) {\n-                        index=msg.indexOf(u_apos, index+1);\n-                        if(index>=0) {\n-                            if(/*(index+1)<msg.length() &&*/ msg.charAt(index+1)==u_apos) {\n-                                // double apostrophe inside quoted literal text\n-                                // still encodes a single apostrophe, skip the second one\n-                                addPart(UMSGPAT_PART_TYPE_SKIP_SYNTAX, ++index, 1, 0, errorCode);\n-                            } else {\n-                                // skip the quote-ending apostrophe\n-                                addPart(UMSGPAT_PART_TYPE_SKIP_SYNTAX, index++, 1, 0, errorCode);\n-                                break;\n-                            }\n+    // Define a reasonable maximum recursion depth for message pattern parsing\n+#ifndef KMAXRECURSIONDEPTH\n+#define KMAXRECURSIONDEPTH 64\n+#endif\n+\n+for(;;) {  // while(index<msg.length()) with U_FAILURE(errorCode) check\n+    if(U_FAILURE(errorCode)) {\n+        return 0;\n+    }\n+    if(index>=msg.length()) {\n+        break;\n+    }\n+    // Add recursion depth check to prevent stack overflow\n+    if(nestingLevel > KMAXRECURSIONDEPTH) {\n+        errorCode = U_PARSE_ERROR;\n+        return 0;\n+    }\n+    char16_t c=msg.charAt(index++);\n+    if(c==u_apos) {\n+        if(index==msg.length()) {\n+            // The apostrophe is the last character in the pattern. \n+            // Add a Part for auto-quoting.\n+            addPart(UMSGPAT_PART_TYPE_INSERT_CHAR, index, 0,\n+                    u_apos, errorCode);  // value=char to be inserted\n+            needsAutoQuoting=true;\n+        } else {\n+            c=msg.charAt(index);\n+            if(c==u_apos) {\n+                // double apostrophe, skip the second one\n+                addPart(UMSGPAT_PART_TYPE_SKIP_SYNTAX, index++, 1, 0, errorCode);\n+            } else if(\n+                aposMode==UMSGPAT_APOS_DOUBLE_REQUIRED ||\n+                c==u_leftCurlyBrace || c==u_rightCurlyBrace ||\n+                (parentType==UMSGPAT_ARG_TYPE_CHOICE && c==u_pipe) ||\n+                (UMSGPAT_ARG_TYPE_HAS_PLURAL_STYLE(parentType) && c==u_pound)\n+            ) {\n+                // skip the quote-starting apostrophe\n+                addPart(UMSGPAT_PART_TYPE_SKIP_SYNTAX, index-1, 1, 0, errorCode);\n+                // find the end of the quoted literal text\n+                for(;;) {\n+                    index=msg.indexOf(u_apos, index+1);\n+                    if(index>=0) {\n+                        if(/*(index+1)<msg.length() &&*/ msg.charAt(index+1)==u_apos) {\n+                            // double apostrophe inside quoted literal text\n+                            // still encodes a single apostrophe, skip the second one\n+                            addPart(UMSGPAT_PART_TYPE_SKIP_SYNTAX, ++index, 1, 0, errorCode);\n                         } else {\n-                            // The quoted text reaches to the end of the of the message.\n-                            index=msg.length();\n-                            // Add a Part for auto-quoting.\n-                            addPart(UMSGPAT_PART_TYPE_INSERT_CHAR, index, 0,\n-                                    u_apos, errorCode);  // value=char to be inserted\n-                            needsAutoQuoting=true;\n+                            // skip the quote-ending apostrophe\n+                            addPart(UMSGPAT_PART_TYPE_SKIP_SYNTAX, index++, 1, 0, errorCode);\n                             break;\n                         }\n+                    } else {\n+                        // The quoted text reaches to the end of the of the message.\n+                        index=msg.length();\n+                        // Add a Part for auto-quoting.\n+                        addPart(UMSGPAT_PART_TYPE_INSERT_CHAR, index, 0,\n+                                u_apos, errorCode);  // value=char to be inserted\n+                        needsAutoQuoting=true;\n+                        break;\n                     }\n-                } else {\n-                    // Interpret the apostrophe as literal text.\n-                    // Add a Part for auto-quoting.\n-                    addPart(UMSGPAT_PART_TYPE_INSERT_CHAR, index, 0,\n-                            u_apos, errorCode);  // value=char to be inserted\n-                    needsAutoQuoting=true;\n                 }\n-            }\n-        } else if(UMSGPAT_ARG_TYPE_HAS_PLURAL_STYLE(parentType) && c==u_pound) {\n-            // The unquoted # in a plural message fragment will be replaced\n-            // with the (number-offset).\n-            addPart(UMSGPAT_PART_TYPE_REPLACE_NUMBER, index-1, 1, 0, errorCode);\n-        } else if(c==u_leftCurlyBrace) {\n-            index=parseArg(index-1, 1, nestingLevel, parseError, errorCode);\n-        } else if((nestingLevel>0 && c==u_rightCurlyBrace) ||\n-                  (parentType==UMSGPAT_ARG_TYPE_CHOICE && c==u_pipe)) {\n-            // Finish the message before the terminator.\n-            // In a choice style, report the \"}\" substring only for the following ARG_LIMIT,\n-            // not for this MSG_LIMIT.\n-            int32_t limitLength=(parentType==UMSGPAT_ARG_TYPE_CHOICE && c==u_rightCurlyBrace) ? 0 : 1;\n-            addLimitPart(msgStart, UMSGPAT_PART_TYPE_MSG_LIMIT, index-1, limitLength,\n-                         nestingLevel, errorCode);\n-            if(parentType==UMSGPAT_ARG_TYPE_CHOICE) {\n-                // Let the choice style parser see the '}' or '|'.\n-                return index-1;\n             } else {\n-                // continue parsing after the '}'\n-                return index;\n+                // Interpret the apostrophe as literal text.\n+                // Add a Part for auto-quoting.\n+                addPart(UMSGPAT_PART_TYPE_INSERT_CHAR, index, 0,\n+                        u_apos, errorCode);  // value=char to be inserted\n+                needsAutoQuoting=true;\n             }\n-        }  // else: c is part of literal text\n-    }\n+        }\n+    } else if(UMSGPAT_ARG_TYPE_HAS_PLURAL_STYLE(parentType) && c==u_pound) {\n+        // The unquoted # in a plural message fragment will be replaced\n+        // with the (number-offset).\n+        addPart(UMSGPAT_PART_TYPE_REPLACE_NUMBER, index-1, 1, 0, errorCode);\n+    } else if(c==u_leftCurlyBrace) {\n+        if(nestingLevel + 1 > KMAXRECURSIONDEPTH) {\n+            errorCode = U_PARSE_ERROR;\n+            return 0;\n+        }\n+        index=parseArg(index-1, 1, nestingLevel, parseError, errorCode);\n+    } else if((nestingLevel>0 && c==u_rightCurlyBrace) ||\n+              (parentType==UMSGPAT_ARG_TYPE_CHOICE && c==u_pipe)) {\n+        // Finish the message before the terminator.\n+        // In a choice style, report the \"}\" substring only for the following ARG_LIMIT,\n+        // not for this MSG_LIMIT.\n+        int32_t limitLength=(parentType==UMSGPAT_ARG_TYPE_CHOICE && c==u_rightCurlyBrace) ? 0 : 1;\n+        addLimitPart(msgStart, UMSGPAT_PART_TYPE_MSG_LIMIT, index-1, limitLength,\n+                     nestingLevel, errorCode);\n+        if(parentType==UMSGPAT_ARG_TYPE_CHOICE) {\n+            // Let the choice style parser see the '}' or '|'.\n+            return index-1;\n+        } else {\n+            // continue parsing after the '}'\n+            return index;\n+        }\n+    }  // else: c is part of literal text\n+}\n+\n     if(nestingLevel>0 && !inTopLevelChoiceMessage(nestingLevel, parentType)) {\n         setParseError(parseError, 0);  // Unmatched '{' braces in message.\n         errorCode=U_UNMATCHED_BRACES;\n", "result": false, "error": ".test_binary_1: /gentest/proj/icu/icu-issue-22798/generated1/generated.cc:32: int main(): Assertion `status == U_INDEX_OUTOFBOUNDS_ERROR' failed.\n"}