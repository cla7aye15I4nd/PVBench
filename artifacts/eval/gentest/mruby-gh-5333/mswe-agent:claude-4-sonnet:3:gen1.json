{"patch": "diff --git a/.gitignore b/.gitignore\nindex 6a0e7e46b..d217e0f49 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -35,3 +35,13 @@ tags\n \n /doc/api\n /doc/capi\n+build/\n+Build/\n+bin/\n+lib/\n+*.out\n+*.obj\n+*.exe\n+*.dll\n+*.so\n+*.dylib\ndiff --git a/src/hash.c b/src/hash.c\nindex 289f02a91..add783198 100644\n--- a/src/hash.c\n+++ b/src/hash.c\n@@ -260,6 +260,7 @@ HT_ASSERT_SAFE_READ(ea_capa);\n \n static uint32_t ib_upper_bound_for(uint32_t capa);\n static uint32_t ib_bit_to_capa(uint32_t bit);\n+static uint32_t ib_ary_size_for(uint32_t ib_bit);\n static void ht_init(\n   mrb_state *mrb, struct RHash *h, uint32_t size,\n   hash_entry *ea, uint32_t ea_capa, hash_table *ht, uint32_t ib_bit);\n@@ -636,10 +637,23 @@ ib_it_next(index_buckets_iter *it)\n   uint32_t slid_ary_index = slid_bit_pos / IB_TYPE_BIT;\n   it->ary_index = slid_ary_index + it->pos / IB_TYPE_BIT * it->bit;\n   it->shift2 = (slid_ary_index + 1) * IB_TYPE_BIT - slid_bit_pos - 1;\n+  \n+  /* Add bounds checking to prevent heap buffer overflow */\n+  uint32_t ary_size = ib_ary_size_for(it->bit);\n+  if (it->ary_index >= ary_size) {\n+    it->ea_index = ib_it_deleted_value(it);\n+    it->shift1 = 0;\n+    it->pos = ib_it_pos_for(it, it->pos + (++it->step));\n+    return;\n+  }\n+  \n   it->ea_index = (ht_ib(it->h)[it->ary_index] >> it->shift2) & it->mask;\n   if (IB_TYPE_BIT - it->bit < it->shift2) {\n     it->shift1 = IB_TYPE_BIT - it->shift2;\n-    it->ea_index |= (ht_ib(it->h)[it->ary_index - 1] << it->shift1) & it->mask;\n+    /* Add bounds checking for ary_index - 1 */\n+    if (it->ary_index > 0) {\n+      it->ea_index |= (ht_ib(it->h)[it->ary_index - 1] << it->shift1) & it->mask;\n+    }\n   }\n   else {\n     it->shift1 = 0;\n@@ -657,15 +671,23 @@ static void\n ib_it_set(index_buckets_iter *it, uint32_t ea_index)\n {\n   uint32_t mask, i;\n+  uint32_t ary_size = ib_ary_size_for(it->bit);\n+  \n   it->ea_index = ea_index;\n-  if (it->shift1) {\n+  if (it->shift1 && it->ary_index > 0) {\n     i = it->ary_index - 1;\n-    mask = it->mask >> it->shift1;\n-    ht_ib(it->h)[i] = (ht_ib(it->h)[i] & ~mask) | (ea_index >> it->shift1);\n+    /* Add bounds checking for ary_index - 1 */\n+    if (i < ary_size) {\n+      mask = it->mask >> it->shift1;\n+      ht_ib(it->h)[i] = (ht_ib(it->h)[i] & ~mask) | (ea_index >> it->shift1);\n+    }\n   }\n   i = it->ary_index;\n-  mask = it->mask << it->shift2;\n-  ht_ib(it->h)[i] = (ht_ib(it->h)[i] & ~mask) | (ea_index << it->shift2);\n+  /* Add bounds checking for ary_index */\n+  if (i < ary_size) {\n+    mask = it->mask << it->shift2;\n+    ht_ib(it->h)[i] = (ht_ib(it->h)[i] & ~mask) | (ea_index << it->shift2);\n+  }\n }\n \n static void\n@@ -724,6 +746,14 @@ ib_byte_size_for(uint32_t ib_bit)\n   return U32(sizeof(uint32_t) * ary_size);\n }\n \n+static uint32_t\n+ib_ary_size_for(uint32_t ib_bit)\n+{\n+  return IB_INIT_BIT == 4 ?\n+    ib_bit_to_capa(ib_bit) * 2 / IB_TYPE_BIT * ib_bit / 2 :\n+    ib_bit_to_capa(ib_bit) / IB_TYPE_BIT * ib_bit;\n+}\n+\n static void\n ib_init(mrb_state *mrb, struct RHash *h, uint32_t ib_bit, size_t ib_byte_size)\n {\n", "result": true}