{"patch": "diff --git a/.gitignore b/.gitignore\nindex c2918f31a..6bf18697a 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -32,3 +32,13 @@ compile_flags.txt\n cscope.files\n cscope.out\n tags\n+build/\n+Build/\n+bin/\n+lib/\n+*.out\n+*.obj\n+*.exe\n+*.dll\n+*.so\n+*.dylib\ndiff --git a/src/string.c b/src/string.c\nindex 1bd3f6f8f..5836610b5 100644\n--- a/src/string.c\n+++ b/src/string.c\n@@ -2950,25 +2950,52 @@ str_bytesplice(mrb_state *mrb, mrb_value str, mrb_int idx1, mrb_int len1, mrb_va\n   if (RSTR_LEN(s) < idx1 || RSTRING_LEN(replace) < idx2) {\n     mrb_raise(mrb, E_INDEX_ERROR, \"index out of string\");\n   }\n-  if (RSTR_LEN(s) <= idx1+len1) {\n+  \n+  /* Check for overflow in idx1+len1 */\n+  mrb_int idx1_plus_len1;\n+  if (mrb_int_add_overflow(idx1, len1, &idx1_plus_len1)) {\n+    /* If overflow occurs, treat as if idx1+len1 is very large */\n     len1 = RSTR_LEN(s) - idx1;\n   }\n-  if (RSTRING_LEN(replace) <= idx2+len2) {\n+  else if (RSTR_LEN(s) <= idx1_plus_len1) {\n+    len1 = RSTR_LEN(s) - idx1;\n+  }\n+  \n+  /* Check for overflow in idx2+len2 */\n+  mrb_int idx2_plus_len2;\n+  if (mrb_int_add_overflow(idx2, len2, &idx2_plus_len2)) {\n+    /* If overflow occurs, treat as if idx2+len2 is very large */\n+    len2 = RSTRING_LEN(replace) - idx2;\n+  }\n+  else if (RSTRING_LEN(replace) <= idx2_plus_len2) {\n     len2 = RSTRING_LEN(replace) - idx2;\n   }\n+  \n   if (len2 == 0) return str;\n   mrb_str_modify(mrb, s);\n   if (len1 >= len2) {\n     memmove(RSTR_PTR(s)+idx1, RSTRING_PTR(replace)+idx2, len2);\n     if (len1 > len2) {\n-      memmove(RSTR_PTR(s)+idx1+len2, RSTR_PTR(s)+idx1+len1, RSTR_LEN(s)-(idx1+len1));\n+      /* Recompute idx1+len1 and idx1+len2 safely */\n+      mrb_int idx1_plus_len1_safe, idx1_plus_len2_safe;\n+      if (mrb_int_add_overflow(idx1, len1, &idx1_plus_len1_safe) ||\n+          mrb_int_add_overflow(idx1, len2, &idx1_plus_len2_safe)) {\n+        mrb_raise(mrb, E_INDEX_ERROR, \"index calculation overflow\");\n+      }\n+      memmove(RSTR_PTR(s)+idx1_plus_len2_safe, RSTR_PTR(s)+idx1_plus_len1_safe, RSTR_LEN(s)-idx1_plus_len1_safe);\n       RSTR_SET_LEN(s, RSTR_LEN(s)-(len1-len2));\n     }\n   }\n   else { /* len1 < len2 */\n     mrb_int slen = RSTR_LEN(s);\n     mrb_str_resize(mrb, str, slen+len2-len1);\n-    memmove(RSTR_PTR(s)+idx1+len2, RSTR_PTR(s)+idx1+len1, slen-(idx1+len1));\n+    /* Recompute idx1+len1 and idx1+len2 safely */\n+    mrb_int idx1_plus_len1_safe, idx1_plus_len2_safe;\n+    if (mrb_int_add_overflow(idx1, len1, &idx1_plus_len1_safe) ||\n+        mrb_int_add_overflow(idx1, len2, &idx1_plus_len2_safe)) {\n+      mrb_raise(mrb, E_INDEX_ERROR, \"index calculation overflow\");\n+    }\n+    memmove(RSTR_PTR(s)+idx1_plus_len2_safe, RSTR_PTR(s)+idx1_plus_len1_safe, slen-idx1_plus_len1_safe);\n     memmove(RSTR_PTR(s)+idx1, RSTRING_PTR(replace)+idx2, len2);\n   }\n   return str;\n", "result": false, "error": "trace (most recent call last):\n\t[1] /gentest-mruby/mruby-gh-5986/generated_2.rb:23\n/gentest-mruby/mruby-gh-5986/generated_2.rb:11:in assert_nothing_raised: bytesplice huge len (INT32) should not crash and return self: got ArgumentError: string too long (len=2147483661 max=1048576) (TestFailure)\n"}