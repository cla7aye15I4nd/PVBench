{"patch": "diff --git a/Packet++/header/DnsResourceData.h b/Packet++/header/DnsResourceData.h\nindex 9acd8a76..31c52c0a 100644\n--- a/Packet++/header/DnsResourceData.h\n+++ b/Packet++/header/DnsResourceData.h\n@@ -387,6 +387,10 @@ namespace pcpp\n \t\t * @return True if data is the same in both objects, meaning byte streams are equal, false otherwise\n \t\t */\n \t\tbool operator==(const GenericDnsResourceData& other) const;\n+\t\t/**\n+\t\t * Get the length of the data stored in this object\n+\t\t */\n+\t\tinline size_t getDataLength() const { return m_DataLen; }\n \n \t\t// implement abstract methods\n \ndiff --git a/Packet++/src/DnsResource.cpp b/Packet++/src/DnsResource.cpp\nindex 8c72cc57..9bddfd88 100644\n--- a/Packet++/src/DnsResource.cpp\n+++ b/Packet++/src/DnsResource.cpp\n@@ -345,7 +345,8 @@ bool DnsResource::setData(IDnsResourceData* data)\n {\n \t// convert data to byte array according to the DNS type\n \tsize_t dataLength = 0;\n-\tuint8_t dataAsByteArr[256];\n+\tconst size_t maxDataLen = 256;\n+\tuint8_t dataAsByteArr[maxDataLen];\n \n \tif (data == nullptr)\n \t{\n@@ -405,7 +406,14 @@ bool DnsResource::setData(IDnsResourceData* data)\n \n \t}\n \n-\t// convert the IDnsResourceData to byte array\n+\t// Check if the data to be written fits in the buffer\n+\tif (data->isTypeOf<GenericDnsResourceData>()) {\n+\t\tconst GenericDnsResourceData* genData = static_cast<const GenericDnsResourceData*>(data);\n+\t\tif (genData->getDataLength() > maxDataLen) {\n+\t\t\tPCPP_LOG_ERROR(\"DNS resource data too large for buffer\");\n+\t\t\treturn false;\n+\t\t}\n+\t}\n \tif (!data->toByteArr(dataAsByteArr, dataLength, this))\n \t{\n \t\tPCPP_LOG_ERROR(\"Cannot convert DNS resource data to byte array, data is probably invalid\");\n", "result": false, "error": ".test_binary_2: /gentest/proj/pcapplusplus/pcap-gh-1137/generated2/generated.cc:29: int main(int, char **): Assertion `answer != nullptr' failed.\n"}