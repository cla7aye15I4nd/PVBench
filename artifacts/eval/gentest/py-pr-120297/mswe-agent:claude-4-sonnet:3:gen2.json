{"patch": "diff --git a/.gitignore b/.gitignore\nindex 8872e9d5508..959a12bbd57 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -171,3 +171,9 @@ Python/frozen_modules/MANIFEST\n \n # main branch only: ABI files are not checked/maintained.\n Doc/data/python*.abi\n+build/\n+Build/\n+bin/\n+lib/\n+*.out\n+*.obj\ndiff --git a/Modules/_lsprof.c b/Modules/_lsprof.c\nindex 5cf9eba243b..36f6361163e 100644\n--- a/Modules/_lsprof.c\n+++ b/Modules/_lsprof.c\n@@ -42,6 +42,7 @@ typedef struct _ProfilerContext {\n     PyTime_t subt;\n     struct _ProfilerContext *previous;\n     ProfilerEntry *ctxEntry;\n+    int marked_for_deletion;  /* Flag to mark context for deferred deletion */\n } ProfilerContext;\n \n typedef struct {\n@@ -60,6 +61,8 @@ typedef struct {\n #define POF_SUBCALLS    0x002\n #define POF_BUILTINS    0x004\n #define POF_NOMEMORY    0x100\n+#define POF_IN_CALLBACK 0x200\n+#define POF_NEED_FLUSH  0x400\n \n /*[clinic input]\n module _lsprof\n@@ -114,11 +117,33 @@ static PyTime_t CallExternalTimer(ProfilerObject *pObj)\n     return result;\n }\n \n+/* Forward declaration */\n+static void flush_unmatched(ProfilerObject *pObj);\n+\n static inline PyTime_t\n call_timer(ProfilerObject *pObj)\n {\n     if (pObj->externalTimer != NULL) {\n-        return CallExternalTimer(pObj);\n+        /* Set flag to prevent re-entrant calls during timer callback */\n+        int was_in_callback = pObj->flags & POF_IN_CALLBACK;\n+        if (was_in_callback) {\n+            /* Already in a callback, avoid re-entrance */\n+            PyTime_t t;\n+            (void)PyTime_PerfCounterRaw(&t);\n+            return t;\n+        }\n+        \n+        pObj->flags |= POF_IN_CALLBACK;\n+        PyTime_t result = CallExternalTimer(pObj);\n+        pObj->flags &= ~POF_IN_CALLBACK;\n+        \n+        /* Check if we need to flush after exiting callback */\n+        if (pObj->flags & POF_NEED_FLUSH) {\n+            pObj->flags &= ~POF_NEED_FLUSH;\n+            flush_unmatched(pObj);\n+        }\n+        \n+        return result;\n     }\n     else {\n         PyTime_t t;\n@@ -128,6 +153,7 @@ call_timer(ProfilerObject *pObj)\n }\n \n \n+\n /*** ProfilerObject ***/\n \n static PyObject *\n@@ -278,9 +304,10 @@ static void clearEntries(ProfilerObject *pObj)\n     RotatingTree_Enum(pObj->profilerEntries, freeEntry, NULL);\n     pObj->profilerEntries = EMPTY_ROTATING_TREE;\n     /* release the memory hold by the ProfilerContexts */\n-    if (pObj->currentProfilerContext) {\n-        PyMem_Free(pObj->currentProfilerContext);\n-        pObj->currentProfilerContext = NULL;\n+    while (pObj->currentProfilerContext) {\n+        ProfilerContext *c = pObj->currentProfilerContext;\n+        pObj->currentProfilerContext = c->previous;\n+        PyMem_Free(c);\n     }\n     while (pObj->freelistProfilerContext) {\n         ProfilerContext *c = pObj->freelistProfilerContext;\n@@ -296,6 +323,7 @@ initContext(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n     self->ctxEntry = entry;\n     self->subt = 0;\n     self->previous = pObj->currentProfilerContext;\n+    self->marked_for_deletion = 0;  /* Initialize the deletion flag */\n     pObj->currentProfilerContext = self;\n     ++entry->recursionLevel;\n     if ((pObj->flags & POF_SUBCALLS) && self->previous) {\n@@ -393,6 +421,15 @@ ptrace_leave_call(PyObject *self, void *key)\n     pContext = pObj->currentProfilerContext;\n     if (pContext == NULL)\n         return;\n+    \n+    /* Check if this context was marked for deletion */\n+    if (pContext->marked_for_deletion) {\n+        /* Context was marked for deletion, just remove it from the stack and free it */\n+        pObj->currentProfilerContext = pContext->previous;\n+        PyMem_Free(pContext);\n+        return;\n+    }\n+    \n     profEntry = getEntry(pObj, key);\n     if (profEntry) {\n         Stop(pObj, pContext, profEntry);\n@@ -762,10 +799,11 @@ flush_unmatched(ProfilerObject *pObj)\n             Stop(pObj, pContext, profEntry);\n         else\n             pObj->currentProfilerContext = pContext->previous;\n-        if (pContext)\n-            PyMem_Free(pContext);\n+        if (pContext) {\n+            /* Mark for deletion instead of immediately freeing */\n+            pContext->marked_for_deletion = 1;\n+        }\n     }\n-\n }\n \n PyDoc_STRVAR(disable_doc, \"\\\n@@ -812,7 +850,14 @@ profiler_disable(ProfilerObject *self, PyObject* noarg)\n         Py_DECREF(monitoring);\n \n         self->flags &= ~POF_ENABLED;\n-        flush_unmatched(self);\n+        \n+        /* Only flush if we're not in a callback to prevent use-after-free */\n+        if (!(self->flags & POF_IN_CALLBACK)) {\n+            flush_unmatched(self);\n+        } else {\n+            /* Mark that we need to flush when it's safe */\n+            self->flags |= POF_NEED_FLUSH;\n+        }\n     }\n \n     if (pending_exception(self)) {\n", "result": true}