{"patch": "diff --git a/.gitignore b/.gitignore\nindex 8872e9d5508..959a12bbd57 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -171,3 +171,9 @@ Python/frozen_modules/MANIFEST\n \n # main branch only: ABI files are not checked/maintained.\n Doc/data/python*.abi\n+build/\n+Build/\n+bin/\n+lib/\n+*.out\n+*.obj\ndiff --git a/Modules/_lsprof.c b/Modules/_lsprof.c\nindex 5cf9eba243b..36f6361163e 100644\n--- a/Modules/_lsprof.c\n+++ b/Modules/_lsprof.c\n@@ -42,6 +42,7 @@ typedef struct _ProfilerContext {\n     PyTime_t subt;\n     struct _ProfilerContext *previous;\n     ProfilerEntry *ctxEntry;\n+    int marked_for_deletion;  /* Flag to mark context for deferred deletion */\n } ProfilerContext;\n \n typedef struct {\n@@ -60,6 +61,8 @@ typedef struct {\n #define POF_SUBCALLS    0x002\n #define POF_BUILTINS    0x004\n #define POF_NOMEMORY    0x100\n+#define POF_IN_CALLBACK 0x200\n+#define POF_NEED_FLUSH  0x400\n \n /*[clinic input]\n module _lsprof\n@@ -114,11 +117,33 @@ static PyTime_t CallExternalTimer(ProfilerObject *pObj)\n     return result;\n }\n \n+/* Forward declaration */\n+static void flush_unmatched(ProfilerObject *pObj);\n+\n static inline PyTime_t\n call_timer(ProfilerObject *pObj)\n {\n     if (pObj->externalTimer != NULL) {\n-        return CallExternalTimer(pObj);\n+        /* Set flag to prevent re-entrant calls during timer callback */\n+        int was_in_callback = pObj->flags & POF_IN_CALLBACK;\n+        if (was_in_callback) {\n+            /* Already in a callback, avoid re-entrance */\n+            PyTime_t t;\n+            (void)PyTime_PerfCounterRaw(&t);\n+            return t;\n+        }\n+        \n+        pObj->flags |= POF_IN_CALLBACK;\n+        PyTime_t result = CallExternalTimer(pObj);\n+        pObj->flags &= ~POF_IN_CALLBACK;\n+        \n+        /* Check if we need to flush after exiting callback */\n+        if (pObj->flags & POF_NEED_FLUSH) {\n+            pObj->flags &= ~POF_NEED_FLUSH;\n+            flush_unmatched(pObj);\n+        }\n+        \n+        return result;\n     }\n     else {\n         PyTime_t t;\n@@ -128,6 +153,7 @@ call_timer(ProfilerObject *pObj)\n }\n \n \n+\n /*** ProfilerObject ***/\n \n static PyObject *\n@@ -278,9 +304,10 @@ static void clearEntries(ProfilerObject *pObj)\n     RotatingTree_Enum(pObj->profilerEntries, freeEntry, NULL);\n     pObj->profilerEntries = EMPTY_ROTATING_TREE;\n     /* release the memory hold by the ProfilerContexts */\n-    if (pObj->currentProfilerContext) {\n-        PyMem_Free(pObj->currentProfilerContext);\n-        pObj->currentProfilerContext = NULL;\n+    while (pObj->currentProfilerContext) {\n+        ProfilerContext *c = pObj->currentProfilerContext;\n+        pObj->currentProfilerContext = c->previous;\n+        PyMem_Free(c);\n     }\n     while (pObj->freelistProfilerContext) {\n         ProfilerContext *c = pObj->freelistProfilerContext;\n@@ -296,6 +323,7 @@ initContext(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n     self->ctxEntry = entry;\n     self->subt = 0;\n     self->previous = pObj->currentProfilerContext;\n+    self->marked_for_deletion = 0;  /* Initialize the deletion flag */\n     pObj->currentProfilerContext = self;\n     ++entry->recursionLevel;\n     if ((pObj->flags & POF_SUBCALLS) && self->previous) {\n@@ -393,6 +421,15 @@ ptrace_leave_call(PyObject *self, void *key)\n     pContext = pObj->currentProfilerContext;\n     if (pContext == NULL)\n         return;\n+    \n+    /* Check if this context was marked for deletion */\n+    if (pContext->marked_for_deletion) {\n+        /* Context was marked for deletion, just remove it from the stack and free it */\n+        pObj->currentProfilerContext = pContext->previous;\n+        PyMem_Free(pContext);\n+        return;\n+    }\n+    \n     profEntry = getEntry(pObj, key);\n     if (profEntry) {\n         Stop(pObj, pContext, profEntry);\n@@ -762,10 +799,11 @@ flush_unmatched(ProfilerObject *pObj)\n             Stop(pObj, pContext, profEntry);\n         else\n             pObj->currentProfilerContext = pContext->previous;\n-        if (pContext)\n-            PyMem_Free(pContext);\n+        if (pContext) {\n+            /* Mark for deletion instead of immediately freeing */\n+            pContext->marked_for_deletion = 1;\n+        }\n     }\n-\n }\n \n PyDoc_STRVAR(disable_doc, \"\\\n@@ -812,7 +850,14 @@ profiler_disable(ProfilerObject *self, PyObject* noarg)\n         Py_DECREF(monitoring);\n \n         self->flags &= ~POF_ENABLED;\n-        flush_unmatched(self);\n+        \n+        /* Only flush if we're not in a callback to prevent use-after-free */\n+        if (!(self->flags & POF_IN_CALLBACK)) {\n+            flush_unmatched(self);\n+        } else {\n+            /* Mark that we need to flush when it's safe */\n+            self->flags |= POF_NEED_FLUSH;\n+        }\n     }\n \n     if (pending_exception(self)) {\n", "result": false, "error": "Traceback (most recent call last):\n  File \"/gentest-cpython/py-pr-120297/generated_3.py\", line 208, in <module>\n    main()\n    ~~~~^^\n  File \"/gentest-cpython/py-pr-120297/generated_3.py\", line 202, in main\n    run_and_check('clear-call', code_clear_on_call)\n    ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/gentest-cpython/py-pr-120297/generated_3.py\", line 5, in run_and_check\n    rc, out, err = assert_python_ok('-c', code)\n                   ~~~~~~~~~~~~~~~~^^^^^^^^^^^^\n  File \"/tmp/py-pr-120297/build/Lib/test/support/script_helper.py\", line 182, in assert_python_ok\n    return _assert_python(True, *args, **env_vars)\n  File \"/tmp/py-pr-120297/build/Lib/test/support/script_helper.py\", line 167, in _assert_python\n    res.fail(cmd_line)\n    ~~~~~~~~^^^^^^^^^^\n  File \"/tmp/py-pr-120297/build/Lib/test/support/script_helper.py\", line 80, in fail\n    raise AssertionError(f\"Process return code is {exitcode}\\n\"\n    ...<10 lines>...\n                         f\"---\")\nAssertionError: Process return code is 1\ncommand line: ['/tmp/py-pr-120297/build/python', '-X', 'faulthandler', '-I', '-c', \"if 1:\\n    import _lsprof, sys\\n\\n    prof = None\\n\\n    class ClearTimer:\\n        def __init__(self, trip_at):\\n            self.count = 0\\n            self.trip_at = trip_at\\n        def __call__(self):\\n            global prof\\n            self.count += 1\\n            if self.count == self.trip_at:\\n                prof.clear()\\n            return self.count\\n\\n    def do_one_call_and_return():\\n        (lambda: None)()\\n\\n    captured = {}\\n    def hook(unraisable):\\n        captured['type'] = unraisable.exc_type\\n        captured['value'] = unraisable.exc_value\\n    sys.unraisablehook = hook\\n\\n    prof = _lsprof.Profiler(ClearTimer(1))  # trigger on call event\\n    prof.enable()\\n    do_one_call_and_return()\\n    prof.disable()\\n    prof.clear()\\n\\n    if captured.get('type') is RuntimeError and 'cannot clear profiler in external timer' in str(captured.get('value')):\\n        print('PASS clear-call')\\n    else:\\n        print('SKIP clear-call')\\n\"]\n\nstdout:\n---\n\n---\n\nstderr:\n---\n=================================================================\n==667268==ERROR: AddressSanitizer: heap-use-after-free on address 0x504000061510 at pc 0x7f4f99545aae bp 0x7ffe9bf19390 sp 0x7ffe9bf19388\nWRITE of size 8 at 0x504000061510 thread T0\n    #0 0x7f4f99545aad in initContext /tmp/py-pr-120297/build/./Modules/_lsprof.c:338:14\n    #1 0x7f4f995449e0 in ptrace_enter_call /tmp/py-pr-120297/build/./Modules/_lsprof.c:407:5\n    #2 0x7f4f99544841 in pystart_callback /tmp/py-pr-120297/build/./Modules/_lsprof.c:641:5\n    #3 0x56002f41c06d in cfunction_vectorcall_FASTCALL /tmp/py-pr-120297/build/Objects/methodobject.c:425:24\n    #4 0x56002f82c71f in _PyObject_VectorcallTstate /tmp/py-pr-120297/build/./Include/internal/pycore_call.h:167:11\n    #5 0x56002f825b67 in call_one_instrument /tmp/py-pr-120297/build/Python/instrumentation.c:907:21\n    #6 0x56002f8238ac in call_instrumentation_vector /tmp/py-pr-120297/build/Python/instrumentation.c:1095:19\n    #7 0x56002f8235ac in _Py_call_instrumentation /tmp/py-pr-120297/build/Python/instrumentation.c:1132:12\n    #8 0x56002f6f77a3 in _PyEval_EvalFrameDefault /tmp/py-pr-120297/build/Python/generated_cases.c.h:3791:27\n    #9 0x56002f6d5f01 in _PyEval_EvalFrame /tmp/py-pr-120297/build/./Include/internal/pycore_ceval.h:119:16\n    #10 0x56002f6d5dfe in _PyEval_Vector /tmp/py-pr-120297/build/Python/ceval.c:1866:12\n    #11 0x56002f6d577c in PyEval_EvalCode /tmp/py-pr-120297/build/Python/ceval.c:624:21\n    #12 0x56002f888693 in run_eval_code_obj /tmp/py-pr-120297/build/Python/pythonrun.c:1292:9\n    #13 0x56002f8883cb in run_mod /tmp/py-pr-120297/build/Python/pythonrun.c:1377:19\n    #14 0x56002f884616 in _PyRun_StringFlagsWithName /tmp/py-pr-120297/build/Python/pythonrun.c:1176:15\n    #15 0x56002f88427e in _PyRun_SimpleStringFlagsWithName /tmp/py-pr-120297/build/Python/pythonrun.c:516:15\n    #16 0x56002f91b467 in pymain_run_command"}