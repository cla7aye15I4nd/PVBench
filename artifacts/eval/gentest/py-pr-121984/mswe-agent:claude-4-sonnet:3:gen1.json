{"patch": "diff --git a/.gitignore b/.gitignore\nindex 8872e9d5508..959a12bbd57 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -171,3 +171,9 @@ Python/frozen_modules/MANIFEST\n \n # main branch only: ABI files are not checked/maintained.\n Doc/data/python*.abi\n+build/\n+Build/\n+bin/\n+lib/\n+*.out\n+*.obj\ndiff --git a/Modules/_lsprof.c b/Modules/_lsprof.c\nindex 5cf9eba243b..911f4ef3c7a 100644\n--- a/Modules/_lsprof.c\n+++ b/Modules/_lsprof.c\n@@ -293,6 +293,11 @@ static void clearEntries(ProfilerObject *pObj)\n static void\n initContext(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n {\n+    /* Get the timer value first, before setting up context linkage.\n+     * This prevents use-after-free if call_timer triggers re-entrant\n+     * calls that might disable the profiler and free contexts. */\n+    PyTime_t t0 = call_timer(pObj);\n+    \n     self->ctxEntry = entry;\n     self->subt = 0;\n     self->previous = pObj->currentProfilerContext;\n@@ -307,26 +312,43 @@ initContext(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n         if (subentry)\n             ++subentry->recursionLevel;\n     }\n-    self->t0 = call_timer(pObj);\n+    self->t0 = t0;\n }\n \n static void\n Stop(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n {\n-    PyTime_t tt = call_timer(pObj) - self->t0;\n-    PyTime_t it = tt - self->subt;\n-    if (self->previous)\n-        self->previous->subt += tt;\n-    pObj->currentProfilerContext = self->previous;\n+    /* Save all context values before calling timer, since call_timer\n+     * might trigger re-entrant calls that free the context. */\n+    PyTime_t t0 = self->t0;\n+    PyTime_t subt = self->subt;\n+    ProfilerContext *previous = self->previous;\n+    \n+    /* Put the context back in the free list before calling timer,\n+     * since the timer call might trigger re-entrant calls that could\n+     * free this context. */\n+    self->previous = pObj->freelistProfilerContext;\n+    pObj->freelistProfilerContext = self;\n+    \n+    /* Update the current context pointer before calling timer */\n+    pObj->currentProfilerContext = previous;\n+    \n+    /* Now get the current timer value */\n+    PyTime_t current_time = call_timer(pObj);\n+    PyTime_t tt = current_time - t0;\n+    PyTime_t it = tt - subt;\n+    \n+    if (previous)\n+        previous->subt += tt;\n     if (--entry->recursionLevel == 0)\n         entry->tt += tt;\n     else\n         ++entry->recursivecallcount;\n     entry->it += it;\n     entry->callcount++;\n-    if ((pObj->flags & POF_SUBCALLS) && self->previous) {\n+    if ((pObj->flags & POF_SUBCALLS) && previous) {\n         /* find or create an entry for me in my caller's entry */\n-        ProfilerEntry *caller = self->previous->ctxEntry;\n+        ProfilerEntry *caller = previous->ctxEntry;\n         ProfilerSubEntry *subentry = getSubEntry(pObj, caller, entry);\n         if (subentry) {\n             if (--subentry->recursionLevel == 0)\n@@ -393,16 +415,20 @@ ptrace_leave_call(PyObject *self, void *key)\n     pContext = pObj->currentProfilerContext;\n     if (pContext == NULL)\n         return;\n+    \n     profEntry = getEntry(pObj, key);\n     if (profEntry) {\n         Stop(pObj, pContext, profEntry);\n+        /* Stop() handles putting the context back in the free list\n+         * and updating pObj->currentProfilerContext */\n     }\n     else {\n+        /* No profEntry found, just update the current context */\n         pObj->currentProfilerContext = pContext->previous;\n+        /* put pContext into the free list */\n+        pContext->previous = pObj->freelistProfilerContext;\n+        pObj->freelistProfilerContext = pContext;\n     }\n-    /* put pContext into the free list */\n-    pContext->previous = pObj->freelistProfilerContext;\n-    pObj->freelistProfilerContext = pContext;\n }\n \n static int\n@@ -755,17 +781,34 @@ profiler_enable(ProfilerObject *self, PyObject *args, PyObject *kwds)\n static void\n flush_unmatched(ProfilerObject *pObj)\n {\n+    /* First, collect all contexts that are currently active */\n+    ProfilerContext *active_contexts = NULL;\n     while (pObj->currentProfilerContext) {\n         ProfilerContext *pContext = pObj->currentProfilerContext;\n         ProfilerEntry *profEntry= pContext->ctxEntry;\n         if (profEntry)\n             Stop(pObj, pContext, profEntry);\n-        else\n+        else {\n             pObj->currentProfilerContext = pContext->previous;\n-        if (pContext)\n-            PyMem_Free(pContext);\n+            /* Add to our list of active contexts to free */\n+            pContext->previous = active_contexts;\n+            active_contexts = pContext;\n+        }\n+    }\n+    \n+    /* Free all active contexts */\n+    while (active_contexts) {\n+        ProfilerContext *pContext = active_contexts;\n+        active_contexts = pContext->previous;\n+        PyMem_Free(pContext);\n+    }\n+    \n+    /* Clear the free list since all contexts should be freed */\n+    while (pObj->freelistProfilerContext) {\n+        ProfilerContext *pContext = pObj->freelistProfilerContext;\n+        pObj->freelistProfilerContext = pContext->previous;\n+        PyMem_Free(pContext);\n     }\n-\n }\n \n PyDoc_STRVAR(disable_doc, \"\\\n", "result": true}