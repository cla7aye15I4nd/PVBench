{"patch": "diff --git a/Modules/_lsprof.c b/Modules/_lsprof.c\nindex 5cf9eba243b..ec5acd3eb42 100644\n--- a/Modules/_lsprof.c\n+++ b/Modules/_lsprof.c\n@@ -291,7 +291,7 @@ static void clearEntries(ProfilerObject *pObj)\n }\n \n static void\n-initContext(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n+initContext(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry, PyTime_t t0)\n {\n     self->ctxEntry = entry;\n     self->subt = 0;\n@@ -307,13 +307,13 @@ initContext(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n         if (subentry)\n             ++subentry->recursionLevel;\n     }\n-    self->t0 = call_timer(pObj);\n+    self->t0 = t0;\n }\n \n static void\n-Stop(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n+Stop(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry, PyTime_t tt)\n {\n-    PyTime_t tt = call_timer(pObj) - self->t0;\n+    tt = tt - self->t0;\n     PyTime_t it = tt - self->subt;\n     if (self->previous)\n         self->previous->subt += tt;\n@@ -376,7 +376,8 @@ ptrace_enter_call(PyObject *self, void *key, PyObject *userObj)\n             goto restorePyerr;\n         }\n     }\n-    initContext(pObj, pContext, profEntry);\n+    PyTime_t t0 = call_timer(pObj);\n+    initContext(pObj, pContext, profEntry, t0);\n \n restorePyerr:\n     PyErr_SetRaisedException(exc);\n@@ -385,6 +386,8 @@ ptrace_enter_call(PyObject *self, void *key, PyObject *userObj)\n static void\n ptrace_leave_call(PyObject *self, void *key)\n {\n+    /* Store the timer value before any potential external timer calls */\n+    PyTime_t tt;\n     /* leaving a call to the function identified by 'key' */\n     ProfilerObject *pObj = (ProfilerObject*)self;\n     ProfilerEntry *profEntry;\n@@ -393,11 +396,21 @@ ptrace_leave_call(PyObject *self, void *key)\n     pContext = pObj->currentProfilerContext;\n     if (pContext == NULL)\n         return;\n+    \n+    /* Get timer value early to avoid external timer calls during context access */\n+    tt = call_timer(pObj);\n+    \n+    /* Check if profiler is still enabled after timer call */\n+    if (!(pObj->flags & POF_ENABLED) || pObj->currentProfilerContext != pContext)\n+        return;\n+        \n     profEntry = getEntry(pObj, key);\n     if (profEntry) {\n-        Stop(pObj, pContext, profEntry);\n+        Stop(pObj, pContext, profEntry, tt);\n     }\n     else {\n+        /* Only update if profiler is still enabled and context is still valid */\n+        if ((pObj->flags & POF_ENABLED) && pObj->currentProfilerContext == pContext)\n         pObj->currentProfilerContext = pContext->previous;\n     }\n     /* put pContext into the free list */\n@@ -759,7 +772,8 @@ flush_unmatched(ProfilerObject *pObj)\n         ProfilerContext *pContext = pObj->currentProfilerContext;\n         ProfilerEntry *profEntry= pContext->ctxEntry;\n         if (profEntry)\n-            Stop(pObj, pContext, profEntry);\n+            /* Use current time for flushing unmatched contexts */\n+            Stop(pObj, pContext, profEntry, call_timer(pObj));\n         else\n             pObj->currentProfilerContext = pContext->previous;\n         if (pContext)\n", "result": true}