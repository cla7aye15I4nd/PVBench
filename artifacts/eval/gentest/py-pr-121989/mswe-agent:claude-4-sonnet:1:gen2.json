{"patch": "diff --git a/.gitignore b/.gitignore\nindex bde596a7a02..cc0fc267f06 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -156,3 +156,9 @@ Python/frozen_modules/MANIFEST\n # Ignore ./python binary on Unix but still look into ./Python/ directory.\n /python\n !/Python/\n+build/\n+Build/\n+bin/\n+lib/\n+*.out\n+*.obj\ndiff --git a/Modules/_lsprof.c b/Modules/_lsprof.c\nindex 257de4387c0..977d9d9328d 100644\n--- a/Modules/_lsprof.c\n+++ b/Modules/_lsprof.c\n@@ -287,7 +287,7 @@ static void clearEntries(ProfilerObject *pObj)\n }\n \n static void\n-initContext(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n+initContext(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry, _PyTime_t t0)\n {\n     self->ctxEntry = entry;\n     self->subt = 0;\n@@ -303,26 +303,29 @@ initContext(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n         if (subentry)\n             ++subentry->recursionLevel;\n     }\n-    self->t0 = call_timer(pObj);\n+    self->t0 = t0;\n }\n \n static void\n Stop(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n {\n-    _PyTime_t tt = call_timer(pObj) - self->t0;\n-    _PyTime_t it = tt - self->subt;\n-    if (self->previous)\n-        self->previous->subt += tt;\n-    pObj->currentProfilerContext = self->previous;\n+    _PyTime_t t0 = self->t0;\n+    _PyTime_t subt = self->subt;\n+    ProfilerContext *previous = self->previous;\n+    _PyTime_t tt = call_timer(pObj) - t0;\n+    _PyTime_t it = tt - subt;\n+    if (previous)\n+        previous->subt += tt;\n+    pObj->currentProfilerContext = previous;\n     if (--entry->recursionLevel == 0)\n         entry->tt += tt;\n     else\n         ++entry->recursivecallcount;\n     entry->it += it;\n     entry->callcount++;\n-    if ((pObj->flags & POF_SUBCALLS) && self->previous) {\n+    if ((pObj->flags & POF_SUBCALLS) && previous) {\n         /* find or create an entry for me in my caller's entry */\n-        ProfilerEntry *caller = self->previous->ctxEntry;\n+        ProfilerEntry *caller = previous->ctxEntry;\n         ProfilerSubEntry *subentry = getSubEntry(pObj, caller, entry);\n         if (subentry) {\n             if (--subentry->recursionLevel == 0)\n@@ -372,7 +375,8 @@ ptrace_enter_call(PyObject *self, void *key, PyObject *userObj)\n             goto restorePyerr;\n         }\n     }\n-    initContext(pObj, pContext, profEntry);\n+    _PyTime_t t0 = call_timer(pObj);\n+    initContext(pObj, pContext, profEntry, t0);\n \n restorePyerr:\n     PyErr_SetRaisedException(exc);\n@@ -389,16 +393,30 @@ ptrace_leave_call(PyObject *self, void *key)\n     pContext = pObj->currentProfilerContext;\n     if (pContext == NULL)\n         return;\n+    \n+    /* Save the previous pointer and current context before calling Stop */\n+    ProfilerContext *previous = pContext->previous;\n+    ProfilerContext *original_context = pContext;\n+    \n     profEntry = getEntry(pObj, key);\n     if (profEntry) {\n         Stop(pObj, pContext, profEntry);\n+        /* After Stop(), check if the current context is still the original context.\n+         * If flush_unmatched() was called during Stop(), pContext would have been freed\n+         * and currentProfilerContext would have been updated to previous. */\n+        if (pObj->currentProfilerContext == original_context) {\n+            /* Context is still valid, add it to free list */\n+            pContext->previous = pObj->freelistProfilerContext;\n+            pObj->freelistProfilerContext = pContext;\n+        }\n+        /* else: pContext was freed by flush_unmatched(), don't access it */\n     }\n     else {\n-        pObj->currentProfilerContext = pContext->previous;\n+        pObj->currentProfilerContext = previous;\n+        /* put pContext into the free list */\n+        pContext->previous = pObj->freelistProfilerContext;\n+        pObj->freelistProfilerContext = pContext;\n     }\n-    /* put pContext into the free list */\n-    pContext->previous = pObj->freelistProfilerContext;\n-    pObj->freelistProfilerContext = pContext;\n }\n \n static int\n", "result": true}