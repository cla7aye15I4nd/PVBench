{"patch": "diff --git a/Modules/_lsprof.c b/Modules/_lsprof.c\nindex 257de4387c0..b59d911ea81 100644\n--- a/Modules/_lsprof.c\n+++ b/Modules/_lsprof.c\n@@ -289,10 +289,11 @@ static void clearEntries(ProfilerObject *pObj)\n static void\n initContext(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n {\n+    _PyTime_t t0 = call_timer(pObj);\n     self->ctxEntry = entry;\n     self->subt = 0;\n     self->previous = pObj->currentProfilerContext;\n-    pObj->currentProfilerContext = self;\n+    self->t0 = t0;\n     ++entry->recursionLevel;\n     if ((pObj->flags & POF_SUBCALLS) && self->previous) {\n         /* find or create an entry for me in my caller's entry */\n@@ -303,13 +304,20 @@ initContext(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n         if (subentry)\n             ++subentry->recursionLevel;\n     }\n-    self->t0 = call_timer(pObj);\n+    pObj->currentProfilerContext = self;\n }\n \n static void\n Stop(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n {\n-    _PyTime_t tt = call_timer(pObj) - self->t0;\n+    _PyTime_t t0 = self->t0;\n+    _PyTime_t subt = self->subt;\n+    ProfilerContext *previous = self->previous;\n+    \n+    /* Temporarily remove from chain to prevent use-after-free during timer call */\n+    pObj->currentProfilerContext = previous;\n+    _PyTime_t current_time = call_timer(pObj);\n+    _PyTime_t tt = current_time - t0;\n     _PyTime_t it = tt - self->subt;\n     if (self->previous)\n         self->previous->subt += tt;\n", "result": true}