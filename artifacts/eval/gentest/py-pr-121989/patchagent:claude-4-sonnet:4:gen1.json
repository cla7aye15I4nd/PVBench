{"patch": "diff --git a/Modules/_lsprof.c b/Modules/_lsprof.c\nindex 257de4387c0..cc097923543 100644\n--- a/Modules/_lsprof.c\n+++ b/Modules/_lsprof.c\n@@ -303,13 +303,26 @@ initContext(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n         if (subentry)\n             ++subentry->recursionLevel;\n     }\n-    self->t0 = call_timer(pObj);\n+    _PyTime_t timer_result = call_timer(pObj);\n+    /* Check if the context is still valid after the timer call,\n+       as external timers can trigger profiler disable */\n+    if (pObj->currentProfilerContext == self) {\n+        self->t0 = timer_result;\n+    }\n }\n \n static void\n Stop(ProfilerObject *pObj, ProfilerContext *self, ProfilerEntry *entry)\n {\n-    _PyTime_t tt = call_timer(pObj) - self->t0;\n+    _PyTime_t timer_result = call_timer(pObj);\n+    /* Check if the context is still valid after the timer call,\n+       as external timers can trigger profiler disable */\n+    if (pObj->currentProfilerContext != self) {\n+        /* Context was freed during timer call, nothing to do */\n+        return;\n+    }\n+    \n+    _PyTime_t tt = timer_result - self->t0;\n     _PyTime_t it = tt - self->subt;\n     if (self->previous)\n         self->previous->subt += tt;\n@@ -385,20 +398,33 @@ ptrace_leave_call(PyObject *self, void *key)\n     ProfilerObject *pObj = (ProfilerObject*)self;\n     ProfilerEntry *profEntry;\n     ProfilerContext *pContext;\n+    ProfilerContext *pPrevious;\n+    int was_enabled;\n \n     pContext = pObj->currentProfilerContext;\n     if (pContext == NULL)\n         return;\n+    /* Save the previous context and enabled state before any calls */\n+    pPrevious = pContext->previous;\n+    was_enabled = pObj->flags & POF_ENABLED;\n+    \n     profEntry = getEntry(pObj, key);\n     if (profEntry) {\n         Stop(pObj, pContext, profEntry);\n     }\n     else {\n-        pObj->currentProfilerContext = pContext->previous;\n+        pObj->currentProfilerContext = pPrevious;\n+    }\n+    \n+    /* Only manipulate pContext if profiler is still enabled and context wasn't freed */\n+    if ((pObj->flags & POF_ENABLED) && was_enabled && \n+        pObj->currentProfilerContext == pPrevious) {\n+        /* pContext is still valid, put it into the free list */\n+        pContext->previous = pObj->freelistProfilerContext;\n+        pObj->freelistProfilerContext = pContext;\n     }\n-    /* put pContext into the free list */\n-    pContext->previous = pObj->freelistProfilerContext;\n-    pObj->freelistProfilerContext = pContext;\n+    /* If profiler was disabled or pContext was freed, it was already handled \n+       in flush_unmatched, so we don't need to do anything */\n }\n \n static int\n", "result": false, "error": "Traceback (most recent call last):\n  File \"/gentest-cpython/py-pr-121989/generated_1.py\", line 186, in <module>\n    test_disable_in_external_timer_disallowed_call_and_return_events()\n  File \"/gentest-cpython/py-pr-121989/generated_1.py\", line 70, in test_disable_in_external_timer_disallowed_call_and_return_events\n    run_subprocess_and_check(code, expected)\n  File \"/gentest-cpython/py-pr-121989/generated_1.py\", line 35, in run_subprocess_and_check\n    assert s in err, f\"Expected {s!r} in stderr, got: {err!r}\"\n           ^^^^^^^^\nAssertionError: Expected b'RuntimeError: cannot disable profiler in external timer' in stderr, got: b''\n"}