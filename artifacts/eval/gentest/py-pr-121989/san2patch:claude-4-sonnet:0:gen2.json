{"patch": "diff --git a/Modules/_lsprof.c b/Modules/_lsprof.c\nindex 257de4387c0..9f872e944b3 100644\n--- a/Modules/_lsprof.c\n+++ b/Modules/_lsprof.c\n@@ -352,7 +352,13 @@ ptrace_enter_call(PyObject *self, void *key, PyObject *userObj)\n      * save and restore any current exception. */\n     PyObject *exc = PyErr_GetRaisedException();\n \n-    profEntry = getEntry(pObj, key);\n+    /* Check if profiler is still active before accessing memory */\n+    if (pObj->flags & POF_NOMEMORY) {\n+        goto restorePyerr;\n+    }\n+\n+// FIXME: Crash CWE-416: Use After Free\n+     profEntry = getEntry(pObj, key);\n     if (profEntry == NULL) {\n         profEntry = newProfilerEntry(pObj, key, userObj);\n         if (profEntry == NULL)\n@@ -745,7 +751,8 @@ profiler_enable(ProfilerObject *self, PyObject *args, PyObject *kwds)\n     Py_DECREF(monitoring);\n \n     self->flags |= POF_ENABLED;\n-    Py_RETURN_NONE;\n+// FIXME: Crash CWE-416: Use After Free\n+     Py_RETURN_NONE;\n }\n \n static void\n@@ -758,7 +765,8 @@ flush_unmatched(ProfilerObject *pObj)\n             Stop(pObj, pContext, profEntry);\n         else\n             pObj->currentProfilerContext = pContext->previous;\n-        if (pContext)\n+        // Clear the pointer after cleanup to prevent use-after-free\n+        pContext = NULL;        if (pContext)\n             PyMem_Free(pContext);\n     }\n \n", "result": true}