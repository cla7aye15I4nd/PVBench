{"patch": "diff --git a/.gitignore b/.gitignore\nindex 8872e9d5508..959a12bbd57 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -171,3 +171,9 @@ Python/frozen_modules/MANIFEST\n \n # main branch only: ABI files are not checked/maintained.\n Doc/data/python*.abi\n+build/\n+Build/\n+bin/\n+lib/\n+*.out\n+*.obj\ndiff --git a/Objects/frameobject.c b/Objects/frameobject.c\nindex d6b4065e130..8f0dd4e466f 100644\n--- a/Objects/frameobject.c\n+++ b/Objects/frameobject.c\n@@ -19,6 +19,13 @@\n \n #define OFF(x) offsetof(PyFrameObject, x)\n \n+// Returns borrowed reference or NULL\n+static PyObject *\n+framelocalsproxy_getval(_PyInterpreterFrame *frame, PyCodeObject *co, int i);\n+\n+// Forward declaration for frame_get_var\n+static int\n+frame_get_var(_PyInterpreterFrame *frame, PyCodeObject *co, int i, PyObject **pvalue);\n \n // Returns borrowed reference or NULL\n static PyObject *\n@@ -134,9 +141,16 @@ framelocalsproxy_getitem(PyObject *self, PyObject *key)\n         return NULL;\n     }\n     if (i >= 0) {\n-        PyObject *value = framelocalsproxy_getval(frame->f_frame, co, i);\n-        assert(value != NULL);\n-        return Py_NewRef(value);\n+        PyObject *value;\n+        if (!frame_get_var(frame->f_frame, co, i, &value)) {\n+            PyErr_Format(PyExc_KeyError, \"local variable is not defined\");\n+            return NULL;\n+        }\n+        if (value == NULL) {\n+            PyErr_Format(PyExc_KeyError, \"local variable is not defined\");\n+            return NULL;\n+        }\n+        return value;  // frame_get_var already returns a new reference\n     }\n \n     // Okay not in the fast locals, try extra locals\n@@ -487,12 +501,14 @@ framelocalsproxy_values(PyObject *self, void *Py_UNUSED(ignored))\n     }\n \n     for (int i = 0; i < co->co_nlocalsplus; i++) {\n-        PyObject *value = framelocalsproxy_getval(frame->f_frame, co, i);\n-        if (value) {\n+        PyObject *value;\n+        if (frame_get_var(frame->f_frame, co, i, &value) && value != NULL) {\n             if (PyList_Append(values, value) < 0) {\n+                Py_DECREF(value);\n                 Py_DECREF(values);\n                 return NULL;\n             }\n+            Py_DECREF(value);  // frame_get_var returns a new reference, so we need to decref\n         }\n     }\n \n@@ -524,10 +540,10 @@ framelocalsproxy_items(PyObject *self, void *Py_UNUSED(ignored))\n \n     for (int i = 0; i < co->co_nlocalsplus; i++) {\n         PyObject *name = PyTuple_GET_ITEM(co->co_localsplusnames, i);\n-        PyObject *value = framelocalsproxy_getval(frame->f_frame, co, i);\n-\n-        if (value) {\n+        PyObject *value;\n+        if (frame_get_var(frame->f_frame, co, i, &value) && value != NULL) {\n             PyObject *pair = PyTuple_Pack(2, name, value);\n+            Py_DECREF(value);  // frame_get_var returns a new reference, so we need to decref\n             if (pair == NULL) {\n                 Py_DECREF(items);\n                 return NULL;\n", "result": false, "error": "Traceback (most recent call last):\n  File \"/gentest-cpython/py-pr-125723/generated_3.py\", line 121, in <module>\n    test_generator_frames_and_locals_outlive_generator_no_crash()\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^\n  File \"/gentest-cpython/py-pr-125723/generated_3.py\", line 114, in test_generator_frames_and_locals_outlive_generator_no_crash\n    rc, out, err = assert_python_ok('-c', code)\n                   ~~~~~~~~~~~~~~~~^^^^^^^^^^^^\n  File \"/tmp/py-pr-125723/build/Lib/test/support/script_helper.py\", line 182, in assert_python_ok\n    return _assert_python(True, *args, **env_vars)\n  File \"/tmp/py-pr-125723/build/Lib/test/support/script_helper.py\", line 167, in _assert_python\n    res.fail(cmd_line)\n    ~~~~~~~~^^^^^^^^^^\n  File \"/tmp/py-pr-125723/build/Lib/test/support/script_helper.py\", line 80, in fail\n    raise AssertionError(f\"Process return code is {exitcode}\\n\"\n    ...<10 lines>...\n                         f\"---\")\nAssertionError: Process return code is 1\ncommand line: ['/tmp/py-pr-125723/build/python', '-X', 'faulthandler', '-I', '-c', 'if 1:\\n        import sys\\n\\n        # 1) Frames retrieved from generators, frame outlives generator\\n        def g1():\\n            a = 42\\n            # Return the current frame object itself\\n            yield sys._getframe()\\n\\n        def g2():\\n            a = 42\\n            # Yield control; caller will read gen.gi_frame\\n            yield\\n\\n        def g3(obj):\\n            a = 42\\n            # Stash frame into an external object\\n            obj.frame = sys._getframe()\\n            yield\\n\\n        class Holder:\\n            def __init__(self):\\n                self.frame = None\\n\\n        def get_frame(index):\\n            if index == 1:\\n                return next(g1())\\n            elif index == 2:\\n                gen = g2()\\n                next(gen)\\n                # Access the generator\\'s frame while it\\'s suspended\\n                return gen.gi_frame\\n            elif index == 3:\\n                h = Holder()\\n                next(g3(h))\\n                return h.frame\\n            else:\\n                return None\\n\\n        for index in (1, 2, 3):\\n            frame = get_frame(index)\\n            # Access f_locals of the frame and validate content\\n            frame_locals = frame.f_locals\\n            assert \\'a\\' in frame_locals, f\"Missing \\'a\\' in frame.f_locals for case {index}: {frame_locals}\"\\n            assert frame_locals[\\'a\\'] == 42, f\"Unexpected value for \\'a\\' in case {index}: {frame_locals}\"\\n\\n        # 2) f_locals objects outlive the generator object\\n        frame_locals_cell = [None]\\n\\n        def g4():\\n            # Assign first to ensure the mapping reflects the variable\\n            a = 42\\n            # Capture a live f_locals mapping from the running frame\\n            frame_locals_cell[0] = sys._getframe().f_locals\\n            yield\\n\\n        def g5():\\n            a = 42\\n            # Return the f_locals mapping directly\\n            yield sys._getframe().f_locals\\n\\n        def get_frame_locals(index):\\n            if index == 1:\\n                next(g4())\\n                return frame_locals_cell[0]\\n            elif index == 2:\\n                return next(g5())\\n            else:\\n                return None\\n\\n        for index in (1, 2):\\n            fl = get_frame_locals(index)\\n            assert \\'a\\' in fl, f\"Missing \\'a\\' in f_locals for case {index}: {fl}\"\\n            assert fl[\\'a\\'] == 42, f\"Unexpected value for \\'a\\' in f_locals for case {index}: {fl}\"\\n\\n        # 3) Repeated exec pattern (similar to poc) where the generator is not retained\\n        # and thus gets destroyed while the returned locals live on.\\n        def g():\\n            a = 42\\n            yield locals(), sys._getframe().f_locals\\n\\n        env = {\\'g\\': g}\\n        for i in range(10):\\n            # Each call creates a fresh generator that is not retained after next(),\\n            # so its frame/generator is cleaned"}