{"patch": "diff --git a/Modules/_asynciomodule.c b/Modules/_asynciomodule.c\nindex 18dc2859357..c47168d654b 100644\n--- a/Modules/_asynciomodule.c\n+++ b/Modules/_asynciomodule.c\n@@ -306,10 +306,32 @@ call_soon(asyncio_state *state, PyObject *loop, PyObject *func, PyObject *arg,\n             stack[2] = arg;\n             nargs++;\n         }\n+        // Ensure all objects are valid before proceeding\n+        if (loop == NULL || func == NULL || ctx == NULL) {\n+            PyErr_SetString(PyExc_ValueError, \"Invalid arguments to call_soon\");\n+            return -1;\n+        }\n+        // Acquire references to all objects to prevent deallocation during call\n+        Py_INCREF(loop);\n+        Py_INCREF(func);\n+        if (arg != NULL) {\n+            Py_INCREF(arg);\n+        }\n+        Py_INCREF(ctx);\n+        \n         stack[nargs] = (PyObject *)ctx;\n         size_t nargsf = nargs | PY_VECTORCALL_ARGUMENTS_OFFSET;\n-        handle = PyObject_VectorcallMethod(&_Py_ID(call_soon), stack, nargsf,\n+// FIXME: Crash CWE-416: Use After Free\n+         handle = PyObject_VectorcallMethod(&_Py_ID(call_soon), stack, nargsf,\n                                            state->context_kwname);\n+        \n+        // Release references after use\n+        Py_DECREF(loop);\n+        Py_DECREF(func);\n+        if (arg != NULL) {\n+            Py_DECREF(arg);\n+        }\n+        Py_DECREF(ctx);\n     }\n \n     if (handle == NULL) {\n", "result": true}