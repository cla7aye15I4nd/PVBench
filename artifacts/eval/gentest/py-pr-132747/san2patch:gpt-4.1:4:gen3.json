{"patch": "diff --git a/Objects/descrobject.c b/Objects/descrobject.c\nindex 268af0b217c..c1cd5e32692 100644\n--- a/Objects/descrobject.c\n+++ b/Objects/descrobject.c\n@@ -141,19 +141,30 @@ method_get(PyObject *self, PyObject *obj, PyObject *type)\n     if (obj == NULL) {\n         return Py_NewRef(descr);\n     }\n-    if (descr_check((PyDescrObject *)descr, obj) < 0) {\n+    if (!descr || !descr->d_method) {\n+        PyErr_SetString(PyExc_TypeError, \"descriptor is invalid or expired\");\n         return NULL;\n     }\n-    if (descr->d_method->ml_flags & METH_METHOD) {\n-        if (PyType_Check(type)) {\n-            return PyCMethod_New(descr->d_method, obj, NULL, descr->d_common.d_type);\n-        } else {\n+    if (descr_check((PyDescrObject *)descr, obj) < 0) {\n+        return NULL;\n+// FIXME: Crash CWE-825: Expired Pointer Dereference\n+     }\n+    if ((descr->d_method->ml_flags & METH_METHOD) != 0) {\n+        if (type == NULL) {\n+            PyErr_Format(PyExc_TypeError,\n+                        \"descriptor '%V' needs a type, got NULL instead\",\n+                        descr_name((PyDescrObject *)descr),\n+                        \"NULL\");\n+            return NULL;\n+        }\n+        if (!PyType_Check(type)) {\n             PyErr_Format(PyExc_TypeError,\n                         \"descriptor '%V' needs a type, not '%s', as arg 2\",\n                         descr_name((PyDescrObject *)descr),\n                         Py_TYPE(type)->tp_name);\n             return NULL;\n         }\n+        return PyCMethod_New(descr->d_method, obj, NULL, descr->d_common.d_type);\n     } else {\n         return PyCFunction_NewEx(descr->d_method, obj, NULL);\n     }\n", "result": false, "error": "Traceback (most recent call last):\n  File \"/gentest-cpython/py-pr-132747/generated_3.py\", line 80, in test_missing_owner_binding_does_not_crash_or_detects_vulnerability\n    rc, out, err = assert_python_ok('-c', code)\n                   ~~~~~~~~~~~~~~~~^^^^^^^^^^^^\n  File \"/tmp/py-pr-132747/build/Lib/test/support/script_helper.py\", line 182, in assert_python_ok\n    return _assert_python(True, *args, **env_vars)\n  File \"/tmp/py-pr-132747/build/Lib/test/support/script_helper.py\", line 167, in _assert_python\n    res.fail(cmd_line)\n    ~~~~~~~~^^^^^^^^^^\n  File \"/tmp/py-pr-132747/build/Lib/test/support/script_helper.py\", line 80, in fail\n    raise AssertionError(f\"Process return code is {exitcode}\\n\"\n    ...<10 lines>...\n                         f\"---\")\nAssertionError: Process return code is 1\ncommand line: ['/tmp/py-pr-132747/build/python', '-X', 'faulthandler', '-I', '-c', 'if 1:\\n    import types, sys\\n    import _io\\n    to_check = []\\n    # PoC target: TextIOBase.detach bound to sys.stderr\\n    to_check.append((_io._TextIOBase.detach, sys.stderr))\\n    # A few other common built-in/extension methods that are typically METH_METHOD\\n    to_check.append((str.capitalize, \"spam\"))\\n    to_check.append((dict.get, {}))\\n    to_check.append((list.append, []))\\n    try:\\n        import _queue as _q\\n        to_check.append((_q.SimpleQueue.put, _q.SimpleQueue()))\\n    except Exception:\\n        pass\\n\\n    for method, instance in to_check:\\n        bound = method.__get__(instance)\\n        assert isinstance(bound, types.BuiltinMethodType), (\\n            f\"Expected BuiltinMethodType for {method!r}, got {type(bound)}\")\\n        assert getattr(bound, \"__self__\", None) is instance, (\\n            \"Bound method should have __self__ == instance\")\\n\\n    # Additionally, exercise a few bound methods to ensure they are callable\\n    assert str.capitalize.__get__(\"abc\")() == \"Abc\", \"capitalize() returned wrong result\"\\n    d = {}\\n    getter = dict.get.__get__(d)\\n    assert getter(\"missing\") is None, \"dict.get bound method returned unexpected value\"\\n    lst = []\\n    append = list.append.__get__(lst)\\n    append(1)\\n    assert lst == [1], f\"append didn\\'t modify list as expected: {lst}\"\\n    try:\\n        import _queue as _q\\n        q = _q.SimpleQueue()\\n        put = _q.SimpleQueue.put.__get__(q)\\n        put(42)\\n        assert q.get() == 42\\n    except Exception:\\n        # If _queue is unavailable for some reason, just skip this part.\\n        pass\\n\\n    print(\"MISSING_OWNER_OK\")\\n    ']\n\nstdout:\n---\n\n---\n\nstderr:\n---\nTraceback (most recent call last):\n  File \"<string>\", line 18, in <module>\n    bound = method.__get__(instance)\nTypeError: descriptor 'detach' needs a type, got NULL instead\n---\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/gentest-cpython/py-pr-132747/generated_3.py\", line 164, in <module>\n    test_missing_owner_binding_does_not_crash_or_detects_vulnerability()\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^\n  File \"/gentest-cpython/py-pr-132747/generated_3.py\", line 87, in test_missing_owner_binding_does_not_crash_or_detects_vulnerability\n    assert _is_crash_assertion(e), (\n           ~~~~~~~~~~~~~~~~~~~^^^\nAssertionError: Unexpected failure mode; expected a crash-like return code. AssertionError was: Process return code is 1\ncommand line: ['/tmp/py-pr-132747/build/python', '-X', 'faulthandler', '-I', '-c', 'if 1:\\n    import types, sys\\n    import _io\\n    to_check = []\\n    # PoC target: TextIOBase.detach bound to sys.stderr\\n    to_check.append((_io._TextIOBase.detach, sys.stderr))\\n    # A few other common built-in/extension methods that are typically METH_METHOD\\n    to_check.append((str.capitalize, \"spam\"))\\n    to_check.append((dict.get, {}))\\n    to_check.append((list.append, []))\\n    try:\\n        import _queue as _q\\n        to_check.append((_q.SimpleQueue.put, _q.SimpleQueue()))\\n    except Exception:\\n        pass\\n\\"}