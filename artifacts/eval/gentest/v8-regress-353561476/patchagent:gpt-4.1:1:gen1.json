{"patch": "diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc\nindex 530a249adde..4883869693b 100644\n--- a/src/ast/scopes.cc\n+++ b/src/ast/scopes.cc\n@@ -2687,19 +2687,28 @@ void Scope::AllocateScopeInfosRecursively(\n \n   auto it = scope_infos_to_reuse.find(UniqueIdInScript());\n   if (it != scope_infos_to_reuse.end()) {\n-    scope_info_ = it->second;\n-    CHECK(NeedsContext());\n-    // The ScopeInfo chain mirrors the context chain, so we only link to the\n-    // next outer scope that needs a context.\n-    next_outer_scope = scope_info_;\n-    DCHECK(!scope_info_.is_null());\n-    DCHECK(!is_hidden_catch_scope());\n-    CHECK_EQ(scope_info_->scope_type(), scope_type_);\n-    CHECK_EQ(scope_info_->ContextLength(), num_heap_slots_);\n+    if (NeedsContext()) {\n+      scope_info_ = it->second;\n+      // The ScopeInfo chain mirrors the context chain, so we only link to the\n+      // next outer scope that needs a context.\n+      next_outer_scope = scope_info_;\n+      DCHECK(!scope_info_.is_null());\n+      DCHECK(!is_hidden_catch_scope());\n+      CHECK_EQ(scope_info_->scope_type(), scope_type_);\n+      CHECK_EQ(scope_info_->ContextLength(), num_heap_slots_);\n #ifdef DEBUG\n-    // Consume the scope info.\n-    it->second = {};\n+      // Consume the scope info.\n+      it->second = {};\n #endif\n+    } else {\n+      // If we don't need a context, clear the entry and proceed as if not found.\n+      scope_infos_to_reuse.erase(it);\n+      if (NeedsScopeInfo()) {\n+        // Will fall through to the next branch below.\n+      } else {\n+        return;\n+      }\n+    }\n   } else if (NeedsScopeInfo()) {\n #ifdef DEBUG\n     // Mark this ID as being used. Skip hidden scopes because they are\n", "result": true}