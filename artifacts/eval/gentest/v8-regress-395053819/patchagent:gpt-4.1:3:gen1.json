{"patch": "diff --git a/src/strings/string-hasher-inl.h b/src/strings/string-hasher-inl.h\nindex fd308f36b7d..60cb7f0c29d 100644\n--- a/src/strings/string-hasher-inl.h\n+++ b/src/strings/string-hasher-inl.h\n@@ -231,25 +231,28 @@ uint32_t StringHasher::HashSequentialString(const char_t* chars_raw,\n           // overflowed an array index.\n           static_assert(String::kMaxArrayIndexSize <\n                         String::kMaxIntegerIndexSize);\n-          switch (detail::TryParseIntegerIndex(chars, length, i, index)) {\n-            case detail::kSuccess: {\n-              uint32_t hash = String::CreateHashFieldValue(\n-                  GetUsableRapidHash(chars, length, seed),\n-                  String::HashFieldType::kIntegerIndex);\n-              if (Name::ContainsCachedArrayIndex(hash)) {\n-                // The hash accidentally looks like a cached index. Fix that by\n-                // setting a bit that looks like a longer-than-cacheable string\n-                // length.\n-                hash |= (String::kMaxCachedArrayIndexLength + 1)\n-                        << String::ArrayIndexLengthBits::kShift;\n-              }\n-              DCHECK(!Name::ContainsCachedArrayIndex(hash));\n-              return hash;\n-            }\n-            case detail::kNonIndex:\n-            case detail::kOverflow:\n-              break;\n-          }\n+           // Prevent passing invalid arguments to TryParseIntegerIndex.\n+           if (i > 0 && index > 0) {\n+             switch (detail::TryParseIntegerIndex(chars, length, i, index)) {\n+               case detail::kSuccess: {\n+                 uint32_t hash = String::CreateHashFieldValue(\n+                     GetUsableRapidHash(chars, length, seed),\n+                     String::HashFieldType::kIntegerIndex);\n+                 if (Name::ContainsCachedArrayIndex(hash)) {\n+                   // The hash accidentally looks like a cached index. Fix that by\n+                   // setting a bit that looks like a longer-than-cacheable string\n+                   // length.\n+                   hash |= (String::kMaxCachedArrayIndexLength + 1)\n+                           << String::ArrayIndexLengthBits::kShift;\n+                 }\n+                 DCHECK(!Name::ContainsCachedArrayIndex(hash));\n+                 return hash;\n+               }\n+               case detail::kNonIndex:\n+               case detail::kOverflow:\n+                 break;\n+             }\n+           }\n #else\n           static_assert(String::kMaxArrayIndexSize ==\n                         String::kMaxIntegerIndexSize);\n", "result": true}