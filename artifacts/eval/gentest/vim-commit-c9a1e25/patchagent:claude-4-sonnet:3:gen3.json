{"patch": "diff --git a/src/misc1.c b/src/misc1.c\nindex 90cf91474..0ab9452dd 100644\n--- a/src/misc1.c\n+++ b/src/misc1.c\n@@ -547,6 +547,11 @@ gchar_pos(pos_T *pos)\n     // When searching columns is sometimes put at the end of a line.\n     if (pos->col == MAXCOL)\n \treturn NUL;\n+    \n+    // Check if the column position is within the line bounds\n+    if (pos->col >= ml_get_len(pos->lnum))\n+\treturn NUL;\n+    \n     ptr = ml_get_pos(pos);\n     if (has_mbyte)\n \treturn (*mb_ptr2char)(ptr);\ndiff --git a/src/register.c b/src/register.c\nindex 3ca425b45..9f0f11cd0 100644\n--- a/src/register.c\n+++ b/src/register.c\n@@ -1269,7 +1269,15 @@ op_yank(oparg_T *oap, int deleting, int mess)\n \t\t    charwise_block_prep(oap->start, oap->end, &bd, lnum, oap->inclusive);\n \n \t\t    // make sure bd.textlen is not longer than the text\n-\t\t    tmp = (int)STRLEN(bd.textstart);\n+\t    // Calculate the maximum safe length to avoid buffer overflow\n+\t    colnr_T line_len = ml_get_len(lnum);\n+\t    colnr_T max_len = (bd.textcol < line_len) ? line_len - bd.textcol : 0;\n+\t    \n+\t    // Safely calculate string length without going beyond line end\n+\t    char_u *p = bd.textstart;\n+\t    tmp = 0;\n+\t    while (tmp < (int)max_len && p[tmp] != NUL)\n+\t\ttmp++;\n \t\t    if (tmp < bd.textlen)\n \t\t\tbd.textlen = tmp;\n \n", "result": true}