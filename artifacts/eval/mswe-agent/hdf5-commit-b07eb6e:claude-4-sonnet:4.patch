
diff --git a/.gitignore b/.gitignore
index 3caf16a1c6..f5d4da06c1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -41,3 +41,14 @@ src/H5overflow.h
 src/H5version.h
 
 /.classpath
+build/
+Build/
+bin/
+lib/
+*.o
+*.out
+*.obj
+*.exe
+*.dll
+*.so
+*.dylib
diff --git a/install/include/H5ACpkg.h b/install/include/H5ACpkg.h
new file mode 100644
index 0000000000..ea7f0bfacf
--- /dev/null
+++ b/install/include/H5ACpkg.h
@@ -0,0 +1,506 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer: John Mainzer -- 4/19/06
+ *
+ * Purpose:     This file contains declarations which are normally visible
+ *              only within the H5AC package (just H5AC.c at present).
+ *
+ *		Source files outside the H5AC package should include
+ *		H5ACprivate.h instead.
+ *
+ *		The one exception to this rule is testpar/t_cache.c.  The
+ *		test code is easier to write if it can look at H5AC_aux_t.
+ *		Indeed, this is the main reason why this file was created.
+ *
+ */
+
+#if !(defined H5AC_FRIEND || defined H5AC_MODULE)
+#error "Do not include this file outside the H5AC package!"
+#endif
+
+#ifndef _H5ACpkg_H
+#define _H5ACpkg_H
+
+/* Get package's private header */
+#include "H5ACprivate.h"	/* Metadata cache			*/
+
+
+/* Get needed headers */
+#include "H5Cprivate.h"         /* Cache                                */
+#include "H5FLprivate.h"        /* Free Lists                           */
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+/* Declare extern the free list to manage the H5AC_aux_t struct */
+H5FL_EXTERN(H5AC_aux_t);
+
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+#define H5AC_DEBUG_DIRTY_BYTES_CREATION	0
+
+#ifdef H5_HAVE_PARALLEL
+
+/* the following #defined are used to specify the operation required
+ * at a sync point.
+ */
+
+#define H5AC_SYNC_POINT_OP__FLUSH_TO_MIN_CLEAN		0
+#define H5AC_SYNC_POINT_OP__FLUSH_CACHE			1
+
+#endif /* H5_HAVE_PARALLEL */
+
+/*-------------------------------------------------------------------------
+ *  It is a bit difficult to set ranges of allowable values on the
+ *  dirty_bytes_threshold field of H5AC_aux_t.  The following are
+ *  probably broader than they should be.
+ *-------------------------------------------------------------------------
+ */
+
+#define H5AC__MIN_DIRTY_BYTES_THRESHOLD		(size_t) \
+						(H5C__MIN_MAX_CACHE_SIZE / 2)
+#define H5AC__DEFAULT_DIRTY_BYTES_THRESHOLD	(256 * 1024)
+#define H5AC__MAX_DIRTY_BYTES_THRESHOLD   	(size_t) \
+						(H5C__MAX_MAX_CACHE_SIZE / 4)
+
+
+/****************************************************************************
+ *
+ * structure H5AC_aux_t
+ *
+ * While H5AC has become a wrapper for the cache implemented in H5C.c, there
+ * are some features of the metadata cache that are specific to it, and which
+ * therefore do not belong in the more generic H5C cache code.
+ *
+ * In particular, there is the matter of synchronizing writes from the
+ * metadata cache to disk in the PHDF5 case.
+ *
+ * Prior to this update, the presumption was that all metadata caches would
+ * write the same data at the same time since all operations modifying
+ * metadata must be performed collectively.  Given this assumption, it was
+ * safe to allow only the writes from process 0 to actually make it to disk,
+ * while metadata writes from all other processes were discarded.
+ *
+ * Unfortunately, this presumption is in error as operations that read
+ * metadata need not be collective, but can change the location of dirty
+ * entries in the metadata cache LRU lists.  This can result in the same
+ * metadata write operation triggering writes from the metadata caches on
+ * some processes, but not all (causing a hang), or in different sets of
+ * entries being written from different caches (potentially resulting in
+ * metadata corruption in the file).
+ *
+ * To deal with this issue, I decided to apply a paradigm shift to the way
+ * metadata is written to disk.
+ *
+ * With this set of changes, only the metadata cache on process 0 is able
+ * to write metadata to disk, although metadata caches on all other
+ * processes can read metadata from disk as before.
+ *
+ * To keep all the other caches from getting plugged up with dirty metadata,
+ * process 0 periodically broadcasts a list of entries that it has flushed
+ * since that last notice, and which are currently clean.  The other caches
+ * mark these entries as clean as well, which allows them to evict the
+ * entries as needed.
+ *
+ * One obvious problem in this approach is synchronizing the broadcasts
+ * and receptions, as different caches may see different amounts of
+ * activity.
+ *
+ * The current solution is for the caches to track the number of bytes
+ * of newly generated dirty metadata, and to broadcast and receive
+ * whenever this value exceeds some user specified threshold.
+ *
+ * Maintaining this count is easy for all processes not on process 0 --
+ * all that is necessary is to add the size of the entry to the total
+ * whenever there is an insertion, a move of a previously clean entry,
+ * or whever a previously clean entry is marked dirty in an unprotect.
+ *
+ * On process 0, we have to be careful not to count dirty bytes twice.
+ * If an entry is marked dirty, flushed, and marked dirty again, all
+ * within a single reporting period, it only th first marking should
+ * be added to the dirty bytes generated tally, as that is all that
+ * the other processes will see.
+ *
+ * At present, this structure exists to maintain the fields needed to
+ * implement the above scheme, and thus is only used in the parallel
+ * case.  However, other uses may arise in the future.
+ *
+ * Instance of this structure are associated with metadata caches via
+ * the aux_ptr field of H5C_t (see H5Cpkg.h).  The H5AC code is
+ * responsible for allocating, maintaining, and discarding instances
+ * of H5AC_aux_t.
+ *
+ * The remainder of this header comments documents the individual fields
+ * of the structure.
+ *
+ *                                              JRM - 6/27/05
+ *
+ * Update: When the above was written, I planned to allow the process
+ *	0 metadata cache to write dirty metadata between sync points.
+ *	However, testing indicated that this allowed occasional 
+ *	messages from the future to reach the caches on other processes.
+ *
+ *	To resolve this, the code was altered to require that all metadata
+ *	writes take place during sync points -- which solved the problem.
+ *	Initially all writes were performed by the process 0 cache.  This 
+ *	approach was later replaced with a distributed write approach
+ *	in which each process writes a subset of the metadata to be 
+ *	written.  
+ *
+ *	After thinking on the matter for a while, I arrived at the 
+ *	conclusion that the process 0 cache could be allowed to write 
+ *	dirty metadata between sync points if it restricted itself to 
+ *	entries that had been dirty at the time of the previous sync point.  
+ *	
+ *	To date, there has been no attempt to implement this optimization.
+ *	However, should it be attempted, much of the supporting code 
+ *	should still be around.
+ *
+ *						JRM -- 1/6/15
+ *
+ * magic:       Unsigned 32 bit integer always set to
+ *		H5AC__H5AC_AUX_T_MAGIC.  This field is used to validate
+ *		pointers to instances of H5AC_aux_t.
+ *
+ * mpi_comm:	MPI communicator associated with the file for which the
+ *		cache has been created.
+ *
+ * mpi_rank:	MPI rank of this process within mpi_comm.
+ *
+ * mpi_size:	Number of processes in mpi_comm.
+ *
+ * write_permitted:  Boolean flag used to control whether the cache
+ *		is permitted to write to file.
+ *
+ * dirty_bytes_threshold: Integer field containing the dirty bytes
+ *		generation threashold.  Whenever dirty byte creation
+ *		exceeds this value, the metadata cache on process 0
+ *		broadcasts a list of the entries it has flushed since
+ *		the last broadcast (or since the beginning of execution)
+ *		and which are currently clean (if they are still in the
+ *		cache)
+ *
+ *		Similarly, metadata caches on processes other than process
+ *		0 will attempt to receive a list of clean entries whenever
+ *		the threshold is exceeded.
+ *
+ * dirty_bytes:  Integer field containing the number of bytes of dirty
+ *		metadata generated since the beginning of the computation,
+ *		or (more typically) since the last clean entries list
+ *		broadcast.  This field is reset to zero after each such
+ *		broadcast.
+ *
+ * metadata_write_strategy: Integer code indicating how we will be 
+ *		writing the metadata.  In the first incarnation of 
+ *		this code, all writes were done from process 0.  This
+ *		field exists to facilitate experiments with other 
+ *		strategies.
+ *
+ *		At present, this field must be set to either
+ *		H5AC_METADATA_WRITE_STRATEGY__PROCESS_0_ONLY or 
+ *		H5AC_METADATA_WRITE_STRATEGY__DISTRIBUTED.
+ *
+ * dirty_bytes_propagations: This field only exists when the
+ *		H5AC_DEBUG_DIRTY_BYTES_CREATION #define is TRUE.
+ *
+ *		It is used to track the number of times the cleaned list
+ *		has been propagated from process 0 to the other
+ *		processes.
+ *
+ * unprotect_dirty_bytes:  This field only exists when the
+ *              H5AC_DEBUG_DIRTY_BYTES_CREATION #define is TRUE.
+ *
+ *		It is used to track the number of dirty bytes created
+ *		via unprotect operations since the last time the cleaned
+ *		list was propagated.
+ *
+ * unprotect_dirty_bytes_updates: This field only exists when the
+ *              H5AC_DEBUG_DIRTY_BYTES_CREATION #define is TRUE.
+ *
+ *		It is used to track the number of times dirty bytes have
+ *		been created via unprotect operations since the last time
+ *		the cleaned list was propagated.
+ *
+ * insert_dirty_bytes:  This field only exists when the
+ *              H5AC_DEBUG_DIRTY_BYTES_CREATION #define is TRUE.
+ *
+ *		It is used to track the number of dirty bytes created
+ *		via insert operations since the last time the cleaned
+ *		list was propagated.
+ *
+ * insert_dirty_bytes_updates:  This field only exists when the
+ *              H5AC_DEBUG_DIRTY_BYTES_CREATION #define is TRUE.
+ *
+ *		It is used to track the number of times dirty bytes have
+ *		been created via insert operations since the last time
+ *		the cleaned list was propagated.
+ *
+ * move_dirty_bytes:  This field only exists when the
+ *              H5AC_DEBUG_DIRTY_BYTES_CREATION #define is TRUE.
+ *
+ *		It is used to track the number of dirty bytes created
+ *		via move operations since the last time the cleaned
+ *		list was propagated.
+ *
+ * move_dirty_bytes_updates:  This field only exists when the
+ *              H...atic hdf5::hdf5_tools-shared hdf5::h5diff hdf5::h5diff-shared hdf5::h5ls hdf5::h5ls-shared hdf5::h5debug hdf5::h5repart hdf5::h5mkgrp hdf5::h5import hdf5::h5repack hdf5::h5repack-shared hdf5::h5jam hdf5::h5unjam hdf5::h5copy hdf5::h5copy-shared hdf5::h5stat hdf5::h5stat-shared hdf5::h5dump hdf5::h5dump-shared hdf5::h5format_convert hdf5::hdf5_hl-static hdf5::hdf5_hl-shared hdf5::gif2h5 hdf5::h52gif hdf5::h5watch hdf5::hdf5_cpp-static hdf5::hdf5_cpp-shared hdf5::hdf5_hl_cpp-static hdf5::hdf5_hl_cpp-shared)
+  list(APPEND _cmake_expected_targets "${_cmake_expected_target}")
+  if(TARGET "${_cmake_expected_target}")
+    list(APPEND _cmake_targets_defined "${_cmake_expected_target}")
+  else()
+    list(APPEND _cmake_targets_not_defined "${_cmake_expected_target}")
+  endif()
+endforeach()
+unset(_cmake_expected_target)
+if(_cmake_targets_defined STREQUAL _cmake_expected_targets)
+  unset(_cmake_targets_defined)
+  unset(_cmake_targets_not_defined)
+  unset(_cmake_expected_targets)
+  unset(CMAKE_IMPORT_FILE_VERSION)
+  cmake_policy(POP)
+  return()
+endif()
+if(NOT _cmake_targets_defined STREQUAL "")
+  string(REPLACE ";" ", " _cmake_targets_defined_text "${_cmake_targets_defined}")
+  string(REPLACE ";" ", " _cmake_targets_not_defined_text "${_cmake_targets_not_defined}")
+  message(FATAL_ERROR "Some (but not all) targets in this export set were already defined.\nTargets Defined: ${_cmake_targets_defined_text}\nTargets not yet defined: ${_cmake_targets_not_defined_text}\n")
+endif()
+unset(_cmake_targets_defined)
+unset(_cmake_targets_not_defined)
+unset(_cmake_expected_targets)
+
+
+# Compute the installation prefix relative to this file.
+get_filename_component(_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)
+get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
+get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
+if(_IMPORT_PREFIX STREQUAL "/")
+  set(_IMPORT_PREFIX "")
+endif()
+
+# Create imported target hdf5::hdf5-static
+add_library(hdf5::hdf5-static STATIC IMPORTED)
+
+set_target_properties(hdf5::hdf5-static PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "m;dl;dl"
+)
+
+# Create imported target hdf5::hdf5-shared
+add_library(hdf5::hdf5-shared SHARED IMPORTED)
+
+set_target_properties(hdf5::hdf5-shared PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "H5_BUILT_AS_DYNAMIC_LIB=1"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "m;dl;dl"
+)
+
+# Create imported target hdf5::hdf5_tools-static
+add_library(hdf5::hdf5_tools-static STATIC IMPORTED)
+
+set_target_properties(hdf5::hdf5_tools-static PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5-static"
+)
+
+# Create imported target hdf5::hdf5_tools-shared
+add_library(hdf5::hdf5_tools-shared SHARED IMPORTED)
+
+set_target_properties(hdf5::hdf5_tools-shared PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "H5_BUILT_AS_DYNAMIC_LIB=1"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5-shared"
+)
+
+# Create imported target hdf5::h5diff
+add_executable(hdf5::h5diff IMPORTED)
+
+# Create imported target hdf5::h5diff-shared
+add_executable(hdf5::h5diff-shared IMPORTED)
+
+# Create imported target hdf5::h5ls
+add_executable(hdf5::h5ls IMPORTED)
+
+# Create imported target hdf5::h5ls-shared
+add_executable(hdf5::h5ls-shared IMPORTED)
+
+# Create imported target hdf5::h5debug
+add_executable(hdf5::h5debug IMPORTED)
+
+# Create imported target hdf5::h5repart
+add_executable(hdf5::h5repart IMPORTED)
+
+# Create imported target hdf5::h5mkgrp
+add_executable(hdf5::h5mkgrp IMPORTED)
+
+# Create imported target hdf5::h5import
+add_executable(hdf5::h5import IMPORTED)
+
+# Create imported target hdf5::h5repack
+add_executable(hdf5::h5repack IMPORTED)
+
+# Create imported target hdf5::h5repack-shared
+add_executable(hdf5::h5repack-shared IMPORTED)
+
+# Create imported target hdf5::h5jam
+add_executable(hdf5::h5jam IMPORTED)
+
+# Create imported target hdf5::h5unjam
+add_executable(hdf5::h5unjam IMPORTED)
+
+# Create imported target hdf5::h5copy
+add_executable(hdf5::h5copy IMPORTED)
+
+# Create imported target hdf5::h5copy-shared
+add_executable(hdf5::h5copy-shared IMPORTED)
+
+# Create imported target hdf5::h5stat
+add_executable(hdf5::h5stat IMPORTED)
+
+# Create imported target hdf5::h5stat-shared
+add_executable(hdf5::h5stat-shared IMPORTED)
+
+# Create imported target hdf5::h5dump
+add_executable(hdf5::h5dump IMPORTED)
+
+# Create imported target hdf5::h5dump-shared
+add_executable(hdf5::h5dump-shared IMPORTED)
+
+# Create imported target hdf5::h5format_convert
+add_executable(hdf5::h5format_convert IMPORTED)
+
+# Create imported target hdf5::hdf5_hl-static
+add_library(hdf5::hdf5_hl-static STATIC IMPORTED)
+
+set_target_properties(hdf5::hdf5_hl-static PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5-static"
+)
+
+# Create imported target hdf5::hdf5_hl-shared
+add_library(hdf5::hdf5_hl-shared SHARED IMPORTED)
+
+set_target_properties(hdf5::hdf5_hl-shared PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "H5_BUILT_AS_DYNAMIC_LIB=1"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5-shared"
+)
+
+# Create imported target hdf5::gif2h5
+add_executable(hdf5::gif2h5 IMPORTED)
+
+# Create imported target hdf5::h52gif
+add_executable(hdf5::h52gif IMPORTED)
+
+# Create imported target hdf5::h5watch
+add_executable(hdf5::h5watch IMPORTED)
+
+# Create imported target hdf5::hdf5_cpp-static
+add_library(hdf5::hdf5_cpp-static STATIC IMPORTED)
+
+set_target_properties(hdf5::hdf5_cpp-static PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5-static"
+)
+
+# Create imported target hdf5::hdf5_cpp-shared
+add_library(hdf5::hdf5_cpp-shared SHARED IMPORTED)
+
+set_target_properties(hdf5::hdf5_cpp-shared PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "H5_BUILT_AS_DYNAMIC_LIB=1"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5-shared"
+)
+
+# Create imported target hdf5::hdf5_hl_cpp-static
+add_library(hdf5::hdf5_hl_cpp-static STATIC IMPORTED)
+
+set_target_properties(hdf5::hdf5_hl_cpp-static PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5_hl-static;hdf5::hdf5-static"
+)
+
+# Create imported target hdf5::hdf5_hl_cpp-shared
+add_library(hdf5::hdf5_hl_cpp-shared SHARED IMPORTED)
+
+set_target_properties(hdf5::hdf5_hl_cpp-shared PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "H5_BUILT_AS_DYNAMIC_LIB=1"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5_hl-shared;hdf5::hdf5-shared"
+)
+
+if(CMAKE_VERSION VERSION_LESS 2.8.12)
+  message(FATAL_ERROR "This file relies on consumers using CMake 2.8.12 or greater.")
+endif()
+
+# Load information for each installed configuration.
+file(GLOB _cmake_config_files "${CMAKE_CURRENT_LIST_DIR}/hdf5-targets-*.cmake")
+foreach(_cmake_config_file IN LISTS _cmake_config_files)
+  include("${_cmake_config_file}")
+endforeach()
+unset(_cmake_config_file)
+unset(_cmake_config_files)
+
+# Cleanup temporary variables.
+set(_IMPORT_PREFIX)
+
+# Loop over all imported files and verify that they actually exist
+foreach(_cmake_target IN LISTS _cmake_import_check_targets)
+  foreach(_cmake_file IN LISTS "_cmake_import_check_files_for_${_cmake_target}")
+    if(NOT EXISTS "${_cmake_file}")
+      message(FATAL_ERROR "The imported target \"${_cmake_target}\" references the file
+   \"${_cmake_file}\"
+but this file does not exist.  Possible reasons include:
+* The file was deleted, renamed, or moved to another location.
+* An install or uninstall procedure did not complete successfully.
+* The installation package was faulty and contained
+   \"${CMAKE_CURRENT_LIST_FILE}\"
+but not all the files it references.
+")
+    endif()
+  endforeach()
+  unset(_cmake_file)
+  unset("_cmake_import_check_files_for_${_cmake_target}")
+endforeach()
+unset(_cmake_target)
+unset(_cmake_import_check_targets)
+
+# This file does not depend on other imported targets which have
+# been exported from the same project but in a separate export set.
+
+# Commands beyond this point should not need to know the version.
+set(CMAKE_IMPORT_FILE_VERSION)
+cmake_policy(POP)
diff --git a/src/H5Gent.c b/src/H5Gent.c
index b781fae70e..05d54b94a0 100644
--- a/src/H5Gent.c
+++ b/src/H5Gent.c
@@ -585,9 +585,14 @@ H5G__ent_debug(const H5G_entry_t *ent, FILE *stream, int indent, int fwidth,
                        (unsigned long)(ent->cache.slink.lval_offset));
             if(heap) {
                 lval = (const char *)H5HL_offset_into(heap, ent->cache.slink.lval_offset);
-                HDfprintf(stream, "%*s%-*s %s\n", nested_indent, "", nested_fwidth,
-                           "Link value:",
-                           lval);
+                if(lval) {
+                    HDfprintf(stream, "%*s%-*s %s\n", nested_indent, "", nested_fwidth,
+                               "Link value:",
+                               lval);
+                } else {
+                    HDfprintf(stream, "%*s%-*s (invalid offset)\n", nested_indent, "", nested_fwidth,
+                               "Link value:");
+                }
             } /* end if */
             else
                 HDfprintf(stream, "%*s%-*s\n", nested_indent, "", nested_fwidth, "Warning: Invalid heap address given, name not displayed!");
diff --git a/src/H5Gnode.c b/src/H5Gnode.c
index 20924ee2b6..12a5c7cdbd 100644
--- a/src/H5Gnode.c
+++ b/src/H5Gnode.c
@@ -258,7 +258,10 @@ H5G_node_debug_key(FILE *stream, int indent, int fwidth, const void *_key,
         HDfprintf(stream, "%*s%-*s ", indent, "", fwidth, "Name:");
 
         s = (const char *)H5HL_offset_into(udata->heap, key->offset);
-        HDfprintf(stream, "%s\n", s);
+        if(s)
+            HDfprintf(stream, "%s\n", s);
+        else
+            HDfprintf(stream, "(invalid offset)\n");
     } /* end if */
     else
         HDfprintf(stream, "%*s%-*s ", indent, "", fwidth, "Cannot get name; heap address not specified\n");
@@ -404,7 +407,7 @@ H5G_node_cmp2(void *_lt_key, void *_udata, void *_rt_key)
     const char		   *base;           /* Base of heap */
     int		           ret_value = -1;  /* Return value */
 
-    FUNC_ENTER_NOAPI_NOINIT_NOERR
+    FUNC_ENTER_NOAPI_NOINIT
 
     /* Sanity checks */
     HDassert(udata && udata->heap);
@@ -413,15 +416,21 @@ H5G_node_cmp2(void *_lt_key, void *_udata, void *_rt_key)
 
     /* Get base address of heap */
     base = (const char *)H5HL_offset_into(udata->heap, (size_t)0);
-    HDassert(base);
+    if(!base)
+        HGOTO_DONE(-1)  /* Return error if heap base is invalid */
 
     /* Get pointers to string names */
-    s1 = base + lt_key->offset;
-    s2 = base + rt_key->offset;
+    s1 = (const char *)H5HL_offset_into(udata->heap, lt_key->offset);
+    if(!s1)
+        HGOTO_DONE(-1)  /* Return error if offset is invalid */
+    s2 = (const char *)H5HL_offset_into(udata->heap, rt_key->offset);
+    if(!s2)
+        HGOTO_DONE(-1)  /* Return error if offset is invalid */
 
     /* Set return value */
     ret_value = HDstrcmp(s1, s2);
 
+done:
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5G_node_cmp2() */
 
@@ -463,7 +472,7 @@ H5G_node_cmp3(void *_lt_key, void *_udata, void *_rt_key)
     const char          *base;              /* Base of heap */
     int                  ret_value = 0;       /* Return value */
 
-    FUNC_ENTER_NOAPI_NOINIT_NOERR
+    FUNC_ENTER_NOAPI_NOINIT
 
     /* Sanity checks */
     HDassert(udata && udata->heap);
@@ -472,19 +481,25 @@ H5G_node_cmp3(void *_lt_key, void *_udata, void *_rt_key)
 
     /* Get base address of heap */
     base = (const char *)H5HL_offset_into(udata->heap, (size_t)0);
-    HDassert(base);
+    if(!base)
+        HGOTO_DONE(-1)  /* Return error if heap base is invalid */
 
     /* left side */
-    s = base + lt_key->offset;
+    s = (const char *)H5HL_offset_into(udata->heap, lt_key->offset);
+    if(!s)
+        HGOTO_DONE(-1)  /* Return error if offset is invalid */
     if(HDstrcmp(udata->name, s) <= 0)
 	ret_value = (-1);
     else {
         /* right side */
-        s = base + rt_key->offset;
+        s = (const char *)H5HL_offset_into(udata->heap, rt_key->offset);
+        if(!s)
+            HGOTO_DONE(-1)  /* Return error if offset is invalid */
         if(HDstrcmp(udata->name, s) > 0)
             ret_value = 1;
     } /* end else */
 
+done:
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5G_node_cmp3() */
 
@@ -544,7 +559,8 @@ H5G_node_found(H5F_t *f, hid_t dxpl_id, haddr_t addr, const void H5_ATTR_UNUSED
 
     /* Get base address of heap */
     base = (const char *)H5HL_offset_into(udata->common.heap, (size_t)0);
-    HDassert(base);
+    if(!base)
+        HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, FAIL, "unable to get heap base address")
 
     /*
      * Binary search.
@@ -552,7 +568,9 @@ H5G_node_found(H5F_t *f, hid_t dxpl_id, haddr_t addr, const void H5_ATTR_UNUSED
     rt = sn->nsyms;
     while(lt < rt && cmp) {
 	idx = (lt + rt) / 2;
-        s = base + sn->entry[idx].name_off;
+        s = (const char *)H5HL_offset_into(udata->common.heap, sn->entry[idx].name_off);
+        if(!s)
+            HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, FAIL, "unable to get name from heap")
 	cmp = HDstrcmp(udata->common.name, s);
 
 	if (cmp < 0)
@@ -650,7 +668,8 @@ H5G_node_insert(H5F_t *f, hid_t dxpl_id, haddr_t addr,
 
     /* Get base address of heap */
     base = (const char *)H5HL_offset_into(udata->common.heap, (size_t)0);
-    HDassert(base);
+    if(!base)
+        HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, H5B_INS_ERROR, "unable to get heap base address")
 
     /*
      * Where does the new symbol get inserted?	We use a binary search.
@@ -658,7 +677,9 @@ H5G_node_insert(H5F_t *f, hid_t dxpl_id, haddr_t addr,
     rt = sn->nsyms;
     while(lt < rt) {
 	idx = (int)((lt + rt) / 2);
-        s = base + sn->entry[idx].name_off;
+        s = (const char *)H5HL_offset_into(udata->common.heap, sn->entry[idx].name_off);
+        if(!s)
+            HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, H5B_INS_ERROR, "unable to get name from heap")
 
         /* Check if symbol is already present */
 	if(0 == (cmp = HDstrcmp(udata->common.name, s)))
@@ -817,6 +838,8 @@ H5G_node_remove(H5F_t *f, hid_t dxpl_id, haddr_t addr, void *_lt_key/*in,out*/,
 
         /* Get base address of heap */
         base = (const char *)H5HL_offset_into(udata->common.heap, (size_t)0);
+        if(!base)
+            HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, H5B_INS_ERROR, "unable to get heap base address")
 
         /* Find the name with a binary search */
         rt = sn->nsyms;
@@ -824,7 +847,9 @@ H5G_node_remove(H5F_t *f, hid_t dxpl_id, haddr_t addr, void *_lt_key/*in,out*/,
             const char *s;          /* Pointer to string in local heap */
 
             idx = (lt + rt) / 2;
-            s = base + sn->entry[idx].name_off;
+            s = (const char *)H5HL_offset_into(udata->common.heap, sn->entry[idx].name_off);
+            if(!s)
+                HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, H5B_INS_ERROR, "unable to get name from heap")
             cmp = HDstrcmp(udata->common.name, s);
             if(cmp < 0)
                 rt = idx;
@@ -1014,7 +1039,8 @@ H5G__node_iterate(H5F_t *f, hid_t dxpl_id, const void H5_ATTR_UNUSED *_lt_key, h
 
             /* Get the pointer to the name of the link in the heap */
             name = (const char *)H5HL_offset_into(udata->heap, ents[u].name_off);
-            HDassert(name);
+            if(!name)
+                HGOTO_ERROR(H5E_SYM, H5E_CANTGET, H5_ITER_ERROR, "unable to get link name from heap")
 
             /* Convert the entry to a link */
             if(H5G__ent_to_link(&lnk, udata->heap, &ents[u], name) < 0)
@@ -1293,6 +1319,8 @@ H5G__node_copy(H5F_t *f, hid_t dxpl_id, const void H5_ATTR_UNUSED *_lt_key, hadd
 
             /* Get pointer to link value in local heap */
             link_name = (char *)H5HL_offset_into(heap, tmp_src_ent.cache.slink.lval_offset);
+            if(!link_name)
+                HGOTO_ERROR(H5E_SYM, H5E_CANTGET, H5_ITER_ERROR, "unable to get soft link value from heap")
 
             /* Check if the object pointed by the soft link exists in the source file */
             if(H5G_loc_info(&grp_loc, link_name, FALSE, &oinfo, H5P_DEFAULT, dxpl_id) >= 0) {
@@ -1343,6 +1371,8 @@ H5G__node_copy(H5F_t *f, hid_t dxpl_id, const void H5_ATTR_UNUSED *_lt_key, hadd
             /* Construct link information for eventual insertion */
             lnk.type = H5L_TYPE_SOFT;
             lnk.u.soft.name = (char *)H5HL_offset_into(heap, src_ent->cache.slink.lval_offset);
+            if(!lnk.u.soft.name)
+                HGOTO_ERROR(H5E_SYM, H5E_CANTGET, H5_ITER_ERROR, "unable to get soft link value from heap")
         } /* else if */
         else
             HDassert(0 && "Unknown entry type");
@@ -1355,7 +1385,8 @@ H5G__node_copy(H5F_t *f, hid_t dxpl_id, const void H5_ATTR_UNUSED *_lt_key, hadd
 
         /* Determine name of source object */
         name = (const char *)H5HL_offset_into(heap, src_ent->name_off);
-	HDassert(name);
+        if(!name)
+            HGOTO_ERROR(H5E_SYM, H5E_CANTGET, H5_ITER_ERROR, "unable to get object name from heap")
 
         /* Set copied metadata tag */
         H5_BEGIN_TAG(dxpl_id, H5AC__COPIED_TAG, H5_ITER_ERROR);
diff --git a/src/H5Gstab.c b/src/H5Gstab.c
index a239cfe62c..96bbca4288 100644
--- a/src/H5Gstab.c
+++ b/src/H5Gstab.c
@@ -710,8 +710,9 @@ H5G_stab_get_name_by_idx_cb(const H5G_entry_t *ent, void *_udata)
     H5G_bt_it_gnbi_t	*udata = (H5G_bt_it_gnbi_t *)_udata;
     size_t name_off;                    /* Offset of name in heap */
     const char *name;                   /* Pointer to name string in heap */
+    herr_t ret_value = SUCCEED;         /* Return value */
 
-    FUNC_ENTER_NOAPI_NOINIT_NOERR
+    FUNC_ENTER_NOAPI_NOINIT
 
     /* Sanity check */
     HDassert(ent);
@@ -720,11 +721,14 @@ H5G_stab_get_name_by_idx_cb(const H5G_entry_t *ent, void *_udata)
     /* Get name offset in heap */
     name_off = ent->name_off;
     name = (const char *)H5HL_offset_into(udata->heap, name_off);
-    HDassert(name);
+    if(!name)
+        HGOTO_DONE(FAIL)  /* Return error if offset is invalid */
     udata->name = H5MM_strdup(name);
-    HDassert(udata->name);
+    if(!udata->name)
+        HGOTO_DONE(FAIL)  /* Return error if strdup fails */
 
-    FUNC_LEAVE_NOAPI(SUCCEED)
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5G_stab_get_name_by_idx_cb */
 
 

@@ -942,7 +946,8 @@ H5G_stab_lookup_by_idx_cb(const H5G_entry_t *ent, void *_udata)
 
     /* Get a pointer to the link name */
     name = (const char *)H5HL_offset_into(udata->heap, ent->name_off);
-    HDassert(name);
+    if(!name)
+        HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get name from heap")
 
     /* Convert the entry to a link */
     if(H5G__ent_to_link(udata->lnk, udata->heap, ent, name) < 0)
diff --git a/src/H5HL.c b/src/H5HL.c
index fa577c3b6b..895320562d 100644
--- a/src/H5HL.c
+++ b/src/H5HL.c
@@ -406,9 +406,12 @@ H5HL_offset_into(const H5HL_t *heap, size_t offset))
 
     /* Sanity check */
     HDassert(heap);
-    HDassert(offset < heap->dblk_size);
-
-    ret_value = heap->dblk_image + offset;
+    
+    /* Check bounds to prevent heap buffer overflow */
+    if(offset >= heap->dblk_size)
+        ret_value = NULL;
+    else
+        ret_value = heap->dblk_image + offset;
 
 END_FUNC(PRIV) /* end H5HL_offset_into() */
 
