
diff --git a/.gitignore b/.gitignore
index 3caf16a1c6..f5d4da06c1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -41,3 +41,14 @@ src/H5overflow.h
 src/H5version.h
 
 /.classpath
+build/
+Build/
+bin/
+lib/
+*.o
+*.out
+*.obj
+*.exe
+*.dll
+*.so
+*.dylib
diff --git a/install/include/H5ACpkg.h b/install/include/H5ACpkg.h
new file mode 100644
index 0000000000..ea7f0bfacf
--- /dev/null
+++ b/install/include/H5ACpkg.h
@@ -0,0 +1,506 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer: John Mainzer -- 4/19/06
+ *
+ * Purpose:     This file contains declarations which are normally visible
+ *              only within the H5AC package (just H5AC.c at present).
+ *
+ *		Source files outside the H5AC package should include
+ *		H5ACprivate.h instead.
+ *
+ *		The one exception to this rule is testpar/t_cache.c.  The
+ *		test code is easier to write if it can look at H5AC_aux_t.
+ *		Indeed, this is the main reason why this file was created.
+ *
+ */
+
+#if !(defined H5AC_FRIEND || defined H5AC_MODULE)
+#error "Do not include this file outside the H5AC package!"
+#endif
+
+#ifndef _H5ACpkg_H
+#define _H5ACpkg_H
+
+/* Get package's private header */
+#include "H5ACprivate.h"	/* Metadata cache			*/
+
+
+/* Get needed headers */
+#include "H5Cprivate.h"         /* Cache                                */
+#include "H5FLprivate.h"        /* Free Lists                           */
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+/* Declare extern the free list to manage the H5AC_aux_t struct */
+H5FL_EXTERN(H5AC_aux_t);
+
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+#define H5AC_DEBUG_DIRTY_BYTES_CREATION	0
+
+#ifdef H5_HAVE_PARALLEL
+
+/* the following #defined are used to specify the operation required
+ * at a sync point.
+ */
+
+#define H5AC_SYNC_POINT_OP__FLUSH_TO_MIN_CLEAN		0
+#define H5AC_SYNC_POINT_OP__FLUSH_CACHE			1
+
+#endif /* H5_HAVE_PARALLEL */
+
+/*-------------------------------------------------------------------------
+ *  It is a bit difficult to set ranges of allowable values on the
+ *  dirty_bytes_threshold field of H5AC_aux_t.  The following are
+ *  probably broader than they should be.
+ *-------------------------------------------------------------------------
+ */
+
+#define H5AC__MIN_DIRTY_BYTES_THRESHOLD		(size_t) \
+						(H5C__MIN_MAX_CACHE_SIZE / 2)
+#define H5AC__DEFAULT_DIRTY_BYTES_THRESHOLD	(256 * 1024)
+#define H5AC__MAX_DIRTY_BYTES_THRESHOLD   	(size_t) \
+						(H5C__MAX_MAX_CACHE_SIZE / 4)
+
+
+/****************************************************************************
+ *
+ * structure H5AC_aux_t
+ *
+ * While H5AC has become a wrapper for the cache implemented in H5C.c, there
+ * are some features of the metadata cache that are specific to it, and which
+ * therefore do not belong in the more generic H5C cache code.
+ *
+ * In particular, there is the matter of synchronizing writes from the
+ * metadata cache to disk in the PHDF5 case.
+ *
+ * Prior to this update, the presumption was that all metadata caches would
+ * write the same data at the same time since all operations modifying
+ * metadata must be performed collectively.  Given this assumption, it was
+ * safe to allow only the writes from process 0 to actually make it to disk,
+ * while metadata writes from all other processes were discarded.
+ *
+ * Unfortunately, this presumption is in error as operations that read
+ * metadata need not be collective, but can change the location of dirty
+ * entries in the metadata cache LRU lists.  This can result in the same
+ * metadata write operation triggering writes from the metadata caches on
+ * some processes, but not all (causing a hang), or in different sets of
+ * entries being written from different caches (potentially resulting in
+ * metadata corruption in the file).
+ *
+ * To deal with this issue, I decided to apply a paradigm shift to the way
+ * metadata is written to disk.
+ *
+ * With this set of changes, only the metadata cache on process 0 is able
+ * to write metadata to disk, although metadata caches on all other
+ * processes can read metadata from disk as before.
+ *
+ * To keep all the other caches from getting plugged up with dirty metadata,
+ * process 0 periodically broadcasts a list of entries that it has flushed
+ * since that last notice, and which are currently clean.  The other caches
+ * mark these entries as clean as well, which allows them to evict the
+ * entries as needed.
+ *
+ * One obvious problem in this approach is synchronizing the broadcasts
+ * and receptions, as different caches may see different amounts of
+ * activity.
+ *
+ * The current solution is for the caches to track the number of bytes
+ * of newly generated dirty metadata, and to broadcast and receive
+ * whenever this value exceeds some user specified threshold.
+ *
+ * Maintaining this count is easy for all processes not on process 0 --
+ * all that is necessary is to add the size of the entry to the total
+ * whenever there is an insertion, a move of a previously clean entry,
+ * or whever a previously clean entry is marked dirty in an unprotect.
+ *
+ * On process 0, we have to be careful not to count dirty bytes twice.
+ * If an entry is marked dirty, flushed, and marked dirty again, all
+ * within a single reporting period, it only th first marking should
+ * be added to the dirty bytes generated tally, as that is all that
+ * the other processes will see.
+ *
+ * At present, this structure exists to maintain the fields needed to
+ * implement the above scheme, and thus is only used in the parallel
+ * case.  However, other uses may arise in the future.
+ *
+ * Instance of this structure are associated with metadata caches via
+ * the aux_ptr field of H5C_t (see H5Cpkg.h).  The H5AC code is
+ * responsible for allocating, maintaining, and discarding instances
+ * of H5AC_aux_t.
+ *
+ * The remainder of this header comments documents the individual fields
+ * of the structure.
+ *
+ *                                              JRM - 6/27/05
+ *
+ * Update: When the above was written, I planned to allow the process
+ *	0 metadata cache to write dirty metadata between sync points.
+ *	However, testing indicated that this allowed occasional 
+ *	messages from the future to reach the caches on other processes.
+ *
+ *	To resolve this, the code was altered to require that all metadata
+ *	writes take place during sync points -- which solved the problem.
+ *	Initially all writes were performed by the process 0 cache.  This 
+ *	approach was later replaced with a distributed write approach
+ *	in which each process writes a subset of the metadata to be 
+ *	written.  
+ *
+ *	After thinking on the matter for a while, I arrived at the 
+ *	conclusion that the process 0 cache could be allowed to write 
+ *	dirty metadata between sync points if it restricted itself to 
+ *	entries that had been dirty at the time of the previous sync point.  
+ *	
+ *	To date, there has been no attempt to implement this optimization.
+ *	However, should it be attempted, much of the supporting code 
+ *	should still be around.
+ *
+ *						JRM -- 1/6/15
+ *
+ * magic:       Unsigned 32 bit integer always set to
+ *		H5AC__H5AC_AUX_T_MAGIC.  This field is used to validate
+ *		pointers to instances of H5AC_aux_t.
+ *
+ * mpi_comm:	MPI communicator associated with the file for which the
+ *		cache has been created.
+ *
+ * mpi_rank:	MPI rank of this process within mpi_comm.
+ *
+ * mpi_size:	Number of processes in mpi_comm.
+ *
+ * write_permitted:  Boolean flag used to control whether the cache
+ *		is permitted to write to file.
+ *
+ * dirty_bytes_threshold: Integer field containing the dirty bytes
+ *		generation threashold.  Whenever dirty byte creation
+ *		exceeds this value, the metadata cache on process 0
+ *		broadcasts a list of the entries it has flushed since
+ *		the last broadcast (or since the beginning of execution)
+ *		and which are currently clean (if they are still in the
+ *		cache)
+ *
+ *		Similarly, metadata caches on processes other than process
+ *		0 will attempt to receive a list of clean entries whenever
+ *		the threshold is exceeded.
+ *
+ * dirty_bytes:  Integer field containing the number of bytes of dirty
+ *		metadata generated since the beginning of the computation,
+ *		or (more typically) since the last clean entries list
+ *		broadcast.  This field is reset to zero after each such
+ *		broadcast.
+ *
+ * metadata_write_strategy: Integer code indicating how we will be 
+ *		writing the metadata.  In the first incarnation of 
+ *		this code, all writes were done from process 0.  This
+ *		field exists to facilitate experiments with other 
+ *		strategies.
+ *
+ *		At present, this field must be set to either
+ *		H5AC_METADATA_WRITE_STRATEGY__PROCESS_0_ONLY or 
+ *		H5AC_METADATA_WRITE_STRATEGY__DISTRIBUTED.
+ *
+ * dirty_bytes_propagations: This field only exists when the
+ *		H5AC_DEBUG_DIRTY_BYTES_CREATION #define is TRUE.
+ *
+ *		It is used to track the number of times the cleaned list
+ *		has been propagated from process 0 to the other
+ *		processes.
+ *
+ * unprotect_dirty_bytes:  This field only exists when the
+ *              H5AC_DEBUG_DIRTY_BYTES_CREATION #define is TRUE.
+ *
+ *		It is used to track the number of dirty bytes created
+ *		via unprotect operations since the last time the cleaned
+ *		list was propagated.
+ *
+ * unprotect_dirty_bytes_updates: This field only exists when the
+ *              H5AC_DEBUG_DIRTY_BYTES_CREATION #define is TRUE.
+ *
+ *		It is used to track the number of times dirty bytes have
+ *		been created via unprotect operations since the last time
+ *		the cleaned list was propagated.
+ *
+ * insert_dirty_bytes:  This field only exists when the
+ *              H5AC_DEBUG_DIRTY_BYTES_CREATION #define is TRUE.
+ *
+ *		It is used to track the number of dirty bytes created
+ *		via insert operations since the last time the cleaned
+ *		list was propagated.
+ *
+ * insert_dirty_bytes_updates:  This field only exists when the
+ *              H5AC_DEBUG_DIRTY_BYTES_CREATION #define is TRUE.
+ *
+ *		It is used to track the number of times dirty bytes have
+ *		been created via insert operations since the last time
+ *		the cleaned list was propagated.
+ *
+ * move_dirty_bytes:  This field only exists when the
+ *              H5AC_DEBUG_DIRTY_BYTES_CREATION #define is TRUE.
+ *
+ *		It is used to track the number of dirty bytes created
+ *		via move operations since the last time the cleaned
+ *		list was propagated.
+ *
+ * move_dirty_bytes_updates:  This field only exists when the
+ *              H5AC_DEBUG_DIRTY_BYTES_CREATION #define is TRUE.
+ *
+ *		It is used to track the number of times dirty bytes have
+ *		been created via move operations since the last time
+ *		the cleaned list was propagated.
+ *
+ * Things have changed a bit since the following four fields were defined.
+ * If metadata_write_strategy is H5AC_METADATA_WRITE_STRATEGY__PROCESS_0_ONLY,
+ * all comments hold as before -- with the caviate that pending further 
+ * coding, the process 0 metadata cache is forbidden to flush entries outside
+ * of a sync point.
+ *
+ * However, for different metadata write strategies, these fields are used
+ * only to maintain the correct dirty byte count on process zero -- and in
+ * most if not all cases, this is redundant, as process zero will be barred
+ * from flushing entries outside of a sync point.
+ *
+ *						JRM -- 3/16/10
+ *
+ * d_slist_ptr:  Pointer to an instance of H5SL_t used to maintain a list
+ *		of entries that have been dirtied since the last time they
+ *		were listed in a clean entries broadcast.  This list is
+ *		only maintained by the metadata cache on process 0 -- it
+ *		it used to maintain a view of the dirty entries as seen
+ *		by the other caches, so as to keep the dirty bytes count
+ *		in synchronization with them.
+ *
+ *		Thus on process 0, the dirty_bytes count is incremented
+ *		only if either
+ *
+ *		1) an entry is inserted in the metadata cache, or
+ *
+ *		2) a previously clean entry is moved, and it does not
+ *		   already appear in the dirty entry list, or
+ *
+ *		3) a previously clean entry is unprotected with the
+ *		   dirtied flag set and the entry does not already appear
+ *		   in the dirty entry list.
+ *
+ *		Entries are added to the dirty entry list whever they cause
+ *		the dirty bytes count to be increased.  They are removed
+ *		when they appear in a clean entries broadcast.  Note that
+ *		moves must be reflected in the dirty entry list.
+ *
+ *		To reitterate, this field is only used on process 0 -- it
+ *		should be NULL on all other processes.
+ *
+ * c_slist_ptr: Pointer to an instance of H5SL_t used to maintain a list
+ *		of entries that were dirty, have been flushed
+ *		to disk since the last clean entries broadcast, and are
+ *		still clean.  Since only process 0 can write to disk, this
+ *		list only exists on process 0.
+ *
+ *		In essence, this slist is used to assemble the contents of
+ *		the next clean entries broadcast.  The list emptied after
+ *		each broadcast.
+ *
+ * The following two fields are used only when metadata_write_strategy
+ * is H5AC_METADATA_WRITE_STRATEGY__DISTRIBUTED.
+ *
+ * candidate_slist_ptr: Pointer to an instance of H5SL_t used by process 0
+ *		to construct a list of entries to be flushed at this sync
+ *		point.  This list is then broadcast to the other processes,
+ *		which then either flush or mark clean all entries on it.
+ *
+ * write_done:  In the parallel test bed, it is necessary to ensure that
+ *              all writes to the server process from cache 0 complete
+ *              before it enters the barrier call with the other caches.
+ *
+ *              The write_done callback allows t_cache to do this without
+ *              requiring an ACK on each write.  Since these ACKs greatly
+ *              increase the run time on some platforms, this is a
+ *              significant optimization.
+ *
+ *              This field must be set to NULL when the callback is not
+ *              needed.
+ *
+ *		Note: This field has been extended for use by all processes
+ *		      with the addition of support for the distributed 
+ *		      metadata write strategy.        
+ *                                                     JRM -- 5/9/10
+ *
+ * sync_point_done:  In the parallel test bed, it is necessary to verify
+ *		that the expected writes, and only the expected writes,
+ *		have taken place at the end of each sync point.
+ *
+ *		The sync_point_done callback allows t_cache to perform 
+ *		this verification.  The field is set to NULL when the 
+ *		callback is not needed.
+ *
+ * The following field supports the metadata cache image feature.
+ *
+ * p0_image_len: unsiged integer containing the length of the metadata cache
+ *		image constructed by MPI process 0.  This field should be 0
+ *		if the value is unknown, or if cache image is not enabled.
+ *
+ ****************************************************************************/
+
+#ifdef H5_HAVE_PARALLEL
+
+#define H5AC__H5AC_AUX_T_MAGIC        (unsigned)0x00D0A01
+
+typedef struct H5AC_aux_t
+{
+    uint32_t	magic;
+
+    MPI_Comm	mpi_comm;
+
+    int		mpi_rank;
+
+    int		mpi_size;
+
+    hbool_t	write_permitted;
+
+    size_t	dirty_bytes_threshold;
+
+    size_t	dirty_bytes;
+
+    int32_t	metadata_write_strategy;
+
+#if H5AC_DEBUG_DIRTY_BYTES_CREATION
+
+    unsigned	dirty_bytes_propagations;
+
+    size_t      unprotect_dirty_bytes;
+    unsigned    unprotect_dirty_bytes_updates;
+
+    size_t      insert_dirty_bytes;
+    unsigned    insert_dirty_bytes_updates;
+
+    size_t      move_dirty_bytes;
+    unsigned    move_dirty_bytes_updates;
+
+#endif /* H5AC_DEBUG_DIRTY_BYTES_CREATION */
+
+    H5SL_t *	d_slist_ptr;
+
+    H5SL_t *	c_slist_ptr;
+
+    H5SL_t *	candidate_slist_ptr;
+
+    void	(* write_done)(void);
+
+    void	(* sync_point_done)(unsigned num_writes, 
+                                    haddr_t * written_entries_tbl);
+
+    unsigned    p0_image_len;
+
+} H5AC_aux_t; /* struct H5AC_aux_t */
+#endif /* H5_HAVE_PARALLEL */
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+#ifdef H5_HAVE_PARALLEL
+/* Parallel I/O routines */
+H5_DLL herr_t H5AC__log_deleted_entry(const H5AC_info_t *entry_ptr);
+H5_DLL herr_t H5AC__log_dirtied_entry(const H5AC_info_t *entry_ptr);
+H5_DLL herr_t H5AC__log_cleaned_entry(const H5AC_info_t *entry_ptr);
+H5_DLL herr_t H5AC__log_flushed_entry(H5C_t *cache_ptr, haddr_t addr,
+    hbool_t was_dirty, unsigned flags);
+H5_DLL herr_t H5AC__log_inserted_entry(const H5AC_info_t *entry_ptr);
+H5_DLL herr_t H5AC__log_moved_entry(const H5F_t *f, haddr_t old_addr,
+    haddr_t new_addr);
+H5_DLL herr_t H5AC__flush_entries(H5F_t *f, hid_t dxpl_id);
+H5_DLL herr_t H5AC__run_sync_point(H5F_t *f, hid_t dxpl_id, int sync_point_op);
+H5_DLL herr_t H5AC__set_sync_point_done_callback(H5C_t *cache_ptr,
+    void (*sync_point_done)(unsigned num_writes, haddr_t *written_entries_tbl));
+H5_DLL herr_t H5AC__set_write_done_callback(H5C_t * cache_ptr,
+    void (* write_done)(void));
+#endif /* H5_HAVE_PARALLEL */
+
+/* Trace file routines */
+H5_DLL herr_t H5AC__close_trace_file(H5AC_t *cache_ptr);
+H5_DLL herr_t H5AC__open_trace_file(H5AC_t *cache_ptr, const char *trace_file_name);
+
+/* Cache logging routines */
+H5_DLL herr_t H5AC__write_create_cache_log_msg(H5AC_t *cache);
+H5_DLL herr_t H5AC__write_destroy_cache_log_msg(H5AC_t *cache);
+H5_DLL herr_t H5AC__write_evict_cache_log_msg(const H5AC_t *cache,
+                                        herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_expunge_entry_log_msg(const H5AC_t *cache,
+                                                haddr_t address,
+                                                int type_id,
+                                                herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_flush_cache_log_msg(const H5AC_t *cache,
+                                              herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_insert_entry_log_msg(const H5AC_t *cache,
+                                               haddr_t address,
+                                               int type_id,
+                                               unsigned flags,
+                                               size_t size,
+                                               herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_mark_dirty_entry_log_msg(const H5AC_t *cache,
+                                                   const H5AC_info_t *entry,
+                                                   herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_mark_clean_entry_log_msg(const H5AC_t *cache,
+    const H5AC_info_t *entry, herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_mark_unserialized_entry_log_msg(const H5AC_t *cache,
+        const H5AC_info_t *entry, herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_mark_serialized_entry_log_msg(const H5AC_t *cache,
+    const H5AC_info_t *entry, herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_move_entry_log_msg(const H5AC_t *cache,
+                                             haddr_t old_addr,
+                                             haddr_t new_addr,
+                                             int type_id,
+                                             herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_pin_entry_log_msg(const H5AC_t *cache,
+                                            const H5AC_info_t *entry,
+                                            herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_create_fd_log_msg(const H5AC_t *cache,
+                                            const H5AC_info_t *parent,
+                                            const H5AC_info_t *child,
+                                            herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_protect_entry_log_msg(const H5AC_t *cache,
+                                                const H5AC_info_t *entry,
+                                                unsigned flags,
+                                                herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_resize_entry_log_msg(const H5AC_t *cache,
+                                               const H5AC_info_t *entry,
+                                               size_t new_size,
+                                               herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_unpin_entry_log_msg(const H5AC_t *cache,
+                                              const H5AC_info_t *entry,
+                                              herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_destroy_fd_log_msg(const H5AC_t *cache,
+                                             const H5AC_info_t *parent,
+                                             const H5AC_info_t *child,
+                                             herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_unprotect_entry_log_msg(const H5AC_t *cache,
+                                                  const H5AC_info_t *entry,
+                                                  int type_id,
+                                                  unsigned flags,
+                                                  herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_set_cache_config_log_msg(const H5AC_t *cache,
+                                                   const H5AC_cache_config_t *config,
+                                                   herr_t fxn_ret_value);
+H5_DLL herr_t H5AC__write_remove_entry_log_msg(const H5AC_t *cache,
+                                              const H5AC_info_t *entry,
+                                              herr_t fxn_ret_value);
+
+#endif /* _H5ACpkg_H */
+
diff --git a/install/include/H5ACpublic.h b/install/include/H5ACpublic.h
new file mode 100644
index 0000000000..654a877f9d
--- /dev/null
+++ b/install/include/H5ACpublic.h
@@ -0,0 +1,574 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5ACpublic.h
+ *                      Jul 10 1997
+ *                      Robb Matzke <matzke@llnl.gov>
+ *
+ * Purpose:             Public include file for cache functions.
+ *
+ * Modifications:
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef _H5ACpublic_H
+#define _H5ACpublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+#include "H5Cpublic.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/****************************************************************************
+ *
+ * structure H5AC_cache_config_t
+ *
+ * H5AC_cache_config_t is a public structure intended for use in public APIs.
+ * At least in its initial incarnation, it is basicaly a copy of struct
+ * H5C_auto_size_ctl_t, minus the report_fcn field, and plus the
+ * dirty_bytes_threshold field.
+ *
+ * The report_fcn field is omitted, as including it would require us to
+ * make H5C_t structure public.
+ *
+ * The dirty_bytes_threshold field does not appear in H5C_auto_size_ctl_t,
+ * as synchronization between caches on different processes is handled at
+ * the H5AC level, not at the level of H5C.  Note however that there is
+ * considerable interaction between this value and the other fields in this
+ * structure.
+ *
+ * Similarly, the open_trace_file, close_trace_file, and trace_file_name
+ * fields do not appear in H5C_auto_size_ctl_t, as most trace file
+ * issues are handled at the H5AC level.  The one exception is storage of
+ * the pointer to the trace file, which is handled by H5C.
+ *
+ * The structure is in H5ACpublic.h as we may wish to allow different
+ * configuration options for metadata and raw data caches.
+ *
+ * The fields of the structure are discussed individually below:
+ *
+ * version: Integer field containing the version number of this version
+ *      of the H5AC_cache_config_t structure.  Any instance of
+ *      H5AC_cache_config_t passed to the cache must have a known
+ *      version number, or an error will be flagged.
+ *
+ * rpt_fcn_enabled: Boolean field used to enable and disable the default
+ *    reporting function.  This function is invoked every time the
+ *    automatic cache resize code is run, and reports on its activities.
+ *
+ *    This is a debugging function, and should normally be turned off.
+ *
+ * open_trace_file: Boolean field indicating whether the trace_file_name
+ *     field should be used to open a trace file for the cache.
+ *
+ *      *** DEPRECATED *** Use H5Fstart/stop logging functions instead
+ *
+ *     The trace file is a debuging feature that allow the capture of
+ *     top level metadata cache requests for purposes of debugging and/or
+ *     optimization.  This field should normally be set to FALSE, as
+ *     trace file collection imposes considerable overhead.
+ *
+ *     This field should only be set to TRUE when the trace_file_name
+ *     contains the full path of the desired trace file, and either
+ *     there is no open trace file on the cache, or the close_trace_file
+ *     field is also TRUE.
+ *
+ * close_trace_file: Boolean field indicating whether the current trace
+ *     file (if any) should be closed.
+ *
+ *      *** DEPRECATED *** Use H5Fstart/stop logging functions instead
+ *
+ *     See the above comments on the open_trace_file field.  This field
+ *     should be set to FALSE unless there is an open trace file on the
+ *     cache that you wish to close.
+ *
+ * trace_file_name: Full path of the trace file to be opened if the
+ *     open_trace_file field is TRUE.
+ *
+ *      *** DEPRECATED *** Use H5Fstart/stop logging functions instead
+ *
+ *     In the parallel case, an ascii representation of the mpi rank of
+ *     the process will be appended to the file name to yield a unique
+ *     trace file name for each process.
+ *
+ *     The length of the path must not exceed H5AC__MAX_TRACE_FILE_NAME_LEN
+ *     characters.
+ *
+ * evictions_enabled:  Boolean field used to either report the current
+ *     evictions enabled status of the cache, or to set the cache's
+ *    evictions enabled status.
+ *
+ *     In general, the metadata cache should always be allowed to
+ *     evict entries.  However, in some cases it is advantageous to
+ *     disable evictions briefly, and thereby postpone metadata
+ *     writes.  However, this must be done with care, as the cache
+ *     can grow quickly.  If you do this, re-enable evictions as
+ *     soon as possible and monitor cache size.
+ *
+ *     At present, evictions can only be disabled if automatic
+ *     cache resizing is also disabled (that is, ( incr_mode ==
+ *    H5C_incr__off ) && ( decr_mode == H5C_decr__off )).  There
+ *    is no logical reason why this should be so, but it simplifies
+ *    implementation and testing, and I can't think of any reason
+ *    why it would be desireable.  If you can think of one, I'll
+ *    revisit the issue.
+ *
+ * set_initial_size: Boolean flag indicating whether the size of the
+ *      initial size of the cache is to be set to the value given in
+ *      the initial_size field.  If set_initial_size is FALSE, the
+ *      initial_size field is ignored.
+ *
+ * initial_size: If enabled, this field contain the size the cache is
+ *      to be set to upon receipt of this structure.  Needless to say,
+ *      initial_size must lie in the closed interval [min_size, max_size].
+ *
+ * min_clean_fraction: double in the range 0 to 1 indicating the fraction
+ *      of the cache that is to be kept clean.  This field is only used
+ *      in parallel mode.  Typical values are 0.1 to 0.5.
+ *
+ * max_size: Maximum size to which the cache can be adjusted.  The
+ *      supplied value must fall in the closed interval
+ *      [MIN_MAX_CACHE_SIZE, MAX_MAX_CACHE_SIZE].  Also, max_size must
+ *      be greater than or equal to min_size.
+ *
+ * min_size: Minimum size to which the cache can be adjusted.  The
+ *      supplied value must fall in the closed interval
+ *      [H5C__MIN_MAX_CACHE_SIZE, H5C__MAX_MAX_CACHE_SIZE].  Also, min_size
+ *      must be less than or equal to max_size.
+ *
+ * epoch_length: Number of accesses on the cache over which to collect
+ *      hit rate stats before running the automatic cache resize code,
+ *      if it is enabled.
+ *
+ *      At the end of an epoch, we discard prior hit rate data and start
+ *      collecting afresh.  The epoch_length must lie in the closed
+ *      interval [H5C__MIN_AR_EPOCH_LENGTH, H5C__MAX_AR_EPOCH_LENGTH].
+ *
+ *
+ * Cache size increase control fields:
+ *
+ * incr_mode: Instance of the H5C_cache_incr_mode enumerated type whose
+ *      value indicates how we determine whether the cache size should be
+ *      increased.  At present there are two possible values:
+ *
+ *      H5C_incr__off:  Don't attempt to increase the size of the cache
+ *              automatically.
+ *
+ *              When this increment mode is selected, the remaining fields
+ *              in the cache size increase section ar ignored.
+ *
+ *      H5C_incr__threshold: Attempt to increase the size of the cache
+ *              whenever the average hit rate over the last epoch drops
+ *              below the value supplied in the lower_hr_threshold
+ *              field.
+ *
+ *              Note that this attempt will fail if the cache is already
+ *              at its maximum size, or if the cache is not already using
+ *              all available space.
+ *
+ *      Note that you must set decr_mode to H5C_incr__off if you
+ *      disable metadata cache entry evictions.
+ *
+ * lower_hr_threshold: Lower hit rate threshold.  If the increment mode
+ *      (incr_mode) is H5C_incr__threshold and the hit rate drops below the
+ *      value supplied in this field in an epoch, increment the cache size by
+ *      size_increment.  Note that cache size may not be incremented above
+ *      max_size, and that the increment may be further restricted by the
+ *      max_increment field if it is enabled.
+ *
+ *      When enabled, this field must contain a value in the range [0.0, 1.0].
+ *      Depending on the incr_mode selected, it may also have to be less than
+ *      upper_hr_threshold.
+ *
+ * increment:  Double containing the multiplier used to derive the new
+ *      cache size from the old if a cache size increment is triggered.
+ *      The increment must be greater than 1.0, and should not exceed 2.0.
+ *
+ *      The new cache size is obtained my multiplying the current max cache
+ *      size by the increment, and then clamping to max_size and to stay
+ *      within the max_increment as necessary.
+ *
+ * apply_max_increment:  Boolean flag indicating whether the max_increment
+ *      field should be used to limit the maximum cache size increment.
+ *
+ * max_increment: If enabled by the apply_max_increment field described
+ *      above, this field contains the maximum number of bytes by which the
+ *      cache size can be increased in a single re-size.
+ *
+ * flash_incr_mode:  Instance of the H5C_cache_flash_incr_mode enumerated
+ *      type whose value indicates whether and by which algorithm we should
+ *      make flash increases in the size of the cache to accomodate insertion
+ *      of large entries and large increases in the size of a single entry.
+ *
+ *      The addition of the flash increment mode was occasioned by performance
+ *      problems that appear when a local heap is increased to a size in excess
+ *      of the current cache size.  While the existing re-size code dealt with
+ *      this eventually, performance was very bad for the remainder of the
+ *      epoch.
+ *
+ *      At present, there are two possible values for the flash_incr_mode:
+ *
+ *      H5C_flash_incr__off:  Don't perform flash increases in the size of
+ *              the cache.
+ *
+ *      H5C_flash_incr__add_space:  Let x be either the size of a newly
+ *              newly inserted entry, or the number of bytes by which the
+ *              size of an existing entry has been increased.
+ *
+ *              If
+ *                      x > flash_threshold * current max cache size,
+ *
+ *              increase the current maximum cache size by x * flash_multiple
+ *              less any free space in the cache, and star a new epoch.  For
+ *              now at least, pay no attention to the maximum increment.
+ *
+ *      In both of the above cases, the flash increment pays no attention to
+ *      the maximum increment (at least in this first incarnation), but DOES
+ *      stay within max_size.
+ *
+ *      With a little thought, it should be obvious that the above flash
+ *      cache size increase algorithm is not sufficient for all circumstances
+ *      -- for example, suppose the user round robins through
+ *      (1/flash_threshold) +1 groups, adding one data set to each on each
+ *      pass.  Then all will increase in size at about the same time, requiring
+ *      the max cache size to at least double to maintain acceptable
+ *      performance, however the above flash increment algorithm will not be
+ *      triggered.
+ *
+ *      Hopefully, the add space algorithms detailed above will be sufficient
+ *      for the performance problems encountered to date.  However, we should
+ *      expect to revisit the issue.
+ *
+ * flash_multiple: Double containing the multiple described above in the
+ *      H5C_flash_incr__add_space section of the discussion of the
+ *      flash_incr_mode section.  This field is ignored unless flash_incr_mode
+ *      is H5C_flash_incr__add_space.
+ *
+ * flash_threshold: Double containing the factor by which current max cache
+ *      size is multiplied to obtain the size threshold for the add_space flash
+ *      increment algorithm.  The field is ignored unless flash_incr_mode is
+ *      H5C_flash_incr__add_space.
+ *
+ *
+ * Cache size decrease control fields:
+ *
+ * decr_mode: Instance of the H5C_cache_decr_mode enumerated type whose
+ *      value indicates how we determine whether the cache size should be
+ *      decreased.  At present there are four possibilities.
+ *
+ *      H5C_decr__off:  Don't attempt to decrease the size of the cache
+ *              automatically.
+ *
+ *              When this increment mode is selected, the remaining fields
+ *              in the cache size decrease section are ignored.
+ *
+ *      H5C_decr__threshold: Attempt to decrease the size of the cache
+ *              whenever the average hit rate over the last epoch rises
+ *              above the value supplied in the upper_hr_threshold
+ *              field.
+ *
+ *      H5C_decr__age_out:  At the end of each epoch, search the cache for
+ *              entries that have not been accessed for at least the number
+ *              of epochs specified in the epochs_before_eviction field, and
+ *              evict these entries.  Conceptually, the maximum cache size
+ *              is then decreased to match the new actual cache size.  However,
+ *              this reduction may be modified by the min_size, the
+ *              max_decrement, and/or the empty_reserve.
+ *
+ *      H5C_decr__age_out_with_threshold:  Same as age_out, but we only
+ *              attempt to reduce the cache size when the hit rate observed
+ *              over the last epoch exceeds the value provided in the
+ *              upper_hr_threshold field.
+ *
+ *      Note that you must set decr_mode to H5C_decr__off if you
+ *      disable metadata cache entry evictions.
+ *
+ * upper_hr_threshold: Upper hit rate threshold.  The use of this field
+ *      varies according to the current decr_mode:
+ *
+ *      H5C_decr__off or H5C_decr__age_out:  The value of this field is
+ *              ignored.
+ *
+ *      H5C_decr__threshold:  If the hit rate exceeds this threshold in any
+ *              epoch, attempt to decrement the cache size by size_decrement.
+ *
+ *              Note that cache size may not be decremented below min_size.
+ *
+ *              Note also that if the upper_threshold is 1.0, the cache size
+ *              will never be reduced.
+ *
+ *      H5C_decr__age_out_with_threshold:  If the hit rate exceeds this
+ *              threshold in any epoch, attempt to reduce the cache size
+ *              by evicting entries that have not been accessed for more
+ *              than the specified number of epochs.
+ *
+ * decrement: This field is only used when the decr_mode is
+ *      H5C_decr__threshold.
+ *
+ *      The field is a double containing the multiplier used to derive the
+ *      new cache size from the old if a cache size decrement is triggered.
+ *      The decrement must be in the range 0.0 (in which case the cache will
+ *      try to contract to its minimum size) to 1.0 (in which case the
+ *      cache will never shrink).
+ *
+ * apply_max_decrement:  Boolean flag used to determine whether decrements
+ *      in cache size are to be limited by the max_decrement field.
+ *
+ * max_decrement: Maximum number of bytes by which the cache size can be
+ *      decreased in a single re-size.  Note that decrements may also be
+ *      restricted by the min_size of the cache, and (in age out modes) by
+ *      the empty_reserve field.
+ *
+ * epochs_before_eviction:  Integer field used in H5C_decr__age_out and
+ *      H5C_decr__age_out_with_threshold decrement modes.
+ *
+ *      This field contains the number of epochs an entry must remain
+ *      unaccessed before it is evicted in an attempt to reduce the
+ *      cache size.  If applicable, this field must lie in the range
+ *      [1, H5C__MAX_EPOCH_MARKERS].
+ *
+ * apply_empty_reserve:  Boolean field controlling whether the empty_reserve
+ *      field is to be used in computing the new cache size when the
+ *      decr_mode is H5C_decr__age_out or H5C_decr__age_out_with_threshold.
+ *
+ * empty_reserve:  To avoid a constant racheting down of cache size by small
+ *      amounts in the H5C_decr__age_out and H5C_decr__age_out_with_threshold
+ *      modes, this field allows one to require that any cache size
+ *      reductions leave the specified fraction of unused space in the cache.
+ *
+ *      The value of this field must be in the range [0.0, 1.0].  I would
+ *      expect typical values to be in the range of 0.01 to 0.1.
+ *
+ *
+ * Parallel Configuration Fields:
+ *
+ * In PHDF5, all operations that modify metadata must be executed collectively.
+ *
+ * We used to think that this was enough to ensure consistency across the
+ * metadata caches, but since we allow processes to read metadata individually,
+ * the order of dirty entries in the LRU list can vary across processes,
+ * which can result in inconsistencies between the caches.
+ *
+ * PHDF5 uses several strategies to prevent such inconsistencies in metadata,
+ * all of which use the fact that the same stream of dirty metadata is seen
+ * by all processes for purposes of synchronization.  This is done by
+ * having each process count the number of bytes of dirty metadata generated,
+ * and then running a "sync point" whenever this count exceeds a user
+ * specified threshold (see dirty_bytes_threshold below).
+ *
+ * The current metadata write strategy is indicated by the
+ * metadata_write_strategy field.  The possible values of this field, along
+ * with the associated metadata write strategies are discussed below.
+ *
+ * dirty_bytes_threshold:  Threshold of dirty byte creation used to
+ *     synchronize updates between caches. (See above for outline and
+ *    motivation.)
+ *
+ *    This value MUST be consistant across all processes accessing the
+ *    file.  This field is ignored unless HDF5 has been compiled for
+ *    parallel.
+ *
+ * metadata_write_strategy: Integer field containing a code indicating the
+ *    desired metadata write strategy.  The valid values of this field
+ *    are enumerated and discussed below:
+ *
+ *
+ *    H5AC_METADATA_WRITE_STRATEGY__PROCESS_0_ONLY:
+ *
+ *    When metadata_write_strategy is set to this value, only process
+ *    zero is allowed to write dirty metadata to disk.  All other
+ *    processes must retain dirty metadata until they are informed at
+ *    a sync point that the dirty metadata in question has been written
+ *    to disk.
+ *
+ *    When the sync point is reached (or when there is a user generated
+ *    flush), process zero flushes sufficient entries to bring it into
+ *    complience with its min clean size (or flushes all dirty entries in
+ *    the case of a user generated flush), broad casts the list of
+ *    entries just cleaned to all the other processes, and then exits
+ *    the sync point.
+ *
+ *    Upon receipt of the broadcast, the other processes mark the indicated
+ *    entries as clean, and leave the sync point as well.
+ *
+ *
+ *    H5AC_METADATA_WRITE_STRATEGY__DISTRIBUTED:
+ *
+ *    In the distributed metadata write strategy, process zero still makes
+ *    the decisions as to what entries should be flushed, but the actual
+ *    flushes are distributed across the processes in the computation to
+ *    the extent possible.
+ *
+ *    In this strategy, when a sync point is triggered (either by dirty
+ *    metadata creation or manual flush), all processes enter a barrier.
+ *
+ *    On the other side of the barrier, process 0 constructs an ordered
+ *    list of the entries to be flushed, and then broadcasts this list
+ *    to the caches in all the processes.
+ *
+ *    All processes then scan the list of entries to be flushed, flushing
+ *    some, and marking the rest as clean.  The algorithm for this purpose
+ *    ensures that each entry in the list is flushed exactly once, and
+ *    all are marked clean in each cache.
+ *
+ *    Note that in the case of a flush of the cache, no message passing
+ *    is necessary, as all processes have the same list of dirty entries,
+ *    and all of these entries must be flushed.  Thus in this case it is
+ *    sufficient for each process to sort its list of dirty entries after
+ *    leaving the initial barrier, and use this list as if it had been
+ *    received from process zero.
+ *
+ *    To avoid possible messages from the past/future, all caches must
+ *    wait until all caches are done before leaving the sync point.
+ *
+ ****************************************************************************/
+
+#define H5AC__CURR_CACHE_CONFIG_VERSION     1
+#define H5AC__MAX_TRACE_FILE_NAME_LEN        1024
+
+#define H5AC_METADATA_WRITE_STRATEGY__PROCESS_0_ONLY    0
+#define H5AC_METADATA_WRITE_STRATEGY__DISTRIBUTED       1
+
+typedef struct H5AC_cache_config_t
+{
+    /* general configuration fields: */
+    int                      version;
+
+    hbool_t             rpt_fcn_enabled;
+
+    hbool_t             open_trace_file;
+    hbool_t                  close_trace_file;
+    char                     trace_file_name[H5AC__MAX_TRACE_FILE_NAME_LEN + 1];
+
+    hbool_t                  evictions_enabled;
+
+    hbool_t                  set_initial_size;
+    size_t                   initial_size;
+
+    double                   min_clean_fraction;
+
+    size_t                   max_size;
+    size_t                   min_size;
+
+    long int                 epoch_length;
+
+
+    /* size increase control fields: */
+    enum H5C_cache_incr_mode incr_mode;
+
+    double                   lower_hr_threshold;
+
+    double                   increment;
+
+    hbool_t                  apply_max_increment;
+    size_t                   max_increment;
+
+    enum H5C_cache_flash_incr_mode      flash_incr_mode;
+    double                              flash_multiple;
+    double                              flash_threshold;
+
+
+    /* size decrease control fields: */
+    enum H5C_cache_decr_mode decr_mode;
+
+    double                   upper_hr_threshold;
+
+    double                   decrement;
+
+    hbool_t                  apply_max_decrement;
+    size_t                   max_decrement;
+
+    int                      epochs_before_eviction;
+
+    hbool_t                  apply_empty_reserve;
+    double                   empty_reserve;
+
+
+    /* parallel configuration fields: */
+    size_t                   dirty_bytes_threshold;
+    int                      metadata_write_strategy;
+
+} H5AC_cache_config_t;
+
+
+/****************************************************************************
+ *
+ * structure H5AC_cache_image_config_t
+ *
+ * H5AC_cache_image_ctl_t is a public structure intended for use in public
+ * APIs.  At least in its initial incarnation, it is a copy of struct
+ * H5C_cache_image_ctl_t.
+ *
+ * The fields of the structure are discussed individually below:
+ *
+ * version: Integer field containing the version number of this version
+ *      of the H5C_image_ctl_t structure.  Any instance of
+ *      H5C_image_ctl_t passed to the cache must have a known
+ *      version number, or an error will be flagged.
+ *
+ * generate_image:  Boolean flag indicating whether a cache image should
+ *      be created on file close.
+ *
+ * save_resize_status:    Boolean flag indicating whether the cache image
+ *    should include the adaptive cache resize configuration and status.
+ *    Note that this field is ignored at present.
+ *
+ * entry_ageout:    Integer field indicating the maximum number of
+ *    times a prefetched entry can appear in subsequent cache images.
+ *    This field exists to allow the user to avoid the buildup of
+ *    infrequently used entries in long sequences of cache images.
+ *
+ *    The value of this field must lie in the range
+ *    H5AC__CACHE_IMAGE__ENTRY_AGEOUT__NONE (-1) to
+ *    H5AC__CACHE_IMAGE__ENTRY_AGEOUT__MAX (100).
+ *
+ *    H5AC__CACHE_IMAGE__ENTRY_AGEOUT__NONE means that no limit
+ *    is imposed on number of times a prefeteched entry can appear
+ *    in subsequent cache images.
+ *
+ *    A value of 0 prevents prefetched entries from being included
+ *    in cache images.
+ *
+ *    Positive integers restrict prefetched entries to the specified
+ *    number of appearances.
+ *
+ *    Note that the number of subsequent cache images that a prefetched
+ *    entry has appeared in is tracked in an 8 bit field.  Thus, while
+ *    H5AC__CACHE_IMAGE__ENTRY_AGEOUT__MAX can be increased from its
+ *    current value, any value in excess of 255 will be the functional
+ *    equivalent of H5AC__CACHE_IMAGE__ENTRY_AGEOUT__NONE.
+ *
+ ****************************************************************************/
+
+#define H5AC__CURR_CACHE_IMAGE_CONFIG_VERSION     1
+
+#define H5AC__CACHE_IMAGE__ENTRY_AGEOUT__NONE    -1
+#define H5AC__CACHE_IMAGE__ENTRY_AGEOUT__MAX    100
+
+typedef struct H5AC_cache_image_config_t {
+    int                                 version;
+    hbool_t                             generate_image;
+    hbool_t                             save_resize_status;
+    int                                 entry_ageout;
+} H5AC_cache_image_config_t;
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/install/include/H5AbstractDs.h b/install/include/H5AbstractDs.h
new file mode 100644
index 0000000000..73a18b8e1c
--- /dev/null
+++ b/install/include/H5AbstractDs.h
@@ -0,0 +1,96 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __AbstractDs_H
+#define __AbstractDs_H
+
+namespace H5 {
+
+class ArrayType;
+class CompType;
+class EnumType;
+class FloatType;
+class IntType;
+class StrType;
+class VarLenType;
+class DataSpace;
+
+/*! \class AbstractDs
+    \brief AbstractDs is an abstract base class, inherited by Attribute
+     and DataSet.
+
+    It provides a collection of services that are common to both Attribute
+    and DataSet.  AbstractDs inherits from H5Object.
+*/
+class H5_DLLCPP AbstractDs {
+   public:
+        // Gets a copy the datatype of that this abstract dataset uses.
+        // Note that this datatype is a generic one and can only be accessed
+        // via generic member functions, i.e., member functions belong
+        // to DataType.  To get specific datatype, i.e. EnumType, FloatType,
+        // etc..., use the specific functions, that follow, instead.
+        DataType getDataType() const;
+
+        // Gets a copy of the specific datatype of this abstract dataset.
+        ArrayType getArrayType() const;
+        CompType getCompType() const;
+        EnumType getEnumType() const;
+        IntType getIntType() const;
+        FloatType getFloatType() const;
+        StrType getStrType() const;
+        VarLenType getVarLenType() const;
+
+        ///\brief Gets the size in memory of this abstract dataset.
+        virtual size_t getInMemDataSize() const = 0;
+
+        ///\brief Gets the dataspace of this abstract dataset - pure virtual.
+        virtual DataSpace getSpace() const = 0;
+
+        // Gets the class of the datatype that is used by this abstract
+        // dataset.
+        H5T_class_t getTypeClass() const;
+
+        ///\brief Returns the amount of storage size required - pure virtual.
+        virtual hsize_t getStorageSize() const = 0;
+
+        // Returns this class name - pure virtual.
+        virtual H5std_string fromClass() const = 0;
+
+        // Destructor
+        virtual ~AbstractDs();
+
+   protected:
+        // Default constructor
+        AbstractDs();
+
+        // *** Deprecation warning ***
+        // The following two constructors are no longer appropriate after the
+        // data member "id" had been moved to the sub-classes.
+        // The copy constructor is a noop and is removed in 1.8.15 and the
+        // other will be removed from 1.10 release, and then from 1.8 if its
+        // removal does not raise any problems in two 1.10 releases.
+
+        // Mar 2016 -BMR, AbstractDs(const hid_t h5_id);
+
+        // Copy constructor
+        // AbstractDs( const AbstractDs& original );
+
+   private:
+        // This member function is implemented by DataSet and Attribute - pure virtual.
+        virtual hid_t p_get_type() const = 0;
+
+}; // end of AbstractDs
+} // namespace H5
+
+#endif // __AbstractDs_H
diff --git a/install/include/H5Alltypes.h b/install/include/H5Alltypes.h
new file mode 100644
index 0000000000..d67f3fe2ab
--- /dev/null
+++ b/install/include/H5Alltypes.h
@@ -0,0 +1,27 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+// This header file simply serves as a container to hold the
+// header files of all datatypes.  It simplifies the header
+// file including in the code.
+
+#include "H5DataType.h"
+#include "H5AtomType.h"
+#include "H5EnumType.h"
+#include "H5IntType.h"
+#include "H5FloatType.h"
+#include "H5StrType.h"
+#include "H5ArrayType.h"
+#include "H5VarLenType.h"
+#include "H5CompType.h"
diff --git a/install/include/H5Apkg.h b/install/include/H5Apkg.h
new file mode 100644
index 0000000000..6d5a83ab2b
--- /dev/null
+++ b/install/include/H5Apkg.h
@@ -0,0 +1,275 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Quincey Koziol
+ *              Monday, Apr 20
+ *
+ * Purpose:     This file contains declarations which are visible only within
+ *              the H5A package.  Source files outside the H5A package should
+ *              include H5Aprivate.h instead.
+ */
+#if !(defined H5A_FRIEND || defined H5A_MODULE)
+#error "Do not include this file outside the H5A package!"
+#endif
+
+#ifndef _H5Apkg_H
+#define _H5Apkg_H
+
+/*
+ * Define this to enable debugging.
+ */
+#ifdef NDEBUG
+#  undef H5A_DEBUG
+#endif
+
+/* Get package's private header */
+#include "H5Aprivate.h"
+
+/* Other private headers needed by this file */
+#include "H5B2private.h"	/* v2 B-trees				*/
+#include "H5FLprivate.h"	/* Free Lists				*/
+#include "H5HFprivate.h"	/* Fractal heaps			*/
+#include "H5Oprivate.h"		/* Object headers		  	*/
+#include "H5Sprivate.h"		/* Dataspace				*/
+#include "H5Tprivate.h"		/* Datatype functions			*/
+
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* This is the initial version, which does not have support for shared datatypes */
+#define H5O_ATTR_VERSION_1	1
+
+/* This version allows support for shared datatypes & dataspaces by adding a
+ *      'flag' byte indicating when those components are shared.  This version
+ *      also dropped the alignment on all the components.
+ */
+#define H5O_ATTR_VERSION_2	2
+
+/* Add support for different character encodings of attribute names */
+#define H5O_ATTR_VERSION_3      3
+
+/* The latest version of the format.  Look through the 'encode', 'decode'
+ *      and 'size' message callbacks for places to change when updating this.
+ */
+#define H5O_ATTR_VERSION_LATEST H5O_ATTR_VERSION_3
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+/* Define the shared attribute structure */
+typedef struct H5A_shared_t {
+    uint8_t     version;    /* Version to encode attribute with */
+
+    char        *name;      /* Attribute's name */
+    H5T_cset_t  encoding;   /* Character encoding of attribute name */
+
+    H5T_t       *dt;        /* Attribute's datatype */
+    size_t      dt_size;    /* Size of datatype on disk */
+
+    H5S_t       *ds;        /* Attribute's dataspace */
+    size_t      ds_size;    /* Size of dataspace on disk */
+
+    void        *data;      /* Attribute data (on a temporary basis) */
+    size_t      data_size;  /* Size of data on disk */
+    H5O_msg_crt_idx_t crt_idx;  /* Attribute's creation index in the object header */
+    unsigned	nrefs;		/* Ref count for times this object is refered	*/
+} H5A_shared_t;
+
+/* Define the main attribute structure */
+struct H5A_t {
+    H5O_shared_t sh_loc;     /* Shared message info (must be first) */
+    H5O_loc_t    oloc;       /* Object location for object attribute is on */
+    hbool_t      obj_opened; /* Object header entry opened? */
+    H5G_name_t   path;       /* Group hierarchy path */
+    H5A_shared_t *shared;    /* Shared attribute information */
+};
+
+/* Typedefs for "dense" attribute storage */
+/* (fractal heap & v2 B-tree info) */
+
+/* Typedef for native 'name' field index records in the v2 B-tree */
+/* (Keep 'id' field first so generic record handling in callbacks works) */
+typedef struct H5A_dense_bt2_name_rec_t {
+    H5O_fheap_id_t id;                  /* Heap ID for attribute */
+    uint8_t flags;                      /* Object header message flags for attribute */
+    H5O_msg_crt_idx_t corder;           /* 'creation order' field value */
+    uint32_t hash;                      /* Hash of 'name' field value */
+} H5A_dense_bt2_name_rec_t;
+
+/* Typedef for native 'creation order' field index records in the v2 B-tree */
+/* (Keep 'id' field first so generic record handling in callbacks works) */
+typedef struct H5A_dense_bt2_corder_rec_t {
+    H5O_fheap_id_t id;                  /* Heap ID for attribute */
+    uint8_t flags;                      /* Object header message flags for attribute */
+    H5O_msg_crt_idx_t corder;           /* 'creation order' field value */
+} H5A_dense_bt2_corder_rec_t;
+
+/* Define the 'found' callback function pointer for matching an attribute record in a v2 B-tree */
+typedef herr_t (*H5A_bt2_found_t)(const H5A_t *attr, hbool_t *took_ownership, void *op_data);
+
+/*
+ * Common data exchange structure for dense attribute storage.  This structure
+ * is passed through the v2 B-tree layer to the methods for the objects
+ * to which the v2 B-tree points.
+ */
+typedef struct H5A_bt2_ud_common_t {
+    /* downward */
+    H5F_t       *f;                     /* Pointer to file that fractal heap is in */
+    hid_t       dxpl_id;                /* DXPL for operation                */
+    H5HF_t      *fheap;                 /* Fractal heap handle               */
+    H5HF_t      *shared_fheap;          /* Fractal heap handle for shared messages */
+    const char  *name;                  /* Name of attribute to compare      */
+    uint32_t    name_hash;              /* Hash of name of attribute to compare */
+    uint8_t     flags;                  /* Flags for attribute storage location */
+    H5O_msg_crt_idx_t corder;           /* Creation order value of attribute to compare */
+    H5A_bt2_found_t found_op;           /* Callback when correct attribute is found */
+    void        *found_op_data;         /* Callback data when correct attribute is found */
+} H5A_bt2_ud_common_t;
+
+/*
+ * Data exchange structure for dense attribute storage.  This structure is
+ * passed through the v2 B-tree layer when inserting attributes.
+ */
+typedef struct H5A_bt2_ud_ins_t {
+    /* downward */
+    H5A_bt2_ud_common_t common;         /* Common info for B-tree user data (must be first) */
+    H5O_fheap_id_t id;                  /* Heap ID of attribute to insert    */
+} H5A_bt2_ud_ins_t;
+
+/* Data structure to hold table of attributes for an object */
+typedef struct {
+    size_t      nattrs;         /* # of attributes in table */
+    H5A_t       **attrs;        /* Pointer to array of attribute pointers */
+} H5A_attr_table_t;
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+/* Declare extern the free list for H5A_t's */
+H5FL_EXTERN(H5A_t);
+
+/* Declare the external free lists for H5A_shared_t's */
+H5FL_EXTERN(H5A_shared_t);
+
+/* Declare extern a free list to manage blocks of type conversion data */
+H5FL_BLK_EXTERN(attr_buf);
+
+/* The v2 B-tree class for indexing 'name' field on attributes */
+H5_DLLVAR const H5B2_class_t H5A_BT2_NAME[1];
+
+/* The v2 B-tree class for indexing 'creation order' field on attributes */
+H5_DLLVAR const H5B2_class_t H5A_BT2_CORDER[1];
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+/* Function prototypes for H5A package scope */
+H5_DLL H5A_t *H5A_create(const H5G_loc_t *loc, const char *name,
+    const H5T_t *type, const H5S_t *space, hid_t acpl_id, hid_t dxpl_id);
+H5_DLL H5A_t *H5A_open_by_name(const H5G_loc_t *loc, const char *obj_name,
+    const char *attr_name, hid_t lapl_id, hid_t dxpl_id);
+H5_DLL H5A_t *H5A_open_by_idx(const H5G_loc_t *loc, const char *obj_name,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t n, hid_t lapl_id, hid_t dxpl_id);
+H5_DLL herr_t H5A__open_common(const H5G_loc_t *loc, H5A_t *attr);
+H5_DLL H5A_t *H5A_copy(H5A_t *new_attr, const H5A_t *old_attr);
+H5_DLL herr_t H5A__get_info(const H5A_t *attr, H5A_info_t *ainfo);
+H5_DLL hid_t H5A_get_create_plist(H5A_t* attr);
+H5_DLL herr_t H5A_free(H5A_t *attr);
+H5_DLL herr_t H5A_close(H5A_t *attr);
+H5_DLL htri_t H5A_get_ainfo(H5F_t *f, hid_t dxpl_id, H5O_t *oh, H5O_ainfo_t *ainfo);
+H5_DLL herr_t H5A_set_version(const H5F_t *f, H5A_t *attr);
+H5_DLL herr_t H5A_rename_by_name(H5G_loc_t loc, const char *obj_name, const char *old_attr_name,
+    const char *new_attr_name, hid_t lapl_id, hid_t dxpl_id);
+H5_DLL htri_t H5A_exists_by_name(H5G_loc_t loc, const char *obj_name, const char *attr_name,
+    hid_t lapl_id, hid_t dxpl_id);
+H5_DLL herr_t H5A__write(H5A_t *attr, const H5T_t *mem_type, const void *buf, hid_t dxpl_id);
+H5_DLL herr_t H5A__read(const H5A_t *attr, const H5T_t *mem_type, void *buf, hid_t dxpl_id);
+H5_DLL ssize_t H5A__get_name(H5A_t *attr, size_t buf_size, char *buf);
+
+/* Attribute "dense" storage routines */
+H5_DLL herr_t H5A_dense_create(H5F_t *f, hid_t dxpl_id, H5O_ainfo_t *ainfo);
+H5_DLL H5A_t *H5A_dense_open(H5F_t *f, hid_t dxpl_id, const H5O_ainfo_t *ainfo,
+    const char *name);
+H5_DLL herr_t H5A_dense_insert(H5F_t *f, hid_t dxpl_id, const H5O_ainfo_t *ainfo,
+    H5A_t *attr);
+H5_DLL herr_t H5A_dense_write(H5F_t *f, hid_t dxpl_id, const H5O_ainfo_t *ainfo,
+    H5A_t *attr);
+H5_DLL herr_t H5A_dense_rename(H5F_t *f, hid_t dxpl_id, const H5O_ainfo_t *ainfo,
+    const char *old_name, const char *new_name);
+H5_DLL herr_t H5A_dense_iterate(H5F_t *f, hid_t dxpl_id, hid_t loc_id,
+    const H5O_ainfo_t *ainfo, H5_index_t idx_type, H5_iter_order_t order,
+    hsize_t skip, hsize_t *last_attr, const H5A_attr_iter_op_t *attr_op,
+    void *op_data);
+H5_DLL herr_t H5A_dense_remove(H5F_t *f, hid_t dxpl_id,
+    const H5O_ainfo_t *ainfo, const char *name);
+H5_DLL herr_t H5A_dense_remove_by_idx(H5F_t *f, hid_t dxpl_id,
+    const H5O_ainfo_t *ainfo, H5_index_t idx_type, H5_iter_order_t order,
+    hsize_t n);
+H5_DLL htri_t H5A_dense_exists(H5F_t *f, hid_t dxpl_id, const H5O_ainfo_t *ainfo,
+    const char *name);
+H5_DLL herr_t H5A_dense_delete(H5F_t *f, hid_t dxpl_id, H5O_ainfo_t *ainfo);
+
+/* Attribute table operations */
+H5_DLL herr_t H5A_compact_build_table(H5F_t *f, hid_t dxpl_id, H5O_t *oh,
+    H5_index_t idx_type, H5_iter_order_t order, H5A_attr_table_t *atable);
+H5_DLL herr_t H5A_dense_build_table(H5F_t *f, hid_t dxpl_id,
+    const H5O_ainfo_t *ainfo, H5_index_t idx_type, H5_iter_order_t order,
+    H5A_attr_table_t *atable);
+H5_DLL herr_t H5A_attr_iterate_table(const H5A_attr_table_t *atable,
+    hsize_t skip, hsize_t *last_attr, hid_t loc_id,
+    const H5A_attr_iter_op_t *attr_op, void *op_data);
+H5_DLL herr_t H5A_attr_release_table(H5A_attr_table_t *atable);
+
+/* Attribute operations */
+H5_DLL herr_t H5O_attr_create(const H5O_loc_t *loc, hid_t dxpl_id, H5A_t *attr);
+H5_DLL H5A_t *H5O_attr_open_by_name(const H5O_loc_t *loc, const char *name,
+    hid_t dxpl_id);
+H5_DLL H5A_t *H5O_attr_open_by_idx(const H5O_loc_t *loc, H5_index_t idx_type,
+    H5_iter_order_t order, hsize_t n, hid_t dxpl_id);
+H5_DLL herr_t H5O_attr_update_shared(H5F_t *f, hid_t dxpl_id, H5O_t *oh,
+        H5A_t *attr, H5O_shared_t *sh_mesg);
+H5_DLL herr_t H5O_attr_write(const H5O_loc_t *loc, hid_t dxpl_id,
+    H5A_t *attr);
+H5_DLL herr_t H5O_attr_rename(const H5O_loc_t *loc, hid_t dxpl_id,
+    const char *old_name, const char *new_name);
+H5_DLL herr_t H5O_attr_remove(const H5O_loc_t *loc, const char *name,
+    hid_t dxpl_id);
+H5_DLL herr_t H5O_attr_remove_by_idx(const H5O_loc_t *loc, H5_index_t idx_type,
+    H5_iter_order_t order, hsize_t n, hid_t dxpl_id);
+H5_DLL htri_t H5O_attr_exists(const H5O_loc_t *loc, const char *name, hid_t dxpl_id);
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+H5_DLL int H5O_attr_count(const H5O_loc_t *loc, hid_t dxpl_id);
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+H5_DLL H5A_t *H5A_attr_copy_file(const H5A_t *attr_src, H5F_t *file_dst, hbool_t *recompute_size,
+    H5O_copy_t *cpy_info, hid_t dxpl_id);
+H5_DLL herr_t H5A_attr_post_copy_file(const H5O_loc_t *src_oloc, const H5A_t *mesg_src,
+    H5O_loc_t *dst_oloc, const H5A_t *mesg_dst, hid_t dxpl_id, H5O_copy_t *cpy_info);
+H5_DLL herr_t H5A_dense_post_copy_file_all(const H5O_loc_t *src_oloc, const H5O_ainfo_t * ainfo_src,
+    H5O_loc_t *dst_oloc, H5O_ainfo_t *ainfo_dst, hid_t dxpl_id, H5O_copy_t *cpy_info);
+
+/* Testing functions */
+#ifdef H5A_TESTING
+H5_DLL htri_t H5A_is_shared_test(hid_t aid);
+H5_DLL herr_t H5A_get_shared_rc_test(hid_t attr_id, hsize_t *ref_count);
+#endif /* H5A_TESTING */
+
+#endif /* _H5Apkg_H */
+
diff --git a/install/include/H5Apublic.h b/install/include/H5Apublic.h
new file mode 100644
index 0000000000..586940b3f5
--- /dev/null
+++ b/install/include/H5Apublic.h
@@ -0,0 +1,118 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5A module.
+ */
+#ifndef _H5Apublic_H
+#define _H5Apublic_H
+
+/* Public headers needed by this file */
+#include "H5Ipublic.h"		/* IDs			  		*/
+#include "H5Opublic.h"		/* Object Headers			*/
+#include "H5Tpublic.h"		/* Datatypes				*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Information struct for attribute (for H5Aget_info/H5Aget_info_by_idx) */
+typedef struct {
+    hbool_t             corder_valid;   /* Indicate if creation order is valid */
+    H5O_msg_crt_idx_t   corder;         /* Creation order                 */
+    H5T_cset_t          cset;           /* Character set of attribute name */
+    hsize_t             data_size;      /* Size of raw data		  */
+} H5A_info_t;
+
+/* Typedef for H5Aiterate2() callbacks */
+typedef herr_t (*H5A_operator2_t)(hid_t location_id/*in*/,
+    const char *attr_name/*in*/, const H5A_info_t *ainfo/*in*/, void *op_data/*in,out*/);
+
+/* Public function prototypes */
+H5_DLL hid_t   H5Acreate2(hid_t loc_id, const char *attr_name, hid_t type_id,
+    hid_t space_id, hid_t acpl_id, hid_t aapl_id);
+H5_DLL hid_t   H5Acreate_by_name(hid_t loc_id, const char *obj_name, const char *attr_name,
+    hid_t type_id, hid_t space_id, hid_t acpl_id, hid_t aapl_id, hid_t lapl_id);
+H5_DLL hid_t   H5Aopen(hid_t obj_id, const char *attr_name, hid_t aapl_id);
+H5_DLL hid_t   H5Aopen_by_name(hid_t loc_id, const char *obj_name,
+    const char *attr_name, hid_t aapl_id, hid_t lapl_id);
+H5_DLL hid_t   H5Aopen_by_idx(hid_t loc_id, const char *obj_name,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t n, hid_t aapl_id,
+    hid_t lapl_id);
+H5_DLL herr_t  H5Awrite(hid_t attr_id, hid_t type_id, const void *buf);
+H5_DLL herr_t  H5Aread(hid_t attr_id, hid_t type_id, void *buf);
+H5_DLL herr_t  H5Aclose(hid_t attr_id);
+H5_DLL hid_t   H5Aget_space(hid_t attr_id);
+H5_DLL hid_t   H5Aget_type(hid_t attr_id);
+H5_DLL hid_t   H5Aget_create_plist(hid_t attr_id);
+H5_DLL ssize_t H5Aget_name(hid_t attr_id, size_t buf_size, char *buf);
+H5_DLL ssize_t H5Aget_name_by_idx(hid_t loc_id, const char *obj_name,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t n,
+    char *name /*out*/, size_t size, hid_t lapl_id);
+H5_DLL hsize_t H5Aget_storage_size(hid_t attr_id);
+H5_DLL herr_t  H5Aget_info(hid_t attr_id, H5A_info_t *ainfo /*out*/);
+H5_DLL herr_t  H5Aget_info_by_name(hid_t loc_id, const char *obj_name,
+    const char *attr_name, H5A_info_t *ainfo /*out*/, hid_t lapl_id);
+H5_DLL herr_t  H5Aget_info_by_idx(hid_t loc_id, const char *obj_name,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t n,
+    H5A_info_t *ainfo /*out*/, hid_t lapl_id);
+H5_DLL herr_t  H5Arename(hid_t loc_id, const char *old_name, const char *new_name);
+H5_DLL herr_t  H5Arename_by_name(hid_t loc_id, const char *obj_name,
+    const char *old_attr_name, const char *new_attr_name, hid_t lapl_id);
+H5_DLL herr_t  H5Aiterate2(hid_t loc_id, H5_index_t idx_type,
+    H5_iter_order_t order, hsize_t *idx, H5A_operator2_t op, void *op_data);
+H5_DLL herr_t  H5Aiterate_by_name(hid_t loc_id, const char *obj_name, H5_index_t idx_type,
+    H5_iter_order_t order, hsize_t *idx, H5A_operator2_t op, void *op_data,
+    hid_t lapd_id);
+H5_DLL herr_t  H5Adelete(hid_t loc_id, const char *name);
+H5_DLL herr_t  H5Adelete_by_name(hid_t loc_id, const char *obj_name,
+    const char *attr_name, hid_t lapl_id);
+H5_DLL herr_t  H5Adelete_by_idx(hid_t loc_id, const char *obj_name,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t n, hid_t lapl_id);
+H5_DLL htri_t H5Aexists(hid_t obj_id, const char *attr_name);
+H5_DLL htri_t H5Aexists_by_name(hid_t obj_id, const char *obj_name,
+    const char *attr_name, hid_t lapl_id);
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+
+
+/* Typedefs */
+
+/* Typedef for H5Aiterate1() callbacks */
+typedef herr_t (*H5A_operator1_t)(hid_t location_id/*in*/,
+    const char *attr_name/*in*/, void *operator_data/*in,out*/);
+
+
+/* Function prototypes */
+H5_DLL hid_t   H5Acreate1(hid_t loc_id, const char *name, hid_t type_id,
+    hid_t space_id, hid_t acpl_id);
+H5_DLL hid_t   H5Aopen_name(hid_t loc_id, const char *name);
+H5_DLL hid_t   H5Aopen_idx(hid_t loc_id, unsigned idx);
+H5_DLL int     H5Aget_num_attrs(hid_t loc_id);
+H5_DLL herr_t  H5Aiterate1(hid_t loc_id, unsigned *attr_num, H5A_operator1_t op,
+    void *op_data);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _H5Apublic_H */
+
diff --git a/install/include/H5ArrayType.h b/install/include/H5ArrayType.h
new file mode 100644
index 0000000000..ffb87129d8
--- /dev/null
+++ b/install/include/H5ArrayType.h
@@ -0,0 +1,65 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5ArrayType_H
+#define __H5ArrayType_H
+
+namespace H5 {
+
+/*! \class ArrayType
+    \brief Class ArrayType inherits from DataType and provides wrappers for
+     the HDF5's Array Datatypes.
+
+    Inheritance: DataType -> H5Object -> H5Location -> IdComponent
+*/
+class H5_DLLCPP ArrayType : public DataType {
+   public:
+        // Constructor that creates a new array data type based on the
+        // specified base type.
+        ArrayType(const DataType& base_type, int ndims, const hsize_t* dims);
+
+        // Assignment operator
+        ArrayType& operator=(const ArrayType& rhs);
+
+        // Constructors that open an array datatype, given a location.
+        ArrayType(const H5Location& loc, const char* name);
+        ArrayType(const H5Location& loc, const H5std_string& name);
+
+        // Returns the number of dimensions of this array datatype.
+        int getArrayNDims() const;
+        //int getArrayNDims(); // removed 1.8.18 and 1.10.1
+
+        // Returns the sizes of dimensions of this array datatype.
+        int getArrayDims(hsize_t* dims) const;
+        //int getArrayDims(hsize_t* dims); // removed 1.8.18 and 1.10.1
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("ArrayType"); }
+
+        // Copy constructor: makes copy of the original object.
+        ArrayType(const ArrayType& original);
+
+        // Constructor that takes an existing id
+        ArrayType(const hid_t existing_id);
+
+        // Noop destructor
+        virtual ~ArrayType();
+
+        // Default constructor
+        ArrayType();
+
+}; // end of ArrayType
+} // namespace H5
+
+#endif // __H5ArrayType_H
diff --git a/install/include/H5AtomType.h b/install/include/H5AtomType.h
new file mode 100644
index 0000000000..0be3cb572d
--- /dev/null
+++ b/install/include/H5AtomType.h
@@ -0,0 +1,83 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5AtomType_H
+#define __H5AtomType_H
+
+namespace H5 {
+
+/*! \class AtomType
+    \brief AtomType is a base class, inherited by IntType, FloatType,
+     StrType, and PredType.
+
+    AtomType provides operations on HDF5 atomic datatypes.  It also inherits
+    from DataType.
+
+    Inheritance: DataType -> H5Object -> H5Location -> IdComponent
+*/
+class H5_DLLCPP AtomType : public DataType {
+   public:
+        // Returns the byte order of an atomic datatype.
+        H5T_order_t getOrder() const;
+        H5T_order_t getOrder(H5std_string& order_string) const;
+
+        // Sets the byte ordering of an atomic datatype.
+        void setOrder(H5T_order_t order) const;
+
+        // Retrieves the bit offset of the first significant bit.
+        // 12/05/00 - changed return type to int from size_t - C API
+        int getOffset() const;
+
+        // Sets the bit offset of the first significant bit.
+        void setOffset(size_t offset) const;
+
+        // Retrieves the padding type of the least and most-significant bit padding.
+        void getPad(H5T_pad_t& lsb, H5T_pad_t& msb) const;
+
+        // Sets the least and most-significant bits padding types
+        void setPad(H5T_pad_t lsb, H5T_pad_t msb) const;
+
+        // Returns the precision of an atomic datatype.
+        size_t getPrecision() const;
+
+        // Sets the precision of an atomic datatype.
+        void setPrecision(size_t precision) const;
+
+        // Sets the total size for an atomic datatype.
+        void setSize(size_t size) const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("AtomType"); }
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+        // Copy constructor - makes copy of the original object
+        AtomType(const AtomType& original);
+
+        // Noop destructor
+        virtual ~AtomType();
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+   protected:
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+        // Default constructor
+        AtomType();
+
+        // Constructor that takes an existing id
+        AtomType(const hid_t existing_id);
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end of AtomType
+} // namespace H5
+
+#endif // __H5AtomType_H
diff --git a/install/include/H5Attribute.h b/install/include/H5Attribute.h
new file mode 100644
index 0000000000..41e74d9bb8
--- /dev/null
+++ b/install/include/H5Attribute.h
@@ -0,0 +1,105 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5Attribute_H
+#define __H5Attribute_H
+
+namespace H5 {
+
+/*! \class Attribute
+    \brief Class Attribute operates on HDF5 attributes.
+
+    An attribute has many characteristics similar to a dataset, thus both
+    Attribute and DataSet are derivatives of AbstractDs.  Attribute also
+    inherits from H5Location because an attribute can be used to specify
+    a location.
+
+    Inheritance: multiple H5Location/AbstractDs -> IdComponent
+*/
+class H5_DLLCPP Attribute : public AbstractDs, public H5Location {
+   public:
+
+        // Copy constructor: makes a copy of an existing Attribute object.
+        Attribute(const Attribute& original);
+
+        // Default constructor
+        Attribute();
+
+        // Creates a copy of an existing attribute using the attribute id
+        Attribute(const hid_t attr_id);
+
+        // Closes this attribute.
+        virtual void close();
+
+        // Gets the name of this attribute.
+        ssize_t getName(char* attr_name, size_t buf_size = 0) const;
+        H5std_string getName(size_t len) const;
+        H5std_string getName() const;
+        ssize_t getName(H5std_string& attr_name, size_t len = 0) const;
+        // The overloaded function below is replaced by the one above and it
+        // is kept for backward compatibility purpose.
+        ssize_t getName(size_t buf_size, H5std_string& attr_name) const;
+
+        // Gets a copy of the dataspace for this attribute.
+        virtual DataSpace getSpace() const;
+
+        // Returns the amount of storage size required for this attribute.
+        virtual hsize_t getStorageSize() const;
+
+        // Returns the in memory size of this attribute's data.
+        virtual size_t getInMemDataSize() const;
+
+        // Reads data from this attribute.
+        void read(const DataType& mem_type, void *buf) const;
+        void read(const DataType& mem_type, H5std_string& strg) const;
+
+        // Writes data to this attribute.
+        void write(const DataType& mem_type, const void *buf) const;
+        void write(const DataType& mem_type, const H5std_string& strg) const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("Attribute"); }
+
+        // Gets the attribute id.
+        virtual hid_t getId() const;
+
+        // Destructor: properly terminates access to this attribute.
+        virtual ~Attribute();
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+   protected:
+        // Sets the attribute id.
+        virtual void p_setId(const hid_t new_id);
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+   private:
+        hid_t id;        // HDF5 attribute id
+
+        // This function contains the common code that is used by
+        // getTypeClass and various API functions getXxxType
+        // defined in AbstractDs for generic datatype and specific
+        // sub-types
+        virtual hid_t p_get_type() const;
+
+        // Reads variable or fixed len strings from this attribute.
+        void p_read_variable_len(const DataType& mem_type, H5std_string& strg) const;
+        void p_read_fixed_len(const DataType& mem_type, H5std_string& strg) const;
+
+        // Friend function to set Attribute id.  For library use only.
+        friend void f_Attribute_setId(Attribute* attr, hid_t new_id);
+
+}; // end of Attribute
+} // namespace H5
+
+#endif // __H5Attribute_H
diff --git a/install/include/H5B2pkg.h b/install/include/H5B2pkg.h
new file mode 100644
index 0000000000..e24d2ebd05
--- /dev/null
+++ b/install/include/H5B2pkg.h
@@ -0,0 +1,487 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:	Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *		Monday, January 31, 2005
+ *
+ * Purpose:	This file contains declarations which are visible only within
+ *		the H5B2 package.  Source files outside the H5B2 package should
+ *		include H5B2private.h instead.
+ */
+#if !(defined H5B2_FRIEND || defined H5B2_MODULE)
+#error "Do not include this file outside the H5B2 package!"
+#endif
+
+#ifndef _H5B2pkg_H
+#define _H5B2pkg_H
+
+/* Get package's private header */
+#include "H5B2private.h"
+
+/* Other private headers needed by this file */
+#include "H5ACprivate.h"	/* Metadata cache			*/
+#include "H5FLprivate.h"	/* Free Lists                           */
+
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* Size of storage for number of records per node (on disk) */
+#define H5B2_SIZEOF_RECORDS_PER_NODE    (unsigned)2
+
+/* Size of a "tree pointer" (on disk) */
+/* (essentially, the largest internal pointer allowed) */
+#define H5B2_TREE_POINTER_SIZE(sizeof_addr, sizeof_size)       (              \
+    (sizeof_addr) +                                                           \
+    H5B2_SIZEOF_RECORDS_PER_NODE +                                            \
+    (sizeof_size)                                                             \
+    )
+
+/* Size of a internal node pointer (on disk) */
+#define H5B2_INT_POINTER_SIZE(h, d) (                                         \
+    (unsigned)(h)->sizeof_addr  /* Address of child node */                   \
+    + (h)->max_nrec_size        /* # of records in child node */              \
+    + (h)->node_info[(d) - 1].cum_max_nrec_size /* Total # of records in child & below */ \
+    )
+
+/* Size of checksum information (on disk) */
+#define H5B2_SIZEOF_CHKSUM      4
+
+/* Format overhead for all v2 B-tree metadata in the file */
+#define H5B2_METADATA_PREFIX_SIZE (                                           \
+    (unsigned)H5_SIZEOF_MAGIC   /* Signature */                               \
+    + (unsigned)1 /* Version */                                               \
+    + (unsigned)1 /* Tree type */                                             \
+    + (unsigned)H5B2_SIZEOF_CHKSUM /* Metadata checksum */                    \
+    )
+
+/* Size of the v2 B-tree header on disk */
+#define H5B2_HEADER_SIZE(sizeof_addr, sizeof_size)   (                        \
+    /* General metadata fields */                                             \
+    H5B2_METADATA_PREFIX_SIZE                                                 \
+                                                                              \
+    /* Header specific fields */                                              \
+    + (unsigned)4 /* Node size, in bytes */                                   \
+    + (unsigned)2 /* Record size, in bytes */                                 \
+    + (unsigned)2 /* Depth of tree */                                         \
+    + (unsigned)1 /* Split % of full (as integer, ie. "98" means 98%) */      \
+    + (unsigned)1 /* Merge % of full (as integer, ie. "98" means 98%) */      \
+    + H5B2_TREE_POINTER_SIZE(sizeof_addr, sizeof_size)  /* Node pointer to root node in tree */ \
+    )
+
+/* Size of the v2 B-tree header on disk (via file pointer) */
+#define H5B2_HEADER_SIZE_FILE(f)   (                                          \
+    H5B2_HEADER_SIZE(H5F_SIZEOF_ADDR(f), H5F_SIZEOF_SIZE(f))                  \
+    )
+
+/* Size of the v2 B-tree header on disk (via v2 B-tree header) */
+#define H5B2_HEADER_SIZE_HDR(h)   (                                           \
+    H5B2_HEADER_SIZE((h)->sizeof_addr, (h)->sizeof_size)                      \
+    )
+
+/* Size of the v2 B-tree internal node prefix */
+#define H5B2_INT_PREFIX_SIZE (                                                \
+    /* General metadata fields */                                             \
+    H5B2_METADATA_PREFIX_SIZE                                                 \
+                                                                              \
+    /* Header specific fields */                                              \
+    /* <none> */                                                              \
+    )
+
+/* Size of the v2 B-tree leaf node prefix */
+#define H5B2_LEAF_PREFIX_SIZE (                                               \
+    /* General metadata fields */                                             \
+    H5B2_METADATA_PREFIX_SIZE                                                 \
+                                                                              \
+    /* Header specific fields */                                              \
+    /* <none> */                                                              \
+    )
+
+/* Macro to retrieve pointer to i'th native record for native record buffer */
+#define H5B2_NAT_NREC(b, hdr, idx)  ((b) + (hdr)->nat_off[(idx)])
+
+/* Macro to retrieve pointer to i'th native record for internal node */
+#define H5B2_INT_NREC(i, hdr, idx)  H5B2_NAT_NREC((i)->int_native, (hdr), (idx))
+
+/* Macro to retrieve pointer to i'th native record for leaf node */
+#define H5B2_LEAF_NREC(l, hdr, idx)  H5B2_NAT_NREC((l)->leaf_native, (hdr), (idx))
+
+/* Number of records that fit into internal node */
+/* (accounts for extra node pointer by counting it in with the prefix bytes) */
+#define H5B2_NUM_INT_REC(h, d) \
+    (((h)->node_size - (H5B2_INT_PREFIX_SIZE + H5B2_INT_POINTER_SIZE(h, d))) / ((h)->rrec_size + H5B2_INT_POINTER_SIZE(h, d)))
+
+/* Uncomment this macro to enable extra sanity checking */
+/* #define H5B2_DEBUG */
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/* A "node pointer" to another B-tree node */
+typedef struct {
+    haddr_t     addr;           /* Address of other node */
+    uint16_t    node_nrec;      /* Number of records used in node pointed to */
+    hsize_t     all_nrec;       /* Number of records in node pointed to and all it's children */
+} H5B2_node_ptr_t;
+
+/* Information about a node at a given depth */
+typedef struct {
+    unsigned    max_nrec;       /* Max. number of records in node */
+    unsigned    split_nrec;     /* Number of records to split node at */
+    unsigned    merge_nrec;     /* Number of records to merge node at */
+    hsize_t     cum_max_nrec;   /* Cumulative max. # of records below this node's depth */
+    uint8_t     cum_max_nrec_size; /* Size to store cumulative max. # of records for this node (in bytes) */
+    H5FL_fac_head_t *nat_rec_fac;   /* Factory for native record blocks */
+    H5FL_fac_head_t *node_ptr_fac;  /* Factory for node pointer blocks */
+} H5B2_node_info_t;
+
+/* The B-tree header information */
+typedef struct H5B2_hdr_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* Internal B-tree information (stored) */
+    H5B2_node_ptr_t root;       /* Node pointer to root node in B-tree        */
+
+    /* Information set by user (stored) */
+    uint8_t     split_percent;  /* Percent full at which to split the node, when inserting */
+    uint8_t     merge_percent;  /* Percent full at which to merge the node, when deleting */
+    uint32_t    node_size;      /* Size of B-tree nodes, in bytes             */
+    uint32_t    rrec_size;      /* Size of "raw" (on disk) record, in bytes   */
+
+    /* Dynamic information (stored) */
+    uint16_t	depth;		/* B-tree's overall depth                     */
+
+    /* Derived information from user's information (not stored) */
+    uint8_t     max_nrec_size;  /* Size to store max. # of records in any node (in bytes) */
+
+    /* Shared internal data structures (not stored) */
+    H5F_t       *f;             /* Pointer to the file that the B-tree is in */
+    haddr_t     addr;           /* Address of B-tree header in the file */
+    size_t      hdr_size;       /* Size of the B-tree header on disk */
+    size_t      rc;             /* Reference count of nodes using this header */
+    size_t      file_rc;        /* Reference count of files using this header */
+    hbool_t     pending_delete; /* B-tree is pending deletion */
+    uint8_t     sizeof_size;    /* Size of file sizes */
+    uint8_t     sizeof_addr;    /* Size of file addresses */
+    H5B2_remove_t remove_op;    /* Callback operator for deleting B-tree */
+    void        *remove_op_data;/* B-tree deletion callback's context */
+    uint8_t	*page;	        /* Common disk page for I/O */
+    size_t      *nat_off;       /* Array of offsets of native records */
+    H5B2_node_info_t *node_info; /* Table of node info structs for current depth of B-tree */
+    void        *min_native_rec; /* Pointer to minimum native record                  */
+    void        *max_native_rec; /* Pointer to maximum native record                  */
+
+    /* SWMR / Flush dependency information (not stored) */
+    hbool_t     swmr_write;     /* Whether we are doing SWMR writes */
+    H5AC_proxy_entry_t *top_proxy;  /* 'Top' proxy cache entry for all B-tree entries */
+    void        *parent;        /* Pointer to 'top' proxy flush dependency
+                                 * parent, if it exists, otherwise NULL.
+                                 * If the v2 B-tree is being used to index a
+                                 * chunked dataset and the dataset metadata is
+                                 * modified by a SWMR writer, this field will
+                                 * be set equal to the object header proxy
+                                 * that is the flush dependency parent
+                                 * of the v2 B-tree header.
+ 				 *
+ 				 * The field is used to avoid duplicate setups
+                                 * of the flush dependency relationship, and to
+                                 * allow the v2 B-tree header to destroy the
+                                 * flush dependency on receipt of an eviction
+                                 * notification from the metadata cache.
+				 */
+    uint64_t    shadow_epoch;   /* Epoch of header, for making shadow copies */
+
+    /* Client information (not stored) */
+    const H5B2_class_t *cls;	/* Class of B-tree client */
+    void        *cb_ctx;        /* Client callback context */
+} H5B2_hdr_t;
+
+/* B-tree leaf node information */
+typedef struct H5B2_leaf_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* Internal B-tree information */
+    H5B2_hdr_t	*hdr;		/* Pointer to the [pinned] v2 B-tree header   */
+    uint8_t     *leaf_native;   /* Pointer to native records                  */
+    uint16_t    nrec;           /* Number of records in node                  */
+
+    /* SWMR / Flush dependency information (not stored) */
+    H5AC_proxy_entry_t *top_proxy;  /* 'Top' proxy cache entry for all B-tree entries */
+    void        *parent;        /* Flush dependency parent for leaf           */
+    uint64_t    shadow_epoch;   /* Epoch of node, for making shadow copies */
+} H5B2_leaf_t;
+
+/* B-tree internal node information */
+typedef struct H5B2_internal_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* Internal B-tree information */
+    H5B2_hdr_t	*hdr;		/* Pointer to the [pinned] v2 B-tree header   */
+    uint8_t     *int_native;    /* Pointer to native records                  */
+    H5B2_node_ptr_t *node_ptrs; /* Pointer to node pointers                   */
+    uint16_t    nrec;           /* Number of records in node                  */
+    uint16_t    depth;          /* Depth of this node in the B-tree           */
+
+    /* SWMR / Flush dependency information (not stored) */
+    H5AC_proxy_entry_t *top_proxy;  /* 'Top' proxy cache entry for all B-tree entries */
+    void        *parent;        /* Flush dependency parent for internal node  */
+    uint64_t    shadow_epoch;   /* Epoch of node, for making shadow copies */
+} H5B2_internal_t;
+
+/* v2 B-tree */
+struct H5B2_t {
+    H5B2_hdr_t  *hdr;           /* Pointer to internal v2 B-tree header info */
+    H5F_t      *f;              /* Pointer to file for v2 B-tree */
+};
+
+/* Node position, for min/max determination */
+typedef enum H5B2_nodepos_t {
+    H5B2_POS_ROOT,              /* Node is root (i.e. both right & left-most in tree) */
+    H5B2_POS_RIGHT,             /* Node is right-most in tree, at a given depth */
+    H5B2_POS_LEFT,              /* Node is left-most in tree, at a given depth */
+    H5B2_POS_MIDDLE             /* Node is neither right or left-most in tree */
+} H5B2_nodepos_t;
+
+/* Update status */
+typedef enum H5B2_update_status_t {
+    H5B2_UPDATE_UNKNOWN,            /* Unknown update status (initial state) */
+    H5B2_UPDATE_MODIFY_DONE,        /* Update successfully modified existing record */
+    H5B2_UPDATE_SHADOW_DONE,        /* Update modified existing record and modified node was shadowed */
+    H5B2_UPDATE_INSERT_DONE,        /* Update inserted record successfully */
+    H5B2_UPDATE_INSERT_CHILD_FULL   /* Update will insert record, but child is full */
+} H5B2_update_status_t;
+
+/* Callback info for loading a v2 B-tree header into the cache */
+typedef struct H5B2_hdr_cache_ud_t {
+    H5F_t *f;                   /* File that v2 b-tree header is within */
+    haddr_t addr;               /* Address of B-tree header in the file */
+    void *ctx_udata;            /* User-data for protecting */
+} H5B2_hdr_cache_ud_t;
+
+/* Callback info for loading a v2 B-tree internal node into the cache */
+typedef struct H5B2_internal_cache_ud_t {
+    H5F_t *f;                   /* File that v2 b-tree header is within */
+    H5B2_hdr_t *hdr;            /* v2 B-tree header */
+    void *parent;               /* Flush dependency parent */
+    uint16_t nrec;              /* Number of records in node to load */
+    uint16_t depth;             /* Depth of node to load */
+} H5B2_internal_cache_ud_t;
+
+/* Callback info for loading a v2 B-tree leaf node into the cache */
+typedef struct H5B2_leaf_cache_ud_t {
+    H5F_t *f;                   /* File that v2 b-tree header is within */
+    H5B2_hdr_t *hdr;            /* v2 B-tree header */
+    void *parent;               /* Flush dependency parent */
+    uint16_t nrec;              /* Number of records in node to load */
+} H5B2_leaf_cache_ud_t;
+
+#ifdef H5B2_TESTING
+/* Node information for testing */
+typedef struct H5B2_node_info_test_t {
+    uint16_t depth;             /* Depth of node */
+    uint16_t nrec;              /* Number of records in node */
+} H5B2_node_info_test_t;
+#endif /* H5B2_TESTING */
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+/* Declare a free list to manage the H5B2_internal_t struct */
+H5FL_EXTERN(H5B2_internal_t);
+
+/* Declare a free list to manage the H5B2_leaf_t struct */
+H5FL_EXTERN(H5B2_leaf_t);
+
+/* Internal v2 B-tree testing class */
+#ifdef H5B2_TESTING
+H5_DLLVAR const H5B2_class_t H5B2_TEST[1];
+H5_DLLVAR const H5B2_class_t H5B2_TEST2[1];
+
+/* B-tree record for testing H5B2_TEST2 class */
+typedef struct H5B2_test_rec_t {
+    hsize_t key;        /* Key for record */
+    hsize_t val;        /* Value for record */
+} H5B2_test_rec_t;
+#endif /* H5B2_TESTING */
+
+/* Array of v2 B-tree client ID -> client class mappings */
+extern const H5B2_class_t *const H5B2_client_class_g[H5B2_NUM_BTREE_ID];
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+/* Generic routines */
+H5_DLL herr_t H5B2__create_flush_depend(H5AC_info_t *parent_entry,
+    H5AC_info_t *child_entry);
+H5_DLL herr_t H5B2__update_flush_depend(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    unsigned depth, const H5B2_node_ptr_t *node_ptr, void *old_parent,
+    void *new_parent);
+H5_DLL herr_t H5B2__destroy_flush_depend(H5AC_info_t *parent_entry,
+    H5AC_info_t *child_entry);
+
+/* Internal node management routines */
+H5_DLL herr_t H5B2__split1(H5B2_hdr_t *hdr, hid_t dxpl_id, uint16_t depth,
+    H5B2_node_ptr_t *curr_node_ptr, unsigned *parent_cache_info_flags_ptr,
+    H5B2_internal_t *internal, unsigned *internal_flags_ptr, unsigned idx);
+H5_DLL herr_t H5B2__redistribute2(H5B2_hdr_t *hdr, hid_t dxpl_id, uint16_t depth,
+    H5B2_internal_t *internal, unsigned idx);
+H5_DLL herr_t H5B2__redistribute3(H5B2_hdr_t *hdr, hid_t dxpl_id, uint16_t depth,
+    H5B2_internal_t *internal, unsigned *internal_flags_ptr, unsigned idx);
+H5_DLL herr_t H5B2__merge2(H5B2_hdr_t *hdr, hid_t dxpl_id, uint16_t depth,
+    H5B2_node_ptr_t *curr_node_ptr, unsigned *parent_cache_info_flags_ptr,
+    H5B2_internal_t *internal, unsigned *internal_flags_ptr, unsigned idx);
+H5_DLL herr_t H5B2__merge3(H5B2_hdr_t *hdr, hid_t dxpl_id, uint16_t depth,
+    H5B2_node_ptr_t *curr_node_ptr, unsigned *parent_cache_info_flags_ptr,
+    H5B2_internal_t *internal, unsigned *internal_flags_ptr, unsigned idx);
+
+/* Routines for managing B-tree header info */
+H5_DLL H5B2_hdr_t *H5B2__hdr_alloc(H5F_t *f);
+H5_DLL haddr_t H5B2__hdr_create(H5F_t *f, hid_t dxpl_id,
+    const H5B2_create_t *cparam, void *ctx_udata);
+H5_DLL herr_t H5B2__hdr_init(H5B2_hdr_t *hdr, const H5B2_create_t *cparam,
+    void *ctx_udata, uint16_t depth);
+H5_DLL herr_t H5B2__hdr_incr(H5B2_hdr_t *hdr);
+H5_DLL herr_t H5B2__hdr_decr(H5B2_hdr_t *hdr);
+H5_DLL herr_t H5B2__hdr_fuse_incr(H5B2_hdr_t *hdr);
+H5_DLL size_t H5B2__hdr_fuse_decr(H5B2_hdr_t *hdr);
+H5_DLL herr_t H5B2__hdr_dirty(H5B2_hdr_t *hdr);
+H5_DLL H5B2_hdr_t *H5B2__hdr_protect(H5F_t *f, hid_t dxpl_id, haddr_t hdr_addr,
+    void *ctx_udata, unsigned flags);
+H5_DLL herr_t H5B2__hdr_unprotect(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    unsigned cache_flags);
+H5_DLL herr_t H5B2__hdr_delete(H5B2_hdr_t *hdr, hid_t dxpl_id);
+
+/* Routines for operating on leaf nodes */
+H5_DLL H5B2_leaf_t * H5B2__protect_leaf(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    void *parent, H5B2_node_ptr_t *node_ptr, hbool_t shadow, unsigned flags);
+H5_DLL herr_t H5B2__swap_leaf(H5B2_hdr_t *hdr, hid_t dxpl_id, uint16_t depth,
+    H5B2_internal_t *internal, unsigned *internal_flags_ptr, unsigned idx,
+    void *swap_loc);
+
+/* Routines for operating on internal nodes */
+H5_DLL H5B2_internal_t *H5B2__protect_internal(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    void *parent, H5B2_node_ptr_t *node_ptr, uint16_t depth, hbool_t shadow,
+    unsigned flags);
+
+/* Routines for allocating nodes */
+H5_DLL herr_t H5B2__split_root(H5B2_hdr_t *hdr, hid_t dxpl_id);
+H5_DLL herr_t H5B2__create_leaf(H5B2_hdr_t *hdr, hid_t dxpl_id, void *parent,
+    H5B2_node_ptr_t *node_ptr);
+H5_DLL herr_t H5B2__create_internal(H5B2_hdr_t *hdr, hid_t dxpl_id, void *parent,
+    H5B2_node_ptr_t *node_ptr, uint16_t depth);
+
+/* Routines for releasing structures */
+H5_DLL herr_t H5B2__hdr_free(H5B2_hdr_t *hdr);
+H5_DLL herr_t H5B2__leaf_free(H5B2_leaf_t *l);
+H5_DLL herr_t H5B2__internal_free(H5B2_internal_t *i);
+
+/* Routines for inserting records */
+H5_DLL herr_t H5B2__insert(H5B2_hdr_t *hdr, hid_t dxpl_id, void *udata);
+H5_DLL herr_t H5B2__insert_internal(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    uint16_t depth, unsigned *parent_cache_info_flags_ptr,
+    H5B2_node_ptr_t *curr_node_ptr, H5B2_nodepos_t curr_pos, void *parent, void *udata);
+H5_DLL herr_t H5B2__insert_leaf(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    H5B2_node_ptr_t *curr_node_ptr, H5B2_nodepos_t curr_pos, void *parent, void *udata);
+
+/* Routines for update records */
+H5_DLL herr_t H5B2__update_internal(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    uint16_t depth, unsigned *parent_cache_info_flags_ptr,
+    H5B2_node_ptr_t *curr_node_ptr, H5B2_update_status_t *status,
+    H5B2_nodepos_t curr_pos, void *parent, void *udata, H5B2_modify_t op,
+    void *op_data);
+H5_DLL herr_t H5B2__update_leaf(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    H5B2_node_ptr_t *curr_node_ptr, H5B2_update_status_t *status,
+    H5B2_nodepos_t curr_pos, void *parent, void *udata, H5B2_modify_t op,
+    void *op_data);
+
+/* Routines for iterating over nodes/records */
+H5_DLL herr_t H5B2__iterate_node(H5B2_hdr_t *hdr, hid_t dxpl_id, uint16_t depth,
+    const H5B2_node_ptr_t *curr_node, void *parent, H5B2_operator_t op, void *op_data);
+H5_DLL herr_t H5B2__node_size(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    uint16_t depth, const H5B2_node_ptr_t *curr_node, void *parent,
+    hsize_t *op_data);
+
+/* Routines for locating records */
+H5_DLL herr_t H5B2__locate_record(const H5B2_class_t *type, unsigned nrec,
+    size_t *rec_off, const uint8_t *native, const void *udata, unsigned *idx, int *result);
+H5_DLL herr_t H5B2__neighbor_internal(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    uint16_t depth, H5B2_node_ptr_t *curr_node_ptr, void *neighbor_loc,
+    H5B2_compare_t comp, void *parent, void *udata, H5B2_found_t op,
+    void *op_data);
+H5_DLL herr_t H5B2__neighbor_leaf(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    H5B2_node_ptr_t *curr_node_ptr, void *neighbor_loc, H5B2_compare_t comp,
+    void *parent, void *udata, H5B2_found_t op, void *op_data);
+
+/* Routines for removing records */
+H5_DLL herr_t H5B2__remove_internal(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    hbool_t *depth_decreased, void *swap_loc, void *swap_parent, uint16_t depth,
+    H5AC_info_t *parent_cache_info, unsigned *parent_cache_info_flags_ptr,
+    H5B2_nodepos_t curr_pos, H5B2_node_ptr_t *curr_node_ptr, void *udata,
+    H5B2_remove_t op, void *op_data);
+H5_DLL herr_t H5B2__remove_leaf(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    H5B2_node_ptr_t *curr_node_ptr, H5B2_nodepos_t curr_pos, void *parent,
+    void *udata, H5B2_remove_t op, void *op_data);
+H5_DLL herr_t H5B2__remove_internal_by_idx(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    hbool_t *depth_decreased, void *swap_loc, void *swap_parent, uint16_t depth,
+    H5AC_info_t *parent_cache_info, unsigned *parent_cache_info_flags_ptr,
+    H5B2_node_ptr_t *curr_node_ptr, H5B2_nodepos_t curr_pos, hsize_t n,
+    H5B2_remove_t op, void *op_data);
+H5_DLL herr_t H5B2__remove_leaf_by_idx(H5B2_hdr_t *hdr, hid_t dxpl_id,
+    H5B2_node_ptr_t *curr_node_ptr, H5B2_nodepos_t curr_pos, void *parent,
+    unsigned idx, H5B2_remove_t op, void *op_data);
+
+/* Routines for deleting nodes */
+H5_DLL herr_t H5B2__delete_node(H5B2_hdr_t *hdr, hid_t dxpl_id, uint16_t depth,
+    const H5B2_node_ptr_t *curr_node, void *parent, H5B2_remove_t op,
+    void *op_data);
+
+/* Debugging routines for dumping file structures */
+H5_DLL herr_t H5B2__hdr_debug(H5F_t *f, hid_t dxpl_id, haddr_t addr,
+    FILE *stream, int indent, int fwidth, const H5B2_class_t *type, haddr_t obj_addr);
+H5_DLL herr_t H5B2__int_debug(H5F_t *f, hid_t dxpl_id, haddr_t addr,
+    FILE *stream, int indent, int fwidth, const H5B2_class_t *type,
+    haddr_t hdr_addr, unsigned nrec, unsigned depth, haddr_t obj_addr);
+H5_DLL herr_t H5B2__leaf_debug(H5F_t *f, hid_t dxpl_id, haddr_t addr,
+    FILE *stream, int indent, int fwidth, const H5B2_class_t *type,
+    haddr_t hdr_addr, unsigned nrec, haddr_t obj_addr);
+
+/* Sanity checking routines */
+#ifdef H5B2_DEBUG
+/* Don't label these with H5_ATTR_PURE or you'll get even more warnings... */
+H5_DLL herr_t H5B2__assert_internal(hsize_t parent_all_nrec, const H5B2_hdr_t *hdr, const H5B2_internal_t *internal);
+H5_DLL herr_t H5B2__assert_internal2(hsize_t parent_all_nrec, const H5B2_hdr_t *hdr, const H5B2_internal_t *internal, const H5B2_internal_t *internal2);
+H5_DLL herr_t H5B2__assert_leaf(const H5B2_hdr_t *hdr, const H5B2_leaf_t *leaf);
+H5_DLL herr_t H5B2__assert_leaf2(const H5B2_hdr_t *hdr, const H5B2_leaf_t *leaf, const H5B2_leaf_t *leaf2);
+#endif /* H5B2_DEBUG */
+
+/* Testing routines */
+#ifdef H5B2_TESTING
+H5_DLL herr_t H5B2_get_root_addr_test(H5B2_t *bt2, haddr_t *root_addr);
+H5_DLL int H5B2_get_node_depth_test(H5B2_t *bt2, hid_t dxpl_id, void *udata);
+H5_DLL herr_t H5B2_get_node_info_test(H5B2_t *bt2, hid_t dxpl_id,
+    void *udata, H5B2_node_info_test_t *ninfo);
+#endif /* H5B2_TESTING */
+
+#endif /* _H5B2pkg_H */
+
diff --git a/install/include/H5B2public.h b/install/include/H5B2public.h
new file mode 100644
index 0000000000..6e0b964b72
--- /dev/null
+++ b/install/include/H5B2public.h
@@ -0,0 +1,52 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5B2public.h
+ *                      Jan 31 2005
+ *                      Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *
+ * Purpose:             Public declarations for the v2 B-tree package.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#ifndef _H5B2public_H
+#define _H5B2public_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/**********************************/
+/* Public API Function Prototypes */
+/**********************************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _H5B2public_H */
+
diff --git a/install/include/H5Bpkg.h b/install/include/H5Bpkg.h
new file mode 100644
index 0000000000..14dce4fb3e
--- /dev/null
+++ b/install/include/H5Bpkg.h
@@ -0,0 +1,94 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:	Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *		Thursday, May 15, 2003
+ *
+ * Purpose:	This file contains declarations which are visible only within
+ *		the H5B package.  Source files outside the H5B package should
+ *		include H5Bprivate.h instead.
+ */
+#if !(defined H5B_FRIEND || defined H5B_MODULE)
+#error "Do not include this file outside the H5B package!"
+#endif
+
+#ifndef _H5Bpkg_H
+#define _H5Bpkg_H
+
+/* Get package's private header */
+#include "H5Bprivate.h"
+
+/* Other private headers needed by this file */
+#include "H5ACprivate.h"	/* Metadata cache			*/
+#include "H5FLprivate.h"        /* Free Lists                           */
+
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* Get the native key at a given index */
+#define H5B_NKEY(b, shared, idx)  ((b)->native + (shared)->nkey[(idx)])
+#define LEVEL_BITS	8 	/* # of bits for node level: 1 byte */
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/* The B-tree node as stored in memory...  */
+typedef struct H5B_t {
+    H5AC_info_t        cache_info;     /* Information for H5AC cache functions */
+                                        /* _must_ be first field in structure */
+    H5UC_t		*rc_shared;	/*ref-counted shared info	     */
+    unsigned		level;		/*node level			     */
+    unsigned		nchildren;	/*number of child pointers	     */
+    haddr_t		left;		/*address of left sibling	     */
+    haddr_t		right;		/*address of right sibling	     */
+    uint8_t		*native;	/*array of keys in native format     */
+    haddr_t		*child;		/*2k child pointers		     */
+} H5B_t;
+
+/* Callback info for loading a B-tree node into the cache */
+typedef struct H5B_cache_ud_t {
+    H5F_t *f;                           /* File that B-tree node is within   */
+    const struct H5B_class_t *type;     /* Type of tree			     */
+    H5UC_t *rc_shared;                  /* Ref-counted shared info	     */
+} H5B_cache_ud_t;
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+/* Declare a free list to manage the haddr_t sequence information */
+H5FL_SEQ_EXTERN(haddr_t);
+
+/* Declare a PQ free list to manage the native block information */
+H5FL_BLK_EXTERN(native_block);
+
+/* Declare a free list to manage the H5B_t struct */
+H5FL_EXTERN(H5B_t);
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+H5_DLL herr_t H5B__node_dest(H5B_t *bt);
+#ifdef H5B_DEBUG
+herr_t H5B__assert(H5F_t *f, hid_t dxpl_id, haddr_t addr, const H5B_class_t *type,
+			 void *udata);
+#endif
+
+#endif /*_H5Bpkg_H*/
+
diff --git a/install/include/H5Bpublic.h b/install/include/H5Bpublic.h
new file mode 100644
index 0000000000..1764f61260
--- /dev/null
+++ b/install/include/H5Bpublic.h
@@ -0,0 +1,39 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5Bproto.h
+ *                      Jul 10 1997
+ *                      Robb Matzke <matzke@llnl.gov>
+ *
+ * Purpose:             Public declarations for the H5B package.
+ *
+ * Modifications:
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef _H5Bpublic_H
+#define _H5Bpublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/install/include/H5Classes.h b/install/include/H5Classes.h
new file mode 100644
index 0000000000..f0f6359937
--- /dev/null
+++ b/install/include/H5Classes.h
@@ -0,0 +1,46 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5Classes_H
+#define __H5Classes_H
+
+namespace H5 {
+        class Exception;
+        class IdComponent;
+        class H5Location;
+        class H5Object;
+        class PropList;
+        class FileCreatPropList;
+        class FileAccPropList;
+        class LinkAccPropList;
+        class DSetCreatPropList;
+        class DSetMemXferPropList;
+        class DTypePropList;
+        class DataType;
+        class DataSpace;
+        class AtomType;
+        class PredType;
+        class EnumType;
+        class IntType;
+        class FloatType;
+        class StrType;
+        class CompType;
+        class AbstractDs;
+        class DataSet;
+        class Group;
+        class H5File;
+        class Attribute;
+        class H5Library;
+}
+#endif // __H5Classes_H
diff --git a/install/include/H5CommonFG.h b/install/include/H5CommonFG.h
new file mode 100644
index 0000000000..3cbad765ad
--- /dev/null
+++ b/install/include/H5CommonFG.h
@@ -0,0 +1,89 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __CommonFG_H
+#define __CommonFG_H
+
+namespace H5 {
+
+// Class forwarding
+class Group;
+class H5File;
+class ArrayType;
+class VarLenType;
+
+/*! \class CommonFG
+    \brief \a CommonFG is an abstract base class of H5File and H5Group.
+
+    It provides common operations of H5File and H5Group.
+*/
+class H5_DLLCPP CommonFG {
+   public:
+        // Opens a generic named datatype in this location.
+        DataType openDataType(const char* name) const;
+        DataType openDataType(const H5std_string& name) const;
+
+        // Opens a named array datatype in this location.
+        ArrayType openArrayType(const char* name) const;
+        ArrayType openArrayType(const H5std_string& name) const;
+
+        // Opens a named compound datatype in this location.
+        CompType openCompType(const char* name) const;
+        CompType openCompType(const H5std_string& name) const;
+
+        // Opens a named enumeration datatype in this location.
+        EnumType openEnumType(const char* name) const;
+        EnumType openEnumType(const H5std_string& name) const;
+
+        // Opens a named integer datatype in this location.
+        IntType openIntType(const char* name) const;
+        IntType openIntType(const H5std_string& name) const;
+
+        // Opens a named floating-point datatype in this location.
+        FloatType openFloatType(const char* name) const;
+        FloatType openFloatType(const H5std_string& name) const;
+
+        // Opens a named string datatype in this location.
+        StrType openStrType(const char* name) const;
+        StrType openStrType(const H5std_string& name) const;
+
+        // Opens a named variable length datatype in this location.
+        VarLenType openVarLenType(const char* name) const;
+        VarLenType openVarLenType(const H5std_string& name) const;
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+        /// For subclasses, H5File and Group, to return the correct
+        /// object id, i.e. file or group id.
+        virtual hid_t getLocId() const = 0;
+
+
+        /// For subclasses, H5File and Group, to throw appropriate exception.
+        virtual void throwException(const H5std_string& func_name, const H5std_string& msg) const = 0;
+
+        // Default constructor.
+        CommonFG();
+
+        // Noop destructor.
+        virtual ~CommonFG();
+
+    protected:
+        virtual void p_setId(const hid_t new_id) = 0;
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end of CommonFG
+} // namespace H5
+
+#endif // __CommonFG_H
+
diff --git a/install/include/H5CompType.h b/install/include/H5CompType.h
new file mode 100644
index 0000000000..018d875507
--- /dev/null
+++ b/install/include/H5CompType.h
@@ -0,0 +1,120 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5CompType_H
+#define __H5CompType_H
+
+namespace H5 {
+
+/*! \class CompType
+    \brief CompType is a derivative of a DataType and operates on HDF5
+    compound datatypes.
+
+    Inheritance: DataType -> H5Object -> H5Location -> IdComponent
+*/
+class H5_DLLCPP CompType : public DataType {
+   public:
+        // Default constructor
+        CompType();
+
+        // Creates a compound datatype using an existing id
+        CompType(const hid_t existing_id);
+
+        // Creates a new compound datatype, given the type's size
+        CompType(size_t size); // H5Tcreate
+
+        // Gets the compound datatype of the specified dataset
+        CompType(const DataSet& dataset);  // H5Dget_type
+
+        // Copy constructor - makes a copy of original object
+        CompType(const CompType& original);
+
+        // Constructors that open a compound datatype, given a location.
+        CompType(const H5Location& loc, const char* name);
+        CompType(const H5Location& loc, const H5std_string& name);
+
+        // Returns the type class of the specified member of this compound
+        // datatype.  It provides to the user a way of knowing what type
+        // to create another datatype of the same class
+        H5T_class_t getMemberClass(unsigned member_num) const;
+
+        // Returns the index of a member in this compound data type.
+        int getMemberIndex(const char* name) const;
+        int getMemberIndex(const H5std_string& name) const;
+
+        // Returns the offset of a member of this compound datatype.
+        size_t getMemberOffset(unsigned memb_no) const;
+
+        // Returns the name of a member of this compound datatype.
+        H5std_string getMemberName(unsigned member_num) const;
+
+        // Returns the generic datatype of the specified member in
+        // this compound datatype.
+        DataType getMemberDataType(unsigned member_num) const;
+
+        // Returns the array datatype of the specified member in
+        // this compound datatype.
+        ArrayType getMemberArrayType(unsigned member_num) const;
+
+        // Returns the compound datatype of the specified member in
+        // this compound datatype.
+        CompType getMemberCompType(unsigned member_num) const;
+
+        // Returns the enumeration datatype of the specified member in
+        // this compound datatype.
+        EnumType getMemberEnumType(unsigned member_num) const;
+
+        // Returns the integer datatype of the specified member in
+        // this compound datatype.
+        IntType getMemberIntType(unsigned member_num) const;
+
+        // Returns the floating-point datatype of the specified member in
+        // this compound datatype.
+        FloatType getMemberFloatType(unsigned member_num) const;
+
+        // Returns the string datatype of the specified member in
+        // this compound datatype.
+        StrType getMemberStrType(unsigned member_num) const;
+
+        // Returns the variable length datatype of the specified member in
+        // this compound datatype.
+        VarLenType getMemberVarLenType(unsigned member_num) const;
+
+        // Returns the number of members in this compound datatype.
+        int getNmembers() const;
+
+        // Adds a new member to this compound datatype.
+        void insertMember(const H5std_string& name, size_t offset, const DataType& new_member) const;
+
+        // Recursively removes padding from within this compound datatype.
+        void pack() const;
+
+        // Sets the total size for this compound datatype.
+        void setSize(size_t size) const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("CompType"); }
+
+        // Noop destructor.
+        virtual ~CompType();
+
+   private:
+        // Contains common code that is used by the member functions
+        // getMemberXxxType
+        hid_t p_get_member_type(unsigned member_num) const;
+
+}; // end of CompType
+} // namespace H5
+
+#endif // __H5CompType_H
diff --git a/install/include/H5Cpkg.h b/install/include/H5Cpkg.h
new file mode 100644
index 0000000000..fdb14a55a1
--- /dev/null
+++ b/install/include/H5Cpkg.h
@@ -0,0 +1,4956 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer: John Mainzer -- 10/12/04
+ *
+ * Purpose:     This file contains declarations which are normally visible
+ *              only within the H5C package.
+ *
+ *		Source files outside the H5C package should include
+ *		H5Cprivate.h instead.
+ *
+ *		The one exception to this rule is test/cache.c.  The test
+ *		code is easier to write if it can look at the cache's
+ *		internal data structures.  Indeed, this is the main
+ *		reason why this file was created.
+ */
+
+#if !(defined H5C_FRIEND || defined H5C_MODULE)
+#error "Do not include this file outside the H5C package!"
+#endif
+
+#ifndef _H5Cpkg_H
+#define _H5Cpkg_H
+
+/* Get package's private header */
+#include "H5Cprivate.h"
+
+/* Other private headers needed by this file */
+#include "H5SLprivate.h"        /* Skip lists */
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* Number of epoch markers active */
+#define H5C__MAX_EPOCH_MARKERS                  10
+
+/* Cache configuration settings */
+#define H5C__HASH_TABLE_LEN     (64 * 1024) /* must be a power of 2 */
+#define H5C__H5C_T_MAGIC	0x005CAC0E
+
+/* Initial allocated size of the "flush_dep_parent" array */
+#define H5C_FLUSH_DEP_PARENT_INIT 8
+
+/****************************************************************************
+ *
+ * We maintain doubly linked lists of instances of H5C_cache_entry_t for a
+ * variety of reasons -- protected list, LRU list, and the clean and dirty
+ * LRU lists at present.  The following macros support linking and unlinking
+ * of instances of H5C_cache_entry_t by both their regular and auxilary next
+ * and previous pointers.
+ *
+ * The size and length fields are also maintained.
+ *
+ * Note that the relevant pair of prev and next pointers are presumed to be
+ * NULL on entry in the insertion macros.
+ *
+ * Finally, observe that the sanity checking macros evaluate to the empty
+ * string when H5C_DO_SANITY_CHECKS is FALSE.  They also contain calls
+ * to the HGOTO_ERROR macro, which may not be appropriate in all cases.
+ * If so, we will need versions of the insertion and deletion macros which
+ * do not reference the sanity checking macros.
+ *							JRM - 5/5/04
+ *
+ * Changes:
+ *
+ *  - Removed the line:
+ *
+ *        ( ( (Size) == (entry_ptr)->size ) && ( (len) != 1 ) ) ||
+ *
+ *    from the H5C__DLL_PRE_REMOVE_SC macro.  With the addition of the
+ *    epoch markers used in the age out based cache size reduction algorithm,
+ *    this invariant need not hold, as the epoch markers are of size 0.
+ *
+ *    One could argue that I should have given the epoch markers a positive
+ *    size, but this would break the index_size = LRU_list_size + pl_size
+ *    + pel_size invariant.
+ *
+ *    Alternatively, I could pass the current decr_mode in to the macro,
+ *    and just skip the check whenever epoch markers may be in use.
+ *
+ *    However, any size errors should be caught when the cache is flushed
+ *    and destroyed.  Until we are tracking such an error, this should be
+ *    good enough.
+ *                                                     JRM - 12/9/04
+ *
+ *
+ *  - In the H5C__DLL_PRE_INSERT_SC macro, replaced the lines:
+ *
+ *    ( ( (len) == 1 ) &&
+ *      ( ( (head_ptr) != (tail_ptr) ) || ( (Size) <= 0 ) ||
+ *        ( (head_ptr) == NULL ) || ( (head_ptr)->size != (Size) )
+ *      )
+ *    ) ||
+ *
+ *    with:
+ *
+ *    ( ( (len) == 1 ) &&
+ *      ( ( (head_ptr) != (tail_ptr) ) ||
+ *        ( (head_ptr) == NULL ) || ( (head_ptr)->size != (Size) )
+ *      )
+ *    ) ||
+ *
+ *    Epoch markers have size 0, so we can now have a non-empty list with
+ *    zero size.  Hence the "( (Size) <= 0 )" clause cause false failures
+ *    in the sanity check.  Since "Size" is typically a size_t, it can't
+ *    take on negative values, and thus the revised clause "( (Size) < 0 )"
+ *    caused compiler warnings.
+ *                                                     JRM - 12/22/04
+ *
+ *  - In the H5C__DLL_SC macro, replaced the lines:
+ *
+ *    ( ( (len) == 1 ) &&
+ *      ( ( (head_ptr) != (tail_ptr) ) || ( (cache_ptr)->size <= 0 ) ||
+ *        ( (head_ptr) == NULL ) || ( (head_ptr)->size != (Size) )
+ *      )
+ *    ) ||
+ *
+ *    with
+ *
+ *    ( ( (len) == 1 ) &&
+ *      ( ( (head_ptr) != (tail_ptr) ) ||
+ *        ( (head_ptr) == NULL ) || ( (head_ptr)->size != (Size) )
+ *      )
+ *    ) ||
+ *
+ *    Epoch markers have size 0, so we can now have a non-empty list with
+ *    zero size.  Hence the "( (Size) <= 0 )" clause cause false failures
+ *    in the sanity check.  Since "Size" is typically a size_t, it can't
+ *    take on negative values, and thus the revised clause "( (Size) < 0 )"
+ *    caused compiler warnings.
+ *                                                     JRM - 1/10/05
+ *
+ *  - Added the H5C__DLL_UPDATE_FOR_SIZE_CHANGE macro and the associated
+ *    sanity checking macros.  These macro are used to update the size of
+ *    a DLL when one of its entries changes size.
+ *
+ *							JRM - 9/8/05
+ *
+ *  - Added macros supporting the index list -- a doubly liked list of 
+ *    all entries in the index.  This list is necessary to reduce the 
+ *    cost of visiting all entries in the cache, which was previously
+ *    done via a scan of the hash table.
+ *
+ *							JRM - 10/15/15
+ *
+ ****************************************************************************/
+
+#if H5C_DO_SANITY_CHECKS
+
+#define H5C__DLL_PRE_REMOVE_SC(entry_ptr, head_ptr, tail_ptr, len, Size, fv) \
+if ( ( (head_ptr) == NULL ) ||                                               \
+     ( (tail_ptr) == NULL ) ||                                               \
+     ( (entry_ptr) == NULL ) ||                                              \
+     ( (len) <= 0 ) ||                                                       \
+     ( (Size) < (entry_ptr)->size ) ||                                       \
+     ( ( (entry_ptr)->prev == NULL ) && ( (head_ptr) != (entry_ptr) ) ) ||   \
+     ( ( (entry_ptr)->next == NULL ) && ( (tail_ptr) != (entry_ptr) ) ) ||   \
+     ( ( (len) == 1 ) &&                                                     \
+       ( ! ( ( (head_ptr) == (entry_ptr) ) &&                                \
+             ( (tail_ptr) == (entry_ptr) ) &&                                \
+             ( (entry_ptr)->next == NULL ) &&                                \
+             ( (entry_ptr)->prev == NULL ) &&                                \
+             ( (Size) == (entry_ptr)->size )                                 \
+           )                                                                 \
+       )                                                                     \
+     )                                                                       \
+   ) {                                                                       \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, (fv), "DLL pre remove SC failed")     \
+}
+
+#define H5C__DLL_SC(head_ptr, tail_ptr, len, Size, fv)                   \
+if ( ( ( ( (head_ptr) == NULL ) || ( (tail_ptr) == NULL ) ) &&           \
+       ( (head_ptr) != (tail_ptr) )                                      \
+     ) ||                                                                \
+     ( (len) < 0 ) ||                                                    \
+     ( (Size) < 0 ) ||                                                   \
+     ( ( (len) == 1 ) &&                                                 \
+       ( ( (head_ptr) != (tail_ptr) ) ||                                 \
+         ( (head_ptr) == NULL ) || ( (head_ptr)->size != (Size) )        \
+       )                                                                 \
+     ) ||                                                                \
+     ( ( (len) >= 1 ) &&                                                 \
+       ( ( (head_ptr) == NULL ) || ( (head_ptr)->prev != NULL ) ||       \
+         ( (tail_ptr) == NULL ) || ( (tail_ptr)->next != NULL )          \
+       )                                                                 \
+     )                                                                   \
+   ) {                                                                   \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, (fv), "DLL sanity check failed")  \
+}
+
+#define H5C__DLL_PRE_INSERT_SC(entry_ptr, head_ptr, tail_ptr, len, Size, fv) \
+if ( ( (entry_ptr) == NULL ) ||                                              \
+     ( (entry_ptr)->next != NULL ) ||                                        \
+     ( (entry_ptr)->prev != NULL ) ||                                        \
+     ( ( ( (head_ptr) == NULL ) || ( (tail_ptr) == NULL ) ) &&               \
+       ( (head_ptr) != (tail_ptr) )                                          \
+     ) ||                                                                    \
+     ( ( (len) == 1 ) &&                                                     \
+       ( ( (head_ptr) != (tail_ptr) ) ||                                     \
+         ( (head_ptr) == NULL ) || ( (head_ptr)->size != (Size) )            \
+       )                                                                     \
+     ) ||                                                                    \
+     ( ( (len) >= 1 ) &&                                                     \
+       ( ( (head_ptr) == NULL ) || ( (head_ptr)->prev != NULL ) ||           \
+         ( (tail_ptr) == NULL ) || ( (tail_ptr)->next != NULL )              \
+       )                                                                     \
+     )                                                                       \
+   ) {                                                                       \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, (fv), "DLL pre insert SC failed")     \
+}
+
+#define H5C__DLL_PRE_SIZE_UPDATE_SC(dll_len, dll_size, old_size, new_size)    \
+if ( ( (dll_len) <= 0 ) ||                                                    \
+     ( (dll_size) <= 0 ) ||                                                   \
+     ( (old_size) <= 0 ) ||                                                   \
+     ( (old_size) > (dll_size) ) ||                                           \
+     ( (new_size) <= 0 ) ||                                                   \
+     ( ( (dll_len) == 1 ) && ( (old_size) != (dll_size) ) ) ) {               \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, FAIL, "DLL pre size update SC failed") \
+}
+
+#define H5C__DLL_POST_SIZE_UPDATE_SC(dll_len, dll_size, old_size, new_size)    \
+if ( ( (new_size) > (dll_size) ) ||                                            \
+     ( ( (dll_len) == 1 ) && ( (new_size) != (dll_size) ) ) ) {                \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, FAIL, "DLL post size update SC failed") \
+}
+
+#else /* H5C_DO_SANITY_CHECKS */
+
+#define H5C__DLL_PRE_REMOVE_SC(entry_ptr, head_ptr, tail_ptr, len, Size, fv)
+#define H5C__DLL_SC(head_ptr, tail_ptr, len, Size, fv)
+#define H5C__DLL_PRE_INSERT_SC(entry_ptr, head_ptr, tail_ptr, len, Size, fv)
+#define H5C__DLL_PRE_SIZE_UPDATE_SC(dll_len, dll_size, old_size, new_size)
+#define H5C__DLL_POST_SIZE_UPDATE_SC(dll_len, dll_size, old_size, new_size)
+
+#endif /* H5C_DO_SANITY_CHECKS */
+
+
+#define H5C__DLL_APPEND(entry_ptr, head_ptr, tail_ptr, len, Size, fail_val) \
+{                                                                           \
+    H5C__DLL_PRE_INSERT_SC(entry_ptr, head_ptr, tail_ptr, len, Size,        \
+                           fail_val)                                        \
+    if ( (head_ptr) == NULL )                                               \
+    {                                                                       \
+       (head_ptr) = (entry_ptr);                                            \
+       (tail_ptr) = (entry_ptr);                                            \
+    }                                                                       \
+    else                                                                    \
+    {                                                                       \
+       (tail_ptr)->next = (entry_ptr);                                      \
+       (entry_ptr)->prev = (tail_ptr);                                      \
+       (tail_ptr) = (entry_ptr);                                            \
+    }                                                                       \
+    (len)++;                                                                \
+    (Size) += (entry_ptr)->size;                                            \
+} /* H5C__DLL_APPEND() */
+
+#define H5C__DLL_PREPEND(entry_ptr, head_ptr, tail_ptr, len, Size, fail_val) \
+{                                                                            \
+    H5C__DLL_PRE_INSERT_SC(entry_ptr, head_ptr, tail_ptr, len, Size,         \
+                           fail_val)                                         \
+    if ( (head_ptr) == NULL )                                                \
+    {                                                                        \
+       (head_ptr) = (entry_ptr);                                             \
+       (tail_ptr) = (entry_ptr);                                             \
+    }                                                                        \
+    else                                                                     \
+    {                                                                        \
+       (head_ptr)->prev = (entry_ptr);                                       \
+       (entry_ptr)->next = (head_ptr);                                       \
+       (head_ptr) = (entry_ptr);                                             \
+    }                                                                        \
+    (len)++;                                                                 \
+    (Size) += entry_ptr->size;                                               \
+} /* H5C__DLL_PREPEND() */
+
+#define H5C__DLL_REMOVE(entry_ptr, head_ptr, tail_ptr, len, Size, fail_val) \
+{                                                                           \
+    H5C__DLL_PRE_REMOVE_SC(entry_ptr, head_ptr, tail_ptr, len, Size,        \
+                           fail_val)                                        \
+    {                                                                       \
+       if ( (head_ptr) == (entry_ptr) )                                     \
+       {                                                                    \
+          (head_ptr) = (entry_ptr)->next;                                   \
+          if ( (head_ptr) != NULL )                                         \
+             (head_ptr)->prev = NULL;                                       \
+       }                                                                    \
+       else                                                                 \
+          (entry_ptr)->prev->next = (entry_ptr)->next;                      \
+       if ( (tail_ptr) == (entry_ptr) )                                     \
+       {                                                                    \
+          (tail_ptr) = (entry_ptr)->prev;                                   \
+          if ( (tail_ptr) != NULL )                                         \
+             (tail_ptr)->next = NULL;                                       \
+       }                                                                    \
+       else                                                                 \
+          (entry_ptr)->next->prev = (entry_ptr)->prev;                      \
+       entry_ptr->next = NULL;                                              \
+       entry_ptr->prev = NULL;                                              \
+       (len)--;                                                             \
+       (Size) -= entry_ptr->size;                                           \
+    }                                                                       \
+} /* H5C__DLL_REMOVE() */
+
+#define H5C__DLL_UPDATE_FOR_SIZE_CHANGE(dll_len, dll_size, old_size, new_size) \
+{                                                                              \
+    H5C__DLL_PRE_SIZE_UPDATE_SC(dll_len, dll_size, old_size, new_size)         \
+    (dll_size) -= (old_size);                                                  \
+    (dll_size) += (new_size);                                                  \
+    H5C__DLL_POST_SIZE_UPDATE_SC(dll_len, dll_size, old_size, new_size)        \
+} /* H5C__DLL_UPDATE_FOR_SIZE_CHANGE() */
+
+#if H5C_DO_SANITY_CHECKS
+
+#define H5C__AUX_DLL_PRE_REMOVE_SC(entry_ptr, hd_ptr, tail_ptr, len, Size, fv) \
+if ( ( (hd_ptr) == NULL ) ||                                                   \
+     ( (tail_ptr) == NULL ) ||                                                 \
+     ( (entry_ptr) == NULL ) ||                                                \
+     ( (len) <= 0 ) ||                                                         \
+     ( (Size) < (entry_ptr)->size ) ||                                         \
+     ( ( (Size) == (entry_ptr)->size ) && ( ! ( (len) == 1 ) ) ) ||            \
+     ( ( (entry_ptr)->aux_prev == NULL ) && ( (hd_ptr) != (entry_ptr) ) ) ||   \
+     ( ( (entry_ptr)->aux_next == NULL ) && ( (tail_ptr) != (entry_ptr) ) ) || \
+     ( ( (len) == 1 ) &&                                                       \
+       ( ! ( ( (hd_ptr) == (entry_ptr) ) && ( (tail_ptr) == (entry_ptr) ) &&   \
+             ( (entry_ptr)->aux_next == NULL ) &&                              \
+             ( (entry_ptr)->aux_prev == NULL ) &&                              \
+             ( (Size) == (entry_ptr)->size )                                   \
+           )                                                                   \
+       )                                                                       \
+     )                                                                         \
+   ) {                                                                         \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, (fv), "aux DLL pre remove SC failed")   \
+}
+
+#define H5C__AUX_DLL_SC(head_ptr, tail_ptr, len, Size, fv)                  \
+if ( ( ( ( (head_ptr) == NULL ) || ( (tail_ptr) == NULL ) ) &&              \
+       ( (head_ptr) != (tail_ptr) )                                         \
+     ) ||                                                                   \
+     ( (len) < 0 ) ||                                                       \
+     ( (Size) < 0 ) ||                                                      \
+     ( ( (len) == 1 ) &&                                                    \
+       ( ( (head_ptr) != (tail_ptr) ) || ( (Size) <= 0 ) ||                 \
+         ( (head_ptr) == NULL ) || ( (head_ptr)->size != (Size) )           \
+       )                                                                    \
+     ) ||                                                                   \
+     ( ( (len) >= 1 ) &&                                                    \
+       ( ( (head_ptr) == NULL ) || ( (head_ptr)->aux_prev != NULL ) ||      \
+         ( (tail_ptr) == NULL ) || ( (tail_ptr)->aux_next != NULL )         \
+       )                                                                    \
+     )                                                                      \
+   ) {                                                                      \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, (fv), "AUX DLL sanity check failed") \
+}
+
+#define H5C__AUX_DLL_PRE_INSERT_SC(entry_ptr, hd_ptr, tail_ptr, len, Size, fv) \
+if ( ( (entry_ptr) == NULL ) ||                                                \
+     ( (entry_ptr)->aux_next != NULL ) ||                                      \
+     ( (entry_ptr)->aux_prev != NULL ) ||                                      \
+     ( ( ( (hd_ptr) == NULL ) || ( (tail_ptr) == NULL ) ) &&                   \
+       ( (hd_ptr) != (tail_ptr) )                                              \
+     ) ||                                                                      \
+     ( ( (len) == 1 ) &&                                                       \
+       ( ( (hd_ptr) != (tail_ptr) ) || ( (Size) <= 0 ) ||                      \
+         ( (hd_ptr) == NULL ) || ( (hd_ptr)->size != (Size) )                  \
+       )                                                                       \
+     ) ||                                                                      \
+     ( ( (len) >= 1 ) &&                                                       \
+       ( ( (hd_ptr) == NULL ) || ( (hd_ptr)->aux_prev != NULL ) ||             \
+         ( (tail_ptr) == NULL ) || ( (tail_ptr)->aux_next != NULL )            \
+       )                                                                       \
+     )                                                                         \
+   ) {                                                                         \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, (fv), "AUX DLL pre insert SC failed")   \
+}
+
+#else /* H5C_DO_SANITY_CHECKS */
+
+#define H5C__AUX_DLL_PRE_REMOVE_SC(entry_ptr, hd_ptr, tail_ptr, len, Size, fv)
+#define H5C__AUX_DLL_SC(head_ptr, tail_ptr, len, Size, fv)
+#define H5C__AUX_DLL_PRE_INSERT_SC(entry_ptr, hd_ptr, tail_ptr, len, Size, fv)
+
+#endif /* H5C_DO_SANITY_CHECKS */
+
+
+#define H5C__AUX_DLL_APPEND(entry_ptr, head_ptr, tail_ptr, len, Size, fail_val)\
+{                                                                              \
+    H5C__AUX_DLL_PRE_INSERT_SC(entry_ptr, head_ptr, tail_ptr, len, Size,       \
+                               fail_val)                                       \
+    if ( (head_ptr) == NULL )                                                  \
+    {                                                                          \
+       (head_ptr) = (entry_ptr);                                               \
+       (tail_ptr) = (entry_ptr);                                               \
+    }                                                                          \
+    else                                                                       \
+    {                                                                          \
+       (tail_ptr)->aux_next = (entry_ptr);                                     \
+       (entry_ptr)->aux_prev = (tail_ptr);                                     \
+       (tail_ptr) = (entry_ptr);                                               \
+    }                                                                          \
+    (len)++;                                                                   \
+    (Size) += entry_ptr->size;                                                 \
+} /* H5C__AUX_DLL_APPEND() */
+
+#define H5C__AUX_DLL_PREPEND(entry_ptr, head_ptr, tail_ptr, len, Size, fv)   \
+{                                                                            \
+    H5C__AUX_DLL_PRE_INSERT_SC(entry_ptr, head_ptr, tail_ptr, len, Size, fv) \
+    if ( (head_ptr) == NULL )                                                \
+    {                                                                        \
+       (head_ptr) = (entry_ptr);                                             \
+       (tail_ptr) = (entry_ptr);                                             \
+    }                                                                        \
+    else                                                                     \
+    {                                                                        \
+       (head_ptr)->aux_prev = (entry_ptr);                                   \
+       (entry_ptr)->aux_next = (head_ptr);                                   \
+       (head_ptr) = (entry_ptr);                                             \
+    }                                                                        \
+    (len)++;                                                                 \
+    (Size) += entry_ptr->size;                                               \
+} /* H5C__AUX_DLL_PREPEND() */
+
+#define H5C__AUX_DLL_REMOVE(entry_ptr, head_ptr, tail_ptr, len, Size, fv)    \
+{                                                                            \
+    H5C__AUX_DLL_PRE_REMOVE_SC(entry_ptr, head_ptr, tail_ptr, len, Size, fv) \
+    {                                                                        \
+       if ( (head_ptr) == (entry_ptr) )                                      \
+       {                                                                     \
+          (head_ptr) = (entry_ptr)->aux_next;                                \
+          if ( (head_ptr) != NULL )                                          \
+             (head_ptr)->aux_prev = NULL;                                    \
+       }                                                                     \
+       else                                                                  \
+          (entry_ptr)->aux_prev->aux_next = (entry_ptr)->aux_next;           \
+       if ( (tail_ptr) == (entry_ptr) )                                      \
+       {                                                                     \
+          (tail_ptr) = (entry_ptr)->aux_prev;                                \
+          if ( (tail_ptr) != NULL )                                          \
+             (tail_ptr)->aux_next = NULL;                                    \
+       }                                                                     \
+       else                                                                  \
+          (entry_ptr)->aux_next->aux_prev = (entry_ptr)->aux_prev;           \
+       entry_ptr->aux_next = NULL;                                           \
+       entry_ptr->aux_prev = NULL;                                           \
+       (len)--;                                                              \
+       (Size) -= entry_ptr->size;                                            \
+    }                                                                        \
+} /* H5C__AUX_DLL_REMOVE() */
+
+#if H5C_DO_SANITY_CHECKS
+
+#define H5C__IL_DLL_PRE_REMOVE_SC(entry_ptr, hd_ptr, tail_ptr, len, Size, fv) \
+if ( ( (hd_ptr) == NULL ) ||                                                  \
+     ( (tail_ptr) == NULL ) ||                                                \
+     ( (entry_ptr) == NULL ) ||                                               \
+     ( (len) <= 0 ) ||                                                        \
+     ( (Size) < (entry_ptr)->size ) ||                                        \
+     ( ( (Size) == (entry_ptr)->size ) && ( ! ( (len) == 1 ) ) ) ||           \
+     ( ( (entry_ptr)->il_prev == NULL ) && ( (hd_ptr) != (entry_ptr) ) ) ||   \
+     ( ( (entry_ptr)->il_next == NULL ) && ( (tail_ptr) != (entry_ptr) ) ) || \
+     ( ( (len) == 1 ) &&                                                      \
+       ( ! ( ( (hd_ptr) == (entry_ptr) ) && ( (tail_ptr) == (entry_ptr) ) &&  \
+             ( (entry_ptr)->il_next == NULL ) &&                              \
+             ( (entry_ptr)->il_prev == NULL ) &&                              \
+             ( (Size) == (entry_ptr)->size )                                  \
+           )                                                                  \
+       )                                                                      \
+     )                                                                        \
+   ) {                                                                        \
+    HDassert(0 && "il DLL pre remove SC failed");                             \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, (fv), "il DLL pre remove SC failed")   \
+}
+
+#define H5C__IL_DLL_PRE_INSERT_SC(entry_ptr, hd_ptr, tail_ptr, len, Size, fv) \
+if ( ( (entry_ptr) == NULL ) ||                                               \
+     ( (entry_ptr)->il_next != NULL ) ||                                      \
+     ( (entry_ptr)->il_prev != NULL ) ||                                      \
+     ( ( ( (hd_ptr) == NULL ) || ( (tail_ptr) == NULL ) ) &&                  \
+       ( (hd_ptr) != (tail_ptr) )                                             \
+     ) ||                                                                     \
+     ( ( (len) == 1 ) &&                                                      \
+       ( ( (hd_ptr) != (tail_ptr) ) || ( (Size) <= 0 ) ||                     \
+         ( (hd_ptr) == NULL ) || ( (hd_ptr)->size != (Size) )                 \
+       )                                                                      \
+     ) ||                                                                     \
+     ( ( (len) >= 1 ) &&                                                      \
+       ( ( (hd_ptr) == NULL ) || ( (hd_ptr)->il_prev != NULL ) ||             \
+         ( (tail_ptr) == NULL ) || ( (tail_ptr)->il_next != NULL )            \
+       )                                                                      \
+     )                                                                        \
+   ) {                                                                        \
+    HDassert(0 && "IL DLL pre insert SC failed");                             \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, (fv), "IL DLL pre insert SC failed")   \
+}
+
+#define H5C__IL_DLL_SC(head_ptr, tail_ptr, len, Size, fv)                  \
+if ( ( ( ( (head_ptr) == NULL ) || ( (tail_ptr) == NULL ) ) &&             \
+       ( (head_ptr) != (tail_ptr) )                                        \
+     ) ||                                                                  \
+     ( ( (len) == 1 ) &&                                                   \
+       ( ( (head_ptr) != (tail_ptr) ) ||                                   \
+         ( (head_ptr) == NULL ) || ( (head_ptr)->size != (Size) )          \
+       )                                                                   \
+     ) ||                                                                  \
+     ( ( (len) >= 1 ) &&                                                   \
+       ( ( (head_ptr) == NULL ) || ( (head_ptr)->il_prev != NULL ) ||      \
+         ( (tail_ptr) == NULL ) || ( (tail_ptr)->il_next != NULL )         \
+       )                                                                   \
+     )                                                                     \
+   ) {                                                                     \
+    HDassert(0 && "IL DLL sanity check failed");                           \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, (fv), "IL DLL sanity check failed") \
+}
+
+#else /* H5C_DO_SANITY_CHECKS */
+
+#define H5C__IL_DLL_PRE_REMOVE_SC(entry_ptr, hd_ptr, tail_ptr, len, Size, fv)
+#define H5C__IL_DLL_PRE_INSERT_SC(entry_ptr, hd_ptr, tail_ptr, len, Size, fv)
+#define H5C__IL_DLL_SC(head_ptr, tail_ptr, len, Size, fv)
+
+#endif /* H5C_DO_SANITY_CHECKS */
+
+
+#define H5C__IL_DLL_APPEND(entry_ptr, head_ptr, tail_ptr, len, Size, fail_val)\
+{                                                                             \
+    H5C__IL_DLL_PRE_INSERT_SC(entry_ptr, head_ptr, tail_ptr, len, Size,       \
+                               fail_val)                                      \
+    if ( (head_ptr) == NULL )                                                 \
+    {                                                                         \
+       (head_ptr) = (entry_ptr);                                              \
+       (tail_ptr) = (entry_ptr);                                              \
+    }                                                                         \
+    else                                                                      \
+    {                                                                         \
+       (tail_ptr)->il_next = (entry_ptr);                                     \
+       (entry_ptr)->il_prev = (tail_ptr);                                     \
+       (tail_ptr) = (entry_ptr);                                              \
+    }                                                                         \
+    (len)++;                                                                  \
+    (Size) += entry_ptr->size;                                                \
+    H5C__IL_DLL_SC(head_ptr, tail_ptr, len, Size, fail_val)                   \
+} /* H5C__IL_DLL_APPEND() */
+
+#define H5C__IL_DLL_REMOVE(entry_ptr, head_ptr, tail_ptr, len, Size, fv)    \
+{                                                                           \
+    H5C__IL_DLL_PRE_REMOVE_SC(entry_ptr, head_ptr, tail_ptr, len, Size, fv) \
+    {                                                                       \
+       if ( (head_ptr) == (entry_ptr) )                                     \
+       {                                                                    \
+          (head_ptr) = (entry_ptr)->il_next;                                \
+          if ( (head_ptr) != NULL )                                         \
+             (head_ptr)->il_prev = NULL;                                    \
+       }                                                                    \
+       else                                                                 \
+          (entry_ptr)->il_prev->il_next = (entry_ptr)->il_next;             \
+       if ( (tail_ptr) == (entry_ptr) )                                     \
+       {                                                                    \
+          (tail_ptr) = (entry_ptr)->il_prev;                                \
+          if ( (tail_ptr) != NULL )                                         \
+             (tail_ptr)->il_next = NULL;                                    \
+       }                                                                    \
+       else                                                                 \
+          (entry_ptr)->il_next->il_prev = (entry_ptr)->il_prev;             \
+       entry_ptr->il_next = NULL;                                           \
+       entry_ptr->il_prev = NULL;                                           \
+       (len)--;                                                             \
+       (Size) -= entry_ptr->size;                                           \
+    }                                                                       \
+    H5C__IL_DLL_SC(head_ptr, tail_ptr, len, Size, fv)                       \
+} /* H5C__IL_DLL_REMOVE() */
+
+

+/***********************************************************************
+ *
+ * Stats collection macros
+ *
+ * The following macros must handle stats collection when this collection
+ * is enabled, and evaluate to the empty string when it is not.
+ *
+ * The sole exception to this rule is
+ * H5C__UPDATE_CACHE_HIT_RATE_STATS(), which is always active as
+ * the cache hit rate stats are always collected and available.
+ *
+ ***********************************************************************/
+
+#define H5C__UPDATE_CACHE_HIT_RATE_STATS(cache_ptr, hit) \
+        (cache_ptr->cache_accesses)++;                   \
+        if ( hit ) {                                     \
+            (cache_ptr->cache_hits)++;                   \
+        }                                                \
+
+#if H5C_COLLECT_CACHE_STATS
+
+#define H5C__UPDATE_MAX_INDEX_SIZE_STATS(cache_ptr)                        \
+        if ( (cache_ptr)->index_size > (cache_ptr)->max_index_size )       \
+            (cache_ptr)->max_index_size = (cache_ptr)->index_size;         \
+        if ( (cache_ptr)->clean_index_size >                               \
+                (cache_ptr)->max_clean_index_size )                        \
+            (cache_ptr)->max_clean_index_size =                            \
+                (cache_ptr)->clean_index_size;                             \
+        if ( (cache_ptr)->dirty_index_size >                               \
+                (cache_ptr)->max_dirty_index_size )                        \
+            (cache_ptr)->max_dirty_index_size =                            \
+                (cache_ptr)->dirty_index_size;
+
+#define H5C__UPDATE_STATS_FOR_DIRTY_PIN(cache_ptr, entry_ptr) \
+	(((cache_ptr)->dirty_pins)[(entry_ptr)->type->id])++;
+
+#define H5C__UPDATE_STATS_FOR_UNPROTECT(cache_ptr)                   \
+        if ( (cache_ptr)->slist_len > (cache_ptr)->max_slist_len )   \
+	    (cache_ptr)->max_slist_len = (cache_ptr)->slist_len;     \
+        if ( (cache_ptr)->slist_size > (cache_ptr)->max_slist_size ) \
+	    (cache_ptr)->max_slist_size = (cache_ptr)->slist_size;   \
+	if ( (cache_ptr)->pel_len > (cache_ptr)->max_pel_len )       \
+	    (cache_ptr)->max_pel_len = (cache_ptr)->pel_len;         \
+	if ( (cache_ptr)->pel_size > (cache_ptr)->max_pel_size )     \
+	    (cache_ptr)->max_pel_size = (cache_ptr)->pel_size;
+
+#define H5C__UPDATE_STATS_FOR_MOVE(cache_ptr, entry_ptr)               \
+	if ( cache_ptr->flush_in_progress )                            \
+            ((cache_ptr)->cache_flush_moves[(entry_ptr)->type->id])++; \
+        if ( entry_ptr->flush_in_progress )                            \
+            ((cache_ptr)->entry_flush_moves[(entry_ptr)->type->id])++; \
+	(((cache_ptr)->moves)[(entry_ptr)->type->id])++;               \
+        (cache_ptr)->entries_relocated_counter++;
+
+#define H5C__UPDATE_STATS_FOR_ENTRY_SIZE_CHANGE(cache_ptr, entry_ptr, new_size)\
+	if ( cache_ptr->flush_in_progress )                                    \
+            ((cache_ptr)->cache_flush_size_changes[(entry_ptr)->type->id])++;  \
+        if ( entry_ptr->flush_in_progress )                                    \
+            ((cache_ptr)->entry_flush_size_changes[(entry_ptr)->type->id])++;  \
+	if ( (entry_ptr)->size < (new_size) ) {                                \
+	    ((cache_ptr)->size_increases[(entry_ptr)->type->id])++;            \
+            H5C__UPDATE_MAX_INDEX_SIZE_STATS(cache_ptr)                        \
+            if ( (cache_ptr)->slist_size > (cache_ptr)->max_slist_size )       \
+                (cache_ptr)->max_slist_size = (cache_ptr)->slist_size;         \
+            if ( (cache_ptr)->pl_size > (cache_ptr)->max_pl_size )             \
+                (cache_ptr)->max_pl_size = (cache_ptr)->pl_size;               \
+	} else if ( (entry_ptr)->size > (new_size) ) {                         \
+	    ((cache_ptr)->size_decreases[(entry_ptr)->type->id])++;            \
+	}
+
+#define H5C__UPDATE_STATS_FOR_HT_INSERTION(cache_ptr) \
+	(cache_ptr)->total_ht_insertions++;
+
+#define H5C__UPDATE_STATS_FOR_HT_DELETION(cache_ptr) \
+	(cache_ptr)->total_ht_deletions++;
+
+#define H5C__UPDATE_STATS_FOR_HT_SEARCH(cache_ptr, success, depth)  \
+	if ( success ) {                                            \
+	    (cache_ptr)->successful_ht_searches++;                  \
+	    (cache_ptr)->total_successful_ht_search_depth += depth; \
+	} else {                                                    \
+	    (cache_ptr)->failed_ht_searches++;                      \
+	    (cache_ptr)->total_failed_ht_search_depth += depth;     \
+	}
+
+#define H5C__UPDATE_STATS_FOR_UNPIN(cache_ptr, entry_ptr) \
+	((cache_ptr)->unpins)[(entry_ptr)->type->id]++;
+
+#define H5C__UPDATE_STATS_FOR_SLIST_SCAN_RESTART(cache_ptr) \
+	((cache_ptr)->slist_scan_restarts)++;
+
+#define H5C__UPDATE_STATS_FOR_LRU_SCAN_RESTART(cache_ptr) \
+	((cache_ptr)->LRU_scan_restarts)++;
+
+#define H5C__UPDATE_STATS_FOR_INDEX_SCAN_RESTART(cache_ptr) \
+	((cache_ptr)->index_scan_restarts)++;
+
+#define H5C__UPDATE_STATS_FOR_CACHE_IMAGE_CREATE(cache_ptr) \
+{                                                           \
+    (cache_ptr)->images_created++;                          \
+}
+
+#define H5C__UPDATE_STATS_FOR_CACHE_IMAGE_READ(cache_ptr)  \
+{                                                          \
+    /* make sure image len is still good */                \
+    HDassert((cache_ptr)->image_len > 0);                  \
+    (cache_ptr)->images_read++;                            \
+}
+
+#define H5C__UPDATE_STATS_FOR_CACHE_IMAGE_LOAD(cache_ptr)  \
+{                                                          \
+    /* make sure image len is still good */                \
+    HDassert((cache_ptr)->image_len > 0);                  \
+    (cache_ptr)->images_loaded++;                          \
+    (cache_ptr)->last_image_size = (cache_ptr)->image_len; \
+}
+
+#define H5C__UPDATE_STATS_FOR_PREFETCH(cache_ptr, dirty) \
+{                                                        \
+    (cache_ptr)->prefetches++;                           \
+    if ( dirty )                                         \
+        (cache_ptr)->dirty_prefetches++;                 \
+}
+
+#define H5C__UPDATE_STATS_FOR_PREFETCH_HIT(cache_ptr) \
+{                                                     \
+    (cache_ptr)->prefetch_hits++;                     \
+}
+
+#if H5C_COLLECT_CACHE_ENTRY_STATS
+
+#define H5C__RESET_CACHE_ENTRY_STATS(entry_ptr) \
+{                                           \
+    (entry_ptr)->accesses = 0;              \
+    (entry_ptr)->clears   = 0;              \
+    (entry_ptr)->flushes  = 0;              \
+    (entry_ptr)->pins     = 0;              \
+}
+
+#define H5C__UPDATE_STATS_FOR_CLEAR(cache_ptr, entry_ptr)        \
+{                                                                \
+    (((cache_ptr)->clears)[(entry_ptr)->type->id])++;            \
+    if((entry_ptr)->is_pinned)                                   \
+        (((cache_ptr)->pinned_clears)[(entry_ptr)->type->id])++; \
+    ((entry_ptr)->clears)++;                                     \
+}
+
+#define H5C__UPDATE_STATS_FOR_FLUSH(cache_ptr, entry_ptr)         \
+{                                                                 \
+    (((cache_ptr)->flushes)[(entry_ptr)->type->id])++;            \
+    if((entry_ptr)->is_pinned)                                    \
+        (((cache_ptr)->pinned_flushes)[(entry_ptr)->type->id])++; \
+    ((entry_ptr)->flushes)++;                                     \
+}
+
+#define H5C__UPDATE_STATS_FOR_EVICTION(cache_ptr, entry_ptr, take_ownership) \
+{                                                                            \
+    if ( take_ownership )                                                    \
+        (((cache_ptr)->take_ownerships)[(entry_ptr)->type->id])++;           \
+    else                                                                     \
+        (((cache_ptr)->evictions)[(entry_ptr)->type->id])++;                 \
+    if ( (entry_ptr)->accesses >                                         \
+            ((cache_ptr)->max_accesses)[(entry_ptr)->type->id] )         \
+        ((cache_ptr)->max_accesses)[(entry_ptr)->type->id] =             \
+            (entry_ptr)->accesses;                                       \
+    if ( (entry_ptr)->accesses <                                         \
+            ((cache_ptr)->min_accesses)[(entry_ptr)->type->id] )         \
+        ((cache_ptr)->min_accesses)[(entry_ptr)->type->id] =             \
+            (entry_ptr)->accesses;                                       \
+    if ( (entry_ptr)->clears >                                           \
+             ((cache_ptr)->max_clears)[(entry_ptr)->type->id] )          \
+            ((cache_ptr)->max_clears)[(entry_ptr)->type->id]             \
+                 = (entry_ptr)->clears;                                  \
+    if ( (entry_ptr)->flushes >                                          \
+            ((cache_ptr)->max_flushes)[(entry_ptr)->type->id] )          \
+        ((cache_ptr)->max_flushes)[(entry_ptr)->type->id]                \
+            = (entry_ptr)->flushes;                                      \
+    if ( (entry_ptr)->size >                                             \
+            ((cache_ptr)->max_size)[(entry_ptr)->type->id] )             \
+        ((cache_ptr)->max_size)[(entry_ptr)->type->id]                   \
+            = (entry_ptr)->size;                                         \
+    if ( (entry_ptr)->pins >                                             \
+            ((cache_ptr)->max_pins)[(entry_ptr)->type->id] )             \
+        ((cache_ptr)->max_pins)[(entry_ptr)->type->id]                   \
+            = (entry_ptr)->pins;                                         \
+}
+
+#define H5C__UPDATE_STATS_FOR_INSERTION(cache_ptr, entry_ptr)        \
+{                                                                    \
+    (((cache_ptr)->insertions)[(entry_ptr)->type->id])++;            \
+    if ( (entry_ptr)->is_pinned ) {                                  \
+        (((cache_ptr)->pinned_insertions)[(entry_ptr)->type->id])++; \
+        ((cache_ptr)->pins)[(entry_ptr)->type->id]++;                \
+        (entry_ptr)->pins++;                                         \
+        if ( (cache_ptr)->pel_len > (cache_ptr)->max_pel_len )       \
+            (cache_ptr)->max_pel_len = (cache_ptr)->pel_len;         \
+        if ( (cache_ptr)->pel_size > (cache_ptr)->max_pel_size )     \
+            (cache_ptr)->max_pel_size = (cache_ptr)->pel_size;       \
+    }                                                                \
+    if ( (cache_ptr)->index_len > (cache_ptr)->max_index_len )       \
+        (cache_ptr)->max_index_len = (cache_ptr)->index_len;         \
+    H5C__UPDATE_MAX_INDEX_SIZE_STATS(cache_ptr)                      \
+    if ( (cache_ptr)->slist_len > (cache_ptr)->max_slist_len )       \
+        (cache_ptr)->max_slist_len = (cache_ptr)->slist_len;         \
+    if ( (cache_ptr)->slist_size > (cache_ptr)->max_slist_size )     \
+        (cache_ptr)->max_slist_size = (cache_ptr)->slist_size;       \
+    if ( (entry_ptr)->size >                                         \
+            ((cache_ptr)->max_size)[(entry_ptr)->type->id] )         \
+        ((cache_ptr)->max_size)[(entry_ptr)->type->id]               \
+             = (entry_ptr)->size;                                    \
+    cache_ptr->entries_inserted_counter++;                           \
+}
+
+#define H5C__UPDATE_STATS_FOR_PROTECT(cache_ptr, entry_ptr, hit)            \
+{                                                                           \
+    if ( hit )                                                              \
+        ((cache_ptr)->hits)[(entry_ptr)->type->id]++;                       \
+    else                                                                    \
+        ((cache_ptr)->misses)[(entry_ptr)->type->id]++;                     \
+    if ( ! ((entry_ptr)->is_read_only) ) {                                  \
+        ((cache_ptr)->write_protects)[(entry_ptr)->type->id]++;             \
+    } else {                                                                \
+        ((cache_ptr)->read_protects)[(entry_ptr)->type->id]++;              \
+        if ( ((entry_ptr)->ro_ref_count) >                                  \
+                ((cache_ptr)->max_read_protects)[(entry_ptr)->type->id] )   \
+            ((cache_ptr)->max_read_protects)[(entry_ptr)->type->id] =       \
+                    ((entry_ptr)->ro_ref_count);                            \
+    }                                                                       \
+    if ( (cache_ptr)->index_len > (cache_ptr)->max_index_len )              \
+        (cache_ptr)->max_index_len = (cache_ptr)->index_len;                \
+    H5C__UPDATE_MAX_INDEX_SIZE_STATS(cache_ptr)                             \
+    if ( (cache_ptr)->pl_len > (cache_ptr)->max_pl_len )                    \
+        (cache_ptr)->max_pl_len = (cache_ptr)->pl_len;                      \
+    if ( (cache_ptr)->pl_size > (cache_ptr)->max_pl_size )                  \
+        (cache_ptr)->max_pl_size = (cache_ptr)->pl_size;                    \
+    if ( (entry_ptr)->size >                                                \
+            ((cache_ptr)->max_size)[(entry_ptr)->type->id] )                \
+        ((cache_ptr)->max_size)[(entry_ptr)->type->id] = (entry_ptr)->size; \
+    ((entry_ptr)->accesses)++;                                              \
+}
+
+#define H5C__UPDATE_STATS_FOR_PIN(cache_ptr, entry_ptr)      \
+{                                                            \
+    ((cache_ptr)->pins)[(entry_ptr)->type->id]++;            \
+    (entry_ptr)->pins++;                                     \
+    if ( (cache_ptr)->pel_len > (cache_ptr)->max_pel_len )   \
+        (cache_ptr)->max_pel_len = (cache_ptr)->pel_len;     \
+    if ( (cache_ptr)->pel_size > (cache_ptr)->max_pel_size ) \
+        (cache_ptr)->max_pel_size = (cache_ptr)->pel_size;   \
+}
+
+#else /* H5C_COLLECT_CACHE_ENTRY_STATS */
+
+#define H5C__RESET_CACHE_ENTRY_STATS(entry_ptr)
+
+#define H5C__UPDATE_STATS_FOR_CLEAR(cache_ptr, entry_ptr)         \
+{                                                                 \
+    (((cache_ptr)->clears)[(entry_ptr)->type->id])++;             \
+    if((entry_ptr)->is_pinned)                                    \
+        (((cache_ptr)->pinned_clears)[(entry_ptr)->type->id])++;  \
+}
+
+#define H5C__UPDATE_STATS_FOR_FLUSH(cache_ptr, entry_ptr)         \
+{                                                                 \
+    (((cache_ptr)->flushes)[(entry_ptr)->type->id])++;            \
+    if ( (entry_ptr)->is_pinned )                                 \
+        (((cache_ptr)->pinned_flushes)[(entry_ptr)->type->id])++; \
+}
+
+#define H5C__UPDATE_STATS_FOR_EVICTION(cache_ptr, entry_ptr, take_ownership) \
+{                                                                            \
+    if ( take_ownership )                                                    \
+        (((cache_ptr)->take_ownerships)[(entry_ptr)->type->id])++;           \
+    else                                                                     \
+        (((cache_ptr)->evictions)[(entry_ptr)->type->id])++;                 \
+}
+
+#define H5C__UPDATE_STATS_FOR_INSERTION(cache_ptr, entry_ptr)        \
+{                                                                    \
+    (((cache_ptr)->insertions)[(entry_ptr)->type->id])++;            \
+    if ( (entry_ptr)->is_pinned ) {                                  \
+        (((cache_ptr)->pinned_insertions)[(entry_ptr)->type->id])++; \
+        ((cache_ptr)->pins)[(entry_ptr)->type->id]++;                \
+        if ( (cache_ptr)->pel_len > (cache_ptr)->max_pel_len )       \
+            (cache_ptr)->max_pel_len = (cache_ptr)->pel_len;         \
+        if ( (cache_ptr)->pel_size > (cache_ptr)->max_pel_size )     \
+            (cache_ptr)->max_pel_size = (cache_ptr)->pel_size;       \
+    }                                                                \
+    if ( (cache_ptr)->index_len > (cache_ptr)->max_index_len )       \
+        (cache_ptr)->max_index_len = (cache_ptr)->index_len;         \
+    H5C__UPDATE_MAX_INDEX_SIZE_STATS(cache_ptr)                      \
+    if ( (cache_ptr)->slist_len > (cache_ptr)->max_slist_len )       \
+        (cache_ptr)->max_slist_len = (cache_ptr)->slist_len;         \
+    if ( (cache_ptr)->slist_size > (cache_ptr)->max_slist_size )     \
+        (cache_ptr)->max_slist_size = (cache_ptr)->slist_size;       \
+    cache_ptr->entries_inserted_counter++;                           \
+}
+
+#define H5C__UPDATE_STATS_FOR_PROTECT(cache_ptr, entry_ptr, hit)            \
+{                                                                           \
+    if ( hit )                                                              \
+        ((cache_ptr)->hits)[(entry_ptr)->type->id]++;                       \
+    else                                                                    \
+        ((cache_ptr)->misses)[(entry_ptr)->type->id]++;                     \
+    if ( ! ((entry_ptr)->is_read_only) )                                    \
+        ((cache_ptr)->write_protects)[(entry_ptr)->type->id]++;             \
+    else {                                                                  \
+        ((cache_ptr)->read_protects)[(entry_ptr)->type->id]++;              \
+        if ( ((entry_ptr)->ro_ref_count) >                                  \
+                ((cache_ptr)->max_read_protects)[(entry_ptr)->type->id] )   \
+            ((cache_ptr)->max_read_protects)[(entry_ptr)->type->id] =       \
+                    ((entry_ptr)->ro_ref_count);                            \
+    }                                                                       \
+    if ( (cache_ptr)->index_len > (cache_ptr)->max_index_len )              \
+        (cache_ptr)->max_index_len = (cache_ptr)->index_len;                \
+    H5C__UPDATE_MAX_INDEX_SIZE_STATS(cache_ptr)                             \
+    if ( (cache_ptr)->pl_len > (cache_ptr)->max_pl_len )                    \
+        (cache_ptr)->max_pl_len = (cache_ptr)->pl_len;                      \
+    if ( (cache_ptr)->pl_size > (cache_ptr)->max_pl_size )                  \
+        (cache_ptr)->max_pl_size = (cache_ptr)->pl_size;                    \
+}
+
+#define H5C__UPDATE_STATS_FOR_PIN(cache_ptr, entry_ptr)      \
+{                                                            \
+    ((cache_ptr)->pins)[(entry_ptr)->type->id]++;            \
+    if ( (cache_ptr)->pel_len > (cache_ptr)->max_pel_len )   \
+        (cache_ptr)->max_pel_len = (cache_ptr)->pel_len;     \
+    if ( (cache_ptr)->pel_size > (cache_ptr)->max_pel_size ) \
+        (cache_ptr)->max_pel_size = (cache_ptr)->pel_size;   \
+}
+
+#endif /* H5C_COLLECT_CACHE_ENTRY_STATS */
+
+#else /* H5C_COLLECT_CACHE_STATS */
+
+#define H5C__RESET_CACHE_ENTRY_STATS(entry_ptr)
+#define H5C__UPDATE_STATS_FOR_DIRTY_PIN(cache_ptr, entry_ptr)
+#define H5C__UPDATE_STATS_FOR_UNPROTECT(cache_ptr)
+#define H5C__UPDATE_STATS_FOR_MOVE(cache_ptr, entry_ptr)
+#define H5C__UPDATE_STATS_FOR_ENTRY_SIZE_CHANGE(cache_ptr, entry_ptr, new_size)
+#define H5C__UPDATE_STATS_FOR_HT_INSERTION(cache_ptr)
+#define H5C__UPDATE_STATS_FOR_HT_DELETION(cache_ptr)
+#define H5C__UPDATE_STATS_FOR_HT_SEARCH(cache_ptr, success, depth)
+#define H5C__UPDATE_STATS_FOR_INSERTION(cache_ptr, entry_ptr)
+#define H5C__UPDATE_STATS_FOR_CLEAR(cache_ptr, entry_ptr)
+#define H5C__UPDATE_STATS_FOR_FLUSH(cache_ptr, entry_ptr)
+#define H5C__UPDATE_STATS_FOR_EVICTION(cache_ptr, entry_ptr, take_ownership)
+#define H5C__UPDATE_STATS_FOR_PROTECT(cache_ptr, entry_ptr, hit)
+#define H5C__UPDATE_STATS_FOR_PIN(cache_ptr, entry_ptr)
+#define H5C__UPDATE_STATS_FOR_UNPIN(cache_ptr, entry_ptr)
+#define H5C__UPDATE_STATS_FOR_SLIST_SCAN_RESTART(cache_ptr)
+#define H5C__UPDATE_STATS_FOR_LRU_SCAN_RESTART(cache_ptr)
+#define H5C__UPDATE_STATS_FOR_INDEX_SCAN_RESTART(cache_ptr)
+#define H5C__UPDATE_STATS_FOR_CACHE_IMAGE_CREATE(cache_ptr)
+#define H5C__UPDATE_STATS_FOR_CACHE_IMAGE_READ(cache_ptr)
+#define H5C__UPDATE_STATS_FOR_CACHE_IMAGE_LOAD(cache_ptr)
+#define H5C__UPDATE_STATS_FOR_PREFETCH(cache_ptr, dirty)
+#define H5C__UPDATE_STATS_FOR_PREFETCH_HIT(cache_ptr)
+
+#endif /* H5C_COLLECT_CACHE_STATS */
+
+

+/***********************************************************************
+ *
+ * Hash table access and manipulation macros:
+ *
+ * The following macros handle searches, insertions, and deletion in
+ * the hash table.
+ *
+ * When modifying these macros, remember to modify the similar macros
+ * in tst/cache.c
+ *
+ * Changes:
+ *
+ *   - Updated existing index macros and sanity check macros to maintain
+ *     the clean_index_size and dirty_index_size fields of H5C_t.  Also
+ *     added macros to allow us to track entry cleans and dirties.
+ *
+ *     						JRM -- 11/5/08
+ *
+ *   - Updated existing index macros and sanity check macros to maintain 
+ *     the index_ring_len, index_ring_size, clean_index_ring_size, and
+ *     dirty_index_ring_size fields of H5C_t.
+ *
+ *						JRM -- 9/1/15
+ *
+ *   - Updated existing index macros and sanity checks macros to 
+ *     maintain an doubly linked list of all entries in the index.
+ *     This is necessary to reduce the computational cost of visiting
+ *     all entries in the index, which used to be done by scanning 
+ *     the hash table.
+ *
+ *                                              JRM -- 10/15/15
+ *
+ ***********************************************************************/
+
+/* H5C__HASH_TABLE_LEN is defined in H5Cpkg.h.  It mut be a power of two. */
+
+#define H5C__HASH_MASK		((size_t)(H5C__HASH_TABLE_LEN - 1) << 3)
+
+#define H5C__HASH_FCN(x)	(int)((unsigned)((x) & H5C__HASH_MASK) >> 3)
+
+#if H5C_DO_SANITY_CHECKS
+
+#define H5C__PRE_HT_INSERT_SC(cache_ptr, entry_ptr, fail_val)           \
+if ( ( (cache_ptr) == NULL ) ||                                         \
+     ( (cache_ptr)->magic != H5C__H5C_T_MAGIC ) ||                      \
+     ( (entry_ptr) == NULL ) ||                                         \
+     ( ! H5F_addr_defined((entry_ptr)->addr) ) ||                       \
+     ( (entry_ptr)->ht_next != NULL ) ||                                \
+     ( (entry_ptr)->ht_prev != NULL ) ||                                \
+     ( (entry_ptr)->size <= 0 ) ||                                      \
+     ( H5C__HASH_FCN((entry_ptr)->addr) < 0 ) ||                        \
+     ( H5C__HASH_FCN((entry_ptr)->addr) >= H5C__HASH_TABLE_LEN ) ||     \
+     ( (cache_ptr)->index_size !=                                       \
+       ((cache_ptr)->clean_index_size +                                 \
+	(cache_ptr)->dirty_index_size) ) ||                             \
+     ( (cache_ptr)->index_size < ((cache_ptr)->clean_index_size) ) ||   \
+     ( (cache_ptr)->index_size < ((cache_ptr)->dirty_index_size) ) ||   \
+     ( (entry_ptr)->ring <= H5C_RING_UNDEFINED ) ||                     \
+     ( (entry_ptr)->ring >= H5C_RING_NTYPES ) ||                        \
+     ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] >                 \
+       (cache_ptr)->index_len ) ||                                      \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] >                \
+       (cache_ptr)->index_size ) ||                                     \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] !=               \
+       ((cache_ptr)->clean_index_ring_size[(entry_ptr)->ring] +         \
+        (cache_ptr)->dirty_index_ring_size[(entry_ptr)->ring]) ) ||     \
+     ( (cache_ptr)->index_len != (cache_ptr)->il_len ) ||               \
+     ( (cache_ptr)->index_size != (cache_ptr)->il_size ) ) {            \
+    HDassert(FALSE);                                                    \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, fail_val, "pre HT insert SC failed") \
+}
+
+#define H5C__POST_HT_INSERT_SC(cache_ptr, entry_ptr, fail_val)          \
+if ( ( (cache_ptr) == NULL ) ||                                         \
+     ( (cache_ptr)->magic != H5C__H5C_T_MAGIC ) ||                      \
+     ( (cache_ptr)->index_size !=                                       \
+       ((cache_ptr)->clean_index_size +                                 \
+	(cache_ptr)->dirty_index_size) ) ||                             \
+     ( (cache_ptr)->index_size < ((cache_ptr)->clean_index_size) ) ||   \
+     ( (cache_ptr)->index_size < ((cache_ptr)->dirty_index_size) ) ||   \
+     ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] == 0 ) ||         \
+     ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] >                 \
+       (cache_ptr)->index_len ) ||                                      \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] >                \
+       (cache_ptr)->index_size ) ||                                     \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] !=               \
+       ((cache_ptr)->clean_index_ring_size[(entry_ptr)->ring] +         \
+        (cache_ptr)->dirty_index_ring_size[(entry_ptr)->ring]) ) ||     \
+     ( (cache_ptr)->index_len != (cache_ptr)->il_len ) ||               \
+     ( (cache_ptr)->index_size != (cache_ptr)->il_size) ) {             \
+    HDassert(FALSE);                                                    \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, fail_val, "post HT insert SC failed") \
+}
+
+#define H5C__PRE_HT_REMOVE_SC(cache_ptr, entry_ptr)                     \
+if ( ( (cache_ptr) == NULL ) ||                                         \
+     ( (cache_ptr)->magic != H5C__H5C_T_MAGIC ) ||                      \
+     ( (cache_ptr)->index_len < 1 ) ||                                  \
+     ( (entry_ptr) == NULL ) ||                                         \
+     ( (cache_ptr)->index_size < (entry_ptr)->size ) ||                 \
+     ( ! H5F_addr_defined((entry_ptr)->addr) ) ||                       \
+     ( (entry_ptr)->size <= 0 ) ||                                      \
+     ( H5C__HASH_FCN((entry_ptr)->addr) < 0 ) ||                        \
+     ( H5C__HASH_FCN((entry_ptr)->addr) >= H5C__HASH_TABLE_LEN ) ||     \
+     ( ((cache_ptr)->index)[(H5C__HASH_FCN((entry_ptr)->addr))]         \
+       == NULL ) ||                                                     \
+     ( ( ((cache_ptr)->index)[(H5C__HASH_FCN((entry_ptr)->addr))]       \
+       != (entry_ptr) ) &&                                              \
+       ( (entry_ptr)->ht_prev == NULL ) ) ||                            \
+     ( ( ((cache_ptr)->index)[(H5C__HASH_FCN((entry_ptr)->addr))] ==    \
+         (entry_ptr) ) &&                                               \
+       ( (entry_ptr)->ht_prev != NULL ) ) ||                            \
+     ( (cache_ptr)->index_size !=                                       \
+       ((cache_ptr)->clean_index_size +                                 \
+	(cache_ptr)->dirty_index_size) ) ||                             \
+     ( (cache_ptr)->index_size < ((cache_ptr)->clean_index_size) ) ||   \
+     ( (cache_ptr)->index_size < ((cache_ptr)->dirty_index_size) ) ||   \
+     ( (entry_ptr)->ring <= H5C_RING_UNDEFINED ) ||                     \
+     ( (entry_ptr)->ring >= H5C_RING_NTYPES ) ||                        \
+     ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] <= 0 ) ||         \
+     ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] >                 \
+       (cache_ptr)->index_len ) ||                                      \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] <                \
+       (entry_ptr)->size ) ||                                           \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] >                \
+       (cache_ptr)->index_size ) ||                                     \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] !=               \
+       ((cache_ptr)->clean_index_ring_size[(entry_ptr)->ring] +         \
+        (cache_ptr)->dirty_index_ring_size[(entry_ptr)->ring]) ) ||     \
+     ( (cache_ptr)->index_len != (cache_ptr)->il_len ) ||               \
+     ( (cache_ptr)->index_size != (cache_ptr)->il_size ) ) {            \
+    HDassert(FALSE);                                                    \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, FAIL, "pre HT remove SC failed") \
+}
+
+#define H5C__POST_HT_REMOVE_SC(cache_ptr, entry_ptr)                     \
+if ( ( (cache_ptr) == NULL ) ||                                          \
+     ( (cache_ptr)->magic != H5C__H5C_T_MAGIC ) ||                       \
+     ( (entry_ptr) == NULL ) ||                                          \
+     ( ! H5F_addr_defined((entry_ptr)->addr) ) ||                        \
+     ( (entry_ptr)->size <= 0 ) ||                                       \
+     ( (entry_ptr)->ht_prev != NULL ) ||                                 \
+     ( (entry_ptr)->ht_prev != NULL ) ||                                 \
+     ( (cache_ptr)->index_size !=                                        \
+       ((cache_ptr)->clean_index_size +                                  \
+	(cache_ptr)->dirty_index_size) ) ||                              \
+     ( (cache_ptr)->index_size < ((cache_ptr)->clean_index_size) ) ||    \
+     ( (cache_ptr)->index_size < ((cache_ptr)->dirty_index_size) ) ||    \
+     ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] >                  \
+       (cache_ptr)->index_len ) ||                                       \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] >                 \
+       (cache_ptr)->index_size ) ||                                      \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] !=                \
+       ((cache_ptr)->clean_index_ring_size[(entry_ptr)->ring] +          \
+        (cache_ptr)->dirty_index_ring_size[(entry_ptr)->ring]) ) ||      \
+     ( (cache_ptr)->index_len != (cache_ptr)->il_len ) ||                \
+     ( (cache_ptr)->index_size != (cache_ptr)->il_size ) ) {             \
+    HDassert(FALSE);                                                     \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, FAIL, "post HT remove SC failed") \
+}
+
+/* (Keep in sync w/H5C_TEST__PRE_HT_SEARCH_SC macro in test/cache_common.h -QAK) */
+#define H5C__PRE_HT_SEARCH_SC(cache_ptr, Addr, fail_val)                    \
+if ( ( (cache_ptr) == NULL ) ||                                             \
+     ( (cache_ptr)->magic != H5C__H5C_T_MAGIC ) ||                          \
+     ( (cache_ptr)->index_size !=                                           \
+       ((cache_ptr)->clean_index_size + (cache_ptr)->dirty_index_size) ) || \
+     ( ! H5F_addr_defined(Addr) ) ||                                        \
+     ( H5C__HASH_FCN(Addr) < 0 ) ||                                         \
+     ( H5C__HASH_FCN(Addr) >= H5C__HASH_TABLE_LEN ) ) {                     \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, fail_val, "pre HT search SC failed") \
+}
+
+/* (Keep in sync w/H5C_TEST__POST_SUC_HT_SEARCH_SC macro in test/cache_common.h -QAK) */
+#define H5C__POST_SUC_HT_SEARCH_SC(cache_ptr, entry_ptr, k, fail_val)       \
+if ( ( (cache_ptr) == NULL ) ||                                             \
+     ( (cache_ptr)->magic != H5C__H5C_T_MAGIC ) ||                          \
+     ( (cache_ptr)->index_len < 1 ) ||                                      \
+     ( (entry_ptr) == NULL ) ||                                             \
+     ( (cache_ptr)->index_size < (entry_ptr)->size ) ||                     \
+     ( (cache_ptr)->index_size !=                                           \
+       ((cache_ptr)->clean_index_size + (cache_ptr)->dirty_index_size) ) || \
+     ( (entry_ptr)->size <= 0 ) ||                                          \
+     ( ((cache_ptr)->index)[k] == NULL ) ||                                 \
+     ( ( ((cache_ptr)->index)[k] != (entry_ptr) ) &&                        \
+       ( (entry_ptr)->ht_prev == NULL ) ) ||                                \
+     ( ( ((cache_ptr)->index)[k] == (entry_ptr) ) &&                        \
+       ( (entry_ptr)->ht_prev != NULL ) ) ||                                \
+     ( ( (entry_ptr)->ht_prev != NULL ) &&                                  \
+       ( (entry_ptr)->ht_prev->ht_next != (entry_ptr) ) ) ||                \
+     ( ( (entry_ptr)->ht_next != NULL ) &&                                  \
+       ( (entry_ptr)->ht_next->ht_prev != (entry_ptr) ) ) ) {               \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, fail_val, "post successful HT search SC failed") \
+}
+
+/* (Keep in sync w/H5C_TEST__POST_HT_SHIFT_TO_FRONT macro in test/cache_common.h -QAK) */
+#define H5C__POST_HT_SHIFT_TO_FRONT(cache_ptr, entry_ptr, k, fail_val) \
+if ( ( (cache_ptr) == NULL ) ||                                        \
+     ( ((cache_ptr)->index)[k] != (entry_ptr) ) ||                     \
+     ( (entry_ptr)->ht_prev != NULL ) ) {                              \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, fail_val, "post HT shift to front SC failed") \
+}
+
+#define H5C__PRE_HT_ENTRY_SIZE_CHANGE_SC(cache_ptr, old_size, new_size, \
+		                         entry_ptr, was_clean)          \
+if ( ( (cache_ptr) == NULL ) ||                                         \
+     ( (cache_ptr)->index_len <= 0 ) ||                                 \
+     ( (cache_ptr)->index_size <= 0 ) ||                                \
+     ( (new_size) <= 0 ) ||                                             \
+     ( (old_size) > (cache_ptr)->index_size ) ||                        \
+     ( ( (cache_ptr)->index_len == 1 ) &&                               \
+       ( (cache_ptr)->index_size != (old_size) ) ) ||                   \
+     ( (cache_ptr)->index_size !=                                       \
+       ((cache_ptr)->clean_index_size +                                 \
+        (cache_ptr)->dirty_index_size) ) ||                             \
+     ( (cache_ptr)->index_size < ((cache_ptr)->clean_index_size) ) ||   \
+     ( (cache_ptr)->index_size < ((cache_ptr)->dirty_index_size) ) ||   \
+     ( ( !( was_clean ) ||                                              \
+	    ( (cache_ptr)->clean_index_size < (old_size) ) ) &&         \
+	  ( ( (was_clean) ) ||                                          \
+	    ( (cache_ptr)->dirty_index_size < (old_size) ) ) ) ||       \
+     ( (entry_ptr) == NULL ) ||                                         \
+     ( (entry_ptr)->ring <= H5C_RING_UNDEFINED ) ||                     \
+     ( (entry_ptr)->ring >= H5C_RING_NTYPES ) ||                        \
+     ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] <= 0 ) ||         \
+     ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] >                 \
+       (cache_ptr)->index_len ) ||                                      \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] >                \
+       (cache_ptr)->index_size ) ||                                     \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] !=               \
+       ((cache_ptr)->clean_index_ring_size[(entry_ptr)->ring] +         \
+        (cache_ptr)->dirty_index_ring_size[(entry_ptr)->ring]) ) ||     \
+     ( (cache_ptr)->index_len != (cache_ptr)->il_len ) ||               \
+     ( (cache_ptr)->index_size != (cache_ptr)->il_size ) ) {            \
+    HDassert(FALSE);                                                    \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, FAIL, "pre HT entry size change SC failed") \
+}
+
+#define H5C__POST_HT_ENTRY_SIZE_CHANGE_SC(cache_ptr, old_size, new_size,  \
+		                          entry_ptr)                      \
+if ( ( (cache_ptr) == NULL ) ||                                           \
+     ( (cache_ptr)->index_len <= 0 ) ||                                   \
+     ( (cache_ptr)->index_size <= 0 ) ||                                  \
+     ( (new_size) > (cache_ptr)->index_size ) ||                          \
+     ( (cache_ptr)->index_size !=                                         \
+	  ((cache_ptr)->clean_index_size +                                \
+           (cache_ptr)->dirty_index_size) ) ||                            \
+     ( (cache_ptr)->index_size < ((cache_ptr)->clean_index_size) ) ||     \
+     ( (cache_ptr)->index_size < ((cache_ptr)->dirty_index_size) ) ||     \
+     ( ( !((entry_ptr)->is_dirty ) ||                                     \
+	    ( (cache_ptr)->dirty_index_size < (new_size) ) ) &&           \
+	  ( ( ((entry_ptr)->is_dirty)  ) ||                               \
+	    ( (cache_ptr)->clean_index_size < (new_size) ) ) ) ||         \
+     ( ( (cache_ptr)->index_len == 1 ) &&                                 \
+       ( (cache_ptr)->index_size != (new_size) ) ) ||                     \
+     ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] >                   \
+       (cache_ptr)->index_len ) ||                                        \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] >                  \
+       (cache_ptr)->index_size ) ||                                       \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] !=                 \
+       ((cache_ptr)->clean_index_ring_size[(entry_ptr)->ring] +           \
+        (cache_ptr)->dirty_index_ring_size[(entry_ptr)->ring]) ) ||       \
+     ( (cache_ptr)->index_len != (cache_ptr)->il_len ) ||                 \
+     ( (cache_ptr)->index_size != (cache_ptr)->il_size ) ) {              \
+    HDassert(FALSE);                                                      \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, FAIL, "post HT entry size change SC failed") \
+}
+
+#define H5C__PRE_HT_UPDATE_FOR_ENTRY_CLEAN_SC(cache_ptr, entry_ptr)           \
+if (                                                                          \
+    ( (cache_ptr) == NULL ) ||                                                \
+    ( (cache_ptr)->magic != H5C__H5C_T_MAGIC ) ||                             \
+    ( (cache_ptr)->index_len <= 0 ) ||                                        \
+    ( (entry_ptr) == NULL ) ||                                                \
+    ( (entry_ptr)->is_dirty != FALSE ) ||                                     \
+    ( (cache_ptr)->index_size < (entry_ptr)->size ) ||                        \
+    ( (cache_ptr)->dirty_index_size < (entry_ptr)->size ) ||                  \
+    ( (cache_ptr)->index_size !=                                              \
+       ((cache_ptr)->clean_index_size + (cache_ptr)->dirty_index_size) ) ||   \
+    ( (cache_ptr)->index_size < ((cache_ptr)->clean_index_size) ) ||          \
+    ( (cache_ptr)->index_size < ((cache_ptr)->dirty_index_size) ) ||          \
+    ( (entry_ptr)->ring <= H5C_RING_UNDEFINED ) ||                            \
+    ( (entry_ptr)->ring >= H5C_RING_NTYPES ) ||                               \
+    ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] <= 0 ) ||                \
+    ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] >                        \
+      (cache_ptr)->index_len ) ||                                             \
+    ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] >                       \
+      (cache_ptr)->index_size ) ||                                            \
+    ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] !=                      \
+      ((cache_ptr)->clean_index_ring_size[(entry_ptr)->ring] +                \
+       (cache_ptr)->dirty_index_ring_size[(entry_ptr)->ring]) ) ) {           \
+    HDassert(FALSE);                                                          \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, FAIL, "pre HT update for entry clean SC failed") \
+}
+
+#define H5C__PRE_HT_UPDATE_FOR_ENTRY_DIRTY_SC(cache_ptr, entry_ptr)           \
+if (                                                                          \
+    ( (cache_ptr) == NULL ) ||                                                \
+    ( (cache_ptr)->magic != H5C__H5C_T_MAGIC ) ||                             \
+    ( (cache_ptr)->index_len <= 0 ) ||                                        \
+    ( (entry_ptr) == NULL ) ||                                                \
+    ( (entry_ptr)->is_dirty != TRUE ) ||                                      \
+    ( (cache_ptr)->index_size < (entry_ptr)->size ) ||                        \
+    ( (cache_ptr)->clean_index_size < (entry_ptr)->size ) ||                  \
+    ( (cache_ptr)->index_size !=                                              \
+       ((cache_ptr)->clean_index_size + (cache_ptr)->dirty_index_size) ) ||   \
+    ( (cache_ptr)->index_size < ((cache_ptr)->clean_index_size) ) ||          \
+    ( (cache_ptr)->index_size < ((cache_ptr)->dirty_index_size) ) ||          \
+    ( (entry_ptr)->ring <= H5C_RING_UNDEFINED ) ||                            \
+    ( (entry_ptr)->ring >= H5C_RING_NTYPES ) ||                               \
+    ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] <= 0 ) ||                \
+    ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] >                        \
+      (cache_ptr)->index_len ) ||                                             \
+    ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] >                       \
+      (cache_ptr)->index_size ) ||                                            \
+    ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] !=                      \
+      ((cache_ptr)->clean_index_ring_size[(entry_ptr)->ring] +                \
+       (cache_ptr)->dirty_index_ring_size[(entry_ptr)->ring]) ) ) {           \
+    HDassert(FALSE);                                                          \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, FAIL, "pre HT update for entry dirty SC failed") \
+}
+
+#define H5C__POST_HT_UPDATE_FOR_ENTRY_CLEAN_SC(cache_ptr, entry_ptr)        \
+if ( ( (cache_ptr)->index_size !=                                           \
+       ((cache_ptr)->clean_index_size + (cache_ptr)->dirty_index_size) ) || \
+     ( (cache_ptr)->index_size < ((cache_ptr)->clean_index_size) ) ||       \
+     ( (cache_ptr)->index_size < ((cache_ptr)->dirty_index_size) ) ||       \
+     ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] >                     \
+       (cache_ptr)->index_len ) ||                                          \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] >                    \
+       (cache_ptr)->index_size ) ||                                         \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] !=                   \
+       ((cache_ptr)->clean_index_ring_size[(entry_ptr)->ring] +             \
+        (cache_ptr)->dirty_index_ring_size[(entry_ptr)->ring]) ) ) {        \
+    HDassert(FALSE);                                                        \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, FAIL, "post HT update for entry clean SC failed") \
+}
+
+#define H5C__POST_HT_UPDATE_FOR_ENTRY_DIRTY_SC(cache_ptr, entry_ptr)        \
+if ( ( (cache_ptr)->index_size !=                                           \
+       ((cache_ptr)->clean_index_size + (cache_ptr)->dirty_index_size) ) || \
+     ( (cache_ptr)->index_size < ((cache_ptr)->clean_index_size) ) ||       \
+     ( (cache_ptr)->index_size < ((cache_ptr)->dirty_index_size) ) ||       \
+     ( (cache_ptr)->index_ring_len[(entry_ptr)->ring] >                     \
+       (cache_ptr)->index_len ) ||                                          \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] >                    \
+       (cache_ptr)->index_size ) ||                                         \
+     ( (cache_ptr)->index_ring_size[(entry_ptr)->ring] !=                   \
+       ((cache_ptr)->clean_index_ring_size[(entry_ptr)->ring] +             \
+        (cache_ptr)->dirty_index_ring_size[(entry_ptr)->ring]) ) ) {        \
+    HDassert(FALSE);                                                        \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, FAIL, "post HT update for entry dirty SC failed") \
+}
+
+#else /* H5C_DO_SANITY_CHECKS */
+
+#define H5C__PRE_HT_INSERT_SC(cache_ptr, entry_ptr, fail_val)
+#define H5C__POST_HT_INSERT_SC(cache_ptr, entry_ptr, fail_val)
+#define H5C__PRE_HT_REMOVE_SC(cache_ptr, entry_ptr)
+#define H5C__POST_HT_REMOVE_SC(cache_ptr, entry_ptr)
+#define H5C__PRE_HT_SEARCH_SC(cache_ptr, Addr, fail_val)
+#define H5C__POST_SUC_HT_SEARCH_SC(cache_ptr, entry_ptr, k, fail_val)
+#define H5C__POST_HT_SHIFT_TO_FRONT(cache_ptr, entry_ptr, k, fail_val)
+#define H5C__PRE_HT_UPDATE_FOR_ENTRY_CLEAN_SC(cache_ptr, entry_ptr)
+#define H5C__PRE_HT_UPDATE_FOR_ENTRY_DIRTY_SC(cache_ptr, entry_ptr)
+#define H5C__PRE_HT_ENTRY_SIZE_CHANGE_SC(cache_ptr, old_size, new_size, \
+		                         entry_ptr, was_clean)
+#define H5C__POST_HT_ENTRY_SIZE_CHANGE_SC(cache_ptr, old_size, new_size, \
+		                          entry_ptr)
+#define H5C__POST_HT_UPDATE_FOR_ENTRY_CLEAN_SC(cache_ptr, entry_ptr)
+#define H5C__POST_HT_UPDATE_FOR_ENTRY_DIRTY_SC(cache_ptr, entry_ptr)
+
+#endif /* H5C_DO_SANITY_CHECKS */
+
+
+#define H5C__INSERT_IN_INDEX(cache_ptr, entry_ptr, fail_val)                 \
+{                                                                            \
+    int k;                                                                   \
+    H5C__PRE_HT_INSERT_SC(cache_ptr, entry_ptr, fail_val)                    \
+    k = H5C__HASH_FCN((entry_ptr)->addr);                                    \
+    if(((cache_ptr)->index)[k] != NULL) {                                    \
+        (entry_ptr)->ht_next = ((cache_ptr)->index)[k];                      \
+        (entry_ptr)->ht_next->ht_prev = (entry_ptr);                         \
+    }                                                                        \
+    ((cache_ptr)->index)[k] = (entry_ptr);                                   \
+    (cache_ptr)->index_len++;                                                \
+    (cache_ptr)->index_size += (entry_ptr)->size;                            \
+    ((cache_ptr)->index_ring_len[entry_ptr->ring])++;                        \
+    ((cache_ptr)->index_ring_size[entry_ptr->ring])                          \
+            += (entry_ptr)->size;                                            \
+    if((entry_ptr)->is_dirty) {                                              \
+        (cache_ptr)->dirty_index_size += (entry_ptr)->size;                  \
+        ((cache_ptr)->dirty_index_ring_size[entry_ptr->ring])                \
+                += (entry_ptr)->size;                                        \
+    } else {                                                                 \
+        (cache_ptr)->clean_index_size += (entry_ptr)->size;                  \
+        ((cache_ptr)->clean_index_ring_size[entry_ptr->ring])                \
+                += (entry_ptr)->size;                                        \
+    }                                                                        \
+    if((entry_ptr)->flush_me_last) {                                         \
+        (cache_ptr)->num_last_entries++;                                     \
+        HDassert((cache_ptr)->num_last_entries <= 2);                        \
+    }                                                                        \
+    H5C__IL_DLL_APPEND((entry_ptr), (cache_ptr)->il_head,                    \
+                       (cache_ptr)->il_tail, (cache_ptr)->il_len,            \
+                       (cache_ptr)->il_size, fail_val)                       \
+    H5C__UPDATE_STATS_FOR_HT_INSERTION(cache_ptr)                            \
+    H5C__POST_HT_INSERT_SC(cache_ptr, entry_ptr, fail_val)                   \
+}
+
+#define H5C__DELETE_FROM_INDEX(cache_ptr, entry_ptr, fail_val)               \
+{                                                                            \
+    int k;                                                                   \
+    H5C__PRE_HT_REMOVE_SC(cache_ptr, entry_ptr)                              \
+    k = H5C__HASH_FCN((entry_ptr)->addr);                                    \
+    if((entry_ptr)->ht_next)                                                 \
+        (entry_ptr)->ht_next->ht_prev = (entry_ptr)->ht_prev;                \
+    if((entry_ptr)->ht_prev)                                                 \
+        (entry_ptr)->ht_prev->ht_next = (entry_ptr)->ht_next;                \
+    if(((cache_ptr)->index)[k] == (entry_ptr))                               \
+        ((cache_ptr)->index)[k] = (entry_ptr)->ht_next;                      \
+    (entry_ptr)->ht_next = NULL;                                             \
+    (entry_ptr)->ht_prev = NULL;                                             \
+    (cache_ptr)->index_len--;                                                \
+    (cache_ptr)->index_size -= (entry_ptr)->size;                            \
+    ((cache_ptr)->index_ring_len[entry_ptr->ring])--;                        \
+    ((cache_ptr)->index_ring_size[entry_ptr->ring])                          \
+            -= (entry_ptr)->size;                                            \
+    if((entry_ptr)->is_dirty) {                                              \
+        (cache_ptr)->dirty_index_size -= (entry_ptr)->size;                  \
+        ((cache_ptr)->dirty_index_ring_size[entry_ptr->ring])                \
+                -= (entry_ptr)->size;                                        \
+    } else {                                                                 \
+        (cache_ptr)->clean_index_size -= (entry_ptr)->size;                  \
+        ((cache_ptr)->clean_index_ring_size[entry_ptr->ring])                \
+                -= (entry_ptr)->size;                                        \
+    }                                                                        \
+    if((entry_ptr)->flush_me_last) {                                         \
+        (cache_ptr)->num_last_entries--;                                     \
+        HDassert((cache_ptr)->num_last_entries <= 1);                        \
+    }                                                                        \
+    H5C__IL_DLL_REMOVE((entry_ptr), (cache_ptr)->il_head,                    \
+                       (cache_ptr)->il_tail, (cache_ptr)->il_len,            \
+                       (cache_ptr)->il_size, fail_val)                       \
+    H5C__UPDATE_STATS_FOR_HT_DELETION(cache_ptr)                             \
+    H5C__POST_HT_REMOVE_SC(cache_ptr, entry_ptr)                             \
+}
+
+#define H5C__SEARCH_INDEX(cache_ptr, Addr, entry_ptr, fail_val)             \
+{                                                                           \
+    int k;                                                                  \
+    int depth = 0;                                                          \
+    H5C__PRE_HT_SEARCH_SC(cache_ptr, Addr, fail_val)                        \
+    k = H5C__HASH_FCN(Addr);                                                \
+    entry_ptr = ((cache_ptr)->index)[k];                                    \
+    while(entry_ptr) {                                                      \
+        if(H5F_addr_eq(Addr, (entry_ptr)->addr)) {                          \
+            H5C__POST_SUC_HT_SEARCH_SC(cache_ptr, entry_ptr, k, fail_val)   \
+            if(entry_ptr != ((cache_ptr)->index)[k]) {                      \
+                if((entry_ptr)->ht_next)                                    \
+                    (entry_ptr)->ht_next->ht_prev = (entry_ptr)->ht_prev;   \
+                HDassert((entry_ptr)->ht_prev != NULL);                     \
+                (entry_ptr)->ht_prev->ht_next = (entry_ptr)->ht_next;       \
+                ((cache_ptr)->index)[k]->ht_prev = (entry_ptr);             \
+                (entry_ptr)->ht_next = ((cache_ptr)->index)[k];             \
+                (entry_ptr)->ht_prev = NULL;                                \
+                ((cache_ptr)->index)[k] = (entry_ptr);                      \
+                H5C__POST_HT_SHIFT_TO_FRONT(cache_ptr, entry_ptr, k, fail_val) \
+            }                                                               \
+            break;                                                          \
+        }                                                                   \
+        (entry_ptr) = (entry_ptr)->ht_next;                                 \
+        (depth)++;                                                          \
+    }                                                                       \
+    H5C__UPDATE_STATS_FOR_HT_SEARCH(cache_ptr, (entry_ptr != NULL), depth)  \
+}
+
+#define H5C__SEARCH_INDEX_NO_STATS(cache_ptr, Addr, entry_ptr, fail_val)    \
+{                                                                           \
+    int k;                                                                  \
+    H5C__PRE_HT_SEARCH_SC(cache_ptr, Addr, fail_val)                        \
+    k = H5C__HASH_FCN(Addr);                                                \
+    entry_ptr = ((cache_ptr)->index)[k];                                    \
+    while(entry_ptr) {                                                      \
+        if(H5F_addr_eq(Addr, (entry_ptr)->addr)) {                          \
+            H5C__POST_SUC_HT_SEARCH_SC(cache_ptr, entry_ptr, k, fail_val)   \
+            if(entry_ptr != ((cache_ptr)->index)[k]) {                      \
+                if((entry_ptr)->ht_next)                                    \
+                    (entry_ptr)->ht_next->ht_prev = (entry_ptr)->ht_prev;   \
+                HDassert((entry_ptr)->ht_prev != NULL);                     \
+                (entry_ptr)->ht_prev->ht_next = (entry_ptr)->ht_next;       \
+                ((cache_ptr)->index)[k]->ht_prev = (entry_ptr);             \
+                (entry_ptr)->ht_next = ((cache_ptr)->index)[k];             \
+                (entry_ptr)->ht_prev = NULL;                                \
+                ((cache_ptr)->index)[k] = (entry_ptr);                      \
+                H5C__POST_HT_SHIFT_TO_FRONT(cache_ptr, entry_ptr, k, fail_val) \
+            }                                                               \
+            break;                                                          \
+        }                                                                   \
+        (entry_ptr) = (entry_ptr)->ht_next;                                 \
+    }                                                                       \
+}
+
+#define H5C__UPDATE_INDEX_FOR_ENTRY_CLEAN(cache_ptr, entry_ptr)   \
+{                                                                 \
+    H5C__PRE_HT_UPDATE_FOR_ENTRY_CLEAN_SC(cache_ptr, entry_ptr);  \
+    (cache_ptr)->dirty_index_size -= (entry_ptr)->size;           \
+    ((cache_ptr)->dirty_index_ring_size[entry_ptr->ring])         \
+		-= (entry_ptr)->size;                             \
+    (cache_ptr)->clean_index_size += (entry_ptr)->size;           \
+    ((cache_ptr)->clean_index_ring_size[entry_ptr->ring])         \
+		+= (entry_ptr)->size;                             \
+    H5C__POST_HT_UPDATE_FOR_ENTRY_CLEAN_SC(cache_ptr, entry_ptr); \
+}
+
+#define H5C__UPDATE_INDEX_FOR_ENTRY_DIRTY(cache_ptr, entry_ptr)   \
+{                                                                 \
+    H5C__PRE_HT_UPDATE_FOR_ENTRY_DIRTY_SC(cache_ptr, entry_ptr);  \
+    (cache_ptr)->clean_index_size -= (entry_ptr)->size;           \
+    ((cache_ptr)->clean_index_ring_size[entry_ptr->ring])         \
+		-= (entry_ptr)->size;                             \
+    (cache_ptr)->dirty_index_size += (entry_ptr)->size;           \
+    ((cache_ptr)->dirty_index_ring_size[entry_ptr->ring])         \
+		+= (entry_ptr)->size;                             \
+    H5C__POST_HT_UPDATE_FOR_ENTRY_DIRTY_SC(cache_ptr, entry_ptr); \
+}
+
+#define H5C__UPDATE_INDEX_FOR_SIZE_CHANGE(cache_ptr, old_size, new_size,    \
+		                          entry_ptr, was_clean)             \
+{                                                                           \
+    H5C__PRE_HT_ENTRY_SIZE_CHANGE_SC(cache_ptr, old_size, new_size,         \
+		                     entry_ptr, was_clean)                  \
+    (cache_ptr)->index_size -= (old_size);                                  \
+    (cache_ptr)->index_size += (new_size);                                  \
+    ((cache_ptr)->index_ring_size[entry_ptr->ring]) -= (old_size);          \
+    ((cache_ptr)->index_ring_size[entry_ptr->ring]) += (new_size);          \
+    if(was_clean) {                                                         \
+        (cache_ptr)->clean_index_size -= (old_size);                        \
+        ((cache_ptr)->clean_index_ring_size[entry_ptr->ring])-= (old_size); \
+    } else {                                                                \
+	(cache_ptr)->dirty_index_size -= (old_size);                        \
+        ((cache_ptr)->dirty_index_ring_size[entry_ptr->ring])-= (old_size); \
+    }                                                                       \
+    if((entry_ptr)->is_dirty) {                                             \
+        (cache_ptr)->dirty_index_size += (new_size);                        \
+        ((cache_ptr)->dirty_index_ring_size[entry_ptr->ring])+= (new_size); \
+    } else {                                                                \
+	(cache_ptr)->clean_index_size += (new_size);                        \
+        ((cache_ptr)->clean_index_ring_size[entry_ptr->ring])+= (new_size); \
+    }                                                                       \
+    H5C__DLL_UPDATE_FOR_SIZE_CHANGE((cache_ptr)->il_len,                    \
+                                    (cache_ptr)->il_size,                   \
+                                    (old_size), (new_size))                 \
+    H5C__POST_HT_ENTRY_SIZE_CHANGE_SC(cache_ptr, old_size, new_size,        \
+                                      entry_ptr)                            \
+}
+
+

+/**************************************************************************
+ *
+ * Skip list insertion and deletion macros:
+ *
+ * These used to be functions, but I converted them to macros to avoid some
+ * function call overhead.
+ *
+ **************************************************************************/
+
+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__INSERT_ENTRY_IN_SLIST
+ *
+ * Purpose:     Insert the specified instance of H5C_cache_entry_t into
+ *		the skip list in the specified instance of H5C_t.  Update
+ *		the associated length and size fields.
+ *
+ * Return:      N/A
+ *
+ * Programmer:  John Mainzer, 5/10/04
+ *
+ * Modifications:
+ *
+ *		JRM -- 7/21/04
+ *		Updated function to set the in_tree flag when inserting
+ *		an entry into the tree.  Also modified the function to
+ *		update the tree size and len fields instead of the similar
+ *		index fields.
+ *
+ *		All of this is part of the modifications to support the
+ *		hash table.
+ *
+ *		JRM -- 7/27/04
+ *		Converted the function H5C_insert_entry_in_tree() into
+ *		the macro H5C__INSERT_ENTRY_IN_TREE in the hopes of
+ *		wringing a little more speed out of the cache.
+ *
+ *		Note that we don't bother to check if the entry is already
+ *		in the tree -- if it is, H5SL_insert() will fail.
+ *
+ *		QAK -- 11/27/04
+ *		Switched over to using skip list routines.
+ *
+ *		JRM -- 6/27/06
+ *		Added fail_val parameter.
+ *
+ *		JRM -- 8/25/06
+ *		Added the H5C_DO_SANITY_CHECKS version of the macro.
+ *
+ *		This version maintains the slist_len_increase and
+ *		slist_size_increase fields that are used in sanity
+ *		checks in the flush routines.
+ *
+ *		All this is needed as the fractal heap needs to be
+ *		able to dirty, resize and/or move entries during the
+ *		flush.
+ *
+ *		JRM -- 12/13/14
+ *		Added code to set cache_ptr->slist_changed to TRUE 
+ *		when an entry is inserted in the slist.
+ *
+ *		JRM -- 9/1/15
+ *		Added code to maintain the cache_ptr->slist_ring_len
+ *		and cache_ptr->slist_ring_size arrays.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#if H5C_DO_SLIST_SANITY_CHECKS
+#define ENTRY_IN_SLIST(cache_ptr, entry_ptr) \
+    H5C_entry_in_skip_list((cache_ptr), (entry_ptr))
+#else /* H5C_DO_SLIST_SANITY_CHECKS */
+#define ENTRY_IN_SLIST(cache_ptr, entry_ptr) FALSE
+#endif /* H5C_DO_SLIST_SANITY_CHECKS */
+
+#if H5C_DO_SANITY_CHECKS
+
+#define H5C__INSERT_ENTRY_IN_SLIST(cache_ptr, entry_ptr, fail_val)             \
+{                                                                              \
+    HDassert( (cache_ptr) );                                                   \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                        \
+    HDassert( (entry_ptr) );                                                   \
+    HDassert( (entry_ptr)->size > 0 );                                         \
+    HDassert( H5F_addr_defined((entry_ptr)->addr) );                           \
+    HDassert( !((entry_ptr)->in_slist) );                                      \
+    HDassert( !ENTRY_IN_SLIST((cache_ptr), (entry_ptr)) );                     \
+    HDassert( (entry_ptr)->ring > H5C_RING_UNDEFINED );                        \
+    HDassert( (entry_ptr)->ring < H5C_RING_NTYPES );                           \
+    HDassert( (cache_ptr)->slist_ring_len[(entry_ptr)->ring] <=                \
+              (cache_ptr)->slist_len );                                        \
+    HDassert( (cache_ptr)->slist_ring_size[(entry_ptr)->ring] <=               \
+              (cache_ptr)->slist_size );                                       \
+                                                                               \
+    if(H5SL_insert((cache_ptr)->slist_ptr, entry_ptr, &(entry_ptr)->addr) < 0) \
+        HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, (fail_val), "can't insert entry in skip list") \
+                                                                               \
+    (entry_ptr)->in_slist = TRUE;                                              \
+    (cache_ptr)->slist_changed = TRUE;                                         \
+    (cache_ptr)->slist_len++;                                                  \
+    (cache_ptr)->slist_size += (entry_ptr)->size;                              \
+    ((cache_ptr)->slist_ring_len[(entry_ptr)->ring])++;                        \
+    ((cache_ptr)->slist_ring_size[(entry_ptr)->ring]) += (entry_ptr)->size;    \
+    (cache_ptr)->slist_len_increase++;                                         \
+    (cache_ptr)->slist_size_increase += (int64_t)((entry_ptr)->size);          \
+                                                                               \
+    HDassert( (cache_ptr)->slist_len > 0 );                                    \
+    HDassert( (cache_ptr)->slist_size > 0 );                                   \
+                                                                               \
+} /* H5C__INSERT_ENTRY_IN_SLIST */
+
+#else /* H5C_DO_SANITY_CHECKS */
+
+#define H5C__INSERT_ENTRY_IN_SLIST(cache_ptr, entry_ptr, fail_val)             \
+{                                                                              \
+    HDassert( (cache_ptr) );                                                   \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                        \
+    HDassert( (entry_ptr) );                                                   \
+    HDassert( (entry_ptr)->size > 0 );                                         \
+    HDassert( H5F_addr_defined((entry_ptr)->addr) );                           \
+    HDassert( !((entry_ptr)->in_slist) );                                      \
+    HDassert( !ENTRY_IN_SLIST((cache_ptr), (entry_ptr)) );                     \
+    HDassert( (entry_ptr)->ring > H5C_RING_UNDEFINED );                        \
+    HDassert( (entry_ptr)->ring < H5C_RING_NTYPES );                           \
+    HDassert( (cache_ptr)->slist_ring_len[(entry_ptr)->ring] <=                \
+              (cache_ptr)->slist_len );                                        \
+    HDassert( (cache_ptr)->slist_ring_size[(entry_ptr)->ring] <=               \
+              (cache_ptr)->slist_size );                                       \
+                                                                               \
+    if(H5SL_insert((cache_ptr)->slist_ptr, entry_ptr, &(entry_ptr)->addr) < 0) \
+        HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, (fail_val), "can't insert entry in skip list") \
+                                                                               \
+    (entry_ptr)->in_slist = TRUE;                                              \
+    (cache_ptr)->slist_changed = TRUE;                                         \
+    (cache_ptr)->slist_len++;                                                  \
+    (cache_ptr)->slist_size += (entry_ptr)->size;                              \
+    ((cache_ptr)->slist_ring_len[(entry_ptr)->ring])++;                        \
+    ((cache_ptr)->slist_ring_size[(entry_ptr)->ring]) += (entry_ptr)->size;    \
+                                                                               \
+    HDassert( (cache_ptr)->slist_len > 0 );                                    \
+    HDassert( (cache_ptr)->slist_size > 0 );                                   \
+                                                                               \
+} /* H5C__INSERT_ENTRY_IN_SLIST */
+
+#endif /* H5C_DO_SANITY_CHECKS */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Function:    H5C__REMOVE_ENTRY_FROM_SLIST
+ *
+ * Purpose:     Remove the specified instance of H5C_cache_entry_t from the
+ *		index skip list in the specified instance of H5C_t.  Update
+ *		the associated length and size fields.
+ *
+ * Return:      N/A
+ *
+ * Programmer:  John Mainzer, 5/10/04
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#if H5C_DO_SANITY_CHECKS
+#define H5C__REMOVE_ENTRY_FROM_SLIST(cache_ptr, entry_ptr, during_flush)    \
+{                                                                           \
+    HDassert( (cache_ptr) );                                                \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                     \
+    HDassert( (entry_ptr) );                                                \
+    HDassert( !((entry_ptr)->is_read_only) );                               \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                           \
+    HDassert( (entry_ptr)->size > 0 );                                      \
+    HDassert( (entry_ptr)->in_slist );                                      \
+    HDassert( (cache_ptr)->slist_ptr );                                     \
+    HDassert( (entry_ptr)->ring > H5C_RING_UNDEFINED );                     \
+    HDassert( (entry_ptr)->ring < H5C_RING_NTYPES );                        \
+    HDassert( (cache_ptr)->slist_ring_len[(entry_ptr)->ring] <=             \
+              (cache_ptr)->slist_len );                                     \
+    HDassert( (cache_ptr)->slist_ring_size[(entry_ptr)->ring] <=            \
+              (cache_ptr)->slist_size );                                    \
+                                                                            \
+    if ( H5SL_remove((cache_ptr)->slist_ptr, &(entry_ptr)->addr)            \
+             != (entry_ptr) )                                               \
+        HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, FAIL, "can't delete entry from skip list") \
+                                                                            \
+    HDassert( (cache_ptr)->slist_len > 0 );                                 \
+    if(!(during_flush))                                                     \
+        (cache_ptr)->slist_changed = TRUE;                                  \
+    (cache_ptr)->slist_len--;                                               \
+    HDassert( (cache_ptr)->slist_size >= (entry_ptr)->size );               \
+    (cache_ptr)->slist_size -= (entry_ptr)->size;                           \
+    ((cache_ptr)->slist_ring_len[(entry_ptr)->ring])--;                     \
+    HDassert( (cache_ptr)->slist_ring_size[(entry_ptr->ring)] >=            \
+              (entry_ptr)->size );                                          \
+    ((cache_ptr)->slist_ring_size[(entry_ptr)->ring]) -= (entry_ptr)->size; \
+    (cache_ptr)->slist_len_increase--;                                      \
+    (cache_ptr)->slist_size_increase -= (int64_t)((entry_ptr)->size);       \
+    (entry_ptr)->in_slist = FALSE;                                          \
+} /* H5C__REMOVE_ENTRY_FROM_SLIST */
+
+#else /* H5C_DO_SANITY_CHECKS */
+
+#define H5C__REMOVE_ENTRY_FROM_SLIST(cache_ptr, entry_ptr, during_flush)    \
+{                                                                           \
+    HDassert( (cache_ptr) );                                                \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                     \
+    HDassert( (entry_ptr) );                                                \
+    HDassert( !((entry_ptr)->is_read_only) );                               \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                           \
+    HDassert( (entry_ptr)->in_slist );                                      \
+    HDassert( (cache_ptr)->slist_ptr );                                     \
+    HDassert( (entry_ptr)->ring > H5C_RING_UNDEFINED );                     \
+    HDassert( (entry_ptr)->ring < H5C_RING_NTYPES );                        \
+    HDassert( (cache_ptr)->slist_ring_len[(entry_ptr)->ring] <=             \
+              (cache_ptr)->slist_len );                                     \
+    HDassert( (cache_ptr)->slist_ring_size[(entry_ptr)->ring] <=            \
+              (cache_ptr)->slist_size );                                    \
+                                                                            \
+    if ( H5SL_remove((cache_ptr)->slist_ptr, &(entry_ptr)->addr)            \
+             != (entry_ptr) )                                               \
+        HGOTO_ERROR(H5E_CACHE, H5E_BADVALUE, FAIL, "can't delete entry from skip list") \
+                                                                            \
+    HDassert( (cache_ptr)->slist_len > 0 );                                 \
+    if(!(during_flush))                                                     \
+        (cache_ptr)->slist_changed = TRUE;                                  \
+    (cache_ptr)->slist_len--;                                               \
+    HDassert( (cache_ptr)->slist_size >= (entry_ptr)->size );               \
+    (cache_ptr)->slist_size -= (entry_ptr)->size;                           \
+    ((cache_ptr)->slist_ring_len[(entry_ptr)->ring])--;                     \
+    HDassert( (cache_ptr)->slist_ring_size[(entry_ptr->ring)] >=            \
+              (entry_ptr)->size );                                          \
+    ((cache_ptr)->slist_ring_size[(entry_ptr)->ring]) -= (entry_ptr)->size; \
+    (entry_ptr)->in_slist = FALSE;                                          \
+} /* H5C__REMOVE_ENTRY_FROM_SLIST */
+#endif /* H5C_DO_SANITY_CHECKS */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Function:    H5C__UPDATE_SLIST_FOR_SIZE_CHANGE
+ *
+ * Purpose:     Update cache_ptr->slist_size for a change in the size of
+ *		and entry in the slist.
+ *
+ * Return:      N/A
+ *
+ * Programmer:  John Mainzer, 9/07/05
+ *
+ * Modifications:
+ *
+ *		JRM -- 8/27/06
+ *		Added the H5C_DO_SANITY_CHECKS version of the macro.
+ *
+ *		This version maintains the slist_size_increase field
+ *		that are used in sanity checks in the flush routines.
+ *
+ *		All this is needed as the fractal heap needs to be
+ *		able to dirty, resize and/or move entries during the
+ *		flush.
+ *
+ *		JRM -- 12/13/14
+ *		Note that we do not set cache_ptr->slist_changed to TRUE 
+ *		in this case, as the structure of the slist is not
+ *		modified.
+ *
+ *		JRM -- 9/1/15
+ *		Added code to maintain the cache_ptr->slist_ring_len
+ *		and cache_ptr->slist_ring_size arrays.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#if H5C_DO_SANITY_CHECKS
+
+#define H5C__UPDATE_SLIST_FOR_SIZE_CHANGE(cache_ptr, old_size, new_size)      \
+{                                                                             \
+    HDassert( (cache_ptr) );                                                  \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                       \
+    HDassert( (old_size) > 0 );                                               \
+    HDassert( (new_size) > 0 );                                               \
+    HDassert( (old_size) <= (cache_ptr)->slist_size );                        \
+    HDassert( (cache_ptr)->slist_len > 0 );                                   \
+    HDassert( ((cache_ptr)->slist_len > 1) ||                                 \
+              ( (cache_ptr)->slist_size == (old_size) ) );                    \
+    HDassert( (entry_ptr)->ring > H5C_RING_UNDEFINED );                       \
+    HDassert( (entry_ptr)->ring < H5C_RING_NTYPES );                          \
+    HDassert( (cache_ptr)->slist_ring_len[(entry_ptr)->ring] <=               \
+              (cache_ptr)->slist_len );                                       \
+    HDassert( (cache_ptr)->slist_ring_size[(entry_ptr)->ring] <=              \
+              (cache_ptr)->slist_size );                                      \
+                                                                              \
+    (cache_ptr)->slist_size -= (old_size);                                    \
+    (cache_ptr)->slist_size += (new_size);                                    \
+                                                                              \
+    HDassert( (cache_ptr)->slist_ring_size[(entry_ptr->ring)] >=(old_size) ); \
+    ((cache_ptr)->slist_ring_size[(entry_ptr)->ring]) -= (old_size);          \
+    ((cache_ptr)->slist_ring_size[(entry_ptr)->ring]) += (new_size);          \
+                                                                              \
+    (cache_ptr)->slist_size_increase -= (int64_t)(old_size);                  \
+    (cache_ptr)->slist_size_increase += (int64_t)(new_size);                  \
+                                                                              \
+    HDassert( (new_size) <= (cache_ptr)->slist_size );                        \
+    HDassert( ( (cache_ptr)->slist_len > 1 ) ||                               \
+              ( (cache_ptr)->slist_size == (new_size) ) );                    \
+} /* H5C__UPDATE_SLIST_FOR_SIZE_CHANGE */
+
+#else /* H5C_DO_SANITY_CHECKS */
+
+#define H5C__UPDATE_SLIST_FOR_SIZE_CHANGE(cache_ptr, old_size, new_size)      \
+{                                                                             \
+    HDassert( (cache_ptr) );                                                  \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                       \
+    HDassert( (old_size) > 0 );                                               \
+    HDassert( (new_size) > 0 );                                               \
+    HDassert( (old_size) <= (cache_ptr)->slist_size );                        \
+    HDassert( (cache_ptr)->slist_len > 0 );                                   \
+    HDassert( ((cache_ptr)->slist_len > 1) ||                                 \
+              ( (cache_ptr)->slist_size == (old_size) ) );                    \
+    HDassert( (entry_ptr)->ring > H5C_RING_UNDEFINED );                       \
+    HDassert( (entry_ptr)->ring < H5C_RING_NTYPES );                          \
+    HDassert( (cache_ptr)->slist_ring_len[(entry_ptr)->ring] <=               \
+              (cache_ptr)->slist_len );                                       \
+    HDassert( (cache_ptr)->slist_ring_size[(entry_ptr)->ring] <=              \
+              (cache_ptr)->slist_size );                                      \
+                                                                              \
+    (cache_ptr)->slist_size -= (old_size);                                    \
+    (cache_ptr)->slist_size += (new_size);                                    \
+                                                                              \
+    HDassert( (cache_ptr)->slist_ring_size[(entry_ptr->ring)] >=(old_size) ); \
+    ((cache_ptr)->slist_ring_size[(entry_ptr)->ring]) -= (old_size);          \
+    ((cache_ptr)->slist_ring_size[(entry_ptr)->ring]) += (new_size);          \
+                                                                              \
+    HDassert( (new_size) <= (cache_ptr)->slist_size );                        \
+    HDassert( ( (cache_ptr)->slist_len > 1 ) ||                               \
+              ( (cache_ptr)->slist_size == (new_size) ) );                    \
+} /* H5C__UPDATE_SLIST_FOR_SIZE_CHANGE */
+
+#endif /* H5C_DO_SANITY_CHECKS */
+
+

+/**************************************************************************
+ *
+ * Replacement policy update macros:
+ *
+ * These used to be functions, but I converted them to macros to avoid some
+ * function call overhead.
+ *
+ **************************************************************************/
+
+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__FAKE_RP_FOR_MOST_RECENT_ACCESS
+ *
+ * Purpose:     For efficiency, we sometimes change the order of flushes --
+ *		but doing so can confuse the replacement policy.  This
+ *		macro exists to allow us to specify an entry as the
+ *		most recently touched so we can repair any such
+ *		confusion.
+ *
+ *		At present, we only support the modified LRU policy, so
+ *		this function deals with that case unconditionally.  If
+ *		we ever support other replacement policies, the macro
+ *		should switch on the current policy and act accordingly.
+ *
+ * Return:      N/A
+ *
+ * Programmer:  John Mainzer, 10/13/05
+ *
+ * Modifications:
+ *
+ *		JRM -- 3/20/06
+ *		Modified macro to ignore pinned entries.  Pinned entries
+ *		do not appear in the data structures maintained by the
+ *		replacement policy code, and thus this macro has nothing
+ *		to do if called for such an entry.
+ *
+ *		JRM -- 3/28/07
+ *		Added sanity checks using the new is_read_only and
+ *		ro_ref_count fields of struct H5C_cache_entry_t.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
+
+#define H5C__FAKE_RP_FOR_MOST_RECENT_ACCESS(cache_ptr, entry_ptr, fail_val) \
+{                                                                           \
+    HDassert( (cache_ptr) );                                                \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                     \
+    HDassert( (entry_ptr) );                                                \
+    HDassert( !((entry_ptr)->is_protected) );                               \
+    HDassert( !((entry_ptr)->is_read_only) );                               \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                           \
+    HDassert( (entry_ptr)->size > 0 );                                      \
+                                                                            \
+    if ( ! ((entry_ptr)->is_pinned) ) {                                     \
+                                                                            \
+        /* modified LRU specific code */                                    \
+                                                                            \
+        /* remove the entry from the LRU list, and re-insert it at the head.\
+	 */                                                                 \
+                                                                            \
+        H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->LRU_head_ptr,             \
+                        (cache_ptr)->LRU_tail_ptr,                          \
+			(cache_ptr)->LRU_list_len,                          \
+                        (cache_ptr)->LRU_list_size, (fail_val))             \
+                                                                            \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,            \
+                         (cache_ptr)->LRU_tail_ptr,                         \
+			 (cache_ptr)->LRU_list_len,                         \
+                         (cache_ptr)->LRU_list_size, (fail_val))            \
+                                                                            \
+        /* Use the dirty flag to infer whether the entry is on the clean or \
+         * dirty LRU list, and remove it.  Then insert it at the head of    \
+         * the same LRU list.                                               \
+         *                                                                  \
+         * At least initially, all entries should be clean.  That may       \
+         * change, so we may as well deal with both cases now.              \
+         */                                                                 \
+                                                                            \
+        if ( (entry_ptr)->is_dirty ) {                                      \
+            H5C__AUX_DLL_REMOVE((entry_ptr), (cache_ptr)->dLRU_head_ptr,    \
+                                (cache_ptr)->dLRU_tail_ptr,                 \
+                                (cache_ptr)->dLRU_list_len,                 \
+                                (cache_ptr)->dLRU_list_size, (fail_val))    \
+                                                                            \
+            H5C__AUX_DLL_PREPEND((entry_ptr), (cache_ptr)->dLRU_head_ptr,   \
+                                 (cache_ptr)->dLRU_tail_ptr,                \
+                                 (cache_ptr)->dLRU_list_len,                \
+                                 (cache_ptr)->dLRU_list_size, (fail_val))   \
+        } else {                                                            \
+            H5C__AUX_DLL_REMOVE((entry_ptr), (cache_ptr)->cLRU_head_ptr,    \
+                                (cache_ptr)->cLRU_tail_ptr,                 \
+                                (cache_ptr)->cLRU_list_len,                 \
+                                (cache_ptr)->cLRU_list_size, (fail_val))    \
+                                                                            \
+            H5C__AUX_DLL_PREPEND((entry_ptr), (cache_ptr)->cLRU_head_ptr,   \
+                                 (cache_ptr)->cLRU_tail_ptr,                \
+                                 (cache_ptr)->cLRU_list_len,                \
+                                 (cache_ptr)->cLRU_list_size, (fail_val))   \
+        }                                                                   \
+                                                                            \
+        /* End modified LRU specific code. */                               \
+    }                                                                       \
+} /* H5C__FAKE_RP_FOR_MOST_RECENT_ACCESS */
+
+#else /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+#define H5C__FAKE_RP_FOR_MOST_RECENT_ACCESS(cache_ptr, entry_ptr, fail_val) \
+{                                                                           \
+    HDassert( (cache_ptr) );                                                \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                     \
+    HDassert( (entry_ptr) );                                                \
+    HDassert( !((entry_ptr)->is_protected) );                               \
+    HDassert( !((entry_ptr)->is_read_only) );                               \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                           \
+    HDassert( (entry_ptr)->size > 0 );                                      \
+                                                                            \
+    if ( ! ((entry_ptr)->is_pinned) ) {                                     \
+                                                                            \
+        /* modified LRU specific code */                                    \
+                                                                            \
+        /* remove the entry from the LRU list, and re-insert it at the head \
+	 */                                                                 \
+                                                                            \
+        H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->LRU_head_ptr,             \
+                        (cache_ptr)->LRU_tail_ptr,                          \
+			(cache_ptr)->LRU_list_len,                          \
+                        (cache_ptr)->LRU_list_size, (fail_val))             \
+                                                                            \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,            \
+                         (cache_ptr)->LRU_tail_ptr,                         \
+			 (cache_ptr)->LRU_list_len,                         \
+                         (cache_ptr)->LRU_list_size, (fail_val))            \
+                                                                            \
+        /* End modified LRU specific code. */                               \
+    }                                                                       \
+} /* H5C__FAKE_RP_FOR_MOST_RECENT_ACCESS */
+
+#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__UPDATE_RP_FOR_EVICTION
+ *
+ * Purpose:     Update the replacement policy data structures for an
+ *		eviction of the specified cache entry.
+ *
+ *		At present, we only support the modified LRU policy, so
+ *		this function deals with that case unconditionally.  If
+ *		we ever support other replacement policies, the function
+ *		should switch on the current policy and act accordingly.
+ *
+ * Return:      Non-negative on success/Negative on failure.
+ *
+ * Programmer:  John Mainzer, 5/10/04
+ *
+ * Modifications:
+ *
+ *		JRM - 7/27/04
+ *		Converted the function H5C_update_rp_for_eviction() to the
+ *		macro H5C__UPDATE_RP_FOR_EVICTION in an effort to squeeze
+ *		a bit more performance out of the cache.
+ *
+ *		At least for the first cut, I am leaving the comments and
+ *		white space in the macro.  If they cause dificulties with
+ *		the pre-processor, I'll have to remove them.
+ *
+ *		JRM - 7/28/04
+ *		Split macro into two version, one supporting the clean and
+ *		dirty LRU lists, and the other not.  Yet another attempt
+ *		at optimization.
+ *
+ *		JRM - 3/20/06
+ *		Pinned entries can't be evicted, so this entry should never
+ *		be called on a pinned entry.  Added assert to verify this.
+ *
+ *		JRM -- 3/28/07
+ *		Added sanity checks for the new is_read_only and
+ *		ro_ref_count fields of struct H5C_cache_entry_t.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
+
+#define H5C__UPDATE_RP_FOR_EVICTION(cache_ptr, entry_ptr, fail_val)          \
+{                                                                            \
+    HDassert( (cache_ptr) );                                                 \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                      \
+    HDassert( (entry_ptr) );                                                 \
+    HDassert( !((entry_ptr)->is_protected) );                                \
+    HDassert( !((entry_ptr)->is_read_only) );                                \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                            \
+    HDassert( !((entry_ptr)->is_pinned) );                                   \
+    HDassert( (entry_ptr)->size > 0 );                                       \
+                                                                             \
+    /* modified LRU specific code */                                         \
+                                                                             \
+    /* remove the entry from the LRU list. */                                \
+                                                                             \
+    H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->LRU_head_ptr,                  \
+                    (cache_ptr)->LRU_tail_ptr, (cache_ptr)->LRU_list_len,    \
+                    (cache_ptr)->LRU_list_size, (fail_val))                  \
+                                                                             \
+    /* If the entry is clean when it is evicted, it should be on the         \
+     * clean LRU list, if it was dirty, it should be on the dirty LRU list.  \
+     * Remove it from the appropriate list according to the value of the     \
+     * dirty flag.                                                           \
+     */                                                                      \
+                                                                             \
+    if ( (entry_ptr)->is_dirty ) {                                           \
+                                                                             \
+        H5C__AUX_DLL_REMOVE((entry_ptr), (cache_ptr)->dLRU_head_ptr,         \
+                            (cache_ptr)->dLRU_tail_ptr,                      \
+                            (cache_ptr)->dLRU_list_len,                      \
+                            (cache_ptr)->dLRU_list_size, (fail_val))         \
+    } else {                                                                 \
+        H5C__AUX_DLL_REMOVE((entry_ptr), (cache_ptr)->cLRU_head_ptr,         \
+                            (cache_ptr)->cLRU_tail_ptr,                      \
+                            (cache_ptr)->cLRU_list_len,                      \
+                            (cache_ptr)->cLRU_list_size, (fail_val))         \
+    }                                                                        \
+                                                                             \
+} /* H5C__UPDATE_RP_FOR_EVICTION */
+
+#else /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+#define H5C__UPDATE_RP_FOR_EVICTION(cache_ptr, entry_ptr, fail_val)          \
+{                                                                            \
+    HDassert( (cache_ptr) );                                                 \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                      \
+    HDassert( (entry_ptr) );                                                 \
+    HDassert( !((entry_ptr)->is_protected) );                                \
+    HDassert( !((entry_ptr)->is_read_only) );                                \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                            \
+    HDassert( !((entry_ptr)->is_pinned) );                                   \
+    HDassert( (entry_ptr)->size > 0 );                                       \
+                                                                             \
+    /* modified LRU specific code */                                         \
+                                                                             \
+    /* remove the entry from the LRU list. */                                \
+                                                                             \
+    H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->LRU_head_ptr,                  \
+                    (cache_ptr)->LRU_tail_ptr, (cache_ptr)->LRU_list_len,    \
+                    (cache_ptr)->LRU_list_size, (fail_val))                  \
+                                                                             \
+} /* H5C__UPDATE_RP_FOR_EVICTION */
+
+#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__UPDATE_RP_FOR_FLUSH
+ *
+ * Purpose:     Update the replacement policy data structures for a flush
+ *		of the specified cache entry.
+ *
+ *		At present, we only support the modified LRU policy, so
+ *		this function deals with that case unconditionally.  If
+ *		we ever support other replacement policies, the function
+ *		should switch on the current policy and act accordingly.
+ *
+ * Return:      N/A
+ *
+ * Programmer:  John Mainzer, 5/6/04
+ *
+ * Modifications:
+ *
+ *		JRM - 7/27/04
+ *		Converted the function H5C_update_rp_for_flush() to the
+ *		macro H5C__UPDATE_RP_FOR_FLUSH in an effort to squeeze
+ *		a bit more performance out of the cache.
+ *
+ *		At least for the first cut, I am leaving the comments and
+ *		white space in the macro.  If they cause dificulties with
+ *		pre-processor, I'll have to remove them.
+ *
+ *		JRM - 7/28/04
+ *		Split macro into two versions, one supporting the clean and
+ *		dirty LRU lists, and the other not.  Yet another attempt
+ *		at optimization.
+ *
+ *		JRM - 3/20/06
+ *		While pinned entries can be flushed, they don't reside in
+ *		the replacement policy data structures when unprotected.
+ *		Thus I modified this macro to do nothing if the entry is
+ *		pinned.
+ *
+ *		JRM - 3/28/07
+ *		Added sanity checks based on the new is_read_only and
+ *		ro_ref_count fields of struct H5C_cache_entry_t.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
+
+#define H5C__UPDATE_RP_FOR_FLUSH(cache_ptr, entry_ptr, fail_val)            \
+{                                                                           \
+    HDassert( (cache_ptr) );                                                \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                     \
+    HDassert( (entry_ptr) );                                                \
+    HDassert( !((entry_ptr)->is_protected) );                               \
+    HDassert( !((entry_ptr)->is_read_only) );                               \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                           \
+    HDassert( (entry_ptr)->size > 0 );                                      \
+                                                                            \
+    if ( ! ((entry_ptr)->is_pinned) ) {                                     \
+                                                                            \
+        /* modified LRU specific code */                                    \
+                                                                            \
+        /* remove the entry from the LRU list, and re-insert it at the      \
+	 * head.                                                            \
+	 */                                                                 \
+                                                                            \
+        H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->LRU_head_ptr,             \
+                        (cache_ptr)->LRU_tail_ptr,                          \
+			(cache_ptr)->LRU_list_len,                          \
+                        (cache_ptr)->LRU_list_size, (fail_val))             \
+                                                                            \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,            \
+                         (cache_ptr)->LRU_tail_ptr,                         \
+			 (cache_ptr)->LRU_list_len,                         \
+                         (cache_ptr)->LRU_list_size, (fail_val))            \
+                                                                            \
+        /* since the entry is being flushed or cleared, one would think     \
+	 * that it must be dirty -- but that need not be the case.  Use the \
+	 * dirty flag to infer whether the entry is on the clean or dirty   \
+	 * LRU list, and remove it.  Then insert it at the head of the      \
+	 * clean LRU list.                                                  \
+         *                                                                  \
+         * The function presumes that a dirty entry will be either cleared  \
+	 * or flushed shortly, so it is OK if we put a dirty entry on the   \
+	 * clean LRU list.                                                  \
+         */                                                                 \
+                                                                            \
+        if ( (entry_ptr)->is_dirty ) {                                      \
+            H5C__AUX_DLL_REMOVE((entry_ptr), (cache_ptr)->dLRU_head_ptr,    \
+                                (cache_ptr)->dLRU_tail_ptr,                 \
+                                (cache_ptr)->dLRU_list_len,                 \
+                                (cache_ptr)->dLRU_list_size, (fail_val))    \
+        } else {                                                            \
+            H5C__AUX_DLL_REMOVE((entry_ptr), (cache_ptr)->cLRU_head_ptr,    \
+                                (cache_ptr)->cLRU_tail_ptr,                 \
+                                (cache_ptr)->cLRU_list_len,                 \
+                                (cache_ptr)->cLRU_list_size, (fail_val))    \
+        }                                                                   \
+                                                                            \
+        H5C__AUX_DLL_PREPEND((entry_ptr), (cache_ptr)->cLRU_head_ptr,       \
+                             (cache_ptr)->cLRU_tail_ptr,                    \
+                             (cache_ptr)->cLRU_list_len,                    \
+                             (cache_ptr)->cLRU_list_size, (fail_val))       \
+                                                                            \
+        /* End modified LRU specific code. */                               \
+    }                                                                       \
+} /* H5C__UPDATE_RP_FOR_FLUSH */
+
+#else /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+#define H5C__UPDATE_RP_FOR_FLUSH(cache_ptr, entry_ptr, fail_val)            \
+{                                                                           \
+    HDassert( (cache_ptr) );                                                \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                     \
+    HDassert( (entry_ptr) );                                                \
+    HDassert( !((entry_ptr)->is_protected) );                               \
+    HDassert( !((entry_ptr)->is_read_only) );                               \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                           \
+    HDassert( (entry_ptr)->size > 0 );                                      \
+                                                                            \
+    if ( ! ((entry_ptr)->is_pinned) ) {                                     \
+                                                                            \
+        /* modified LRU specific code */                                    \
+                                                                            \
+        /* remove the entry from the LRU list, and re-insert it at the      \
+	 * head.                                                            \
+	 */                                                                 \
+                                                                            \
+        H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->LRU_head_ptr,             \
+                        (cache_ptr)->LRU_tail_ptr,                          \
+			(cache_ptr)->LRU_list_len,                          \
+                        (cache_ptr)->LRU_list_size, (fail_val))             \
+                                                                            \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,            \
+                         (cache_ptr)->LRU_tail_ptr,                         \
+			 (cache_ptr)->LRU_list_len,                         \
+                         (cache_ptr)->LRU_list_size, (fail_val))            \
+                                                                            \
+        /* End modified LRU specific code. */                               \
+    }                                                                       \
+} /* H5C__UPDATE_RP_FOR_FLUSH */
+
+#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__UPDATE_RP_FOR_INSERT_APPEND
+ *
+ * Purpose:     Update the replacement policy data structures for an
+ *		insertion of the specified cache entry.  
+ *
+ *		Unlike H5C__UPDATE_RP_FOR_INSERTION below, mark the 
+ *		new entry as the LEAST recently used entry, not the 
+ *		most recently used.  
+ *
+ *		For now at least, this macro should only be used in 
+ *		the reconstruction of the metadata cache from a cache 
+ *		image block.
+ *
+ *		At present, we only support the modified LRU policy, so
+ *		this function deals with that case unconditionally.  If
+ *		we ever support other replacement policies, the function
+ *		should switch on the current policy and act accordingly.
+ *
+ * Return:      N/A
+ *
+ * Programmer:  John Mainzer, 8/15/15
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
+
+#define H5C__UPDATE_RP_FOR_INSERT_APPEND(cache_ptr, entry_ptr, fail_val)   \
+{                                                                          \
+    HDassert( (cache_ptr) );                                               \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                    \
+    HDassert( (entry_ptr) );                                               \
+    HDassert( !((entry_ptr)->is_protected) );                              \
+    HDassert( !((entry_ptr)->is_read_only) );                              \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                          \
+    HDassert( (entry_ptr)->size > 0 );                                     \
+                                                                           \
+    if ( (entry_ptr)->is_pinned ) {                                        \
+                                                                           \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->pel_head_ptr,           \
+                         (cache_ptr)->pel_tail_ptr,                        \
+                         (cache_ptr)->pel_len,                             \
+                         (cache_ptr)->pel_size, (fail_val))                \
+                                                                           \
+    } else {                                                               \
+                                                                           \
+        /* modified LRU specific code */                                   \
+                                                                           \
+        /* insert the entry at the tail of the LRU list. */                \
+                                                                           \
+        H5C__DLL_APPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,            \
+                        (cache_ptr)->LRU_tail_ptr,                         \
+		        (cache_ptr)->LRU_list_len,                         \
+                        (cache_ptr)->LRU_list_size, (fail_val))            \
+                                                                           \
+        /* insert the entry at the tail of the clean or dirty LRU list as  \
+         * appropriate.                                                    \
+         */                                                                \
+                                                                           \
+        if ( entry_ptr->is_dirty ) {                                       \
+            H5C__AUX_DLL_APPEND((entry_ptr), (cache_ptr)->dLRU_head_ptr,   \
+                                (cache_ptr)->dLRU_tail_ptr,                \
+                                (cache_ptr)->dLRU_list_len,                \
+                                (cache_ptr)->dLRU_list_size, (fail_val))   \
+        } else {                                                           \
+            H5C__AUX_DLL_APPEND((entry_ptr), (cache_ptr)->cLRU_head_ptr,   \
+                                (cache_ptr)->cLRU_tail_ptr,                \
+                                (cache_ptr)->cLRU_list_len,                \
+                                (cache_ptr)->cLRU_list_size, (fail_val))   \
+        }                                                                  \
+                                                                           \
+        /* End modified LRU specific code. */                              \
+    }                                                                      \
+}
+
+#else /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+#define H5C__UPDATE_RP_FOR_INSERT_APPEND(cache_ptr, entry_ptr, fail_val)   \
+{                                                                          \
+    HDassert( (cache_ptr) );                                               \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                    \
+    HDassert( (entry_ptr) );                                               \
+    HDassert( !((entry_ptr)->is_protected) );                              \
+    HDassert( !((entry_ptr)->is_read_only) );                              \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                          \
+    HDassert( (entry_ptr)->size > 0 );                                     \
+                                                                           \
+    if ( (entry_ptr)->is_pinned ) {                                        \
+                                                                           \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->pel_head_ptr,           \
+                         (cache_ptr)->pel_tail_ptr,                        \
+                         (cache_ptr)->pel_len,                             \
+                         (cache_ptr)->pel_size, (fail_val))                \
+	                                                                   \
+    } else {                                                               \
+                                                                           \
+        /* modified LRU specific code */                                   \
+                                                                           \
+        /* insert the entry at the tail of the LRU list. */                \
+                                                                           \
+        H5C__DLL_APPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,            \
+                        (cache_ptr)->LRU_tail_ptr,                         \
+			(cache_ptr)->LRU_list_len,                         \
+                        (cache_ptr)->LRU_list_size, (fail_val))            \
+                                                                           \
+        /* End modified LRU specific code. */                              \
+    }                                                                      \
+}
+
+#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__UPDATE_RP_FOR_INSERTION
+ *
+ * Purpose:     Update the replacement policy data structures for an
+ *		insertion of the specified cache entry.
+ *
+ *		At present, we only support the modified LRU policy, so
+ *		this function deals with that case unconditionally.  If
+ *		we ever support other replacement policies, the function
+ *		should switch on the current policy and act accordingly.
+ *
+ * Return:      N/A
+ *
+ * Programmer:  John Mainzer, 5/17/04
+ *
+ * Modifications:
+ *
+ *		JRM - 7/27/04
+ *		Converted the function H5C_update_rp_for_insertion() to the
+ *		macro H5C__UPDATE_RP_FOR_INSERTION in an effort to squeeze
+ *		a bit more performance out of the cache.
+ *
+ *		At least for the first cut, I am leaving the comments and
+ *		white space in the macro.  If they cause dificulties with
+ *		pre-processor, I'll have to remove them.
+ *
+ *		JRM - 7/28/04
+ *		Split macro into two version, one supporting the clean and
+ *		dirty LRU lists, and the other not.  Yet another attempt
+ *		at optimization.
+ *
+ *		JRM - 3/10/06
+ *		This macro should never be called on a pinned entry.
+ *		Inserted an assert to verify this.
+ *
+ *		JRM - 8/9/06
+ *		Not any more.  We must now allow insertion of pinned
+ *		entries.  Updated macro to support this.
+ *
+ *		JRM - 3/28/07
+ *		Added sanity checks using the new is_read_only and
+ *		ro_ref_count fields of struct H5C_cache_entry_t.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
+
+#define H5C__UPDATE_RP_FOR_INSERTION(cache_ptr, entry_ptr, fail_val)       \
+{                                                                          \
+    HDassert( (cache_ptr) );                                               \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                    \
+    HDassert( (entry_ptr) );                                               \
+    HDassert( !((entry_ptr)->is_protected) );                              \
+    HDassert( !((entry_ptr)->is_read_only) );                              \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                          \
+    HDassert( (entry_ptr)->size > 0 );                                     \
+                                                                           \
+    if ( (entry_ptr)->is_pinned ) {                                        \
+                                                                           \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->pel_head_ptr,           \
+                         (cache_ptr)->pel_tail_ptr,                        \
+                         (cache_ptr)->pel_len,                             \
+                         (cache_ptr)->pel_size, (fail_val))                \
+                                                                           \
+    } else {                                                               \
+                                                                           \
+        /* modified LRU specific code */                                   \
+                                                                           \
+        /* insert the entry at the head of the LRU list. */                \
+                                                                           \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,           \
+                         (cache_ptr)->LRU_tail_ptr,                        \
+			 (cache_ptr)->LRU_list_len,                        \
+                         (cache_ptr)->LRU_list_size, (fail_val))           \
+                                                                           \
+        /* insert the entry at the head of the clean or dirty LRU list as  \
+         * appropriate.                                                    \
+         */                                                                \
+                                                                           \
+        if ( entry_ptr->is_dirty ) {                                       \
+            H5C__AUX_DLL_PREPEND((entry_ptr), (cache_ptr)->dLRU_head_ptr,  \
+                                 (cache_ptr)->dLRU_tail_ptr,               \
+                                 (cache_ptr)->dLRU_list_len,               \
+                                 (cache_ptr)->dLRU_list_size, (fail_val))  \
+        } else {                                                           \
+            H5C__AUX_DLL_PREPEND((entry_ptr), (cache_ptr)->cLRU_head_ptr,  \
+                                 (cache_ptr)->cLRU_tail_ptr,               \
+                                 (cache_ptr)->cLRU_list_len,               \
+                                 (cache_ptr)->cLRU_list_size, (fail_val))  \
+        }                                                                  \
+                                                                           \
+        /* End modified LRU specific code. */                              \
+    }                                                                      \
+}
+
+#else /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+#define H5C__UPDATE_RP_FOR_INSERTION(cache_ptr, entry_ptr, fail_val)       \
+{                                                                          \
+    HDassert( (cache_ptr) );                                               \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                    \
+    HDassert( (entry_ptr) );                                               \
+    HDassert( !((entry_ptr)->is_protected) );                              \
+    HDassert( !((entry_ptr)->is_read_only) );                              \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                          \
+    HDassert( (entry_ptr)->size > 0 );                                     \
+                                                                           \
+    if ( (entry_ptr)->is_pinned ) {                                        \
+                                                                           \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->pel_head_ptr,           \
+                         (cache_ptr)->pel_tail_ptr,                        \
+                         (cache_ptr)->pel_len,                             \
+                         (cache_ptr)->pel_size, (fail_val))                \
+	                                                                   \
+    } else {                                                               \
+                                                                           \
+        /* modified LRU specific code */                                   \
+                                                                           \
+        /* insert the entry at the head of the LRU list. */                \
+                                                                           \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,           \
+                         (cache_ptr)->LRU_tail_ptr,                        \
+			 (cache_ptr)->LRU_list_len,                        \
+                         (cache_ptr)->LRU_list_size, (fail_val))           \
+                                                                           \
+        /* End modified LRU specific code. */                              \
+    }                                                                      \
+}
+
+#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__UPDATE_RP_FOR_PROTECT
+ *
+ * Purpose:     Update the replacement policy data structures for a
+ *		protect of the specified cache entry.
+ *
+ *		To do this, unlink the specified entry from any data
+ *		structures used by the replacement policy, and add the
+ *		entry to the protected list.
+ *
+ *		At present, we only support the modified LRU policy, so
+ *		this function deals with that case unconditionally.  If
+ *		we ever support other replacement policies, the function
+ *		should switch on the current policy and act accordingly.
+ *
+ * Return:      N/A
+ *
+ * Programmer:  John Mainzer, 5/17/04
+ *
+ * Modifications:
+ *
+ *		JRM - 7/27/04
+ *		Converted the function H5C_update_rp_for_protect() to the
+ *		macro H5C__UPDATE_RP_FOR_PROTECT in an effort to squeeze
+ *		a bit more performance out of the cache.
+ *
+ *		At least for the first cut, I am leaving the comments and
+ *		white space in the macro.  If they cause dificulties with
+ *		pre-processor, I'll have to remove them.
+ *
+ *		JRM - 7/28/04
+ *		Split macro into two version, one supporting the clean and
+ *		dirty LRU lists, and the other not.  Yet another attempt
+ *		at optimization.
+ *
+ *		JRM - 3/17/06
+ *		Modified macro to attempt to remove pinned entriese from
+ *		the pinned entry list instead of from the data structures
+ *		maintained by the replacement policy.
+ *
+ *		JRM - 3/28/07
+ *		Added sanity checks based on the new is_read_only and
+ *		ro_ref_count fields of struct H5C_cache_entry_t.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
+
+#define H5C__UPDATE_RP_FOR_PROTECT(cache_ptr, entry_ptr, fail_val)        \
+{                                                                         \
+    HDassert( (cache_ptr) );                                              \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                   \
+    HDassert( (entry_ptr) );                                              \
+    HDassert( !((entry_ptr)->is_protected) );                             \
+    HDassert( !((entry_ptr)->is_read_only) );                             \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                         \
+    HDassert( (entry_ptr)->size > 0 );                                    \
+									  \
+    if ( (entry_ptr)->is_pinned ) {                                       \
+                                                                          \
+        H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->pel_head_ptr,           \
+                        (cache_ptr)->pel_tail_ptr, 			  \
+			(cache_ptr)->pel_len,                             \
+                        (cache_ptr)->pel_size, (fail_val))                \
+                                                                          \
+    } else {                                                              \
+                                                                          \
+        /* modified LRU specific code */                                  \
+                                                                          \
+        /* remove the entry from the LRU list. */                         \
+                                                                          \
+        H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->LRU_head_ptr,           \
+                        (cache_ptr)->LRU_tail_ptr,                        \
+			(cache_ptr)->LRU_list_len,                        \
+                        (cache_ptr)->LRU_list_size, (fail_val))           \
+                                                                          \
+        /* Similarly, remove the entry from the clean or dirty LRU list   \
+         * as appropriate.                                                \
+         */                                                               \
+                                                                          \
+        if ( (entry_ptr)->is_dirty ) {                                    \
+                                                                          \
+            H5C__AUX_DLL_REMOVE((entry_ptr), (cache_ptr)->dLRU_head_ptr,  \
+                                (cache_ptr)->dLRU_tail_ptr,               \
+                                (cache_ptr)->dLRU_list_len,               \
+                                (cache_ptr)->dLRU_list_size, (fail_val))  \
+                                                                          \
+        } else {                                                          \
+                                                                          \
+            H5C__AUX_DLL_REMOVE((entry_ptr), (cache_ptr)->cLRU_head_ptr,  \
+                                (cache_ptr)->cLRU_tail_ptr,               \
+                                (cache_ptr)->cLRU_list_len,               \
+                                (cache_ptr)->cLRU_list_size, (fail_val))  \
+        }                                                                 \
+                                                                          \
+        /* End modified LRU specific code. */                             \
+    }                                                                     \
+                                                                          \
+    /* Regardless of the replacement policy, or whether the entry is      \
+     * pinned, now add the entry to the protected list.                   \
+     */                                                                   \
+                                                                          \
+    H5C__DLL_APPEND((entry_ptr), (cache_ptr)->pl_head_ptr,                \
+                    (cache_ptr)->pl_tail_ptr,                             \
+                    (cache_ptr)->pl_len,                                  \
+                    (cache_ptr)->pl_size, (fail_val))                     \
+} /* H5C__UPDATE_RP_FOR_PROTECT */
+
+#else /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+#define H5C__UPDATE_RP_FOR_PROTECT(cache_ptr, entry_ptr, fail_val)        \
+{                                                                         \
+    HDassert( (cache_ptr) );                                              \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                   \
+    HDassert( (entry_ptr) );                                              \
+    HDassert( !((entry_ptr)->is_protected) );                             \
+    HDassert( !((entry_ptr)->is_read_only) );                             \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                         \
+    HDassert( (entry_ptr)->size > 0 );                                    \
+									  \
+    if ( (entry_ptr)->is_pinned ) {                                       \
+                                                                          \
+        H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->pel_head_ptr,           \
+                        (cache_ptr)->pel_tail_ptr, 			  \
+			(cache_ptr)->pel_len,                             \
+                        (cache_ptr)->pel_size, (fail_val))                \
+                                                                          \
+    } else {                                                              \
+                                                                          \
+        /* modified LRU specific code */                                  \
+                                                                          \
+        /* remove the entry from the LRU list. */                         \
+                                                                          \
+        H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->LRU_head_ptr,           \
+                        (cache_ptr)->LRU_tail_ptr,                        \
+			(cache_ptr)->LRU_list_len,                        \
+                        (cache_ptr)->LRU_list_size, (fail_val))           \
+                                                                          \
+        /* End modified LRU specific code. */                             \
+    }                                                                     \
+                                                                          \
+    /* Regardless of the replacement policy, or whether the entry is      \
+     * pinned, now add the entry to the protected list.                   \
+     */                                                                   \
+                                                                          \
+    H5C__DLL_APPEND((entry_ptr), (cache_ptr)->pl_head_ptr,                \
+                    (cache_ptr)->pl_tail_ptr,                             \
+                    (cache_ptr)->pl_len,                                  \
+                    (cache_ptr)->pl_size, (fail_val))                     \
+} /* H5C__UPDATE_RP_FOR_PROTECT */
+
+#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__UPDATE_RP_FOR_MOVE
+ *
+ * Purpose:     Update the replacement policy data structures for a
+ *		move of the specified cache entry.
+ *
+ *		At present, we only support the modified LRU policy, so
+ *		this function deals with that case unconditionally.  If
+ *		we ever support other replacement policies, the function
+ *		should switch on the current policy and act accordingly.
+ *
+ * Return:      N/A
+ *
+ * Programmer:  John Mainzer, 5/17/04
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
+
+#define H5C__UPDATE_RP_FOR_MOVE(cache_ptr, entry_ptr, was_dirty, fail_val) \
+{                                                                            \
+    HDassert( (cache_ptr) );                                                 \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                      \
+    HDassert( (entry_ptr) );                                                 \
+    HDassert( !((entry_ptr)->is_read_only) );                                \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                            \
+    HDassert( (entry_ptr)->size > 0 );                                       \
+                                                                             \
+    if ( ! ( (entry_ptr)->is_pinned ) && ! ( (entry_ptr->is_protected ) ) ) { \
+	                                                                     \
+        /* modified LRU specific code */                                     \
+                                                                             \
+        /* remove the entry from the LRU list, and re-insert it at the head. \
+	 */                                                                  \
+                                                                             \
+            H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->LRU_head_ptr,          \
+                             (cache_ptr)->LRU_tail_ptr,                      \
+			     (cache_ptr)->LRU_list_len,                      \
+                             (cache_ptr)->LRU_list_size, (fail_val))         \
+                                                                             \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,             \
+                         (cache_ptr)->LRU_tail_ptr,                          \
+			 (cache_ptr)->LRU_list_len,                          \
+                         (cache_ptr)->LRU_list_size, (fail_val))             \
+                                                                             \
+            /* remove the entry from either the clean or dirty LUR list as   \
+             * indicated by the was_dirty parameter                          \
+             */                                                              \
+            if ( was_dirty ) {                                               \
+                                                                             \
+                H5C__AUX_DLL_REMOVE((entry_ptr),                             \
+				     (cache_ptr)->dLRU_head_ptr,             \
+                                     (cache_ptr)->dLRU_tail_ptr,             \
+                                     (cache_ptr)->dLRU_list_len,             \
+                                     (cache_ptr)->dLRU_list_size,            \
+				     (fail_val))                             \
+                                                                             \
+            } else {                                                         \
+                                                                             \
+                H5C__AUX_DLL_REMOVE((entry_ptr),                             \
+				     (cache_ptr)->cLRU_head_ptr,             \
+                                     (cache_ptr)->cLRU_tail_ptr,             \
+                                     (cache_ptr)->cLRU_list_len,             \
+                                     (cache_ptr)->cLRU_list_size,            \
+				     (fail_val))                             \
+            }                                                                \
+                                                                             \
+            /* insert the entry at the head of either the clean or dirty     \
+	     * LRU list as appropriate.                                      \
+             */                                                              \
+                                                                             \
+            if ( (entry_ptr)->is_dirty ) {                                   \
+                                                                             \
+                H5C__AUX_DLL_PREPEND((entry_ptr),                            \
+				      (cache_ptr)->dLRU_head_ptr,            \
+                                      (cache_ptr)->dLRU_tail_ptr,            \
+                                      (cache_ptr)->dLRU_list_len,            \
+                                      (cache_ptr)->dLRU_list_size,           \
+				      (fail_val))                            \
+                                                                             \
+            } else {                                                         \
+                                                                             \
+                H5C__AUX_DLL_PREPEND((entry_ptr),                            \
+				      (cache_ptr)->cLRU_head_ptr,            \
+                                      (cache_ptr)->cLRU_tail_ptr,            \
+                                      (cache_ptr)->cLRU_list_len,            \
+                                      (cache_ptr)->cLRU_list_size,           \
+				      (fail_val))                            \
+            }                                                                \
+                                                                             \
+            /* End modified LRU specific code. */                            \
+        }                                                                    \
+} /* H5C__UPDATE_RP_FOR_MOVE */
+
+#else /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+#define H5C__UPDATE_RP_FOR_MOVE(cache_ptr, entry_ptr, was_dirty, fail_val) \
+{                                                                            \
+    HDassert( (cache_ptr) );                                                 \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                      \
+    HDassert( (entry_ptr) );                                                 \
+    HDassert( !((entry_ptr)->is_read_only) );                                \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                            \
+    HDassert( (entry_ptr)->size > 0 );                                       \
+                                                                             \
+    if ( ! ( (entry_ptr)->is_pinned ) && ! ( (entry_ptr->is_protected ) ) ) { \
+	                                                                     \
+        /* modified LRU specific code */                                     \
+                                                                             \
+        /* remove the entry from the LRU list, and re-insert it at the head. \
+	 */                                                                  \
+                                                                             \
+            H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->LRU_head_ptr,          \
+                             (cache_ptr)->LRU_tail_ptr,                      \
+			     (cache_ptr)->LRU_list_len,                      \
+                             (cache_ptr)->LRU_list_size, (fail_val))         \
+                                                                             \
+            H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,         \
+                              (cache_ptr)->LRU_tail_ptr,                     \
+			      (cache_ptr)->LRU_list_len,                     \
+                              (cache_ptr)->LRU_list_size, (fail_val))        \
+                                                                             \
+            /* End modified LRU specific code. */                            \
+        }                                                                    \
+} /* H5C__UPDATE_RP_FOR_MOVE */
+
+#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__UPDATE_RP_FOR_SIZE_CHANGE
+ *
+ * Purpose:     Update the replacement policy data structures for a
+ *		size change of the specified cache entry.
+ *
+ *		To do this, determine if the entry is pinned.  If it is,
+ *		update the size of the pinned entry list.
+ *
+ *		If it isn't pinned, the entry must handled by the
+ *		replacement policy.  Update the appropriate replacement
+ *		policy data structures.
+ *
+ *		At present, we only support the modified LRU policy, so
+ *		this function deals with that case unconditionally.  If
+ *		we ever support other replacement policies, the function
+ *		should switch on the current policy and act accordingly.
+ *
+ * Return:      N/A
+ *
+ * Programmer:  John Mainzer, 8/23/06
+ *
+ * Modifications:
+ *
+ * 		JRM -- 3/28/07
+ *		Added sanity checks based on the new is_read_only and
+ *		ro_ref_count fields of struct H5C_cache_entry_t.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
+
+#define H5C__UPDATE_RP_FOR_SIZE_CHANGE(cache_ptr, entry_ptr, new_size)    \
+{                                                                         \
+    HDassert( (cache_ptr) );                                              \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                   \
+    HDassert( (entry_ptr) );                                              \
+    HDassert( !((entry_ptr)->is_protected) );                             \
+    HDassert( !((entry_ptr)->is_read_only) );                             \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                         \
+    HDassert( (entry_ptr)->size > 0 );                                    \
+    HDassert( new_size > 0 );                                             \
+                                                                          \
+    if ( (entry_ptr)->coll_access ) {                                     \
+                                                                          \
+	H5C__DLL_UPDATE_FOR_SIZE_CHANGE((cache_ptr)->coll_list_len,       \
+			                (cache_ptr)->coll_list_size,      \
+			                (entry_ptr)->size,                \
+					(new_size));                      \
+	                                                                  \
+    }                                                                     \
+                                                                          \
+    if ( (entry_ptr)->is_pinned ) {                                       \
+                                                                          \
+	H5C__DLL_UPDATE_FOR_SIZE_CHANGE((cache_ptr)->pel_len,             \
+			                (cache_ptr)->pel_size,            \
+			                (entry_ptr)->size,                \
+					(new_size));                      \
+	                                                                  \
+    } else {                                                              \
+                                                                          \
+        /* modified LRU specific code */                                  \
+                                                                          \
+	/* Update the size of the LRU list */                             \
+                                                                          \
+	H5C__DLL_UPDATE_FOR_SIZE_CHANGE((cache_ptr)->LRU_list_len,        \
+			                (cache_ptr)->LRU_list_size,       \
+			                (entry_ptr)->size,                \
+					(new_size));                      \
+                                                                          \
+        /* Similarly, update the size of the clean or dirty LRU list as   \
+	 * appropriate.  At present, the entry must be clean, but that    \
+	 * could change.                                                  \
+         */                                                               \
+                                                                          \
+        if ( (entry_ptr)->is_dirty ) {                                    \
+                                                                          \
+	    H5C__DLL_UPDATE_FOR_SIZE_CHANGE((cache_ptr)->dLRU_list_len,   \
+			                    (cache_ptr)->dLRU_list_size,  \
+			                    (entry_ptr)->size,            \
+					    (new_size));                  \
+                                                                          \
+        } else {                                                          \
+                                                                          \
+	    H5C__DLL_UPDATE_FOR_SIZE_CHANGE((cache_ptr)->cLRU_list_len,   \
+			                    (cache_ptr)->cLRU_list_size,  \
+			                    (entry_ptr)->size,            \
+					    (new_size));                  \
+        }                                                                 \
+                                                                          \
+        /* End modified LRU specific code. */                             \
+    }                                                                     \
+                                                                          \
+} /* H5C__UPDATE_RP_FOR_SIZE_CHANGE */
+
+#else /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+#define H5C__UPDATE_RP_FOR_SIZE_CHANGE(cache_ptr, entry_ptr, new_size)    \
+{                                                                         \
+    HDassert( (cache_ptr) );                                              \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                   \
+    HDassert( (entry_ptr) );                                              \
+    HDassert( !((entry_ptr)->is_protected) );                             \
+    HDassert( !((entry_ptr)->is_read_only) );                             \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                         \
+    HDassert( (entry_ptr)->size > 0 );                                    \
+    HDassert( new_size > 0 );                                             \
+				  					  \
+    if ( (entry_ptr)->is_pinned ) {                                       \
+                                                                          \
+	H5C__DLL_UPDATE_FOR_SIZE_CHANGE((cache_ptr)->pel_len,             \
+			                (cache_ptr)->pel_size,            \
+			                (entry_ptr)->size,                \
+					(new_size));                      \
+                                                                          \
+    } else {                                                              \
+                                                                          \
+        /* modified LRU specific code */                                  \
+                                                                          \
+	/* Update the size of the LRU list */                             \
+                                                                          \
+	H5C__DLL_UPDATE_FOR_SIZE_CHANGE((cache_ptr)->LRU_list_len,        \
+			                (cache_ptr)->LRU_list_size,       \
+			                (entry_ptr)->size,                \
+					(new_size));                      \
+                                                                          \
+        /* End modified LRU specific code. */                             \
+    }                                                                     \
+                                                                          \
+} /* H5C__UPDATE_RP_FOR_SIZE_CHANGE */
+
+#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__UPDATE_RP_FOR_UNPIN
+ *
+ * Purpose:     Update the replacement policy data structures for an
+ *		unpin of the specified cache entry.
+ *
+ *		To do this, unlink the specified entry from the protected
+ *		entry list, and re-insert it in the data structures used
+ *		by the current replacement policy.
+ *
+ *		At present, we only support the modified LRU policy, so
+ *		this function deals with that case unconditionally.  If
+ *		we ever support other replacement policies, the macro
+ *		should switch on the current policy and act accordingly.
+ *
+ * Return:      N/A
+ *
+ * Programmer:  John Mainzer, 3/22/06
+ *
+ * Modifications:
+ *
+ *		JRM -- 3/28/07
+ *		Added sanity checks based on the new is_read_only and
+ *		ro_ref_count fields of struct H5C_cache_entry_t.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
+
+#define H5C__UPDATE_RP_FOR_UNPIN(cache_ptr, entry_ptr, fail_val)       \
+{                                                                      \
+    HDassert( (cache_ptr) );                                           \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                \
+    HDassert( (entry_ptr) );                                           \
+    HDassert( !((entry_ptr)->is_protected) );                          \
+    HDassert( !((entry_ptr)->is_read_only) );                          \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                      \
+    HDassert( (entry_ptr)->is_pinned);                                 \
+    HDassert( (entry_ptr)->size > 0 );                                 \
+                                                                       \
+    /* Regardless of the replacement policy, remove the entry from the \
+     * pinned entry list.                                              \
+     */                                                                \
+    H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->pel_head_ptr,            \
+                    (cache_ptr)->pel_tail_ptr, (cache_ptr)->pel_len,   \
+                    (cache_ptr)->pel_size, (fail_val))                 \
+                                                                       \
+    /* modified LRU specific code */                                   \
+                                                                       \
+    /* insert the entry at the head of the LRU list. */                \
+                                                                       \
+    H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,           \
+                     (cache_ptr)->LRU_tail_ptr,                        \
+                     (cache_ptr)->LRU_list_len,                        \
+                     (cache_ptr)->LRU_list_size, (fail_val))           \
+                                                                       \
+    /* Similarly, insert the entry at the head of either the clean     \
+     * or dirty LRU list as appropriate.                               \
+     */                                                                \
+                                                                       \
+    if ( (entry_ptr)->is_dirty ) {                                     \
+                                                                       \
+        H5C__AUX_DLL_PREPEND((entry_ptr),                              \
+                              (cache_ptr)->dLRU_head_ptr,              \
+                              (cache_ptr)->dLRU_tail_ptr,              \
+                              (cache_ptr)->dLRU_list_len,              \
+                              (cache_ptr)->dLRU_list_size,             \
+                              (fail_val))                              \
+                                                                       \
+    } else {                                                           \
+                                                                       \
+        H5C__AUX_DLL_PREPEND((entry_ptr),                              \
+                              (cache_ptr)->cLRU_head_ptr,              \
+                              (cache_ptr)->cLRU_tail_ptr,              \
+                              (cache_ptr)->cLRU_list_len,              \
+                              (cache_ptr)->cLRU_list_size,             \
+                              (fail_val))                              \
+     }                                                                 \
+                                                                       \
+    /* End modified LRU specific code. */                              \
+                                                                       \
+} /* H5C__UPDATE_RP_FOR_UNPIN */
+
+#else /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+#define H5C__UPDATE_RP_FOR_UNPIN(cache_ptr, entry_ptr, fail_val)       \
+{                                                                      \
+    HDassert( (cache_ptr) );                                           \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                \
+    HDassert( (entry_ptr) );                                           \
+    HDassert( !((entry_ptr)->is_protected) );                          \
+    HDassert( !((entry_ptr)->is_read_only) );                          \
+    HDassert( ((entry_ptr)->ro_ref_count) == 0 );                      \
+    HDassert( (entry_ptr)->is_pinned);                                 \
+    HDassert( (entry_ptr)->size > 0 );                                 \
+                                                                       \
+    /* Regardless of the replacement policy, remove the entry from the \
+     * pinned entry list.                                              \
+     */                                                                \
+    H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->pel_head_ptr,            \
+                    (cache_ptr)->pel_tail_ptr, (cache_ptr)->pel_len,   \
+                    (cache_ptr)->pel_size, (fail_val))                 \
+                                                                       \
+        /* modified LRU specific code */                               \
+                                                                       \
+        /* insert the entry at the head of the LRU list. */            \
+                                                                       \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,       \
+                         (cache_ptr)->LRU_tail_ptr,                    \
+                         (cache_ptr)->LRU_list_len,                    \
+                         (cache_ptr)->LRU_list_size, (fail_val))       \
+                                                                       \
+        /* End modified LRU specific code. */                          \
+                                                                       \
+} /* H5C__UPDATE_RP_FOR_UNPIN */
+
+#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__UPDATE_RP_FOR_UNPROTECT
+ *
+ * Purpose:     Update the replacement policy data structures for an
+ *		unprotect of the specified cache entry.
+ *
+ *		To do this, unlink the specified entry from the protected
+ *		list, and re-insert it in the data structures used by the
+ *		current replacement policy.
+ *
+ *		At present, we only support the modified LRU policy, so
+ *		this function deals with that case unconditionally.  If
+ *		we ever support other replacement policies, the function
+ *		should switch on the current policy and act accordingly.
+ *
+ * Return:      N/A
+ *
+ * Programmer:  John Mainzer, 5/19/04
+ *
+ * Modifications:
+ *
+ *		JRM - 7/27/04
+ *		Converted the function H5C_update_rp_for_unprotect() to
+ *		the macro H5C__UPDATE_RP_FOR_UNPROTECT in an effort to
+ *		squeeze a bit more performance out of the cache.
+ *
+ *		At least for the first cut, I am leaving the comments and
+ *		white space in the macro.  If they cause dificulties with
+ *		pre-processor, I'll have to remove them.
+ *
+ *		JRM - 7/28/04
+ *		Split macro into two version, one supporting the clean and
+ *		dirty LRU lists, and the other not.  Yet another attempt
+ *		at optimization.
+ *
+ *		JRM - 3/17/06
+ *		Modified macro to put pinned entries on the pinned entry
+ *		list instead of inserting them in the data structures
+ *		maintained by the replacement policy.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#if H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS
+
+#define H5C__UPDATE_RP_FOR_UNPROTECT(cache_ptr, entry_ptr, fail_val)       \
+{                                                                          \
+    HDassert( (cache_ptr) );                                               \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                    \
+    HDassert( (entry_ptr) );                                               \
+    HDassert( (entry_ptr)->is_protected);                                  \
+    HDassert( (entry_ptr)->size > 0 );                                     \
+                                                                           \
+    /* Regardless of the replacement policy, remove the entry from the     \
+     * protected list.                                                     \
+     */                                                                    \
+    H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->pl_head_ptr,                 \
+                    (cache_ptr)->pl_tail_ptr, (cache_ptr)->pl_len,         \
+                    (cache_ptr)->pl_size, (fail_val))                      \
+                                                                           \
+    if ( (entry_ptr)->is_pinned ) {                                        \
+                                                                           \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->pel_head_ptr,           \
+                         (cache_ptr)->pel_tail_ptr,                        \
+                         (cache_ptr)->pel_len,                             \
+                         (cache_ptr)->pel_size, (fail_val))                \
+                                                                           \
+    } else {                                                               \
+                                                                           \
+        /* modified LRU specific code */                                   \
+                                                                           \
+        /* insert the entry at the head of the LRU list. */                \
+                                                                           \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,           \
+                         (cache_ptr)->LRU_tail_ptr,                        \
+                         (cache_ptr)->LRU_list_len,                        \
+                         (cache_ptr)->LRU_list_size, (fail_val))           \
+                                                                           \
+        /* Similarly, insert the entry at the head of either the clean or  \
+         * dirty LRU list as appropriate.                                  \
+         */                                                                \
+                                                                           \
+        if ( (entry_ptr)->is_dirty ) {                                     \
+                                                                           \
+            H5C__AUX_DLL_PREPEND((entry_ptr), (cache_ptr)->dLRU_head_ptr,  \
+                                 (cache_ptr)->dLRU_tail_ptr,               \
+                                 (cache_ptr)->dLRU_list_len,               \
+                                 (cache_ptr)->dLRU_list_size, (fail_val))  \
+                                                                           \
+        } else {                                                           \
+                                                                           \
+            H5C__AUX_DLL_PREPEND((entry_ptr), (cache_ptr)->cLRU_head_ptr,  \
+                                 (cache_ptr)->cLRU_tail_ptr,               \
+                                 (cache_ptr)->cLRU_list_len,               \
+                                 (cache_ptr)->cLRU_list_size, (fail_val))  \
+        }                                                                  \
+                                                                           \
+        /* End modified LRU specific code. */                              \
+    }                                                                      \
+                                                                           \
+} /* H5C__UPDATE_RP_FOR_UNPROTECT */
+
+#else /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+#define H5C__UPDATE_RP_FOR_UNPROTECT(cache_ptr, entry_ptr, fail_val)       \
+{                                                                          \
+    HDassert( (cache_ptr) );                                               \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                    \
+    HDassert( (entry_ptr) );                                               \
+    HDassert( (entry_ptr)->is_protected);                                  \
+    HDassert( (entry_ptr)->size > 0 );                                     \
+                                                                           \
+    /* Regardless of the replacement policy, remove the entry from the     \
+     * protected list.                                                     \
+     */                                                                    \
+    H5C__DLL_REMOVE((entry_ptr), (cache_ptr)->pl_head_ptr,                 \
+                    (cache_ptr)->pl_tail_ptr, (cache_ptr)->pl_len,         \
+                    (cache_ptr)->pl_size, (fail_val))                      \
+                                                                           \
+    if ( (entry_ptr)->is_pinned ) {                                        \
+                                                                           \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->pel_head_ptr,           \
+                         (cache_ptr)->pel_tail_ptr,                        \
+                         (cache_ptr)->pel_len,                             \
+                         (cache_ptr)->pel_size, (fail_val))                \
+                                                                           \
+    } else {                                                               \
+                                                                           \
+        /* modified LRU specific code */                                   \
+                                                                           \
+        /* insert the entry at the head of the LRU list. */                \
+                                                                           \
+        H5C__DLL_PREPEND((entry_ptr), (cache_ptr)->LRU_head_ptr,           \
+                         (cache_ptr)->LRU_tail_ptr,                        \
+                         (cache_ptr)->LRU_list_len,                        \
+                         (cache_ptr)->LRU_list_size, (fail_val))           \
+                                                                           \
+        /* End modified LRU specific code. */                              \
+    }                                                                      \
+} /* H5C__UPDATE_RP_FOR_UNPROTECT */
+
+#endif /* H5C_MAINTAIN_CLEAN_AND_DIRTY_LRU_LISTS */
+
+#ifdef H5_HAVE_PARALLEL
+
+#if H5C_DO_SANITY_CHECKS
+
+#define H5C__COLL_DLL_PRE_REMOVE_SC(entry_ptr, hd_ptr, tail_ptr, len, Size, fv) \
+if ( ( (hd_ptr) == NULL ) ||                                                   \
+     ( (tail_ptr) == NULL ) ||                                                 \
+     ( (entry_ptr) == NULL ) ||                                                \
+     ( (len) <= 0 ) ||                                                         \
+     ( (Size) < (entry_ptr)->size ) ||                                         \
+     ( ( (Size) == (entry_ptr)->size ) && ( ! ( (len) == 1 ) ) ) ||            \
+     ( ( (entry_ptr)->coll_prev == NULL ) && ( (hd_ptr) != (entry_ptr) ) ) ||  \
+     ( ( (entry_ptr)->coll_next == NULL ) && ( (tail_ptr) != (entry_ptr) ) ) || \
+     ( ( (len) == 1 ) &&                                                       \
+       ( ! ( ( (hd_ptr) == (entry_ptr) ) && ( (tail_ptr) == (entry_ptr) ) &&   \
+             ( (entry_ptr)->coll_next == NULL ) &&                             \
+             ( (entry_ptr)->coll_prev == NULL ) &&                             \
+             ( (Size) == (entry_ptr)->size )                                   \
+           )                                                                   \
+       )                                                                       \
+     )                                                                         \
+   ) {                                                                         \
+    HDassert(0 && "coll DLL pre remove SC failed");                            \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, (fv), "coll DLL pre remove SC failed")  \
+}
+
+#define H5C__COLL_DLL_SC(head_ptr, tail_ptr, len, Size, fv)                 \
+if ( ( ( ( (head_ptr) == NULL ) || ( (tail_ptr) == NULL ) ) &&              \
+       ( (head_ptr) != (tail_ptr) )                                         \
+     ) ||                                                                   \
+     ( (len) < 0 ) ||                                                       \
+     ( (Size) < 0 ) ||                                                      \
+     ( ( (len) == 1 ) &&                                                    \
+       ( ( (head_ptr) != (tail_ptr) ) || ( (Size) <= 0 ) ||                 \
+         ( (head_ptr) == NULL ) || ( (head_ptr)->size != (Size) )           \
+       )                                                                    \
+     ) ||                                                                   \
+     ( ( (len) >= 1 ) &&                                                    \
+       ( ( (head_ptr) == NULL ) || ( (head_ptr)->coll_prev != NULL ) ||     \
+         ( (tail_ptr) == NULL ) || ( (tail_ptr)->coll_next != NULL )        \
+       )                                                                    \
+     )                                                                      \
+   ) {                                                                      \
+    HDassert(0 && "COLL DLL sanity check failed");                          \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, (fv), "COLL DLL sanity check failed") \
+}
+
+#define H5C__COLL_DLL_PRE_INSERT_SC(entry_ptr, hd_ptr, tail_ptr, len, Size, fv) \
+if ( ( (entry_ptr) == NULL ) ||                                                \
+     ( (entry_ptr)->coll_next != NULL ) ||                                     \
+     ( (entry_ptr)->coll_prev != NULL ) ||                                     \
+     ( ( ( (hd_ptr) == NULL ) || ( (tail_ptr) == NULL ) ) &&                   \
+       ( (hd_ptr) != (tail_ptr) )                                              \
+     ) ||                                                                      \
+     ( ( (len) == 1 ) &&                                                       \
+       ( ( (hd_ptr) != (tail_ptr) ) || ( (Size) <= 0 ) ||                      \
+         ( (hd_ptr) == NULL ) || ( (hd_ptr)->size != (Size) )                  \
+       )                                                                       \
+     ) ||                                                                      \
+     ( ( (len) >= 1 ) &&                                                       \
+       ( ( (hd_ptr) == NULL ) || ( (hd_ptr)->coll_prev != NULL ) ||            \
+         ( (tail_ptr) == NULL ) || ( (tail_ptr)->coll_next != NULL )           \
+       )                                                                       \
+     )                                                                         \
+   ) {                                                                         \
+    HDassert(0 && "COLL DLL pre insert SC failed");                            \
+    HGOTO_ERROR(H5E_CACHE, H5E_SYSTEM, (fv), "COLL DLL pre insert SC failed")  \
+}
+
+#else /* H5C_DO_SANITY_CHECKS */
+
+#define H5C__COLL_DLL_PRE_REMOVE_SC(entry_ptr, hd_ptr, tail_ptr, len, Size, fv)
+#define H5C__COLL_DLL_SC(head_ptr, tail_ptr, len, Size, fv)
+#define H5C__COLL_DLL_PRE_INSERT_SC(entry_ptr, hd_ptr, tail_ptr, len, Size, fv)
+
+#endif /* H5C_DO_SANITY_CHECKS */
+
+
+#define H5C__COLL_DLL_APPEND(entry_ptr, head_ptr, tail_ptr, len, Size, fail_val) \
+{                                                                            \
+    H5C__COLL_DLL_PRE_INSERT_SC(entry_ptr, head_ptr, tail_ptr, len, Size,    \
+                               fail_val)                                     \
+    if ( (head_ptr) == NULL )                                                \
+    {                                                                        \
+       (head_ptr) = (entry_ptr);                                             \
+       (tail_ptr) = (entry_ptr);                                             \
+    }                                                                        \
+    else                                                                     \
+    {                                                                        \
+       (tail_ptr)->coll_next = (entry_ptr);                                  \
+       (entry_ptr)->coll_prev = (tail_ptr);                                  \
+       (tail_ptr) = (entry_ptr);                                             \
+    }                                                                        \
+    (len)++;                                                                 \
+    (Size) += entry_ptr->size;                                               \
+} /* H5C__COLL_DLL_APPEND() */
+
+#define H5C__COLL_DLL_PREPEND(entry_ptr, head_ptr, tail_ptr, len, Size, fv)  \
+{                                                                            \
+    H5C__COLL_DLL_PRE_INSERT_SC(entry_ptr, head_ptr, tail_ptr, len, Size, fv)\
+    if ( (head_ptr) == NULL )                                                \
+    {                                                                        \
+       (head_ptr) = (entry_ptr);                                             \
+       (tail_ptr) = (entry_ptr);                                             \
+    }                                                                        \
+    else                                                                     \
+    {                                                                        \
+       (head_ptr)->coll_prev = (entry_ptr);                                  \
+       (entry_ptr)->coll_next = (head_ptr);                                  \
+       (head_ptr) = (entry_ptr);                                             \
+    }                                                                        \
+    (len)++;                                                                 \
+    (Size) += entry_ptr->size;                                               \
+} /* H5C__COLL_DLL_PREPEND() */
+
+#define H5C__COLL_DLL_REMOVE(entry_ptr, head_ptr, tail_ptr, len, Size, fv)   \
+{                                                                            \
+    H5C__COLL_DLL_PRE_REMOVE_SC(entry_ptr, head_ptr, tail_ptr, len, Size, fv)\
+    {                                                                        \
+       if ( (head_ptr) == (entry_ptr) )                                      \
+       {                                                                     \
+          (head_ptr) = (entry_ptr)->coll_next;                               \
+          if ( (head_ptr) != NULL )                                          \
+             (head_ptr)->coll_prev = NULL;                                   \
+       }                                                                     \
+       else                                                                  \
+       {                                                                     \
+          (entry_ptr)->coll_prev->coll_next = (entry_ptr)->coll_next;        \
+       }                                                                     \
+       if ( (tail_ptr) == (entry_ptr) )                                      \
+       {                                                                     \
+          (tail_ptr) = (entry_ptr)->coll_prev;                               \
+          if ( (tail_ptr) != NULL )                                          \
+             (tail_ptr)->coll_next = NULL;                                   \
+       }                                                                     \
+       else                                                                  \
+          (entry_ptr)->coll_next->coll_prev = (entry_ptr)->coll_prev;        \
+       entry_ptr->coll_next = NULL;                                          \
+       entry_ptr->coll_prev = NULL;                                          \
+       (len)--;                                                              \
+       (Size) -= entry_ptr->size;                                            \
+    }                                                                        \
+} /* H5C__COLL_DLL_REMOVE() */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__INSERT_IN_COLL_LIST
+ *
+ * Purpose:     Insert entry into collective entries list
+ *
+ * Return:      N/A
+ *
+ * Programmer:  Mohamad Chaarawi
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#define H5C__INSERT_IN_COLL_LIST(cache_ptr, entry_ptr, fail_val)        \
+{                                                                       \
+    HDassert( (cache_ptr) );                                            \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                 \
+    HDassert( (entry_ptr) );                                            \
+                                                                        \
+    /* insert the entry at the head of the list. */                     \
+                                                                        \
+    H5C__COLL_DLL_PREPEND((entry_ptr), (cache_ptr)->coll_head_ptr,      \
+                          (cache_ptr)->coll_tail_ptr,                   \
+                          (cache_ptr)->coll_list_len,                   \
+                          (cache_ptr)->coll_list_size,                  \
+                          (fail_val))                                   \
+                                                                        \
+} /* H5C__INSERT_IN_COLL_LIST */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__REMOVE_FROM_COLL_LIST
+ *
+ * Purpose:     Remove entry from collective entries list
+ *
+ * Return:      N/A
+ *
+ * Programmer:  Mohamad Chaarawi
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#define H5C__REMOVE_FROM_COLL_LIST(cache_ptr, entry_ptr, fail_val)      \
+{                                                                       \
+    HDassert( (cache_ptr) );                                            \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                 \
+    HDassert( (entry_ptr) );                                            \
+                                                                        \
+    /* remove the entry from the list. */                               \
+                                                                        \
+    H5C__COLL_DLL_REMOVE((entry_ptr), (cache_ptr)->coll_head_ptr,       \
+                         (cache_ptr)->coll_tail_ptr,                    \
+                         (cache_ptr)->coll_list_len,                    \
+                         (cache_ptr)->coll_list_size,                   \
+                         (fail_val))                                    \
+                                                                        \
+} /* H5C__REMOVE_FROM_COLL_LIST */
+
+

+/*-------------------------------------------------------------------------
+ *
+ * Macro:	H5C__MOVE_TO_TOP_IN_COLL_LIST
+ *
+ * Purpose:     Update entry position in collective entries list
+ *
+ * Return:      N/A
+ *
+ * Programmer:  Mohamad Chaarawi
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#define H5C__MOVE_TO_TOP_IN_COLL_LIST(cache_ptr, entry_ptr, fail_val)   \
+{                                                                       \
+    HDassert( (cache_ptr) );                                            \
+    HDassert( (cache_ptr)->magic == H5C__H5C_T_MAGIC );                 \
+    HDassert( (entry_ptr) );                                            \
+                                                                        \
+    /* Remove entry and insert at the head of the list. */              \
+    H5C__COLL_DLL_REMOVE((entry_ptr), (cache_ptr)->coll_head_ptr,       \
+                         (cache_ptr)->coll_tail_ptr,                    \
+                         (cache_ptr)->coll_list_len,                    \
+                         (cache_ptr)->coll_list_size,                   \
+                         (fail_val))                                    \
+                                                                        \
+    H5C__COLL_DLL_PREPEND((entry_ptr), (cache_ptr)->coll_head_ptr,      \
+                          (cache_ptr)->coll_tail_ptr,                   \
+                          (cache_ptr)->coll_list_len,                   \
+                          (cache_ptr)->coll_list_size,                  \
+                          (fail_val))                                   \
+                                                                        \
+} /* H5C__MOVE_TO_TOP_IN_COLL_LIST */
+#endif /* H5_HAVE_PARALLEL */
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/****************************************************************************
+ *
+ * structure H5C_tag_info_t
+ *
+ * Structure about each set of tagged entries for an object in the file.
+ *
+ * Each H5C_tag_info_t struct corresponds to a particular object in the file.
+ *
+ * Each H5C_cache_entry struct in the linked list of entries for this tag
+ *      also contains a pointer back to the H5C_tag_info_t struct for the
+ *      overall object.
+ *
+ *
+ * The fields of this structure are discussed individually below:
+ *
+ * tag:	Address (i.e. "tag") of the object header for all the entries
+ *              corresponding to parts of that object.
+ *
+ * head: Head of doubly-linked list of all entries belonging to the tag.
+ *
+ * entry_cnt: Number of entries on linked list of entries for this tag.
+ *
+ * corked: Boolean flag indicating whether entries for this object can be
+ * 		evicted.
+ *
+ ****************************************************************************/
+typedef struct H5C_tag_info_t {
+    haddr_t tag;                /* Tag (address) of the entries (must be first, for skiplist) */
+    H5C_cache_entry_t *head;    /* Head of the list of entries for this tag */
+    size_t entry_cnt;           /* Number of entries on list */
+    hbool_t corked;             /* Whether this object is corked */
+} H5C_tag_info_t;
+
+
+/****************************************************************************
+ *
+ * structure H5C_t
+ *
+ * Catchall structure for all variables specific to an instance of the cache.
+ *
+ * While the individual fields of the structure are discussed below, the
+ * following overview may be helpful.
+ *
+ * Entries in the cache are stored in an instance of H5TB_TREE, indexed on
+ * the entry's disk address.  While the H5TB_TREE is less efficient than
+ * hash table, it keeps the entries in address sorted order.  As flushes
+ * in parallel mode are more efficient if they are issued in increasing
+ * address order, this is a significant benefit.  Also the H5TB_TREE code
+ * was readily available, which reduced development time.
+ *
+ * While the cache was designed with multiple replacement policies in mind,
+ * at present only a modified form of LRU is supported.
+ *
+ *                                              JRM - 4/26/04
+ *
+ * Profiling has indicated that searches in the instance of H5TB_TREE are
+ * too expensive.  To deal with this issue, I have augmented the cache
+ * with a hash table in which all entries will be stored.  Given the
+ * advantages of flushing entries in increasing address order, the TBBT
+ * is retained, but only dirty entries are stored in it.  At least for
+ * now, we will leave entries in the TBBT after they are flushed.
+ *
+ * Note that index_size and index_len now refer to the total size of
+ * and number of entries in the hash table.
+ *
+ *						JRM - 7/19/04
+ *
+ * The TBBT has since been replaced with a skip list.  This change
+ * greatly predates this note.
+ *
+ *						JRM - 9/26/05
+ *
+ * magic:	Unsigned 32 bit integer always set to H5C__H5C_T_MAGIC. 
+ * 		This field is used to validate pointers to instances of
+ * 		H5C_t.
+ *
+ * flush_in_progress: Boolean flag indicating whether a flush is in
+ * 		progress.
+ *
+ * trace_file_ptr:  File pointer pointing to the trace file, which is used
+ *              to record cache operations for use in simulations and design
+ *              studies.  This field will usually be NULL, indicating that
+ *              no trace file should be recorded.
+ *
+ *              Since much of the code supporting the parallel metadata
+ *              cache is in H5AC, we don't write the trace file from
+ *              H5C.  Instead, H5AC reads the trace_file_ptr as needed.
+ *
+ *              When we get to using H5C in other places, we may add
+ *              code to write trace file data at the H5C level as well.
+ *
+ * logging_enabled: Boolean flag indicating whether cache logging
+ *              which is used to record cache operations for use in
+ *              debugging and performance analysis. When this flag is set
+ *              to TRUE, it means that the log file is open and ready to
+ *              receive log entries. It does NOT mean that cache operations
+ *              are currently being recorded. That is controlled by the
+ *              currently_logging flag (below).
+ *
+ *              Since much of the code supporting the parallel metadata
+ *              cache is in H5AC, we don't write the trace file from
+ *              H5C.  Instead, H5AC reads the trace_file_ptr as needed.
+ *
+ *              When we get to using H5C in other places, we may add
+ *              code to write trace file data at the H5C level as well.
+ *
+ * currently_logging: Boolean flag that indicates if cache operations are
+ *              currently being logged. This flag is flipped by the
+ *              H5Fstart/stop_mdc_logging functions.
+ *
+ * log_file_ptr:  File pointer pointing to the log file. The I/O functions
+ *              in stdio.h are used to write to the log file regardless of
+ *              the VFD selected.
+ *
+ * aux_ptr:	Pointer to void used to allow wrapper code to associate
+ *		its data with an instance of H5C_t.  The H5C cache code
+ *		sets this field to NULL, and otherwise leaves it alone.
+ *
+ * max_type_id:	Integer field containing the maximum type id number assigned
+ *		to a type of entry in the cache.  All type ids from 0 to
+ *		max_type_id inclusive must be defined.  The names of the
+ *		types are stored in the type_name_table discussed below, and
+ *		indexed by the ids.
+ *
+ * class_table_ptr: Pointer to an array of H5C_class_t of length
+ *              max_type_id + 1.  Entry classes for the cache.
+ *
+ * max_cache_size:  Nominal maximum number of bytes that may be stored in the
+ *              cache.  This value should be viewed as a soft limit, as the
+ *              cache can exceed this value under the following circumstances:
+ *
+ *              a) All entries in the cache are protected, and the cache is
+ *                 asked to insert a new entry.  In this case the new entry
+ *                 will be created.  If this causes the cache to exceed
+ *                 max_cache_size, it will do so.  The cache will attempt
+ *                 to reduce its size as entries are unprotected.
+ *
+ *              b) When running in parallel mode, the cache may not be
+ *		   permitted to flush a dirty entry in response to a read.
+ *		   If there are no clean entries available to evict, the
+ *		   cache will exceed its maximum size.  Again the cache
+ *                 will attempt to reduce its size to the max_cache_size
+ *                 limit on the next cache write.
+ *
+ *		c) When an entry increases in size, the cache may exceed
+ *		   the max_cache_size limit until the next time the cache
+ *		   attempts to load or insert an entry.
+ *
+ *		d) When the evictions_enabled field is false (see below),
+ *		   the cache size will increase without limit until the
+ *		   field is set to true.
+ *
+ * min_clean_size: Nominal minimum number of clean bytes in the cache.
+ *              The cache attempts to maintain this number of bytes of
+ *              clean data so as to avoid case b) above.  Again, this is
+ *              a soft limit.
+ *
+ * close_warning_received: Boolean flag indicating that a file closing 
+ *		warning has been received.
+ *
+ *
+ * In addition to the call back functions required for each entry, the
+ * cache requires the following call back functions for this instance of
+ * the cache as a whole:
+ *
+ * check_write_permitted:  In certain applications, the cache may not
+ *		be allowed to write to disk at certain time.  If specified,
+ *		the check_write_permitted function is used to determine if
+ *		a write is permissible at any given point in time.
+ *
+ *		If no such function is specified (i.e. this field is NULL),
+ *		the cache uses the following write_permitted field to
+ *		determine whether writes are permitted.
+ *
+ * write_permitted: If check_write_permitted is NULL, this boolean flag
+ *		indicates whether writes are permitted.
+ *
+ * log_flush:	If provided, this function is called whenever a dirty
+ *		entry is flushed to disk.
+ *
+ *
+ * In cases where memory is plentiful, and performance is an issue, it may
+ * be useful to disable all cache evictions, and thereby postpone metadata
+ * writes.  The following field is used to implement this.
+ *
+ * evictions_enabled:  Boolean flag that is initialized to TRUE.  When
+ * 		this flag is set to FALSE, the metadata cache will not
+ * 		attempt to evict entries to make space for newly protected
+ * 		entries, and instead the will grow without limit.
+ * 		
+ * 		Needless to say, this feature must be used with care.
+ *
+ *
+ * The cache requires an index to facilitate searching for entries.  The
+ * following fields support that index.
+ *
+ * Addendum:  JRM -- 10/14/15
+ *
+ * We sometimes need to visit all entries in the cache.  In the past, this
+ * was done by scanning the hash table.  However, this is expensive, and 
+ * we have come to scan the hash table often enough that it has become a 
+ * performance issue.  To repair this, I have added code to maintain a 
+ * list of all entries in the index -- call this list the index list.  
+ *
+ * The index list is maintained by the same macros that maintain the 
+ * index, and must have the same length and size as the index proper.
+ *
+ * index_len:   Number of entries currently in the hash table used to index
+ *		the cache.
+ *
+ * index_size:  Number of bytes of cache entries currently stored in the
+ *              hash table used to index the cache.
+ *
+ *              This value should not be mistaken for footprint of the
+ *              cache in memory.  The average cache entry is small, and
+ *              the cache has a considerable overhead.  Multiplying the
+ *              index_size by three should yield a conservative estimate
+ *              of the cache's memory footprint.
+ *
+ * index_ring_len: Array of integer of length H5C_RING_NTYPES used to 
+ *		maintain a count of entries in the index by ring.  Note 
+ *		that the sum of all the cells in this array must equal 
+ *		the value stored in index_len above.
+ *
+ * index_ring_size: Array of size_t of length H5C_RING_NTYPES used to 
+ *		maintain the sum of the sizes of all entries in the index
+ *		by ring.  Note that the sum of all cells in this array must
+ *		equal the value stored in index_size above.
+ *
+ * clean_index_size: Number of bytes of clean entries currently stored in
+ * 		the hash table.  Note that the index_size field (above)
+ *		is also the sum of the sizes of all entries in the cache.
+ *		Thus we should have the invariant that clean_index_size +
+ *		dirty_index_size == index_size.
+ *
+ *		WARNING:
+ *
+ *		   The value of the clean_index_size must not be mistaken
+ *		   for the current clean size of the cache.  Rather, the
+ *		   clean size of the cache is the current value of
+ *		   clean_index_size plus the amount of empty space (if any)
+ *                 in the cache.
+ *
+ * clean_index_ring_size: Array of size_t of length H5C_RING_NTYPES used to
+ *		maintain the sum of the sizes of all clean entries in the 
+ *		index by ring.  Note that the sum of all cells in this array 
+ *		must equal the value stored in clean_index_size above.
+ *
+ * dirty_index_size: Number of bytes of dirty entries currently stored in
+ * 		the hash table.  Note that the index_size field (above)
+ *		is also the sum of the sizes of all entries in the cache.
+ *		Thus we should have the invariant that clean_index_size +
+ *		dirty_index_size == index_size.
+ *
+ * dirty_index_ring_size: Array of size_t of length H5C_RING_NTYPES used to
+ *		maintain the sum of the sizes of all dirty entries in the 
+ *		index by ring.  Note that the sum of all cells in this array 
+ *		must equal the value stored in dirty_index_size above.
+ *
+ * index:	Array of pointer to H5C_cache_entry_t of size
+ *		H5C__HASH_TABLE_LEN.  At present, this value is a power
+ *		of two, not the usual prime number.
+ *
+ *		I hope that the variable size of cache elements, the large
+ *		hash table size, and the way in which HDF5 allocates space
+ *		will combine to avoid problems with periodicity.  If so, we
+ *		can use a trivial hash function (a bit-and and a 3 bit left
+ *		shift) with some small savings.
+ *
+ *		If not, it will become evident in the statistics. Changing
+ *		to the usual prime number length hash table will require
+ *		changing the H5C__HASH_FCN macro and the deletion of the
+ *		H5C__HASH_MASK #define.  No other changes should be required.
+ *
+ * il_len:	Number of entries on the index list.  
+ *
+ *		This must always be equal to index_len.  As such, this 
+ *		field is redundant.  However, the existing linked list 
+ *		management macros expect to maintain a length field, so 
+ *		this field exists primarily to avoid adding complexity to
+ *		these macros.
+ *
+ * il_size: 	Number of bytes of cache entries currently stored in the
+ *		index list.
+ *
+ *		This must always be equal to index_size.  As such, this 
+ *		field is redundant.  However, the existing linked list 
+ *		management macros expect to maintain a size field, so 
+ *		this field exists primarily to avoid adding complexity to
+ *		these macros.
+ *
+ * il_head:	Pointer to the head of the doubly linked list of entries in
+ *              the index list.  Note that cache entries on this list are 
+ *		linked by their il_next and il_prev fields.
+ *
+ *              This field is NULL if the index is empty.
+ *
+ * il_tail:	Pointer to the tail of the doubly linked list of entries in
+ *              the index list.  Note that cache entries on this list are 
+ *              linked by their il_next and il_prev fields.
+ *
+ *              This field is NULL if the index is empty.
+ *
+ *
+ * With the addition of the take ownership flag, it is possible that 
+ * an entry may be removed from the cache as the result of the flush of 
+ * a second entry.  In general, this causes little trouble, but it is 
+ * possible that the entry removed may be the next entry in the scan of 
+ * a list.  In this case, we must be able to detect the fact that the 
+ * entry has been removed, so that the scan doesn't attempt to proceed with
+ * an entry that is no longer in the cache.
+ *
+ * The following fields are maintained to facilitate this.
+ *
+ * entries_removed_counter:	Counter that is incremented each time an
+ *		entry is removed from the cache by any means (eviction, 
+ *		expungement, or take ownership at this point in time).
+ *		Functions that perform scans on lists may set this field
+ *		to zero prior to calling H5C__flush_single_entry().  
+ *		Unexpected changes to the counter indicate that an entry 
+ *		was removed from the cache as a side effect of the flush.
+ *
+ * last_entry_removed_ptr:	Pointer to the instance of H5C_cache_entry_t
+ *		which contained the last entry to be removed from the cache,
+ *		or NULL if there either is no such entry, or if a function
+ *		performing a scan of a list has set this field to NULL prior
+ *		to calling H5C__flush_single_entry().
+ *
+ *		WARNING!!! This field must NEVER be dereferenced.  It is 
+ *		maintained to allow functions that perform scans of lists
+ *		to compare this pointer with their pointers to next, thus
+ *		allowing them to avoid unnecessary restarts of scans if the
+ *		pointers don't match, and if entries_removed_counter is 
+ *		one.
+ *
+ * entry_watched_for_removal:	Pointer to an instance of H5C_cache_entry_t
+ *		which contains the 'next' entry for an iteration.  Removing
+ *              this entry must trigger a rescan of the iteration, so each
+ *              entry removed from the cache is compared against this pointer
+ *              and the pointer is reset to NULL if the watched entry is removed.
+ *              (This functions similarly to a "dead man's switch")
+ *
+ *
+ * When we flush the cache, we need to write entries out in increasing
+ * address order.  An instance of a skip list is used to store dirty entries in
+ * sorted order.  Whether it is cheaper to sort the dirty entries as needed,
+ * or to maintain the list is an open question.  At a guess, it depends
+ * on how frequently the cache is flushed.  We will see how it goes.
+ *
+ * For now at least, I will not remove dirty entries from the list as they
+ * are flushed. (this has been changed -- dirty entries are now removed from
+ * the skip list as they are flushed.  JRM - 10/25/05)
+ *
+ * slist_changed: Boolean flag used to indicate whether the contents of 
+ *		the slist has changed since the last time this flag was
+ *		reset.  This is used in the cache flush code to detect 
+ *		conditions in which pre-serialize or serialize callbacks
+ *		have modified the slist -- which obliges us to restart 
+ *		the scan of the slist from the beginning.
+ *
+ * slist_len:   Number of entries currently in the skip list
+ *              used to maintain a sorted list of dirty entries in the
+ *              cache.
+ *
+ * slist_size:  Number of bytes of cache entries currently stored in the
+ *              skip list used to maintain a sorted list of
+ *              dirty entries in the cache.
+ *
+ * slist_ring_len: Array of integer of length H5C_RING_NTYPES used to 
+ *		maintain a count of entries in the slist by ring.  Note 
+ *		that the sum of all the cells in this array must equal 
+ *		the value stored in slist_len above.
+ *
+ * slist_ring_size: Array of size_t of length H5C_RING_NTYPES used to
+ *              maintain the sum of the sizes of all entries in the 
+ *		slist by ring.  Note that the sum of all cells in this 
+ *		array must equal the value stored in slist_size above.
+ *
+ * slist_ptr:   pointer to the instance of H5SL_t used maintain a sorted
+ *              list of dirty entries in the cache.  This sorted list has
+ *              two uses:
+ *
+ *              a) It allows us to flush dirty entries in increasing address
+ *                 order, which results in significant savings.
+ *
+ *              b) It facilitates checking for adjacent dirty entries when
+ *                 attempting to evict entries from the cache.  While we
+ *                 don't use this at present, I hope that this will allow
+ *                 some optimizations when I get to it.
+ *
+ * num_last_entries: The number of entries in the cache that can only be
+ *		flushed after all other entries in the cache have
+ *              been flushed. At this time, this will only ever be
+ *              one entry (the superblock), and the code has been
+ *              protected with HDasserts to enforce this. This restraint
+ *              can certainly be relaxed in the future if the need for
+ *              multiple entries being flushed last arises, though
+ *              explicit tests for that case should be added when said
+ *              HDasserts are removed.
+ *
+ *		Update: There are now two possible last entries
+ *		(superblock and file driver info message).  This
+ *		number will probably increase as we add superblock
+ *		messages.   JRM -- 11/18/14
+ *
+ * With the addition of the fractal heap, the cache must now deal with
+ * the case in which entries may be dirtied, moved, or have their sizes
+ * changed during a flush.  To allow sanity checks in this situation, the
+ * following two fields have been added.  They are only compiled in when
+ * H5C_DO_SANITY_CHECKS is TRUE.
+ *
+ * slist_len_increase: Number of entries that have been added to the
+ * 		slist since the last time this field was set to zero.
+ *		Note that this value can be negative.
+ *
+ * slist_size_increase: Total size of all entries that have been added
+ * 		to the slist since the last time this field was set to
+ * 		zero.  Note that this value can be negative.
+ *
+ * Cache entries belonging to a particular object are "tagged" with that
+ * object's base object header address.
+ *
+ * The following fields are maintained to facilitate this.
+ *
+ * tag_list: A skip list to track entries that belong to an object.
+ *                Each H5C_tag_info_t struct on the tag list corresponds to
+ *                a particular object in the file.  Tagged entries can be
+ *                flushed or evicted as a group, or corked to prevent entries
+ *                from being evicted from the cache.
+ *
+ *                "Global" entries, like the superblock and the file's
+ *                freelist, as well as shared entries like global
+ *                heaps and shared object header messages, are not tagged.
+ *
+ * ignore_tags:	Boolean flag to disable tag validation during entry insertion.
+ *
+ * When a cache entry is protected, it must be removed from the LRU
+ * list(s) as it cannot be either flushed or evicted until it is unprotected.
+ * The following fields are used to implement the protected list (pl).
+ *
+ * pl_len:      Number of entries currently residing on the protected list.
+ *
+ * pl_size:     Number of bytes of cache entries currently residing on the
+ *              protected list.
+ *
+ * pl_head_ptr: Pointer to the head of the doubly linked list of protected
+ *              entries.  Note that cache entries on this list are linked
+ *              by their next and prev fields.
+ *
+ *              This field is NULL if the list is empty.
+ *
+ * pl_tail_ptr: Pointer to the tail of the doubly linked list of protected
+ *              entries.  Note that cache entries on this list are linked
+ *              by their next and prev fields.
+ *
+ *              This field is NULL if the list is empty.
+ *
+ *
+ * For very frequently used entries, the protect/unprotect overhead can
+ * become burdensome.  To avoid this overhead, I have modified the cache
+ * to allow entries to be "pinned".  A pinned entry is similar to a
+ * protected entry, in the sense that it cannot be evicted, and that
+ * the entry can be modified at any time.
+ *
+ * Pinning an entry has the following implications:
+ *
+ *	1) A pinned entry cannot be evicted.  Thus unprotected
+ *         pinned entries reside in the pinned entry list, instead
+ *         of the LRU list(s) (or other lists maintained by the current
+ *         replacement policy code).
+ *
+ *      2) A pinned entry can be accessed or modified at any time.
+ *         This places an additional burden on the associated pre-serialize
+ *	   and serialize callbacks, which must ensure the the entry is in 
+ *	   a consistant state before creating an image of it.
+ *
+ *      3) A pinned entry can be marked as dirty (and possibly
+ *         change size) while it is unprotected.
+ *
+ *      4) The flush-destroy code must allow pinned entries to
+ *         be unpinned (and possibly unprotected) during the
+ *         flush.
+ *
+ * Since pinned entries cannot be evicted, they must be kept on a pinned
+ * entry list (pel), instead of being entrusted to the replacement policy 
+ * code.
+ *
+ * Maintaining the pinned entry list requires the following fields:
+ *
+ * pel_len:	Number of entries currently residing on the pinned
+ * 		entry list.
+ *
+ * pel_size:	Number of bytes of cache entries currently residing on
+ * 		the pinned entry list.
+ *
+ * pel_head_ptr: Pointer to the head of the doubly linked list of pinned
+ * 		but not protected entries.  Note that cache entries on
+ * 		this list are linked by their next and prev fields.
+ *
+ *              This field is NULL if the list is empty.
+ *
+ * pel_tail_ptr: Pointer to the tail of the doubly linked list of pinned
+ * 		but not protected entries.  Note that cache entries on
+ * 		this list are linked by their next and prev fields.
+ *
+ *              This field is NULL if the list is empty.
+ *
+ *
+ * The cache must have a replacement policy, and the fields supporting this
+ * policy must be accessible from this structure.
+ *
+ * While there has been interest in several replacement policies for
+ * this cache, the initial development schedule is tight.  Thus I have
+ * elected to support only a modified LRU (least recently used) policy 
+ * for the first cut.
+ *
+ * To further simplify matters, I have simply included the fields needed
+ * by the modified LRU in this structure.  When and if we add support for
+ * other policies, it will probably be easiest to just add the necessary
+ * fields to this structure as well -- we only create one instance of this
+ * structure per file, so the overhead is not excessive.
+ *
+ *
+ * Fields supporting the modified LRU policy:
+ *
+ * See most any OS text for a discussion of the LRU replacement policy.
+ *
+ * When operating in parallel mode, we must ensure that a read does not
+ * cause a write.  If it does, the process will hang, as the write will
+ * be collective and the other processes will not know to participate.
+ *
+ * To deal with this issue, I have modified the usual LRU policy by adding
+ * clean and dirty LRU lists to the usual LRU list.  In general, these 
+ * lists are only exist in parallel builds.
+ *
+ * The clean LRU list is simply the regular LRU list with all dirty cache
+ * entries removed.
+ *
+ * Similarly, the dirty LRU list is the regular LRU list with all the clean
+ * cache entries removed.
+ *
+ * When reading in parallel mode, we evict from the clean LRU list only.
+ * This implies that we must try to ensure that the clean LRU list is
+ * reasonably well stocked at all times.
+ *
+ * We attempt to do this by trying to flush enough entries on each write
+ * to keep the cLRU_list_size >= min_clean_size.
+ *
+ * Even if we start with a completely clean cache, a sequence of protects
+ * without unprotects can empty the clean LRU list.  In this case, the
+ * cache must grow temporarily.  At the next sync point, we will attempt to
+ * evict enough entries to reduce index_size to less than max_cache_size.
+ * While this will usually be possible, all bets are off if enough entries
+ * are protected.
+ *
+ * Discussions of the individual fields used by the modified LRU replacement
+ * policy follow:
+ *
+ * LRU_list_len:  Number of cache entries currently on the LRU list.
+ *
+ *              Observe that LRU_list_len + pl_len + pel_len must always 
+ *		equal index_len.
+ *
+ * LRU_list_size:  Number of bytes of cache entries currently residing on the
+ *              LRU list.
+ *
+ *              Observe that LRU_list_size + pl_size + pel_size must always 
+ *		equal index_size.
+ *
+ * LRU_head_ptr:  Pointer to the head of the doubly linked LRU list.  Cache
+ *              entries on this list are linked by their next and prev fields.
+ *
+ *              This field is NULL if the list is empty.
+ *
+ * LRU_tail_ptr:  Pointer to the tail of the doubly linked LRU list.  Cache
+ *              entries on this list are linked by their next and prev fields.
+ *
+ *              This field is NULL if the list is empty.
+ *
+ * cLRU_list_len: Number of cache entries currently on the clean LRU list.
+ *
+ *              Observe that cLRU_list_len + dLRU_list_len must always
+ *              equal LRU_list_len.
+ *
+ * cLRU_list_size:  Number of bytes of cache entries currently residing on
+ *              the clean LRU list.
+ *
+ *              Observe that cLRU_list_size + dLRU_list_size must always
+ *              equal LRU_list_size.
+ *
+ * cLRU_head_ptr:  Pointer to the head of the doubly linked clean LRU list.
+ *              Cache entries on this list are linked by their aux_next and
+ *              aux_prev fields.
+ *
+ *              This field is NULL if the list is empty.
+ *
+ * cLRU_tail_ptr:  Pointer to the tail of the doubly linked clean LRU list.
+ *              Cache entries on this list are linked by their aux_next and
+ *              aux_prev fields.
+ *
+ *              This field is NULL if the list is empty.
+ *
+ * dLRU_list_len: Number of cache entries currently on the dirty LRU list.
+ *
+ *              Observe that cLRU_list_len + dLRU_list_len must always
+ *              equal LRU_list_len.
+ *
+ * dLRU_list_size:  Number of cache entries currently on the dirty LRU list.
+ *
+ *              Observe that cLRU_list_len + dLRU_list_len must always
+ *              equal LRU_list_len.
+ *
+ * dLRU_head_ptr:  Pointer to the head of the doubly linked dirty LRU list.
+ *              Cache entries on this list are linked by their aux_next and
+ *              aux_prev fields.
+ *
+ *              This field is NULL if the list is empty.
+ *
+ * dLRU_tail_ptr:  Pointer to the tail of the doubly linked dirty LRU list.
+ *              Cache entries on this list are linked by their aux_next and
+ *              aux_prev fields.
+ *
+ *              This field is NULL if the list is empty.
+ *
+ *
+ * Automatic cache size adjustment:
+ *
+ * While the default cache size is adequate for most cases, we can run into
+ * cases where the default is too small.  Ideally, we will let the user
+ * adjust the cache size as required.  However, this is not possible in all
+ * cases.  Thus I have added automatic cache size adjustment code.
+ *
+ * The configuration for the automatic cache size adjustment is stored in
+ * the structure described below:
+ *
+ * size_increase_possible:  Depending on the configuration data given
+ *		in the resize_ctl field, it may or may not be possible
+ *		to increase the size of the cache.  Rather than test for
+ *		all the ways this can happen, we simply set this flag when
+ *		we receive a new configuration.
+ *
+ * flash_size_increase_possible: Depending on the configuration data given
+ *              in the resize_ctl field, it may or may not be possible
+ *              for a flash size increase to occur.  We set this flag
+ *              whenever we receive a new configuration so as to avoid
+ *              repeated calculations.
+ *
+ * flash_size_increase_threshold: If a flash cache size increase is possible,
+ *              this field is used to store the minimum size of a new entry
+ *              or size increase needed to trigger a flash cache size
+ *              increase.  Note that this field must be updated whenever
+ *              the size of the cache is changed.
+ *
+ * size_decrease_possible:  Depending on the configuration data given
+ *              in the resize_ctl field, it may or may not be possible
+ *              to decrease the size of the cache.  Rather than test for
+ *              all the ways this can happen, we simply set this flag when
+ *              we receive a new configuration.
+ *
+ * resize_enabled:  This is another convenience flag which is set whenever
+ *		a new set of values for resize_ctl are provided.  Very
+ *		simply,
+ *
+ *		    resize_enabled = size_increase_possible ||
+ *                                   size_decrease_possible;
+ *
+ * cache_full:	Boolean flag used to keep track of whether the cache is
+ *		full, so we can refrain from increasing the size of a
+ *		cache which hasn't used up the space allotted to it.
+ *
+ *		The field is initialized to FALSE, and then set to TRUE
+ *		whenever we attempt to make space in the cache.
+ *
+ * size_decreased:  Boolean flag set to TRUE whenever the maximum cache
+ *		size is decreased.  The flag triggers a call to
+ *		H5C__make_space_in_cache() on the next call to H5C_protect().
+ *
+ * resize_in_progress: As the metadata cache has become re-entrant, it is 
+ *		possible that a protect may trigger a call to 
+ *		H5C__auto_adjust_cache_size(), which may trigger a flush,
+ *		which may trigger a protect, which will result in another 
+ *		call to H5C__auto_adjust_cache_size().  
+ *
+ *		The resize_in_progress boolean flag is used to detect this,
+ *		and to prevent the infinite recursion that would otherwise
+ *		occur.
+ *
+ *		Note that this issue is not hypothetical -- this field 
+ *		was added 12/29/15 to fix a bug exposed in the testing 
+ *		of changes to the file driver info superblock extension
+ *		management code needed to support rings.
+ *
+ * msic_in_progress: As the metadata cache has become re-entrant, and as
+ *              the free space manager code has become more tightly 
+ *              integrated with the metadata cache, it is possible that 
+ *              a call to H5C_insert_entry() may trigger a call to 
+ *              H5C_make_space_in_cache(), which, via H5C__flush_single_entry()
+ *              and client callbacks, may trigger an infinite regression
+ *              of calls to H5C_make_space_in_cache().
+ *
+ *              The msic_in_progress boolean flag is used to detect this,
+ *              and prevent the infinite regression that would otherwise
+ *              occur.
+ *
+ *              Note that this is issue is not hypothetical -- this field 
+ *              was added 2/16/17 to address this issue when it was 
+ *              exposed by modifications to test/fheap.c to cause it to 
+ *              use paged allocation.
+ *
+ * resize_ctl:	Instance of H5C_auto_size_ctl_t containing configuration
+ * 		data for automatic cache resizing.
+ *
+ * epoch_markers_active:  Integer field containing the number of epoch
+ *		markers currently in use in the LRU list.  This value
+ *		must be in the range [0, H5C__MAX_EPOCH_MARKERS - 1].
+ *
+ * epoch_marker_active:  Array of boolean of length H5C__MAX_EPOCH_MARKERS.
+ *		This array is used to track which epoch markers are currently
+ *		in use.
+ *
+ * epoch_marker_ringbuf:  Array of int of length H5C__MAX_EPOCH_MARKERS + 1.
+ *
+ *		To manage the epoch marker cache entries, it is necessary
+ *		to track their order in the LRU list.  This is done with
+ *		epoch_marker_ringbuf.  When markers are inserted at the
+ *		head of the LRU list, the index of the marker in the
+ *		epoch_markers array is inserted at the tail of the ring
+ *		buffer.  When it becomes the epoch_marker_active'th marker
+ *		in the LRU list, it will have worked its way to the head
+ *		of the ring buffer as well.  This allows us to remove it
+ *		without scanning the LRU list if such is required.
+ *
+ * epoch_marker_ringbuf_first: Integer field containing the index of the
+ *		first entry in the ring buffer.
+ *
+ * epoch_marker_ringbuf_last: Integer field containing the index of the
+ *		last entry in the ring buffer.
+ *
+ * epoch_marker_ringbuf_size: Integer field containing the number of entries
+ *		in the ring buffer.
+ *
+ * epoch_markers:  Array of instances of H5C_cache_entry_t of length
+ *		H5C__MAX_EPOCH_MARKERS.  The entries are used as markers
+ *		in the LRU list to identify cache entries that haven't
+ *		been accessed for some (small) specified number of
+ *		epochs.  These entries (if any) can then be evicted and
+ *		the cache size reduced -- ideally without evicting any
+ *		of the current working set.  Needless to say, the epoch
+ *		length and the number of epochs before an unused entry
+ *		must be chosen so that all, or almost all, the working
+ *		set will be accessed before the limit.
+ *
+ *		Epoch markers only appear in the LRU list, never in
+ *		the index or slist.  While they are of type
+ *		H5C__EPOCH_MARKER_TYPE, and have associated class
+ *		functions, these functions should never be called.
+ *
+ *		The addr fields of these instances of H5C_cache_entry_t
+ *		are set to the index of the instance in the epoch_markers
+ *		array, the size is set to 0, and the type field points
+ *		to the constant structure epoch_marker_class defined
+ *		in H5C.c.  The next and prev fields are used as usual
+ *		to link the entry into the LRU list.
+ *
+ *		All other fields are unused.
+ *
+ *
+ * Cache hit rate collection fields:
+ *
+ * We supply the current cache hit rate on request, so we must keep a
+ * simple cache hit rate computation regardless of whether statistics
+ * collection is enabled.  The following fields support this capability.
+ *
+ * cache_hits: Number of cache hits since the last time the cache hit
+ *	rate statistics were reset.  Note that when automatic cache
+ *	re-sizing is enabled, this field will be reset every automatic
+ *	resize epoch.
+ *
+ * cache_accesses: Number of times the cache has been accessed while
+ *	since the last since the last time the cache hit rate statistics
+ *	were reset.  Note that when automatic cache re-sizing is enabled,
+ *	this field will be reset every automatic resize epoch.
+ *
+ *
+ * Metadata cache image management related fields.
+ *
+ * image_ctl:	Instance of H5C_cache_image_ctl_t containing configuration
+ * 		data for generation of a cache image on file close.
+ *
+ * serialization_in_progress:  Boolean field that is set to TRUE iff
+ *		the cache is in the process of being serialized.  This 
+ *		field is needed to support the H5C_serialization_in_progress()
+ *		call, which is in turn required for sanity checks in some
+ *		cache clients.
+ *
+ * load_image:	Boolean flag indicating that the metadata cache image 
+ *		superblock extension message exists and should be 
+ *		read, and the image block read and decoded on the next
+ *		call to H5C_protect().  
+ *
+ * image_loaded:  Boolean flag indicating that the metadata cache has 
+ *              loaded the metadata cache image as directed by the 
+ *              MDC cache image superblock extension message.
+ *
+ * delete_image: Boolean flag indicating whether the metadata cache image
+ *		superblock message should be deleted and the cache image
+ *		file space freed after they have been read and decoded.
+ *
+ *		This flag should be set to TRUE iff the file is opened 
+ *		R/W and there is a cache image to be read.
+ *
+ * image_addr:  haddr_t containing the base address of the on disk 
+ *		metadata cache image, or HADDR_UNDEF if that value is 
+ *		undefined.  Note that this field is used both in the 
+ *		construction and write, and the read and decode of 
+ *		metadata cache image blocks.
+ *
+ * image_len:	hsize_t containing the size of the on disk metadata cache 
+ *		image, or zero if that value is undefined.  Note that this 
+ *		field is used both in the construction and write, and the 
+ *		read and decode of metadata cache image blocks.
+ *
+ * image_data_len:  size_t containing the number of bytes of data in the 
+ *		on disk metadata cache image, or zero if that value is 
+ *		undefined.
+ *
+ *		In most cases, this value is the same as the image_len
+ *		above.  It exists to allow for metadata cache image blocks
+ *		that are larger than the actual image.  Thus in all 
+ *		cases image_data_len <= image_len.
+ *
+ * To create the metadata cache image, we must first serialize all the
+ * entries in the metadata cache.  This is done by a scan of the index.
+ * As entries must be serialized in increasing flush dependency height
+ * order, we scan the index repeatedly, once for each flush dependency
+ * height in increasing order.
+ *
+ * This operation is complicated by the fact that entries other the the
+ * target may be inserted, loaded, relocated, or removed from the cache 
+ * (either by eviction or the take ownership flag) as the result of a 
+ * pre_serialize or serialize callback.  While entry removals are not 
+ * a problem for the scan of the index, insertions, loads, and relocations
+ * are.  Hence the entries loaded, inserted, and relocated counters 
+ * listed below have been implemented to allow these conditions to be 
+ * detected and dealt with by restarting the scan.
+ *
+ * The serialization operation is further complicated by the fact that 
+ * the flush dependency height of a given entry may increase (as the 
+ * result of an entry load or insert) or decrease (as the result of an 
+ * entry removal -- via either eviction or the take ownership flag).  The
+ * entry_fd_height_change_counter field is maintained to allow detection
+ * of this condition, and a restart of the scan when it occurs.
+ *
+ * Note that all these new fields would work just as well as booleans.
+ *
+ * entries_loaded_counter: Number of entries loaded into the cache 
+ *		since the last time this field was reset.
+ *
+ * entries_inserted_counter: Number of entries inserted into the cache 
+ *		since the last time this field was reset.
+ *
+ * entries relocated_counter: Number of entries whose base address has
+ *		been changed since the last time this field was reset.
+ *
+ * entry_fd_height_change_counter: Number of entries whose flush dependency
+ *		height has changed since the last time this field was reset.
+ *
+ * The following fields are used assemble the cache image prior to 
+ * writing it to disk.
+ *
+ * num_entries_in_image: Unsigned integer field containing the number of entries
+ *		to be copied into the metadata cache image.  Note that 
+ *		this value will be less than the number of entries in 
+ *		the cache, and the superblock and its related entries 
+ *		are not written to the metadata cache image.
+ *
+ * image_entries: Pointer to a dynamically allocated array of instance of
+ *		H5C_image_entry_t of length num_entries_in_image, or NULL
+ *		if that array does not exist.  This array is used to
+ *		assemble entry data to be included in the image, and to 
+ *		sort them by flush dependency height and LRU rank.
+ * 
+ * image_buffer: Pointer to the dynamically allocated buffer of length
+ *		image_len in which the metadata cache image is assembled, 
+ *		or NULL if that	buffer does not exist.
+ *
+ *
+ * Free Space Manager Related fields:
+ *
+ * The free space managers must be informed when we are about to close 
+ * or flush the file so that they order themselves accordingly.  This used
+ * to be done much later in the close process, but with cache image and 
+ * page buffering, this is no longer viable, as we must finalize the on 
+ * disk image of all metadata much sooner.
+ *
+ * This is handled by the H5MF_settle_raw_data_fsm() and
+ * H5MF_settle_meta_data_FSM() routines.  As these calls are expensive,
+ * the following fields are used to track whether the target free space
+ * managers are clean.
+ *
+ * They are also used in sanity checking, as once a free space manager is
+ * settled, it should not become unsettled (i.e. be asked to allocate or
+ * free file space) either ever (in the case of a file close) or until the
+ * flush is complete.
+ *
+ * rdfsm_settled:  Boolean flag indicating whether the raw data free space
+ *		manager is settled -- i.e. whether the correct space has 
+ *		been allocated for it in the file.
+ *
+ *		Note that the name of this field is deceptive.  In the 
+ *		multi file case, the flag applies to all free space 
+ *		managers that are not involved in allocating space for
+ *		free space manager metadata.
+ *
+ * mdfsm_settled:  Boolean flag indicating whether the meta data free space
+ *              manager is settled -- i.e. whether the correct space has
+ *              been allocated for it in the file.
+ *
+ *              Note that the name of this field is deceptive.  In the 
+ *              multi file case, the flag applies only to free space 
+ *		managers that are involved in allocating space for free 
+ *		space managers.
+ *
+ *
+ * Statistics collection fields:
+ *
+ * When enabled, these fields are used to collect statistics as described
+ * below.  The first set are collected only when H5C_COLLECT_CACHE_STATS
+ * is true.
+ *
+ * hits:        Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the number of times an entry with type id
+ *		equal to the array index has been in cache when requested in
+ *		the current epoch.
+ *
+ * misses:      Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the number of times an entry with type id
+ *		equal to the array index has not been in cache when
+ *		requested in the current epoch.
+ *
+ * write_protects:  Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The
+ * 		cells are used to record the number of times an entry with
+ * 		type id equal to the array index has been write protected
+ * 		in the current epoch.
+ *
+ * 		Observe that (hits + misses) = (write_protects + read_protects).
+ *
+ * read_protects: Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The
+ * 		cells are used to record the number of times an entry with
+ * 		type id equal to the array index has been read protected in
+ * 		the current epoch.
+ *
+ *              Observe that (hits + misses) = (write_protects + read_protects).
+ *
+ * max_read_protects:  Array of int32 of length H5C__MAX_NUM_TYPE_IDS + 1.
+ * 		The cells are used to maximum number of simultaneous read
+ * 		protects on any entry with type id equal to the array index
+ * 		in the current epoch.
+ *
+ * insertions:  Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the number of times an entry with type
+ *		id equal to the array index has been inserted into the
+ *		cache in the current epoch.
+ *
+ * pinned_insertions:  Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1. 
+ * 		The cells are used to record the number of times an entry
+ * 		with type id equal to the array index has been inserted
+ * 		pinned into the cache in the current epoch.
+ *
+ * clears:      Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the number of times a dirty entry with type
+ *		id equal to the array index has been cleared in the current
+ *		epoch.
+ *
+ * flushes:     Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the number of times an entry with type id
+ *		equal to the array index has been written to disk in the
+ *              current epoch.
+ *
+ * evictions:   Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the number of times an entry with type id
+ *		equal to the array index has been evicted from the cache in
+ *		the current epoch.
+ *
+ * take_ownerships: Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The 
+ *		cells are used to record the number of times an entry with 
+ *		type id equal to the array index has been removed from the 
+ *		cache via the H5C__TAKE_OWNERSHIP_FLAG in the current epoch.
+ *
+ * moves:       Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the number of times an entry with type
+ *		id equal to the array index has been moved in the current
+ *		epoch.
+ *
+ * entry_flush_moves: Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1. 
+ * 		The cells are used to record the number of times an entry
+ * 		with type id equal to the array index has been moved
+ * 		during its pre-serialize callback in the current epoch.
+ *
+ * cache_flush_moves: Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1. 
+ * 		The cells are used to record the number of times an entry
+ * 		with type id equal to the array index has been moved
+ * 		during a cache flush in the current epoch.
+ *
+ * pins:        Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the number of times an entry with type
+ *		id equal to the array index has been pinned in the current
+ *		epoch.
+ *
+ * unpins:      Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the number of times an entry with type
+ *		id equal to the array index has been unpinned in the current
+ *		epoch.
+ *
+ * dirty_pins:	Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the number of times an entry with type
+ *		id equal to the array index has been marked dirty while pinned
+ *		in the current epoch.
+ *
+ * pinned_flushes:  Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The
+ * 		cells are used to record the number of times an  entry
+ * 		with type id equal to the array index has been flushed while
+ * 		pinned in the current epoch.
+ *
+ * pinned_clears:  Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.  The
+ * 		cells are used to record the number of times an  entry
+ * 		with type id equal to the array index has been cleared while
+ * 		pinned in the current epoch.
+ *
+ * size_increases:  Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.
+ *		The cells are used to record the number of times an entry
+ *		with type id equal to the array index has increased in
+ *		size in the current epoch.
+ *
+ * size_decreases:  Array of int64 of length H5C__MAX_NUM_TYPE_IDS + 1.
+ *		The cells are used to record the number of times an entry
+ *		with type id equal to the array index has decreased in
+ *		size in the current epoch.
+ *
+ * entry_flush_size_changes:  Array of int64 of length
+ * 		H5C__MAX_NUM_TYPE_IDS + 1.  The cells are used to record
+ * 		the number of times an entry with type id equal to the
+ * 		array index has changed size while in its pre-serialize 
+ *		callback.
+ *
+ * cache_flush_size_changes:  Array of int64 of length
+ * 		H5C__MAX_NUM_TYPE_IDS + 1.  The cells are used to record
+ * 		the number of times an entry with type id equal to the
+ * 		array index has changed size during a cache flush
+ *
+ * total_ht_insertions: Number of times entries have been inserted into the
+ *		hash table in the current epoch.
+ *
+ * total_ht_deletions: Number of times entries have been deleted from the
+ *              hash table in the current epoch.
+ *
+ * successful_ht_searches: int64 containing the total number of successful
+ *		searches of the hash table in the current epoch.
+ *
+ * total_successful_ht_search_depth: int64 containing the total number of
+ *		entries other than the targets examined in successful
+ *		searches of the hash table in the current epoch.
+ *
+ * failed_ht_searches: int64 containing the total number of unsuccessful
+ *              searches of the hash table in the current epoch.
+ *
+ * total_failed_ht_search_depth: int64 containing the total number of
+ *              entries examined in unsuccessful searches of the hash
+ *		table in the current epoch.
+ *
+ * max_index_len:  Largest value attained by the index_len field in the
+ *              current epoch.
+ *
+ * max_index_size:  Largest value attained by the index_size field in the
+ *              current epoch.
+ *
+ * max_clean_index_size: Largest value attained by the clean_index_size field
+ * 		in the current epoch.
+ *
+ * max_dirty_index_size: Largest value attained by the dirty_index_size field
+ * 		in the current epoch.
+ *
+ * max_slist_len:  Largest value attained by the slist_len field in the
+ *              current epoch.
+ *
+ * max_slist_size:  Largest value attained by the slist_size field in the
+ *              current epoch.
+ *
+ * max_pl_len:  Largest value attained by the pl_len field in the
+ *              current epoch.
+ *
+ * max_pl_size: Largest value attained by the pl_size field in the
+ *              current epoch.
+ *
+ * max_pel_len: Largest value attained by the pel_len field in the
+ *              current epoch.
+ *
+ * max_pel_size: Largest value attained by the pel_size field in the
+ *              current epoch.
+ *
+ * calls_to_msic: Total number of calls to H5C__make_space_in_cache
+ *
+ * total_entries_skipped_in_msic: Number of clean entries skipped while
+ *              enforcing the min_clean_fraction in H5C__make_space_in_cache().
+ *
+ * total_dirty_pf_entries_skipped_in_msic: Number of dirty prefetched entries
+ *              skipped in H5C__make_space_in_cache().  Note that this can 
+ *              only occur when a file is opened R/O with a cache image
+ *              containing dirty entries.
+ *
+ * total_entries_scanned_in_msic: Number of clean entries skipped while
+ *              enforcing the min_clean_fraction in H5C__make_space_in_cache().
+ *
+ * max_entries_skipped_in_msic: Maximum number of clean entries skipped
+ *              in any one call to H5C__make_space_in_cache().
+ *
+ * max_dirty_pf_entries_skipped_in_msic: Maximum number of dirty prefetched
+ *              entries skipped in any one call to H5C__make_space_in_cache().
+ *              Note that this can only occur when the file is opened 
+ *              R/O with a cache image containing dirty entries.
+ *
+ * max_entries_scanned_in_msic: Maximum number of entries scanned over
+ *              in any one call to H5C__make_space_in_cache().
+ *
+ * entries_scanned_to_make_space: Number of entries scanned only when looking
+ *              for entries to evict in order to make space in cache.
+ *
+ *
+ * The following fields track statistics on cache images.  
+ *
+ * images_created:  Integer field containing the number of cache images
+ *		created since the last time statistics were reset.  
+ *
+ *		At present, this field must always be either 0 or 1.
+ *		Further, since cache images are only created at file 
+ *		close, this field should only be set at that time.
+ *
+ * images_read: Integer field containing the number of cache images 
+ *              read from file.  Note that reading an image is different
+ *              from loading it -- reading the image means just that,
+ *              while loading the image refers to decoding it and loading
+ *              it into the metadata cache.
+ *
+ *              In the serial case, image_read should always equal 
+ *              images_loaded.  However, in the parallel case, the 
+ *              image should only be read by process 0.  All other 
+ *              processes should receive the cache image via a broadcast
+ *              from process 0.
+ *
+ * images_loaded:  Integer field containing the number of cache images
+ *		loaded since the last time statistics were reset.
+ *
+ *		At present, this field must always be either 0 or 1.
+ *		Further, since cache images are only loaded at the 
+ *		time of the first protect or on file close, this value
+ *		should only change on those events.
+ *
+ * last_image_size:  Size of the most recently loaded metadata cache image
+ *             loaded into the cache, or zero if no image has been
+ *             loaded.  
+ *
+ *             At present, at most one cache image can be loaded into 
+ *             the metadata cache for any given file, and this image
+ *             will be loaded either on the first protect, or on file
+ *             close if no entry is protected before then.
+ *
+ *
+ * Fields for tracking prefetched entries.  Note that flushes and evictions
+ * of prefetched entries are tracked in the flushes and evictions arrays 
+ * discused above.
+ *
+ * prefetches:	Number of prefetched entries that are loaded to the 
+ *		cache.
+ *
+ * dirty_prefetches:  Number of dirty prefetched entries that are loaded
+ *		into the cache.
+ *
+ * prefetch_hits:  Number of prefetched entries that are actually used.
+ *
+ * 
+ * As entries are now capable of moving, loading, dirtying, and deleting 
+ * other entries in their pre_serialize and serialize callbacks, it has 
+ * been necessary to insert code to restart scans of lists so as to avoid 
+ * improper behavior if the next entry in the list is the target of one on 
+ * these operations.
+ *
+ * The following fields are use to count such occurances.  They are used 
+ * both in tests (to verify that the scan has been restarted), and to 
+ * obtain estimates of how frequently these restarts occur.
+ *
+ * slist_scan_restarts: Number of times a scan of the slist (that contains
+ *		calls to H5C__flush_single_entry()) has been restarted to 
+ *		avoid potential issues with change of status of the next 
+ *		entry in the scan.
+ *
+ * LRU_scan_restarts: Number of times a scan of the LRU list (that contains
+ *              calls to H5C__flush_single_entry()) has been restarted to 
+ *              avoid potential issues with change of status of the next 
+ *              entry in the scan.
+ *
+ * index_scan_restarts: Number of times a scan of the index has been 
+ *		restarted to avoid potential issues with load, insertion
+ *		or change in flush dependency height of an entry other 
+ *		than the target entry as the result of call(s) to the
+ *		pre_serialize or serialize callbacks.
+ *
+ *		Note that at present, this condition can only be triggerd
+ *		by a call to H5C_serialize_single_entry().
+ *
+ * The remaining stats are collected only when both H5C_COLLECT_CACHE_STATS
+ * and H5C_COLLECT_CACHE_ENTRY_STATS are true.
+ *
+ * max_accesses: Array of int32 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the maximum number of times any single
+ *		entry with type id equal to the array index has been
+ *		accessed in the current epoch.
+ *
+ * min_accesses: Array of int32 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the minimum number of times any single
+ *		entry with type id equal to the array index has been
+ *		accessed in the current epoch.
+ *
+ * max_clears:  Array of int32 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the maximum number of times any single
+ *		entry with type id equal to the array index has been cleared
+ *		in the current epoch.
+ *
+ * max_flushes: Array of int32 of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *		are used to record the maximum number of times any single
+ *		entry with type id equal to the array index has been
+ *		flushed in the current epoch.
+ *
+ * max_size:	Array of size_t of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *              are used to record the maximum size of any single entry
+ *		with type id equal to the array index that has resided in
+ *		the cache in the current epoch.
+ *
+ * max_pins:	Array of size_t of length H5C__MAX_NUM_TYPE_IDS + 1.  The cells
+ *              are used to record the maximum number of times that any single
+ *              entry with type id equal to the array index that has been
+ *              marked as pinned in the cache in the current epoch.
+ *
+ *
+ * Fields supporting testing:
+ *
+ * prefix	Array of char used to prefix debugging output.  The
+ *		field is intended to allow marking of output of with
+ *		the processes mpi rank.
+ *
+ * get_entry_ptr_from_addr_counter: Counter used to track the number of
+ *              times the H5C_get_entry_ptr_from_addr() function has been
+ *              called successfully.  This field is only defined when
+ *              NDEBUG is not #defined.
+ *
+ ****************************************************************************/
+struct H5C_t {
+    uint32_t			magic;
+    hbool_t			flush_in_progress;
+    FILE *			trace_file_ptr;
+    hbool_t                     logging_enabled;
+    hbool_t                     currently_logging;
+    FILE *			log_file_ptr;
+    void *			aux_ptr;
+    int32_t			max_type_id;
+    const H5C_class_t * const   *class_table_ptr;
+    size_t                      max_cache_size;
+    size_t                      min_clean_size;
+    H5C_write_permitted_func_t	check_write_permitted;
+    hbool_t			write_permitted;
+    H5C_log_flush_func_t	log_flush;
+    hbool_t			evictions_enabled;
+    hbool_t			close_warning_received;
+
+    /* Fields for maintaining [hash table] index of entries */
+    uint32_t                    index_len;
+    size_t                      index_size;
+    uint32_t			index_ring_len[H5C_RING_NTYPES];
+    size_t			index_ring_size[H5C_RING_NTYPES];
+    size_t 			clean_index_size;
+    size_t			clean_index_ring_size[H5C_RING_NTYPES];
+    size_t			dirty_index_size;
+    size_t			dirty_index_ring_size[H5C_RING_NTYPES];
+    H5C_cache_entry_t *	        index[H5C__HASH_TABLE_LEN];
+    uint32_t                    il_len;
+    size_t                      il_size;
+    H5C_cache_entry_t *	        il_head;
+    H5C_cache_entry_t *	        il_tail;
+
+    /* Fields to detect entries removed during scans */
+    int64_t			entries_removed_counter;
+    H5C_cache_entry_t *		last_entry_removed_ptr;
+    H5C_cache_entry_t *		entry_watched_for_removal;
+
+    /* Fields for maintaining list of in-order entries, for flushing */
+    hbool_t			slist_changed;
+    uint32_t                    slist_len;
+    size_t                      slist_size;
+    uint32_t			slist_ring_len[H5C_RING_NTYPES];
+    size_t			slist_ring_size[H5C_RING_NTYPES];
+    H5SL_t *                    slist_ptr;
+    uint32_t                    num_last_entries;
+#if H5C_DO_SANITY_CHECKS
+    int32_t			slist_len_increase;
+    ssize_t			slist_size_increase;
+#endif /* H5C_DO_SANITY_CHECKS */
+
+    /* Fields for maintaining list of tagged entries */
+    H5SL_t *                    tag_list;
+    hbool_t                     ignore_tags;
+
+    /* Fields for tracking protected entries */
+    uint32_t                    pl_len;
+    size_t                      pl_size;
+    H5C_cache_entry_t *	        pl_head_ptr;
+    H5C_cache_entry_t *  	pl_tail_ptr;
+
+    /* Fields for tracking pinned entries */
+    uint32_t                    pel_len;
+    size_t                      pel_size;
+    H5C_cache_entry_t *	        pel_head_ptr;
+    H5C_cache_entry_t *  	pel_tail_ptr;
+
+    /* Fields for complete LRU list of entries */
+    uint32_t                    LRU_list_len;
+    size_t                      LRU_list_size;
+    H5C_cache_entry_t *		LRU_head_ptr;
+    H5C_cache_entry_t *		LRU_tail_ptr;
+
+    /* Fields for clean LRU list of entries */
+    uint32_t                    cLRU_list_len;
+    size_t                      cLRU_list_size;
+    H5C_cache_entry_t *		cLRU_head_ptr;
+    H5C_cache_entry_t *		cLRU_tail_ptr;
+
+    /* Fields for dirty LRU list of entries */
+    uint32_t                    dLRU_list_len;
+    size_t                      dLRU_list_size;
+    H5C_cache_entry_t *		dLRU_head_ptr;
+    H5C_cache_entry_t *	        dLRU_tail_ptr;
+
+#ifdef H5_HAVE_PARALLEL
+    /* Fields for collective metadata reads */
+    uint32_t                    coll_list_len;
+    size_t                      coll_list_size;
+    H5C_cache_entry_t *		coll_head_ptr;
+    H5C_cache_entry_t *		coll_tail_ptr;
+
+    /* Fields for collective metadata writes */
+    H5SL_t *                    coll_write_list;
+#endif /* H5_HAVE_PARALLEL */
+
+    /* Fields for automatic cache size adjustment */
+    hbool_t			size_increase_possible;
+    hbool_t			flash_size_increase_possible;
+    size_t			flash_size_increase_threshold;
+    hbool_t			size_decrease_possible;
+    hbool_t			resize_enabled;
+    hbool_t			cache_full;
+    hbool_t			size_decreased;
+    hbool_t			resize_in_progress;
+    hbool_t			msic_in_progress;
+    H5C_auto_size_ctl_t		resize_ctl;
+
+    /* Fields for epoch markers used in automatic cache size adjustment */
+    int32_t			epoch_markers_active;
+    hbool_t			epoch_marker_active[H5C__MAX_EPOCH_MARKERS];
+    int32_t			epoch_marker_ringbuf[H5C__MAX_EPOCH_MARKERS+1];
+    int32_t			epoch_marker_ringbuf_first;
+    int32_t			epoch_marker_ringbuf_last;
+    int32_t			epoch_marker_ringbuf_size;
+    H5C_cache_entry_t		epoch_markers[H5C__MAX_EPOCH_MARKERS];
+
+    /* Fields for cache hit rate collection */
+    int64_t			cache_hits;
+    int64_t			cache_accesses;
+
+    /* fields supporting generation of a cache image on file close */
+    H5C_cache_image_ctl_t	image_ctl;
+    hbool_t			serialization_in_progress;
+    hbool_t			load_image;
+    hbool_t                     image_loaded;
+    hbool_t			delete_image;
+    haddr_t 			image_addr;
+    hsize_t			image_len;
+    hsize_t			image_data_len;
+    int64_t			entries_loaded_counter;
+    int64_t			entries_inserted_counter;
+    int64_t			entries_relocated_counter;
+    int64_t			entry_fd_height_change_counter;
+    uint32_t			num_entries_in_image;
+    H5C_image_entry_t *		image_entries;
+    void *                      image_buffer;
+
+    /* Free Space Manager Related fields */
+    hbool_t 			rdfsm_settled;
+    hbool_t			mdfsm_settled;
+
+#if H5C_COLLECT_CACHE_STATS
+    /* stats fields */
+    int64_t                     hits[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     misses[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     write_protects[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     read_protects[H5C__MAX_NUM_TYPE_IDS + 1];
+    int32_t                     max_read_protects[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     insertions[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     pinned_insertions[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     clears[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     flushes[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     evictions[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     take_ownerships[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     moves[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     entry_flush_moves[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     cache_flush_moves[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     pins[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     unpins[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     dirty_pins[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     pinned_flushes[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     pinned_clears[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     size_increases[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     size_decreases[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     entry_flush_size_changes[H5C__MAX_NUM_TYPE_IDS + 1];
+    int64_t                     cache_flush_size_changes[H5C__MAX_NUM_TYPE_IDS + 1];
+
+    /* Fields for hash table operations */
+    int64_t			total_ht_insertions;
+    int64_t			total_ht_deletions;
+    int64_t			successful_ht_searches;
+    int64_t			total_successful_ht_search_depth;
+    int64_t			failed_ht_searches;
+    int64_t			total_failed_ht_search_depth;
+    uint32_t                    max_index_len;
+    size_t                      max_index_size;
+    size_t                      max_clean_index_size;
+    size_t                      max_dirty_index_size;
+
+    /* Fields for in-order skip list */
+    uint32_t                    max_slist_len;
+    size_t                      max_slist_size;
+
+    /* Fields for protected entry list */
+    uint32_t                    max_pl_len;
+    size_t                      max_pl_size;
+
+    /* Fields for pinned entry list */
+    uint32_t                    max_pel_len;
+    size_t                      max_pel_size;
+
+    /* Fields for tracking 'make space in cache' (msic) operations */
+    int64_t                     calls_to_msic;
+    int64_t                     total_entries_skipped_in_msic;
+    int64_t                     total_dirty_pf_entries_skipped_in_msic;
+    int64_t                     total_entries_scanned_in_msic;
+    int32_t                     max_entries_skipped_in_msic;
+    int32_t                     max_dirty_pf_entries_skipped_in_msic;
+    int32_t                     max_entries_scanned_in_msic;
+    int64_t                     entries_scanned_to_make_space;
+ 
+    /* Fields for tracking skip list scan restarts */
+    int64_t			slist_scan_restarts;
+    int64_t			LRU_scan_restarts;
+    int64_t			index_scan_restarts;
+
+    /* Fields for tracking cache image operations */
+    int32_t			images_created;
+    int32_t			images_read;
+    int32_t			images_loaded;
+    hsize_t			last_image_size;
+
+    /* Fields for tracking prefetched entries */
+    int64_t			prefetches;
+    int64_t			dirty_prefetches;
+    int64_t			prefetch_hits;
+
+#if H5C_COLLECT_CACHE_ENTRY_STATS
+    int32_t                     max_accesses[H5C__MAX_NUM_TYPE_IDS + 1];
+    int32_t                     min_accesses[H5C__MAX_NUM_TYPE_IDS + 1];
+    int32_t                     max_clears[H5C__MAX_NUM_TYPE_IDS + 1];
+    int32_t                     max_flushes[H5C__MAX_NUM_TYPE_IDS + 1];
+    size_t                      max_size[H5C__MAX_NUM_TYPE_IDS + 1];
+    int32_t                     max_pins[H5C__MAX_NUM_TYPE_IDS + 1];
+#endif /* H5C_COLLECT_CACHE_ENTRY_STATS */
+#endif /* H5C_COLLECT_CACHE_STATS */
+
+    char			prefix[H5C__PREFIX_LEN];
+
+#ifndef NDEBUG
+    int64_t                     get_entry_ptr_from_addr_counter;
+#endif /* NDEBUG */
+};
+
+/* Define typedef for tagged cache entry iteration callbacks */
+typedef int (*H5C_tag_iter_cb_t)(H5C_cache_entry_t *entry, void *ctx);
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+H5_DLL herr_t H5C__prep_image_for_file_close(H5F_t *f, hid_t dxpl_id,
+    hbool_t *image_generated);
+H5_DLL herr_t H5C__deserialize_prefetched_entry(H5F_t *f, hid_t dxpl_id,
+    H5C_t * cache_ptr, H5C_cache_entry_t** entry_ptr_ptr, 
+    const H5C_class_t * type, haddr_t addr, void * udata);
+
+/* General routines */
+H5_DLL herr_t H5C__flush_single_entry(H5F_t *f, hid_t dxpl_id,
+    H5C_cache_entry_t *entry_ptr, unsigned flags);
+H5_DLL herr_t H5C__generate_cache_image(H5F_t *f, hid_t dxpl_id, H5C_t *cache_ptr);
+H5_DLL herr_t H5C__load_cache_image(H5F_t *f, hid_t dxpl_id);
+H5_DLL herr_t H5C__mark_flush_dep_serialized(H5C_cache_entry_t * entry_ptr);
+H5_DLL herr_t H5C__mark_flush_dep_unserialized(H5C_cache_entry_t * entry_ptr);
+H5_DLL herr_t H5C__make_space_in_cache(H5F_t * f, hid_t dxpl_id,
+    size_t  space_needed, hbool_t write_permitted);
+H5_DLL herr_t H5C__flush_marked_entries(H5F_t * f, hid_t dxpl_id);
+H5_DLL herr_t H5C__generate_image(H5F_t *f, H5C_t *cache_ptr,
+    H5C_cache_entry_t *entry_ptr, hid_t dxpl_id);
+H5_DLL herr_t H5C__serialize_cache(H5F_t *f, hid_t dxpl_id);
+H5_DLL herr_t H5C__iter_tagged_entries(H5C_t *cache, haddr_t tag, hbool_t match_global,
+    H5C_tag_iter_cb_t cb, void *cb_ctx);
+
+/* Routines for operating on entry tags */
+H5_DLL herr_t H5C__tag_entry(H5C_t * cache_ptr, H5C_cache_entry_t * entry_ptr,
+    hid_t dxpl_id);
+H5_DLL herr_t H5C__untag_entry(H5C_t *cache, H5C_cache_entry_t *entry);
+
+/* Testing functions */
+#ifdef H5C_TESTING
+H5_DLL herr_t H5C__verify_cork_tag_test(hid_t fid, haddr_t tag, hbool_t status);
+#endif /* H5C_TESTING */
+
+#endif /* _H5Cpkg_H */
+
diff --git a/install/include/H5Cpp.h b/install/include/H5Cpp.h
new file mode 100644
index 0000000000..09914e82c4
--- /dev/null
+++ b/install/include/H5Cpp.h
@@ -0,0 +1,59 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5Cpp_H
+#define __H5Cpp_H
+
+#include "H5Include.h"
+#include "H5Exception.h"
+#include "H5IdComponent.h"
+#include "H5DataSpace.h"
+#include "H5PropList.h"
+#include "H5FaccProp.h"
+#include "H5FcreatProp.h"
+#include "H5OcreatProp.h"
+#include "H5DcreatProp.h"
+#include "H5DxferProp.h"
+#include "H5LaccProp.h"
+#include "H5Location.h"
+#include "H5Object.h"
+#include "H5AbstractDs.h"
+#include "H5Attribute.h"
+#include "H5DataType.h"
+#include "H5AtomType.h"
+#include "H5PredType.h"
+#include "H5EnumType.h"
+#include "H5IntType.h"
+#include "H5FloatType.h"
+#include "H5StrType.h"
+#include "H5CompType.h"
+#include "H5ArrayType.h"
+#include "H5VarLenType.h"
+#include "H5DataSet.h"
+#include "H5CommonFG.h"
+#include "H5Group.h"
+#include "H5File.h"
+#include "H5Library.h"
+
+/* Some C++ compilers do not have offsetof macro; define to bypass the problem
+   - BMR- -EIP- 2007/08/01
+*/
+#ifndef H5_CXX_HAVE_OFFSETOF
+#ifdef HOFFSET
+   #undef HOFFSET
+#endif
+#define HOFFSET(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+
+#endif // __H5Cpp_H
diff --git a/install/include/H5CppDoc.h b/install/include/H5CppDoc.h
new file mode 100644
index 0000000000..543f49bf9c
--- /dev/null
+++ b/install/include/H5CppDoc.h
@@ -0,0 +1,98 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5CppDoc_H
+#define __H5CppDoc_H
+
+//-------------------------------------------------------------------------
+// The following section will be used to generate the 'Mainpage'
+// and the 'Examples' for the RM.
+// ------------------------------------------------------------------------
+
+/*! \mainpage notitle
+ * <br />
+ * \section intro_sec Introduction
+ *
+ * The C++ API provides C++ wrappers for the HDF5 C Library.
+ * 
+ * It is assumed that the user has knowledge of the 
+ * <a href="https://www.hdfgroup.org/HDF5/doc/H5.format.html">
+ * HDF5 file format</a> and its components. 
+ * For more information on the HDF5 C Library, see the 
+ * <a href="https://www.hdfgroup.org/HDF5/doc/index.html"> 
+ * HDF5 Software Documentation</a> page.
+ *
+ * Because the HDF5 C Library maps very well to
+ * the object oriented design approach, classes in the C++ API can
+ * closely represent the interfaces of the C APIs as follows:
+ *
+ * \verbatim
+    HDF5 C APIs                       C++ Classes
+    -----------                       -----------
+    Attribute Interface (H5A)         Attribute
+    Datasets Interface (H5D)          DataSet
+    Error Interface (H5E)             Exception
+    File Interface (H5F)              H5File
+    Group Interface (H5G)             Group
+    Identifier Interface (H5I)        IdComponent
+    Property List Interface (H5P)     PropList and subclasses
+    Dataspace Interface (H5S)         DataSpace
+    Datatype Interface (H5T)          DataType and subclasses
+  \endverbatim
+ * <br />
+ * \section install_sec Installation
+ *
+ * The HDF5 C++ API is included with the HDF5 source code and can 
+ * be obtained from 
+ * <a href="https://www.hdfgroup.org/HDF5/release/obtainsrc.html">
+ * https://www.hdfgroup.org/HDF5/release/obtainsrc.html</a>.
+ * 
+ * Please refer to the release_docs/INSTALL file under the top directory 
+ * of the HDF5 source code for information about installing, building, 
+ * and testing the C++ API.
+ *
+ * <br />
+ */
+
+///        This example shows how to create datasets.
+///\par
+///\example     create.cpp
+
+///\par
+///        This example shows how to write datasets.
+///\example     writedata.cpp
+
+///\par
+///        This example shows how to read datasets.
+///\example     readdata.cpp
+
+///\par
+///        This example shows how to create a compound datatype,
+///        write an array which has the compound datatype to the file,
+///        and read back fields' subsets.
+///\example     compound.cpp
+
+///\par
+///        This example shows how to work with extendible datasets.
+///\example     extend_ds.cpp
+
+///\par
+///        This example shows how to read data from a chunked dataset.
+///\example     chunks.cpp
+
+///\par
+///        This example shows how to work with groups.
+///\example     h5group.cpp
+
+#endif // __H5CppDoc_H
diff --git a/install/include/H5Cpublic.h b/install/include/H5Cpublic.h
new file mode 100644
index 0000000000..62107d971f
--- /dev/null
+++ b/install/include/H5Cpublic.h
@@ -0,0 +1,59 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:	H5Cpublic.h
+ *              June 4, 2005
+ *              John Mainzer
+ *
+ * Purpose:     Public include file for cache functions.
+ *
+ * Modifications:
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef _H5Cpublic_H
+#define _H5Cpublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum H5C_cache_incr_mode
+{
+    H5C_incr__off,
+    H5C_incr__threshold
+};
+
+enum H5C_cache_flash_incr_mode
+{
+     H5C_flash_incr__off,
+     H5C_flash_incr__add_space
+};
+
+enum H5C_cache_decr_mode
+{
+    H5C_decr__off,
+    H5C_decr__threshold,
+    H5C_decr__age_out,
+    H5C_decr__age_out_with_threshold
+};
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/install/include/H5DOpublic.h b/install/include/H5DOpublic.h
new file mode 100644
index 0000000000..d5c8de43d1
--- /dev/null
+++ b/install/include/H5DOpublic.h
@@ -0,0 +1,45 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef _H5DOpublic_H
+#define _H5DOpublic_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*-------------------------------------------------------------------------
+ *
+ * "Optimized dataset" routines.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+H5_HLDLL herr_t H5DOwrite_chunk(hid_t dset_id, hid_t dxpl_id, uint32_t filters, 
+    const hsize_t *offset, size_t data_size, const void *buf);
+
+H5_HLDLL herr_t H5DOread_chunk(hid_t dset_id, /*in*/
+            hid_t dxpl_id,         /*in*/
+            const hsize_t *offset, /*in*/
+            uint32_t *filters,     /*out*/
+            void *buf);            /*out*/
+
+H5_HLDLL herr_t H5DOappend(hid_t dset_id, hid_t dxpl_id, unsigned axis,
+    size_t extension, hid_t memtype, const void *buf);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/install/include/H5DSpublic.h b/install/include/H5DSpublic.h
new file mode 100644
index 0000000000..615122cb7c
--- /dev/null
+++ b/install/include/H5DSpublic.h
@@ -0,0 +1,77 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef _H5DSpublic_H
+#define _H5DSpublic_H
+
+
+
+#define DIMENSION_SCALE_CLASS "DIMENSION_SCALE"
+#define DIMENSION_LIST        "DIMENSION_LIST"
+#define REFERENCE_LIST        "REFERENCE_LIST"
+#define DIMENSION_LABELS      "DIMENSION_LABELS"
+
+
+typedef herr_t  (*H5DS_iterate_t)(hid_t dset, unsigned dim, hid_t scale, void *visitor_data);
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5_HLDLL herr_t  H5DSattach_scale( hid_t did,
+                        hid_t dsid,
+                        unsigned int idx);
+
+H5_HLDLL herr_t  H5DSdetach_scale( hid_t did,
+                        hid_t dsid,
+                        unsigned int idx);
+
+H5_HLDLL herr_t  H5DSset_scale( hid_t dsid,
+                     const char *dimname);
+
+H5_HLDLL int H5DSget_num_scales( hid_t did,
+                       unsigned int dim);
+
+H5_HLDLL herr_t  H5DSset_label( hid_t did,
+                     unsigned int idx,
+                     const char *label);
+
+H5_HLDLL ssize_t H5DSget_label( hid_t did,
+                      unsigned int idx,
+                      char *label,
+                      size_t size);
+
+H5_HLDLL ssize_t H5DSget_scale_name( hid_t did,
+                           char *name,
+                           size_t size);
+
+H5_HLDLL htri_t H5DSis_scale( hid_t did);
+
+H5_HLDLL herr_t  H5DSiterate_scales( hid_t did,
+                          unsigned int dim,
+                          int *idx,
+                          H5DS_iterate_t visitor,
+                          void *visitor_data);
+
+H5_HLDLL htri_t H5DSis_attached( hid_t did,
+                       hid_t dsid,
+                       unsigned int idx);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5DataSet.h b/install/include/H5DataSet.h
new file mode 100644
index 0000000000..2f3eebeaf6
--- /dev/null
+++ b/install/include/H5DataSet.h
@@ -0,0 +1,134 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5DataSet_H
+#define __H5DataSet_H
+
+namespace H5 {
+
+/*! \class DataSet
+    \brief Class DataSet operates on HDF5 datasets.
+
+    An datasets has many characteristics similar to an attribute, thus both
+    Attribute and DataSet are derivatives of AbstractDs.  DataSet also
+    inherits from H5Object because a dataset is an HDF5 object.
+
+    Inheritance: multiple H5Object/AbstractDs -> H5Location -> IdComponent
+*/
+class H5_DLLCPP DataSet : public H5Object, public AbstractDs {
+   public:
+
+        // Close this dataset.
+        virtual void close();
+
+        // Extends the dataset with unlimited dimension.
+        void extend(const hsize_t* size) const;
+
+        // Fills a selection in memory with a value
+        void fillMemBuf(const void *fill, const DataType& fill_type, void *buf, const DataType& buf_type, const DataSpace& space) const;
+        //void fillMemBuf(const void *fill, DataType& fill_type, void *buf, DataType& buf_type, DataSpace& space); // removed from 1.8.18 and 1.10.1
+
+        // Fills a selection in memory with zero
+        void fillMemBuf(void *buf, const DataType& buf_type, const DataSpace& space) const;
+        //void fillMemBuf(void *buf, DataType& buf_type, DataSpace& space); // removed from 1.8.18 and 1.10.1
+
+        // Gets the creation property list of this dataset.
+        DSetCreatPropList getCreatePlist() const;
+
+        // Returns the address of this dataset in the file.
+        haddr_t getOffset() const;
+
+        // Gets the dataspace of this dataset.
+        virtual DataSpace getSpace() const;
+
+        // Determines whether space has been allocated for a dataset.
+        void getSpaceStatus(H5D_space_status_t& status) const;
+
+        // Returns the amount of storage size required for this dataset.
+        virtual hsize_t getStorageSize() const;
+
+        // Returns the in memory size of this attribute's data.
+        virtual size_t getInMemDataSize() const;
+
+        // Returns the number of bytes required to store VL data.
+        hsize_t getVlenBufSize(const DataType& type, const DataSpace& space) const;
+        //hsize_t getVlenBufSize(DataType& type, DataSpace& space) const; // removed from 1.8.18 and 1.10.1
+
+        // Reclaims VL datatype memory buffers.
+        static void vlenReclaim(const DataType& type, const DataSpace& space, const DSetMemXferPropList& xfer_plist, void* buf);
+        static void vlenReclaim(void *buf, const DataType& type, const DataSpace& space = DataSpace::ALL, const DSetMemXferPropList& xfer_plist = DSetMemXferPropList::DEFAULT);
+
+        // Reads the data of this dataset and stores it in the provided buffer.
+        // The memory and file dataspaces and the transferring property list
+        // can be defaults.
+        void read(void* buf, const DataType& mem_type, const DataSpace& mem_space = DataSpace::ALL, const DataSpace& file_space = DataSpace::ALL, const DSetMemXferPropList& xfer_plist = DSetMemXferPropList::DEFAULT) const;
+        void read(H5std_string& buf, const DataType& mem_type, const DataSpace& mem_space = DataSpace::ALL, const DataSpace& file_space = DataSpace::ALL, const DSetMemXferPropList& xfer_plist = DSetMemXferPropList::DEFAULT) const;
+
+        // Writes the buffered data to this dataset.
+        // The memory and file dataspaces and the transferring property list
+        // can be defaults.
+        void write(const void* buf, const DataType& mem_type, const DataSpace& mem_space = DataSpace::ALL, const DataSpace& file_space = DataSpace::ALL, const DSetMemXferPropList& xfer_plist = DSetMemXferPropList::DEFAULT) const;
+        void write(const H5std_string& buf, const DataType& mem_type, const DataSpace& mem_space = DataSpace::ALL, const DataSpace& file_space = DataSpace::ALL, const DSetMemXferPropList& xfer_plist = DSetMemXferPropList::DEFAULT) const;
+
+        // Iterates the selected elements in the specified dataspace - not implemented in C++ style yet
+        int iterateElems(void* buf, const DataType& type, const DataSpace& space, H5D_operator_t op, void* op_data = NULL);
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("DataSet"); }
+
+        // Creates a dataset by way of dereference.
+        DataSet(const H5Location& loc, const void* ref, H5R_type_t ref_type = H5R_OBJECT, const PropList& plist = PropList::DEFAULT);
+        DataSet(const Attribute& attr, const void* ref, H5R_type_t ref_type = H5R_OBJECT, const PropList& plist = PropList::DEFAULT);
+
+        // Default constructor.
+        DataSet();
+
+        // Copy constructor.
+        DataSet(const DataSet& original);
+
+        // Creates a copy of an existing DataSet using its id.
+        DataSet(const hid_t existing_id);
+
+        // Gets the dataset id.
+        virtual hid_t getId() const;
+
+        // Destructor: properly terminates access to this dataset.
+        virtual ~DataSet();
+
+   protected:
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+        // Sets the dataset id.
+        virtual void p_setId(const hid_t new_id);
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+   private:
+        hid_t id;       // HDF5 dataset id
+
+        // This function contains the common code that is used by
+        // getTypeClass and various API functions getXxxType
+        // defined in AbstractDs for generic datatype and specific
+        // sub-types
+        virtual hid_t p_get_type() const;
+
+        // Reads variable or fixed len strings from this dataset.
+        void p_read_fixed_len(const hid_t mem_type_id, const hid_t mem_space_id, const hid_t file_space_id, const hid_t xfer_plist_id, H5std_string& strg) const;
+        void p_read_variable_len(const hid_t mem_type_id, const hid_t mem_space_id, const hid_t file_space_id, const hid_t xfer_plist_id, H5std_string& strg) const;
+
+        // Friend function to set DataSet id.  For library use only.
+        friend void f_DataSet_setId(DataSet* dset, hid_t new_id);
+
+}; // end of DataSet
+} // namespace H5
+
+#endif // __H5DataSet_H
diff --git a/install/include/H5DataSpace.h b/install/include/H5DataSpace.h
new file mode 100644
index 0000000000..c0a1d2b7b1
--- /dev/null
+++ b/install/include/H5DataSpace.h
@@ -0,0 +1,154 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5DataSpace_H
+#define __H5DataSpace_H
+
+namespace H5 {
+
+/*! \class DataSpace
+    \brief Class DataSpace inherits from IdComponent and provides wrappers for
+     the HDF5's dataspaces.
+
+    Inheritance: IdComponent
+*/
+class H5_DLLCPP DataSpace : public IdComponent {
+   public:
+        ///\brief Default DataSpace objects
+        static const DataSpace& ALL;
+
+        // Creates a dataspace object given the space type
+        DataSpace(H5S_class_t type = H5S_SCALAR);
+
+        // Creates a simple dataspace
+        DataSpace(int rank, const hsize_t * dims, const hsize_t * maxdims = NULL);
+
+        // Creates a DataSpace object using an existing dataspace id.
+        DataSpace(const hid_t space_id);
+
+        // Copy constructor: makes a copy of the original DataSpace object.
+        DataSpace(const DataSpace& original);
+
+        // Assignment operator
+        DataSpace& operator=(const DataSpace& rhs);
+
+        // Closes this dataspace.
+        virtual void close();
+
+        // Makes copy of an existing dataspace.
+        void copy(const DataSpace& like_space);
+
+        // Copies the extent of this dataspace.
+        void extentCopy(const DataSpace& dest_space) const;
+        // removed from 1.8.18 and 1.10.1
+        //void extentCopy(DataSpace& dest_space) const;
+
+        // Gets the bounding box containing the current selection.
+        void getSelectBounds(hsize_t* start, hsize_t* end) const;
+
+        // Gets the number of element points in the current selection.
+        hssize_t getSelectElemNpoints() const;
+
+        // Retrieves the list of element points currently selected.
+        void getSelectElemPointlist(hsize_t startpoint, hsize_t numpoints, hsize_t *buf) const;
+
+        // Gets the list of hyperslab blocks currently selected.
+        void getSelectHyperBlocklist(hsize_t startblock, hsize_t numblocks, hsize_t *buf) const;
+
+        // Get number of hyperslab blocks.
+        hssize_t getSelectHyperNblocks() const;
+
+        // Gets the number of elements in this dataspace selection.
+        hssize_t getSelectNpoints() const;
+
+        // Retrieves dataspace dimension size and maximum size.
+        int getSimpleExtentDims(hsize_t *dims, hsize_t *maxdims = NULL) const;
+
+        // Gets the dimensionality of this dataspace.
+        int getSimpleExtentNdims() const;
+
+        // Gets the number of elements in this dataspace.
+        // 12/05/00 - changed return type to hssize_t from hsize_t - C API
+        hssize_t getSimpleExtentNpoints() const;
+
+        // Gets the current class of this dataspace.
+        H5S_class_t getSimpleExtentType() const;
+
+        // Determines if this dataspace is a simple one.
+        bool isSimple() const;
+
+        // Sets the offset of this simple dataspace.
+        void offsetSimple(const hssize_t* offset) const;
+
+        // Selects the entire dataspace.
+        void selectAll() const;
+
+        // Selects array elements to be included in the selection for
+        // this dataspace.
+        void selectElements(H5S_seloper_t op, const size_t num_elements, const hsize_t *coord) const;
+
+        // Selects a hyperslab region to add to the current selected region.
+        void selectHyperslab(H5S_seloper_t op, const hsize_t *count, const hsize_t *start, const hsize_t *stride = NULL, const hsize_t *block = NULL) const;
+
+        // Resets the selection region to include no elements.
+        void selectNone() const;
+
+        // Verifies that the selection is within the extent of the dataspace.
+        bool selectValid() const;
+
+        // Removes the extent from this dataspace.
+        void setExtentNone() const;
+
+        // Sets or resets the size of this dataspace.
+        void setExtentSimple(int rank, const hsize_t *current_size, const hsize_t *maximum_size = NULL) const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("DataSpace"); }
+
+        // Gets the dataspace id.
+        virtual hid_t getId() const;
+
+        // Deletes the global constant
+        static void deleteConstants();
+
+        // Destructor: properly terminates access to this dataspace.
+        virtual ~DataSpace();
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+   protected:
+        // Sets the dataspace id.
+        virtual void p_setId(const hid_t new_id);
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+   private:
+        hid_t id;       // HDF5 dataspace id
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+        static DataSpace* ALL_;
+
+        // Creates the global constant
+        static DataSpace* getConstant();
+
+        // Friend function to set DataSpace id.  For library use only.
+        friend void f_DataSpace_setId(DataSpace *dspace, hid_t new_id);
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end of DataSpace
+} // namespace H5
+
+#endif // __H5DataSpace_H
diff --git a/install/include/H5DataType.h b/install/include/H5DataType.h
new file mode 100644
index 0000000000..32a79fa986
--- /dev/null
+++ b/install/include/H5DataType.h
@@ -0,0 +1,160 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5DataType_H
+#define __H5DataType_H
+
+namespace H5 {
+
+/*! \class DataType
+    \brief Class DataType provides generic operations on HDF5 datatypes.
+
+    DataType inherits from H5Object because a named datatype is an HDF5
+    object and is a base class of ArrayType, AtomType, CompType, EnumType,
+    and VarLenType.
+
+    Inheritance: DataType -> H5Object -> H5Location -> IdComponent
+*/
+class H5_DLLCPP DataType : public H5Object {
+   public:
+        // Creates a datatype given its class and size
+        DataType(const H5T_class_t type_class, size_t size);
+
+        // Copy constructor: makes a copy of the original object
+        DataType(const DataType& original);
+
+        // Creates a copy of a predefined type
+        DataType(const PredType& pred_type);
+
+        // Creates a datatype by way of dereference.
+        DataType(const H5Location& loc, const void* ref, H5R_type_t ref_type = H5R_OBJECT, const PropList& plist = PropList::DEFAULT);
+//        DataType(const Attribute& attr, const void* ref, H5R_type_t ref_type = H5R_OBJECT, const PropList& plist = PropList::DEFAULT);
+
+        // Closes this datatype.
+        virtual void close();
+
+        // Copies an existing datatype to this datatype object.
+        void copy(const DataType& like_type);
+
+        // Copies the datatype of dset to this datatype object.
+        void copy(const DataSet& dset);
+
+        // Returns the datatype class identifier.
+        H5T_class_t getClass() const;
+
+        // Commits a transient datatype to a file; this datatype becomes
+        // a named datatype which can be accessed from the location.
+        void commit(const H5Location& loc, const char* name);
+        void commit(const H5Location& loc, const H5std_string& name);
+
+        // These two overloaded functions are kept for backward compatibility
+        // only; they missed the const - removed from 1.8.18 and 1.10.1
+        //void commit(H5Location& loc, const char* name);
+        //void commit(H5Location& loc, const H5std_string& name);
+
+        // Determines whether this datatype is a named datatype or
+        // a transient datatype.
+        bool committed() const;
+
+        // Finds a conversion function that can handle the conversion
+        // this datatype to the given datatype, dest.
+        H5T_conv_t find(const DataType& dest, H5T_cdata_t **pcdata) const;
+
+        // Converts data from between specified datatypes.
+        void convert(const DataType& dest, size_t nelmts, void *buf, void *background, const PropList& plist=PropList::DEFAULT) const;
+
+        // Assignment operator
+        DataType& operator=(const DataType& rhs);
+
+        // Determines whether two datatypes are the same.
+        bool operator==(const DataType& compared_type) const;
+
+        // Locks a datatype.
+        void lock() const;
+
+        // Returns the size of a datatype.
+        size_t getSize() const;
+
+        // Returns the base datatype from which a datatype is derived.
+        // Note: not quite right for specific types yet???
+        DataType getSuper() const;
+
+        // Registers a conversion function.
+        void registerFunc(H5T_pers_t pers, const char* name, const DataType& dest, H5T_conv_t func) const;
+        void registerFunc(H5T_pers_t pers, const H5std_string& name, const DataType& dest, H5T_conv_t func) const;
+
+        // Removes a conversion function from all conversion paths.
+        void unregister(H5T_pers_t pers, const char* name, const DataType& dest, H5T_conv_t func) const;
+        void unregister(H5T_pers_t pers, const H5std_string& name, const DataType& dest, H5T_conv_t func) const;
+
+        // Tags an opaque datatype.
+        void setTag(const char* tag) const;
+        void setTag(const H5std_string& tag) const;
+
+        // Gets the tag associated with an opaque datatype.
+        H5std_string getTag() const;
+
+        // Checks whether this datatype contains (or is) a certain type class.
+        bool detectClass(H5T_class_t cls) const;
+
+        // Checks whether this datatype is a variable-length string.
+        bool isVariableStr() const;
+
+        // Returns a copy of the creation property list of a datatype.
+        PropList getCreatePlist() const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("DataType"); }
+
+// From CommonFG then H5Location
+        // Constructors to open a generic named datatype at a given location.
+        DataType(const H5Location& loc, const char* name);
+        DataType(const H5Location& loc, const H5std_string& name);
+
+// End of From CommonFG then H5Location
+
+        // Creates a copy of an existing DataType using its id
+        DataType(const hid_t type_id);
+
+        // Default constructor
+        DataType();
+
+        // Gets the datatype id.
+        virtual hid_t getId() const;
+
+        // Destructor: properly terminates access to this datatype.
+        virtual ~DataType();
+
+   protected:
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+        hid_t id;    // HDF5 datatype id
+
+        // Sets the datatype id.
+        virtual void p_setId(const hid_t new_id);
+
+        // Opens a datatype and returns the id.
+        hid_t p_opentype(const H5Location& loc, const char* dtype_name) const;
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+   private:
+        // Friend function to set DataType id.  For library use only.
+        friend void f_DataType_setId(DataType* dtype, hid_t new_id);
+
+        void p_commit(hid_t loc_id, const char* name);
+
+}; // end of DataType
+} // namespace H5
+
+#endif // __H5DataType_H
diff --git a/install/include/H5DcreatProp.h b/install/include/H5DcreatProp.h
new file mode 100644
index 0000000000..5d5714a506
--- /dev/null
+++ b/install/include/H5DcreatProp.h
@@ -0,0 +1,151 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5DSCreatPropList_H
+#define __H5DSCreatPropList_H
+
+namespace H5 {
+
+class DataType;
+class DataSpace;
+
+/*! \class DSetCreatPropList
+    \brief Class DSetCreatPropList inherits from ObjCreatPropList and provides
+    wrappers for the HDF5 dataset creation property functions.
+
+    Inheritance: ObjCreatPropList -> PropList -> IdComponent
+*/
+class H5_DLLCPP DSetCreatPropList : public ObjCreatPropList {
+   public:
+        ///\brief Default dataset creation property list.
+        static const DSetCreatPropList& DEFAULT;
+
+        // Creates a dataset creation property list.
+        DSetCreatPropList();
+
+        // Queries whether all the filters set in this property list are
+        // available currently.
+        bool allFiltersAvail() const;
+
+        // Get space allocation time for this property.
+        H5D_alloc_time_t getAllocTime() const;
+
+        // Set space allocation time for dataset during creation.
+        void setAllocTime(H5D_alloc_time_t alloc_time) const;
+
+        // Retrieves the size of the chunks used to store a chunked layout dataset.
+        int getChunk(int max_ndims, hsize_t* dim) const;
+
+        // Sets the size of the chunks used to store a chunked layout dataset.
+        void setChunk(int ndims, const hsize_t* dim) const;
+
+        // Returns information about an external file.
+        void getExternal(unsigned idx, size_t name_size, char* name, off_t& offset, hsize_t& size) const;
+
+        // Returns the number of external files for a dataset.
+        int getExternalCount() const;
+
+        // Gets fill value writing time.
+        H5D_fill_time_t getFillTime() const;
+
+        // Sets fill value writing time for dataset.
+        void setFillTime(H5D_fill_time_t fill_time) const;
+
+        // Retrieves a dataset fill value.
+        void getFillValue(const DataType& fvalue_type, void* value) const;
+
+        // Sets a dataset fill value.
+        void setFillValue(const DataType& fvalue_type, const void* value) const;
+
+        // Returns information about a filter in a pipeline.
+        H5Z_filter_t getFilter(int filter_number, unsigned int& flags, size_t& cd_nelmts, unsigned int* cd_values, size_t namelen, char name[], unsigned int &filter_config) const;
+
+        // Returns information about a filter in a pipeline given the filter id.
+        void getFilterById(H5Z_filter_t filter_id, unsigned int &flags, size_t &cd_nelmts, unsigned int* cd_values, size_t namelen, char name[], unsigned int &filter_config) const;
+
+        // Gets the layout of the raw data storage of the data that uses this
+        // property list.
+        H5D_layout_t getLayout() const;
+
+        // Sets the type of storage used to store the raw data for the
+        // dataset that uses this property list.
+        void setLayout(H5D_layout_t layout) const;
+
+        // Returns the number of filters in the pipeline.
+        int getNfilters() const;
+
+        // Checks if fill value has been defined for this property.
+        H5D_fill_value_t isFillValueDefined() const;
+
+        // Modifies the specified filter.
+        void modifyFilter(H5Z_filter_t filter_id, unsigned int flags, size_t cd_nelmts, const unsigned int cd_values[]) const;
+
+        // Remove one or all filters from the filter pipeline.
+        void removeFilter(H5Z_filter_t filter_id) const;
+
+        // Sets compression method and compression level.
+        void setDeflate(int level) const;
+
+        // Adds an external file to the list of external files.
+        void setExternal(const char* name, off_t offset, hsize_t size) const;
+
+        // Adds a filter to the filter pipeline.
+        void setFilter(H5Z_filter_t filter, unsigned int flags = 0, size_t cd_nelmts = 0, const unsigned int cd_values[] = NULL) const;
+
+        // Sets Fletcher32 checksum of EDC for this property list.
+        void setFletcher32() const;
+
+        // Sets method of the shuffle filter.
+        void setShuffle() const;
+
+        // Sets SZIP compression method.
+        void setSzip(unsigned int options_mask, unsigned int pixels_per_block) const;
+
+        // Sets N-bit compression method.
+        void setNbit() const;
+
+        // Maps elements of a virtual dataset to elements of the source dataset.
+        void setVirtual(const DataSpace& vspace, const char *src_fname, const char *src_dsname, const DataSpace& sspace) const;
+        void setVirtual(const DataSpace& vspace, const H5std_string src_fname, const H5std_string src_dsname, const DataSpace& sspace) const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("DSetCreatPropList"); }
+
+        // Copy constructor: creates a copy of a DSetCreatPropList object.
+        DSetCreatPropList(const DSetCreatPropList& orig);
+
+        // Creates a copy of an existing dataset creation property list
+        // using the property list id.
+        DSetCreatPropList(const hid_t plist_id);
+
+        // Noop destructor.
+        virtual ~DSetCreatPropList();
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+        // Deletes the global constant, should only be used by the library
+        static void deleteConstants();
+
+    private:
+        static DSetCreatPropList* DEFAULT_;
+
+        // Creates the global constant, should only be used by the library
+        static DSetCreatPropList* getConstant();
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end of DSetCreatPropList
+} // namespace H5
+
+#endif // __H5DSCreatPropList_H
diff --git a/install/include/H5Dpkg.h b/install/include/H5Dpkg.h
new file mode 100644
index 0000000000..a6857b9d96
--- /dev/null
+++ b/install/include/H5Dpkg.h
@@ -0,0 +1,787 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:	Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *		Monday, April 14, 2003
+ *
+ * Purpose:	This file contains declarations which are visible only within
+ *		the H5D package.  Source files outside the H5D package should
+ *		include H5Dprivate.h instead.
+ */
+#if !(defined H5D_FRIEND || defined H5D_MODULE)
+#error "Do not include this file outside the H5D package!"
+#endif
+
+#ifndef _H5Dpkg_H
+#define _H5Dpkg_H
+
+/* Get package's private header */
+#include "H5Dprivate.h"
+
+/* Other private headers needed by this file */
+#include "H5ACprivate.h"	/* Metadata cache			*/
+#include "H5B2private.h"        /* v2 B-trees                           */
+#include "H5Fprivate.h"		/* File access				*/
+#include "H5Gprivate.h"		/* Groups 			  	*/
+#include "H5SLprivate.h"	/* Skip lists				*/
+#include "H5Tprivate.h"		/* Datatypes         			*/
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* Set the minimum object header size to create objects with */
+#define H5D_MINHDR_SIZE 256
+
+/* [Simple] Macro to construct a H5D_io_info_t from it's components */
+#define H5D_BUILD_IO_INFO_WRT(io_info, ds, dxpl_c, dxpl_m, dxpl_r, str, buf)    \
+    (io_info)->dset = ds;                                               \
+    (io_info)->dxpl_cache = dxpl_c;                                     \
+    (io_info)->raw_dxpl_id = dxpl_r;                                    \
+    (io_info)->md_dxpl_id = dxpl_m;                                     \
+    (io_info)->store = str;                                             \
+    (io_info)->op_type = H5D_IO_OP_WRITE;                               \
+    (io_info)->u.wbuf = buf
+#define H5D_BUILD_IO_INFO_RD(io_info, ds, dxpl_c, dxpl_m, dxpl_r, str, buf) \
+    (io_info)->dset = ds;                                               \
+    (io_info)->dxpl_cache = dxpl_c;                                     \
+    (io_info)->raw_dxpl_id = dxpl_r;                                    \
+    (io_info)->md_dxpl_id = dxpl_m;                                     \
+    (io_info)->store = str;                                             \
+    (io_info)->op_type = H5D_IO_OP_READ;                                \
+    (io_info)->u.rbuf = buf
+
+/* Flags for marking aspects of a dataset dirty */
+#define H5D_MARK_SPACE  0x01
+#define H5D_MARK_LAYOUT  0x02
+
+/* Default creation parameters for chunk index data structures */
+/* See H5O_layout_chunk_t */
+
+/* Fixed array creation values */
+#define H5D_FARRAY_CREATE_PARAM_SIZE		1	/* Size of the creation parameters in bytes */
+#define H5D_FARRAY_MAX_DBLK_PAGE_NELMTS_BITS 	10  	/* i.e. 1024 elements per data block page */
+
+/* Extensible array creation values */
+#define H5D_EARRAY_CREATE_PARAM_SIZE		5	/* Size of the creation parameters in bytes */
+#define H5D_EARRAY_MAX_NELMTS_BITS         	32	/* i.e. 4 giga-elements */
+#define H5D_EARRAY_IDX_BLK_ELMTS           	4
+#define H5D_EARRAY_SUP_BLK_MIN_DATA_PTRS   	4
+#define H5D_EARRAY_DATA_BLK_MIN_ELMTS      	16
+#define H5D_EARRAY_MAX_DBLOCK_PAGE_NELMTS_BITS 	10 	/* i.e. 1024 elements per data block page */
+
+/* v2 B-tree creation values for raw meta_size */
+#define H5D_BT2_CREATE_PARAM_SIZE	6		/* Size of the creation parameters in bytes */
+#define H5D_BT2_NODE_SIZE       	2048
+#define H5D_BT2_SPLIT_PERC      	100
+#define H5D_BT2_MERGE_PERC      	40
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/* Typedef for datatype information for raw data I/O operation */
+typedef struct H5D_type_info_t {
+    /* Initial values */
+    const H5T_t *mem_type;              /* Pointer to memory datatype */
+    const H5T_t *dset_type;             /* Pointer to dataset datatype */
+    H5T_path_t *tpath;                  /* Datatype conversion path */
+    hid_t src_type_id;                  /* Source datatype ID */
+    hid_t dst_type_id;                  /* Destination datatype ID */
+
+    /* Computed/derived values */
+    size_t src_type_size;		/* Size of source type	*/
+    size_t dst_type_size;	        /* Size of destination type */
+    size_t max_type_size;	        /* Size of largest source/destination type */
+    hbool_t is_conv_noop;               /* Whether the type conversion is a NOOP */
+    hbool_t is_xform_noop;              /* Whether the data transform is a NOOP */
+    const H5T_subset_info_t *cmpd_subset;   /* Info related to the compound subset conversion functions */
+    H5T_bkg_t need_bkg;		        /* Type of background buf needed */
+    size_t request_nelmts;		/* Requested strip mine	*/
+    uint8_t *tconv_buf;	                /* Datatype conv buffer	*/
+    hbool_t tconv_buf_allocated;        /* Whether the type conversion buffer was allocated */
+    uint8_t *bkg_buf;	                /* Background buffer	*/
+    hbool_t bkg_buf_allocated;          /* Whether the background buffer was allocated */
+} H5D_type_info_t;
+
+/* Forward declaration of structs used below */
+struct H5D_io_info_t;
+struct H5D_chunk_map_t;
+
+/* Function pointers for I/O on particular types of dataset layouts */
+typedef herr_t (*H5D_layout_construct_func_t)(H5F_t *f, H5D_t *dset);
+typedef herr_t (*H5D_layout_init_func_t)(H5F_t *f, hid_t dxpl_id, const H5D_t *dset,
+    hid_t dapl_id);
+typedef hbool_t (*H5D_layout_is_space_alloc_func_t)(const H5O_storage_t *storage);
+typedef herr_t (*H5D_layout_io_init_func_t)(const struct H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info,
+    hsize_t nelmts, const H5S_t *file_space, const H5S_t *mem_space,
+    struct H5D_chunk_map_t *cm);
+typedef herr_t (*H5D_layout_read_func_t)(struct H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info, hsize_t nelmts, const H5S_t *file_space,
+    const H5S_t *mem_space, struct H5D_chunk_map_t *fm);
+typedef herr_t (*H5D_layout_write_func_t)(struct H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info, hsize_t nelmts, const H5S_t *file_space,
+    const H5S_t *mem_space, struct H5D_chunk_map_t *fm);
+typedef ssize_t (*H5D_layout_readvv_func_t)(const struct H5D_io_info_t *io_info,
+    size_t dset_max_nseq, size_t *dset_curr_seq, size_t dset_len_arr[], hsize_t dset_offset_arr[],
+    size_t mem_max_nseq, size_t *mem_curr_seq, size_t mem_len_arr[], hsize_t mem_offset_arr[]);
+typedef ssize_t (*H5D_layout_writevv_func_t)(const struct H5D_io_info_t *io_info,
+    size_t dset_max_nseq, size_t *dset_curr_seq, size_t dset_len_arr[], hsize_t dset_offset_arr[],
+    size_t mem_max_nseq, size_t *mem_curr_seq, size_t mem_len_arr[], hsize_t mem_offset_arr[]);
+typedef herr_t (*H5D_layout_flush_func_t)(H5D_t *dataset, hid_t dxpl_id);
+typedef herr_t (*H5D_layout_io_term_func_t)(const struct H5D_chunk_map_t *cm);
+typedef herr_t (*H5D_layout_dest_func_t)(H5D_t *dataset, hid_t dxpl_id);
+
+/* Typedef for grouping layout I/O routines */
+typedef struct H5D_layout_ops_t {
+    H5D_layout_construct_func_t construct;      /* Layout constructor for new datasets */
+    H5D_layout_init_func_t init;        /* Layout initializer for dataset */
+    H5D_layout_is_space_alloc_func_t is_space_alloc;    /* Query routine to determine if storage is allocated */
+    H5D_layout_io_init_func_t io_init;  /* I/O initialization routine */
+    H5D_layout_read_func_t ser_read;    /* High-level I/O routine for reading data in serial */
+    H5D_layout_write_func_t ser_write;  /* High-level I/O routine for writing data in serial */
+#ifdef H5_HAVE_PARALLEL
+    H5D_layout_read_func_t par_read;    /* High-level I/O routine for reading data in parallel */
+    H5D_layout_write_func_t par_write;  /* High-level I/O routine for writing data in parallel */
+#endif /* H5_HAVE_PARALLEL */
+    H5D_layout_readvv_func_t readvv;    /* Low-level I/O routine for reading data */
+    H5D_layout_writevv_func_t writevv;  /* Low-level I/O routine for writing data */
+    H5D_layout_flush_func_t flush;      /* Low-level I/O routine for flushing raw data */
+    H5D_layout_io_term_func_t io_term;  /* I/O shutdown routine */
+    H5D_layout_dest_func_t dest;        /* Destroy layout info */
+} H5D_layout_ops_t;
+
+/* Function pointers for either multiple or single block I/O access */
+typedef herr_t (*H5D_io_single_read_func_t)(const struct H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info,
+    hsize_t nelmts, const H5S_t *file_space, const H5S_t *mem_space);
+typedef herr_t (*H5D_io_single_write_func_t)(const struct H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info,
+    hsize_t nelmts, const H5S_t *file_space, const H5S_t *mem_space);
+
+/* Typedef for raw data I/O framework info */
+typedef struct H5D_io_ops_t {
+    H5D_layout_read_func_t multi_read;          /* High-level I/O routine for reading data */
+    H5D_layout_write_func_t multi_write;        /* High-level I/O routine for writing data */
+    H5D_io_single_read_func_t single_read;      /* I/O routine for reading single block */
+    H5D_io_single_write_func_t single_write;    /* I/O routine for writing single block */
+} H5D_io_ops_t;
+
+/* Typedefs for dataset storage information */
+typedef struct {
+    haddr_t dset_addr;      /* Address of dataset in file */
+    hsize_t dset_size;      /* Total size of dataset in file */
+} H5D_contig_storage_t;
+
+typedef struct {
+    hsize_t *scaled;        /* Scaled coordinates for a chunk */
+} H5D_chunk_storage_t;
+
+typedef struct {
+    void *buf;              /* Buffer for compact dataset */
+    hbool_t *dirty;         /* Pointer to dirty flag to mark */
+} H5D_compact_storage_t;
+
+typedef union H5D_storage_t {
+    H5D_contig_storage_t contig; /* Contiguous information for dataset */
+    H5D_chunk_storage_t chunk;  /* Chunk information for dataset */
+    H5D_compact_storage_t compact; /* Compact information for dataset */
+    H5O_efl_t   efl;            /* External file list information for dataset */
+} H5D_storage_t;
+
+/* Typedef for raw data I/O operation info */
+typedef enum H5D_io_op_type_t {
+    H5D_IO_OP_READ,         /* Read operation */
+    H5D_IO_OP_WRITE         /* Write operation */
+} H5D_io_op_type_t;
+
+typedef struct H5D_io_info_t {
+    const H5D_t *dset;          /* Pointer to dataset being operated on */
+#ifndef H5_HAVE_PARALLEL
+    const
+#endif /* H5_HAVE_PARALLEL */
+        H5D_dxpl_cache_t *dxpl_cache; /* Pointer to cached DXPL info */
+    hid_t raw_dxpl_id;          /* Original DXPL ID */
+    hid_t md_dxpl_id;           /* metadata dxpl needed for parallel HDF5 */
+#ifdef H5_HAVE_PARALLEL
+    MPI_Comm comm;              /* MPI communicator for file */
+    hbool_t using_mpi_vfd;      /* Whether the file is using an MPI-based VFD */
+    struct {
+        H5FD_mpio_xfer_t xfer_mode; /* Parallel transfer for this request (H5D_XFER_IO_XFER_MODE_NAME) */
+        H5FD_mpio_collective_opt_t coll_opt_mode; /* Parallel transfer with independent IO or collective IO with this mode */
+        H5D_io_ops_t io_ops;    /* I/O operation function pointers */
+    } orig;
+#endif /* H5_HAVE_PARALLEL */
+    H5D_storage_t *store;       /* Dataset storage info */
+    H5D_layout_ops_t layout_ops;    /* Dataset layout I/O operation function pointers */
+    H5D_io_ops_t io_ops;        /* I/O operation function pointers */
+    H5D_io_op_type_t op_type;
+    union {
+        void *rbuf;             /* Pointer to buffer for read */
+        const void *wbuf;       /* Pointer to buffer to write */
+    } u;
+} H5D_io_info_t;
+
+
+/******************/
+/* Chunk typedefs */
+/******************/
+
+/* Typedef for chunked dataset index operation info */
+typedef struct H5D_chk_idx_info_t {
+    H5F_t *f;                   /* File pointer for operation */
+    hid_t dxpl_id;              /* DXPL ID for operation */
+    const H5O_pline_t *pline;   /* I/O pipeline info */
+    H5O_layout_chunk_t *layout;           /* Chunk layout description */
+    H5O_storage_chunk_t *storage;         /* Chunk storage description */
+} H5D_chk_idx_info_t;
+
+/*
+ * "Generic" chunk record.  Each chunk is keyed by the minimum logical
+ * N-dimensional coordinates and the datatype size of the chunk.
+ * The fastest-varying dimension is assumed to reference individual bytes of
+ * the array, so a 100-element 1-D array of 4-byte integers would really be a
+ * 2-D array with the slow varying dimension of size 100 and the fast varying
+ * dimension of size 4 (the storage dimensionality has very little to do with
+ * the real dimensionality).
+ *
+ * The chunk's file address, filter mask and size on disk are not key values.
+ */
+typedef struct H5D_chunk_rec_t {
+    hsize_t	scaled[H5O_LAYOUT_NDIMS];	/* Logical offset to start */
+    uint32_t	nbytes;				/* Size of stored data	*/
+    uint32_t	filter_mask;			/* Excluded filters	*/
+    haddr_t     chunk_addr;                     /* Address of chunk in file */
+} H5D_chunk_rec_t;
+
+/*
+ * Common data exchange structure for indexed storage nodes.  This structure is
+ * passed through the indexing layer to the methods for the objects
+ * to which the index points.
+ */
+typedef struct H5D_chunk_common_ud_t {
+    const H5O_layout_chunk_t *layout;           /* Chunk layout description */
+    const H5O_storage_chunk_t *storage;         /* Chunk storage description */
+    const hsize_t *scaled;		        /* Scaled coordinates for a chunk */
+} H5D_chunk_common_ud_t;
+
+/* B-tree callback info for various operations */
+typedef struct H5D_chunk_ud_t {
+    /* Downward */
+    H5D_chunk_common_ud_t common;       /* Common info for B-tree user data (must be first) */
+
+    /* Upward */
+    unsigned    idx_hint;               /* Index of chunk in cache, if present */
+    H5F_block_t chunk_block;            /* Offset/length of chunk in file */
+    unsigned	filter_mask;		/* Excluded filters	*/
+    hbool_t     new_unfilt_chunk;       /* Whether the chunk just became unfiltered */
+    hsize_t     chunk_idx;              /* Chunk index for EA, FA indexing */
+} H5D_chunk_ud_t;
+
+/* Typedef for "generic" chunk callbacks */
+typedef int (*H5D_chunk_cb_func_t)(const H5D_chunk_rec_t *chunk_rec,
+    void *udata);
+
+/* Typedefs for chunk operations */
+typedef herr_t (*H5D_chunk_init_func_t)(const H5D_chk_idx_info_t *idx_info,
+    const H5S_t *space, haddr_t dset_ohdr_addr);
+typedef herr_t (*H5D_chunk_create_func_t)(const H5D_chk_idx_info_t *idx_info);
+typedef hbool_t (*H5D_chunk_is_space_alloc_func_t)(const H5O_storage_chunk_t *storage);
+typedef herr_t (*H5D_chunk_insert_func_t)(const H5D_chk_idx_info_t *idx_info,
+    H5D_chunk_ud_t *udata, const H5D_t *dset);
+typedef herr_t (*H5D_chunk_get_addr_func_t)(const H5D_chk_idx_info_t *idx_info,
+    H5D_chunk_ud_t *udata);
+typedef herr_t (*H5D_chunk_resize_func_t)(H5O_layout_chunk_t *layout);
+typedef int (*H5D_chunk_iterate_func_t)(const H5D_chk_idx_info_t *idx_info,
+    H5D_chunk_cb_func_t chunk_cb, void *chunk_udata);
+typedef herr_t (*H5D_chunk_remove_func_t)(const H5D_chk_idx_info_t *idx_info,
+    H5D_chunk_common_ud_t *udata);
+typedef herr_t (*H5D_chunk_delete_func_t)(const H5D_chk_idx_info_t *idx_info);
+typedef herr_t (*H5D_chunk_copy_setup_func_t)(const H5D_chk_idx_info_t *idx_info_src,
+    const H5D_chk_idx_info_t *idx_info_dst);
+typedef herr_t (*H5D_chunk_copy_shutdown_func_t)(H5O_storage_chunk_t *storage_src,
+    H5O_storage_chunk_t *storage_dst, hid_t dxpl_id);
+typedef herr_t (*H5D_chunk_size_func_t)(const H5D_chk_idx_info_t *idx_info,
+    hsize_t *idx_size);
+typedef herr_t (*H5D_chunk_reset_func_t)(H5O_storage_chunk_t *storage, hbool_t reset_addr);
+typedef herr_t (*H5D_chunk_dump_func_t)(const H5O_storage_chunk_t *storage,
+    FILE *stream);
+typedef herr_t (*H5D_chunk_dest_func_t)(const H5D_chk_idx_info_t *idx_info);
+
+/* Typedef for grouping chunk I/O routines */
+typedef struct H5D_chunk_ops_t {
+    hbool_t can_swim;                       /* Flag to indicate that the index supports SWMR access */
+    H5D_chunk_init_func_t init;             /* Routine to initialize indexing information in memory */
+    H5D_chunk_create_func_t create;         /* Routine to create chunk index */
+    H5D_chunk_is_space_alloc_func_t is_space_alloc;    /* Query routine to determine if storage/index is allocated */
+    H5D_chunk_insert_func_t insert;         /* Routine to insert a chunk into an index */
+    H5D_chunk_get_addr_func_t get_addr;     /* Routine to retrieve address of chunk in file */
+    H5D_chunk_resize_func_t resize;         /* Routine to update chunk index info after resizing dataset */
+    H5D_chunk_iterate_func_t iterate;       /* Routine to iterate over chunks */
+    H5D_chunk_remove_func_t remove;         /* Routine to remove a chunk from an index */
+    H5D_chunk_delete_func_t idx_delete;     /* Routine to delete index & all chunks from file*/
+    H5D_chunk_copy_setup_func_t copy_setup; /* Routine to perform any necessary setup for copying chunks */
+    H5D_chunk_copy_shutdown_func_t copy_shutdown; /* Routine to perform any necessary shutdown for copying chunks */
+    H5D_chunk_size_func_t size;             /* Routine to get size of indexing information */
+    H5D_chunk_reset_func_t reset;           /* Routine to reset indexing information */
+    H5D_chunk_dump_func_t dump;             /* Routine to dump indexing information */
+    H5D_chunk_dest_func_t dest;             /* Routine to destroy indexing information in memory */
+} H5D_chunk_ops_t;
+
+/* Structure holding information about a chunk's selection for mapping */
+typedef struct H5D_chunk_info_t {
+    hsize_t index;              /* "Index" of chunk in dataset */
+    uint32_t chunk_points;      /* Number of elements selected in chunk */
+    hsize_t scaled[H5O_LAYOUT_NDIMS];   /* Scaled coordinates of chunk (in file dataset's dataspace) */
+    H5S_t *fspace;              /* Dataspace describing chunk & selection in it */
+    hbool_t fspace_shared;      /* Indicate that the file space for a chunk is shared and shouldn't be freed */
+    H5S_t *mspace;              /* Dataspace describing selection in memory corresponding to this chunk */
+    hbool_t mspace_shared;      /* Indicate that the memory space for a chunk is shared and shouldn't be freed */
+} H5D_chunk_info_t;
+
+/* Main structure holding the mapping between file chunks and memory */
+typedef struct H5D_chunk_map_t {
+    H5O_layout_t *layout;       /* Dataset layout information*/
+    hsize_t nelmts;             /* Number of elements selected in file & memory dataspaces */
+
+    const H5S_t *file_space;    /* Pointer to the file dataspace */
+    unsigned f_ndims;           /* Number of dimensions for file dataspace */
+
+    const H5S_t *mem_space;     /* Pointer to the memory dataspace */
+    H5S_t *mchunk_tmpl;         /* Dataspace template for new memory chunks */
+    H5S_sel_iter_t mem_iter;    /* Iterator for elements in memory selection */
+    unsigned m_ndims;           /* Number of dimensions for memory dataspace */
+    H5S_sel_type msel_type;     /* Selection type in memory */
+    H5S_sel_type fsel_type;     /* Selection type in file */
+
+    H5SL_t *sel_chunks;         /* Skip list containing information for each chunk selected */
+
+    H5S_t  *single_space;       /* Dataspace for single chunk */
+    H5D_chunk_info_t *single_chunk_info;  /* Pointer to single chunk's info */
+    hbool_t use_single;         /* Whether I/O is on a single element */
+
+    hsize_t last_index;         /* Index of last chunk operated on */
+    H5D_chunk_info_t *last_chunk_info;  /* Pointer to last chunk's info */
+
+    hsize_t chunk_dim[H5O_LAYOUT_NDIMS];    /* Size of chunk in each dimension */
+
+#ifdef H5_HAVE_PARALLEL
+    H5D_chunk_info_t **select_chunk;    /* Store the information about whether this chunk is selected or not */
+#endif /* H5_HAVE_PARALLEL */
+} H5D_chunk_map_t;
+
+/* Cached information about a particular chunk */
+typedef struct H5D_chunk_cached_t {
+    hbool_t     valid;                          /*whether cache info is valid*/
+    hsize_t	scaled[H5O_LAYOUT_NDIMS];	/*scaled offset of chunk*/
+    haddr_t	addr;				/*file address of chunk */
+    uint32_t	nbytes;				/*size of stored data	*/
+    hsize_t     chunk_idx;			/*index of chunk in dataset */
+    unsigned	filter_mask;			/*excluded filters	*/
+} H5D_chunk_cached_t;
+
+/****************************/
+/* Virtual dataset typedefs */
+/****************************/
+
+/* List of files held open during refresh operations */
+typedef struct H5D_virtual_held_file_t {
+    H5F_t *file;                                /* Pointer to file held open */
+    struct H5D_virtual_held_file_t *next;       /* Pointer to next node in list */
+} H5D_virtual_held_file_t;
+
+/* The raw data chunk cache */
+struct H5D_rdcc_ent_t;  /* Forward declaration of struct used below */
+typedef struct H5D_rdcc_t {
+    struct {
+        unsigned	ninits;	/* Number of chunk creations		*/
+        unsigned	nhits;	/* Number of cache hits			*/
+        unsigned	nmisses;/* Number of cache misses		*/
+        unsigned	nflushes;/* Number of cache flushes		*/
+    } stats;
+    size_t		nbytes_max; /* Maximum cached raw data in bytes	*/
+    size_t		nslots;	/* Number of chunk slots allocated	*/
+    double		w0;     /* Chunk preemption policy          */
+    struct H5D_rdcc_ent_t *head; /* Head of doubly linked list		*/
+    struct H5D_rdcc_ent_t *tail; /* Tail of doubly linked list		*/
+    struct H5D_rdcc_ent_t *tmp_head; /* Head of temporary doubly linked list.  Chunks on this list are not in the hash table (slot).  The head entry is a sentinel (does not refer to an actual chunk). */
+    size_t		nbytes_used; /* Current cached raw data in bytes */
+    int			nused;	/* Number of chunk slots in use		*/
+    H5D_chunk_cached_t last;    /* Cached copy of last chunk information */
+    struct H5D_rdcc_ent_t **slot; /* Chunk slots, each points to a chunk*/
+    H5SL_t		*sel_chunks; /* Skip list containing information for each chunk selected */
+    H5S_t		*single_space; /* Dataspace for single element I/O on chunks */
+    H5D_chunk_info_t    *single_chunk_info;  /* Pointer to single chunk's info */
+
+    /* Cached information about scaled dataspace dimensions */
+    hsize_t             scaled_dims[H5S_MAX_RANK];          /* The scaled dim sizes */
+    hsize_t             scaled_power2up[H5S_MAX_RANK];      /* The scaled dim sizes, rounded up to next power of 2 */
+    unsigned            scaled_encode_bits[H5S_MAX_RANK];   /* The number of bits needed to encode the scaled dim sizes */
+} H5D_rdcc_t;
+
+/* The raw data contiguous data cache */
+typedef struct H5D_rdcdc_t {
+    unsigned char *sieve_buf;   /* Buffer to hold data sieve buffer */
+    haddr_t sieve_loc;          /* File location (offset) of the data sieve buffer */
+    size_t sieve_size;          /* Size of the data sieve buffer used (in bytes) */
+    size_t sieve_buf_size;      /* Size of the data sieve buffer allocated (in bytes) */
+    hbool_t sieve_dirty;        /* Flag to indicate that the data sieve buffer is dirty */
+} H5D_rdcdc_t;
+
+/*
+ * A dataset is made of two layers, an H5D_t struct that is unique to
+ * each instance of an opened datset, and a shared struct that is only
+ * created once for a given dataset.  Thus, if a dataset is opened twice,
+ * there will be two IDs and two H5D_t structs, both sharing one H5D_shared_t.
+ */
+typedef struct H5D_shared_t {
+    size_t              fo_count;       /* Reference count */
+    hbool_t             closing;        /* Flag to indicate dataset is closing */
+    hid_t               type_id;        /* ID for dataset's datatype    */
+    H5T_t              *type;           /* Datatype for this dataset     */
+    H5S_t              *space;          /* Dataspace of this dataset    */
+    hid_t               dcpl_id;        /* Dataset creation property id */
+    H5D_dcpl_cache_t    dcpl_cache;     /* Cached DCPL values */
+    H5O_layout_t        layout;         /* Data layout                  */
+    hbool_t             checked_filters;/* TRUE if dataset passes can_apply check */
+
+    /* Cached dataspace info */
+    unsigned            ndims;          /* The dataset's dataspace rank */
+    hsize_t             curr_dims[H5S_MAX_RANK];    /* The curr. size of dataset dimensions */
+    hsize_t             curr_power2up[H5S_MAX_RANK];    /* The curr. dim sizes, rounded up to next power of 2 */
+    hsize_t             max_dims[H5S_MAX_RANK];     /* The max. size of dataset dimensions */ 
+
+    /* Buffered/cached information for types of raw data storage*/
+    struct {
+        H5D_rdcdc_t     contig;         /* Information about contiguous data */
+                                        /* (Note that the "contig" cache
+                                         * information can be used by a chunked
+                                         * dataset in certain circumstances)
+                                         */
+        H5D_rdcc_t      chunk;          /* Information about chunked data */
+    } cache;
+
+    H5D_append_flush_t  append_flush;   /* Append flush property information */
+    char                *extfile_prefix; /* expanded external file prefix */
+} H5D_shared_t;
+
+struct H5D_t {
+    H5O_loc_t           oloc;           /* Object header location       */
+    H5G_name_t          path;           /* Group hierarchy path         */
+    H5D_shared_t        *shared;        /* cached information from file */
+};
+
+/* Enumerated type for allocating dataset's storage */
+typedef enum {
+    H5D_ALLOC_CREATE,           /* Dataset is being created */
+    H5D_ALLOC_OPEN,             /* Dataset is being opened */
+    H5D_ALLOC_EXTEND,           /* Dataset's dataspace is being extended */
+    H5D_ALLOC_WRITE             /* Dataset is being extended */
+} H5D_time_alloc_t;
+
+
+/* Typedef for dataset creation operation */
+typedef struct {
+    hid_t type_id;              /* Datatype for dataset */
+    const H5S_t *space;         /* Dataspace for dataset */
+    hid_t dcpl_id;              /* Dataset creation property list */
+    hid_t dapl_id;              /* Dataset access property list */
+} H5D_obj_create_t;
+
+/* Typedef for filling a buffer with a fill value */
+typedef struct H5D_fill_buf_info_t {
+    H5MM_allocate_t fill_alloc_func;    /* Routine to call for allocating fill buffer */
+    void        *fill_alloc_info;       /* Extra info for allocation routine */
+    H5MM_free_t fill_free_func;         /* Routine to call for freeing fill buffer */
+    void        *fill_free_info;        /* Extra info for free routine */
+    H5T_path_t *fill_to_mem_tpath;      /* Datatype conversion path for converting the fill value to the memory buffer */
+    H5T_path_t *mem_to_dset_tpath;      /* Datatype conversion path for converting the memory buffer to the dataset elements */
+    const H5O_fill_t *fill;             /* Pointer to fill value */
+    void       *fill_buf;               /* Fill buffer */
+    size_t      fill_buf_size;          /* Size of fill buffer */
+    hbool_t     use_caller_fill_buf;    /* Whether the caller provided the fill buffer */
+    void       *bkg_buf;                /* Background conversion buffer */
+    size_t      bkg_buf_size;           /* Size of background buffer */
+    H5T_t      *mem_type;               /* Pointer to memory datatype */
+    const H5T_t *file_type;             /* Pointer to file datatype */
+    hid_t       mem_tid;                /* ID for memory version of disk datatype */
+    hid_t       file_tid;               /* ID for disk datatype */
+    size_t      mem_elmt_size, file_elmt_size;       /* Size of element in memory and on disk */
+    size_t      max_elmt_size;          /* Max. size of memory or file datatype */
+    size_t      elmts_per_buf;          /* # of elements that fit into a buffer */
+    hbool_t     has_vlen_fill_type;     /* Whether the datatype for the fill value has a variable-length component */
+} H5D_fill_buf_info_t;
+
+/* Internal data structure for computing variable-length dataset's total size */
+typedef struct {
+    H5D_t *dset;        /* Dataset for operation */
+    H5S_t *fspace;      /* Dataset's dataspace for operation */
+    H5S_t *mspace;      /* Memory dataspace for operation */
+    void *fl_tbuf;      /* Ptr to the temporary buffer we are using for fixed-length data */
+    void *vl_tbuf;      /* Ptr to the temporary buffer we are using for VL data */
+    hid_t xfer_pid;     /* ID of the dataset xfer property list */
+    hsize_t size;       /* Accumulated number of bytes for the selection */
+} H5D_vlen_bufsize_t;
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+extern H5D_dxpl_cache_t H5D_def_dxpl_cache;
+
+/* Storage layout class I/O operations */
+H5_DLLVAR const H5D_layout_ops_t H5D_LOPS_CONTIG[1];
+H5_DLLVAR const H5D_layout_ops_t H5D_LOPS_EFL[1];
+H5_DLLVAR const H5D_layout_ops_t H5D_LOPS_COMPACT[1];
+H5_DLLVAR const H5D_layout_ops_t H5D_LOPS_CHUNK[1];
+H5_DLLVAR const H5D_layout_ops_t H5D_LOPS_VIRTUAL[1];
+
+/* Chunked layout operations */
+H5_DLLVAR const H5D_chunk_ops_t H5D_COPS_BTREE[1];
+H5_DLLVAR const H5D_chunk_ops_t H5D_COPS_NONE[1];
+H5_DLLVAR const H5D_chunk_ops_t H5D_COPS_SINGLE[1];
+H5_DLLVAR const H5D_chunk_ops_t H5D_COPS_EARRAY[1];
+H5_DLLVAR const H5D_chunk_ops_t H5D_COPS_FARRAY[1];
+H5_DLLVAR const H5D_chunk_ops_t H5D_COPS_BT2[1];
+
+/* The v2 B-tree class for indexing chunked datasets with >1 unlimited dimensions */
+H5_DLLVAR const H5B2_class_t H5D_BT2[1];
+H5_DLLVAR const H5B2_class_t H5D_BT2_FILT[1];
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+H5_DLL H5D_t *H5D__create(H5F_t *file, hid_t type_id, const H5S_t *space,
+    hid_t dcpl_id, hid_t dapl_id, hid_t dxpl_id);
+H5_DLL H5D_t *H5D__create_named(const H5G_loc_t *loc, const char *name,
+    hid_t type_id, const H5S_t *space, hid_t lcpl_id, hid_t dcpl_id,
+    hid_t dapl_id, hid_t dxpl_id);
+H5_DLL H5D_t *H5D__open_name(const H5G_loc_t *loc, const char *name,
+    hid_t dapl_id, hid_t dxpl_id);
+H5_DLL herr_t H5D__get_space_status(H5D_t *dset, H5D_space_status_t *allocation,
+    hid_t dxpl_id);
+H5_DLL herr_t H5D__alloc_storage(const H5D_io_info_t *io_info, H5D_time_alloc_t time_alloc,
+    hbool_t full_overwrite, hsize_t old_dim[]);
+H5_DLL herr_t H5D__get_storage_size(H5D_t *dset, hid_t dxpl_id, hsize_t *storage_size);
+H5_DLL herr_t H5D__get_chunk_storage_size(H5D_t *dset, hid_t dxpl_id, const hsize_t *offset, hsize_t *storage_size);
+H5_DLL haddr_t H5D__get_offset(const H5D_t *dset);
+H5_DLL void *H5D__vlen_get_buf_size_alloc(size_t size, void *info);
+H5_DLL herr_t H5D__vlen_get_buf_size(void *elem, hid_t type_id, unsigned ndim,
+    const hsize_t *point, void *op_data);
+H5_DLL herr_t H5D__check_filters(H5D_t *dataset);
+H5_DLL herr_t H5D__set_extent(H5D_t *dataset, const hsize_t *size, hid_t dxpl_id);
+H5_DLL herr_t H5D__get_dxpl_cache(hid_t dxpl_id, H5D_dxpl_cache_t **cache);
+H5_DLL herr_t H5D__flush_sieve_buf(H5D_t *dataset, hid_t dxpl_id);
+H5_DLL herr_t H5D__flush_real(H5D_t *dataset, hid_t dxpl_id);
+H5_DLL herr_t H5D__mark(const H5D_t *dataset, hid_t dxpl_id, unsigned flags);
+H5_DLL herr_t H5D__refresh(hid_t dset_id, H5D_t *dataset, hid_t dxpl_id);
+#ifdef H5_DEBUG_BUILD
+H5_DLL herr_t H5D_set_io_info_dxpls(H5D_io_info_t *io_info, hid_t dxpl_id);
+#endif /* H5_DEBUG_BUILD */
+
+/* To convert a dataset's chunk indexing type to v1 B-tree */
+H5_DLL herr_t H5D__format_convert(H5D_t *dataset, hid_t dxpl_id);
+
+/* Internal I/O routines */
+H5_DLL herr_t H5D__read(H5D_t *dataset, hid_t mem_type_id,
+    const H5S_t *mem_space, const H5S_t *file_space, hid_t dset_xfer_plist,
+    void *buf/*out*/);
+H5_DLL herr_t H5D__write(H5D_t *dataset, hid_t mem_type_id,
+    const H5S_t *mem_space, const H5S_t *file_space, hid_t dset_xfer_plist,
+    const void *buf);
+
+/* Functions that perform direct serial I/O operations */
+H5_DLL herr_t H5D__select_read(const H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info,
+    hsize_t nelmts, const H5S_t *file_space, const H5S_t *mem_space);
+H5_DLL herr_t H5D__select_write(const H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info,
+    hsize_t nelmts, const H5S_t *file_space, const H5S_t *mem_space);
+
+/* Functions that perform scatter-gather serial I/O operations */
+H5_DLL herr_t H5D__scatter_mem(const void *_tscat_buf,
+    const H5S_t *space, H5S_sel_iter_t *iter, size_t nelmts,
+    const H5D_dxpl_cache_t *dxpl_cache, void *_buf);
+H5_DLL herr_t H5D__scatgath_read(const H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info,
+    hsize_t nelmts, const H5S_t *file_space, const H5S_t *mem_space);
+H5_DLL herr_t H5D__scatgath_write(const H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info,
+    hsize_t nelmts, const H5S_t *file_space, const H5S_t *mem_space);
+
+/* Functions that operate on dataset's layout information */
+H5_DLL herr_t H5D__layout_set_io_ops(const H5D_t *dataset);
+H5_DLL size_t H5D__layout_meta_size(const H5F_t *f, const H5O_layout_t *layout,
+    hbool_t include_compact_data);
+H5_DLL herr_t H5D__layout_set_latest_version(H5O_layout_t *layout,
+    const H5S_t *space, const H5D_dcpl_cache_t *dcpl_cache);
+H5_DLL herr_t H5D__layout_set_latest_indexing(H5O_layout_t *layout,
+    const H5S_t *space, const H5D_dcpl_cache_t *dcpl_cache);
+H5_DLL herr_t H5D__layout_oh_create(H5F_t *file, hid_t dxpl_id, H5O_t *oh,
+    H5D_t *dset, hid_t dapl_id);
+H5_DLL herr_t H5D__layout_oh_read(H5D_t *dset, hid_t dxpl_id, hid_t dapl_id,
+    H5P_genplist_t *plist);
+H5_DLL herr_t H5D__layout_oh_write(H5D_t *dataset, hid_t dxpl_id, H5O_t *oh,
+    unsigned update_flags);
+
+/* Functions that operate on contiguous storage */
+H5_DLL herr_t H5D__contig_alloc(H5F_t *f, hid_t dxpl_id,
+    H5O_storage_contig_t *storage);
+H5_DLL hbool_t H5D__contig_is_space_alloc(const H5O_storage_t *storage);
+H5_DLL herr_t H5D__contig_fill(const H5D_io_info_t *io_info);
+H5_DLL herr_t H5D__contig_read(H5D_io_info_t *io_info, const H5D_type_info_t *type_info,
+    hsize_t nelmts, const H5S_t *file_space, const H5S_t *mem_space,
+    H5D_chunk_map_t *fm);
+H5_DLL herr_t H5D__contig_write(H5D_io_info_t *io_info, const H5D_type_info_t *type_info,
+    hsize_t nelmts, const H5S_t *file_space, const H5S_t *mem_space,
+    H5D_chunk_map_t *fm);
+H5_DLL herr_t H5D__contig_copy(H5F_t *f_src, const H5O_storage_contig_t *storage_src,
+    H5F_t *f_dst, H5O_storage_contig_t *storage_dst, H5T_t *src_dtype,
+    H5O_copy_t *cpy_info, hid_t dxpl_id);
+H5_DLL herr_t H5D__contig_delete(H5F_t *f, hid_t dxpl_id,
+    const H5O_storage_t *store);
+
+/* Functions that operate on chunked dataset storage */
+H5_DLL htri_t H5D__chunk_cacheable(const H5D_io_info_t *io_info, haddr_t caddr,
+    hbool_t write_op);
+H5_DLL herr_t H5D__chunk_create(const H5D_t *dset /*in,out*/, hid_t dxpl_id);
+H5_DLL herr_t H5D__chunk_set_info(const H5D_t *dset);
+H5_DLL hbool_t H5D__chunk_is_space_alloc(const H5O_storage_t *storage);
+H5_DLL herr_t H5D__chunk_lookup(const H5D_t *dset, hid_t dxpl_id,
+    const hsize_t *scaled, H5D_chunk_ud_t *udata);
+H5_DLL herr_t H5D__chunk_allocated(H5D_t *dset, hid_t dxpl_id, hsize_t *nbytes);
+H5_DLL herr_t H5D__chunk_allocate(const H5D_io_info_t *io_info, hbool_t full_overwrite, hsize_t old_dim[]);
+H5_DLL herr_t H5D__chunk_update_old_edge_chunks(H5D_t *dset, hid_t dxpl_id,
+    hsize_t old_dim[]);
+H5_DLL herr_t H5D__chunk_prune_by_extent(H5D_t *dset, hid_t dxpl_id,
+    const hsize_t *old_dim);
+H5_DLL herr_t H5D__chunk_set_sizes(H5D_t *dset);
+#ifdef H5_HAVE_PARALLEL
+H5_DLL herr_t H5D__chunk_addrmap(const H5D_io_info_t *io_info, haddr_t chunk_addr[]);
+#endif /* H5_HAVE_PARALLEL */
+H5_DLL herr_t H5D__chunk_update_cache(H5D_t *dset, hid_t dxpl_id);
+H5_DLL herr_t H5D__chunk_copy(H5F_t *f_src, H5O_storage_chunk_t *storage_src,
+    H5O_layout_chunk_t *layout_src, H5F_t *f_dst, H5O_storage_chunk_t *storage_dst,
+    const H5S_extent_t *ds_extent_src, const H5T_t *dt_src,
+    const H5O_pline_t *pline_src, H5O_copy_t *cpy_info, hid_t dxpl_id);
+H5_DLL herr_t H5D__chunk_bh_info(const H5O_loc_t *loc, hid_t dxpl_id, H5O_t *oh,
+    H5O_layout_t *layout, hsize_t *btree_size);
+H5_DLL herr_t H5D__chunk_dump_index(H5D_t *dset, hid_t dxpl_id, FILE *stream);
+H5_DLL herr_t H5D__chunk_delete(H5F_t *f, hid_t dxpl_id, H5O_t *oh,
+    H5O_storage_t *store);
+H5_DLL herr_t H5D__chunk_direct_write(const H5D_t *dset, hid_t dxpl_id, uint32_t filters, 
+         hsize_t *offset, uint32_t data_size, const void *buf);
+H5_DLL herr_t H5D__chunk_direct_read(const H5D_t *dset, hid_t dxpl_id, hsize_t *offset,
+         uint32_t *filters, void *buf);
+#ifdef H5D_CHUNK_DEBUG
+H5_DLL herr_t H5D__chunk_stats(const H5D_t *dset, hbool_t headers);
+#endif /* H5D_CHUNK_DEBUG */
+
+/* format convert */
+H5_DLL herr_t H5D__chunk_format_convert(H5D_t *dset, H5D_chk_idx_info_t *idx_info, H5D_chk_idx_info_t *new_idx_info);
+
+/* Functions that operate on compact dataset storage */
+H5_DLL herr_t H5D__compact_fill(const H5D_t *dset, hid_t dxpl_id);
+H5_DLL herr_t H5D__compact_copy(H5F_t *f_src, H5O_storage_compact_t *storage_src,
+    H5F_t *f_dst, H5O_storage_compact_t *storage_dst, H5T_t *src_dtype,
+    H5O_copy_t *cpy_info, hid_t dxpl_id);
+
+/* Functions that operate on virtual dataset storage */
+H5_DLL herr_t H5D__virtual_copy_layout(H5O_layout_t *layout);
+H5_DLL herr_t H5D__virtual_set_extent_unlim(const H5D_t *dset, hid_t dxpl_id);
+H5_DLL herr_t H5D__virtual_reset_layout(H5O_layout_t *layout);
+H5_DLL herr_t H5D__virtual_delete(H5F_t *f, hid_t dxpl_id, H5O_storage_t *storage);
+H5_DLL herr_t H5D__virtual_copy(H5F_t *f_src, H5O_layout_t *layout_dst,
+    hid_t dxpl_id);
+H5_DLL herr_t H5D__virtual_init(H5F_t *f, hid_t dxpl_id, const H5D_t *dset,
+    hid_t dapl_id);
+H5_DLL hbool_t H5D__virtual_is_space_alloc(const H5O_storage_t *storage);
+H5_DLL herr_t H5D__virtual_hold_source_dset_files(const H5D_t *dset, H5D_virtual_held_file_t **head);
+H5_DLL herr_t H5D__virtual_refresh_source_dsets(H5D_t *dset, hid_t dxpl_id);
+H5_DLL herr_t H5D__virtual_release_source_dset_files(H5D_virtual_held_file_t *head);
+
+/* Functions that operate on EFL (External File List)*/
+H5_DLL hbool_t H5D__efl_is_space_alloc(const H5O_storage_t *storage);
+H5_DLL herr_t H5D__efl_bh_info(H5F_t *f, hid_t dxpl_id, H5O_efl_t *efl,
+    hsize_t *heap_size);
+
+/* Functions that perform fill value operations on datasets */
+H5_DLL herr_t H5D__fill(const void *fill, const H5T_t *fill_type, void *buf,
+    const H5T_t *buf_type, const H5S_t *space, hid_t dxpl_id);
+H5_DLL herr_t H5D__fill_init(H5D_fill_buf_info_t *fb_info, void *caller_fill_buf,
+    H5MM_allocate_t alloc_func, void *alloc_info,
+    H5MM_free_t free_func, void *free_info,
+    const H5O_fill_t *fill, const H5T_t *dset_type, hid_t dset_type_id,
+    size_t nelmts, size_t min_buf_size, hid_t dxpl_id);
+H5_DLL herr_t H5D__fill_refill_vl(H5D_fill_buf_info_t *fb_info, size_t nelmts, hid_t dxpl_id);
+H5_DLL herr_t H5D__fill_term(H5D_fill_buf_info_t *fb_info);
+
+#ifdef H5_HAVE_PARALLEL
+
+#ifdef H5S_DEBUG
+#ifndef H5Dmpio_DEBUG
+#define H5Dmpio_DEBUG
+#endif /*H5Dmpio_DEBUG*/
+#endif/*H5S_DEBUG*/
+/* MPI-IO function to read, it will select either regular or irregular read */
+H5_DLL herr_t H5D__mpio_select_read(const H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info,
+    hsize_t nelmts, const H5S_t *file_space, const H5S_t *mem_space);
+
+/* MPI-IO function to write, it will select either regular or irregular read */
+H5_DLL herr_t H5D__mpio_select_write(const H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info,
+    hsize_t nelmts, const H5S_t *file_space, const H5S_t *mem_space);
+
+/* MPI-IO functions to handle contiguous collective IO */
+H5_DLL herr_t H5D__contig_collective_read(H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info, hsize_t nelmts, const H5S_t *file_space,
+    const H5S_t *mem_space, H5D_chunk_map_t *fm);
+H5_DLL herr_t H5D__contig_collective_write(H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info, hsize_t nelmts, const H5S_t *file_space,
+    const H5S_t *mem_space, H5D_chunk_map_t *fm);
+
+/* MPI-IO functions to handle chunked collective IO */
+H5_DLL herr_t H5D__chunk_collective_read(H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info, hsize_t nelmts, const H5S_t *file_space,
+    const H5S_t *mem_space, H5D_chunk_map_t *fm);
+H5_DLL herr_t H5D__chunk_collective_write(H5D_io_info_t *io_info,
+    const H5D_type_info_t *type_info, hsize_t nelmts, const H5S_t *file_space,
+    const H5S_t *mem_space, H5D_chunk_map_t *fm);
+
+/* MPI-IO function to check if a direct I/O transfer is possible between
+ * memory and the file */
+H5_DLL htri_t H5D__mpio_opt_possible(const H5D_io_info_t *io_info,
+    const H5S_t *file_space, const H5S_t *mem_space,
+    const H5D_type_info_t *type_info, const H5D_chunk_map_t *fm,
+    H5P_genplist_t *dx_plist);
+
+#endif /* H5_HAVE_PARALLEL */
+
+/* Testing functions */
+#ifdef H5D_TESTING
+H5_DLL herr_t H5D__layout_version_test(hid_t did, unsigned *version);
+H5_DLL herr_t H5D__layout_contig_size_test(hid_t did, hsize_t *size);
+H5_DLL herr_t H5D__layout_compact_dirty_test(hid_t did, hbool_t *dirty);
+H5_DLL herr_t H5D__layout_idx_type_test(hid_t did, H5D_chunk_index_t *idx_type);
+H5_DLL herr_t H5D__layout_type_test(hid_t did, H5D_layout_t *layout_type);
+H5_DLL herr_t H5D__current_cache_size_test(hid_t did, size_t *nbytes_used, int *nused);
+#endif /* H5D_TESTING */
+
+#endif /*_H5Dpkg_H*/
+
diff --git a/install/include/H5Dpublic.h b/install/include/H5Dpublic.h
new file mode 100644
index 0000000000..baa844ac8a
--- /dev/null
+++ b/install/include/H5Dpublic.h
@@ -0,0 +1,204 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5D module.
+ */
+#ifndef _H5Dpublic_H
+#define _H5Dpublic_H
+
+/* System headers needed by this file */
+
+/* Public headers needed by this file */
+#include "H5public.h"
+#include "H5Ipublic.h"
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* Macros used to "unset" chunk cache configuration parameters */
+#define H5D_CHUNK_CACHE_NSLOTS_DEFAULT      ((size_t) -1)
+#define H5D_CHUNK_CACHE_NBYTES_DEFAULT      ((size_t) -1)
+#define H5D_CHUNK_CACHE_W0_DEFAULT          (-1.0f)
+
+/* Bit flags for the H5Pset_chunk_opts() and H5Pget_chunk_opts() */
+#define H5D_CHUNK_DONT_FILTER_PARTIAL_CHUNKS      (0x0002u)
+
+/* Property names for H5LTDdirect_chunk_write */   
+#define H5D_XFER_DIRECT_CHUNK_WRITE_FLAG_NAME	        "direct_chunk_flag"
+#define H5D_XFER_DIRECT_CHUNK_WRITE_FILTERS_NAME	"direct_chunk_filters"
+#define H5D_XFER_DIRECT_CHUNK_WRITE_OFFSET_NAME		"direct_chunk_offset"
+#define H5D_XFER_DIRECT_CHUNK_WRITE_DATASIZE_NAME	"direct_chunk_datasize"
+
+/* Property names for H5LTDdirect_chunk_read */
+#define H5D_XFER_DIRECT_CHUNK_READ_FLAG_NAME        "direct_chunk_read_flag"
+#define H5D_XFER_DIRECT_CHUNK_READ_OFFSET_NAME      "direct_chunk_read_offset"
+#define H5D_XFER_DIRECT_CHUNK_READ_FILTERS_NAME     "direct_chunk_read_filters"
+ 
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/* Values for the H5D_LAYOUT property */
+typedef enum H5D_layout_t {
+    H5D_LAYOUT_ERROR	= -1,
+
+    H5D_COMPACT		= 0,	/*raw data is very small		     */
+    H5D_CONTIGUOUS	= 1,	/*the default				     */
+    H5D_CHUNKED		= 2,	/*slow and fancy			     */
+    H5D_VIRTUAL         = 3,    /*actual data is stored in other datasets     */
+    H5D_NLAYOUTS	= 4	/*this one must be last!		     */
+} H5D_layout_t;
+
+/* Types of chunk index data structures */
+typedef enum H5D_chunk_index_t {
+    H5D_CHUNK_IDX_BTREE	= 0,    /* v1 B-tree index (default)                */
+    H5D_CHUNK_IDX_SINGLE = 1,   /* Single Chunk index (cur dims[]=max dims[]=chunk dims[]; filtered & non-filtered) */
+    H5D_CHUNK_IDX_NONE = 2,     /* Implicit: No Index (H5D_ALLOC_TIME_EARLY, non-filtered, fixed dims) */
+    H5D_CHUNK_IDX_FARRAY = 3,   /* Fixed array (for 0 unlimited dims)       */
+    H5D_CHUNK_IDX_EARRAY = 4,   /* Extensible array (for 1 unlimited dim)   */
+    H5D_CHUNK_IDX_BT2 = 5,      /* v2 B-tree index (for >1 unlimited dims)  */
+    H5D_CHUNK_IDX_NTYPES        /* This one must be last!                   */
+} H5D_chunk_index_t;
+
+/* Values for the space allocation time property */
+typedef enum H5D_alloc_time_t {
+    H5D_ALLOC_TIME_ERROR	= -1,
+    H5D_ALLOC_TIME_DEFAULT  	= 0,
+    H5D_ALLOC_TIME_EARLY	= 1,
+    H5D_ALLOC_TIME_LATE		= 2,
+    H5D_ALLOC_TIME_INCR		= 3
+} H5D_alloc_time_t;
+
+/* Values for the status of space allocation */
+typedef enum H5D_space_status_t {
+    H5D_SPACE_STATUS_ERROR		= -1,
+    H5D_SPACE_STATUS_NOT_ALLOCATED	= 0,
+    H5D_SPACE_STATUS_PART_ALLOCATED	= 1,
+    H5D_SPACE_STATUS_ALLOCATED		= 2
+} H5D_space_status_t;
+
+/* Values for time of writing fill value property */
+typedef enum H5D_fill_time_t {
+    H5D_FILL_TIME_ERROR	= -1,
+    H5D_FILL_TIME_ALLOC = 0,
+    H5D_FILL_TIME_NEVER	= 1,
+    H5D_FILL_TIME_IFSET	= 2
+} H5D_fill_time_t;
+
+/* Values for fill value status */
+typedef enum H5D_fill_value_t {
+    H5D_FILL_VALUE_ERROR        =-1,
+    H5D_FILL_VALUE_UNDEFINED    =0,
+    H5D_FILL_VALUE_DEFAULT      =1,
+    H5D_FILL_VALUE_USER_DEFINED =2
+} H5D_fill_value_t;
+
+/* Values for VDS bounds option */
+typedef enum H5D_vds_view_t {
+    H5D_VDS_ERROR               = -1,
+    H5D_VDS_FIRST_MISSING       = 0,
+    H5D_VDS_LAST_AVAILABLE      = 1
+} H5D_vds_view_t;
+
+/* Callback for H5Pset_append_flush() in a dataset access property list */
+typedef herr_t (*H5D_append_cb_t)(hid_t dataset_id, hsize_t *cur_dims, void *op_data);
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Define the operator function pointer for H5Diterate() */
+typedef herr_t (*H5D_operator_t)(void *elem, hid_t type_id, unsigned ndim,
+				 const hsize_t *point, void *operator_data);
+
+/* Define the operator function pointer for H5Dscatter() */
+typedef herr_t (*H5D_scatter_func_t)(const void **src_buf/*out*/,
+                                     size_t *src_buf_bytes_used/*out*/,
+                                     void *op_data);
+
+/* Define the operator function pointer for H5Dgather() */
+typedef herr_t (*H5D_gather_func_t)(const void *dst_buf,
+                                    size_t dst_buf_bytes_used, void *op_data);
+
+H5_DLL hid_t H5Dcreate2(hid_t loc_id, const char *name, hid_t type_id,
+    hid_t space_id, hid_t lcpl_id, hid_t dcpl_id, hid_t dapl_id);
+H5_DLL hid_t H5Dcreate_anon(hid_t file_id, hid_t type_id, hid_t space_id,
+    hid_t plist_id, hid_t dapl_id);
+H5_DLL hid_t H5Dopen2(hid_t file_id, const char *name, hid_t dapl_id);
+H5_DLL herr_t H5Dclose(hid_t dset_id);
+H5_DLL hid_t H5Dget_space(hid_t dset_id);
+H5_DLL herr_t H5Dget_space_status(hid_t dset_id, H5D_space_status_t *allocation);
+H5_DLL hid_t H5Dget_type(hid_t dset_id);
+H5_DLL hid_t H5Dget_create_plist(hid_t dset_id);
+H5_DLL hid_t H5Dget_access_plist(hid_t dset_id);
+H5_DLL hsize_t H5Dget_storage_size(hid_t dset_id);
+H5_DLL herr_t H5Dget_chunk_storage_size(hid_t dset_id, const hsize_t *offset, hsize_t *chunk_bytes);
+H5_DLL haddr_t H5Dget_offset(hid_t dset_id);
+H5_DLL herr_t H5Dread(hid_t dset_id, hid_t mem_type_id, hid_t mem_space_id,
+			hid_t file_space_id, hid_t plist_id, void *buf/*out*/);
+H5_DLL herr_t H5Dwrite(hid_t dset_id, hid_t mem_type_id, hid_t mem_space_id,
+			 hid_t file_space_id, hid_t plist_id, const void *buf);
+H5_DLL herr_t H5Diterate(void *buf, hid_t type_id, hid_t space_id,
+            H5D_operator_t op, void *operator_data);
+H5_DLL herr_t H5Dvlen_reclaim(hid_t type_id, hid_t space_id, hid_t plist_id, void *buf);
+H5_DLL herr_t H5Dvlen_get_buf_size(hid_t dataset_id, hid_t type_id, hid_t space_id, hsize_t *size);
+H5_DLL herr_t H5Dfill(const void *fill, hid_t fill_type, void *buf,
+        hid_t buf_type, hid_t space);
+H5_DLL herr_t H5Dset_extent(hid_t dset_id, const hsize_t size[]);
+H5_DLL herr_t H5Dflush(hid_t dset_id);
+H5_DLL herr_t H5Drefresh(hid_t dset_id);
+H5_DLL herr_t H5Dscatter(H5D_scatter_func_t op, void *op_data, hid_t type_id,
+    hid_t dst_space_id, void *dst_buf);
+H5_DLL herr_t H5Dgather(hid_t src_space_id, const void *src_buf, hid_t type_id,
+    size_t dst_buf_size, void *dst_buf, H5D_gather_func_t op, void *op_data);
+H5_DLL herr_t H5Ddebug(hid_t dset_id);
+
+/* Internal API routines */
+H5_DLL herr_t H5Dformat_convert(hid_t dset_id);
+H5_DLL herr_t H5Dget_chunk_index_type(hid_t did, H5D_chunk_index_t *idx_type);
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+#define H5D_CHUNK_BTREE H5D_CHUNK_IDX_BTREE
+
+
+/* Typedefs */
+
+
+/* Function prototypes */
+H5_DLL hid_t H5Dcreate1(hid_t file_id, const char *name, hid_t type_id,
+    hid_t space_id, hid_t dcpl_id);
+H5_DLL hid_t H5Dopen1(hid_t file_id, const char *name);
+H5_DLL herr_t H5Dextend(hid_t dset_id, const hsize_t size[]);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _H5Dpublic_H */
+
diff --git a/install/include/H5DxferProp.h b/install/include/H5DxferProp.h
new file mode 100644
index 0000000000..4a38bd04bf
--- /dev/null
+++ b/install/include/H5DxferProp.h
@@ -0,0 +1,132 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5DSetMemXferPropList_H
+#define __H5DSetMemXferPropList_H
+
+namespace H5 {
+
+/*! \class DSetMemXferPropList
+    \brief Class DSetCreatPropList inherits from PropList and provides
+    wrappers for the HDF5 dataset memory and transfer property list.
+
+    Inheritance: ObjCreatPropList -> PropList -> IdComponent
+*/
+class H5_DLLCPP DSetMemXferPropList : public PropList {
+   public:
+        ///\brief Default dataset memory and transfer property list.
+        static const DSetMemXferPropList& DEFAULT;
+
+        // Creates a dataset memory and transfer property list.
+        DSetMemXferPropList();
+
+        // Creates a dataset transform property list.
+        DSetMemXferPropList(const char* expression);
+
+        // Sets type conversion and background buffers.
+        void setBuffer(size_t size, void* tconv, void* bkg) const;
+
+        // Reads buffer settings.
+        size_t getBuffer(void** tconv, void** bkg) const;
+
+        // Sets B-tree split ratios for a dataset transfer property list.
+        void setBtreeRatios(double left, double middle, double right) const;
+
+        // Gets B-tree split ratios for a dataset transfer property list.
+        void getBtreeRatios(double& left, double& middle, double& right) const;
+
+        // Sets data transform expression.
+        void setDataTransform(const char* expression) const;
+        void setDataTransform(const H5std_string& expression) const;
+
+        // Gets data transform expression.
+        ssize_t getDataTransform(char* exp, size_t buf_size=0) const;
+        H5std_string getDataTransform() const;
+
+        // Sets the dataset transfer property list status to TRUE or FALSE.
+        void setPreserve(bool status) const;
+
+        // Checks status of the dataset transfer property list.
+        bool getPreserve() const;
+
+        // Sets an exception handling callback for datatype conversion.
+        void setTypeConvCB(H5T_conv_except_func_t op, void *user_data) const;
+
+        // Gets the exception handling callback for datatype conversion.
+        void getTypeConvCB(H5T_conv_except_func_t *op, void **user_data) const;
+
+        // Sets the memory manager for variable-length datatype
+        // allocation in H5Dread and H5Dvlen_reclaim.
+        void setVlenMemManager(H5MM_allocate_t alloc, void* alloc_info,
+                               H5MM_free_t free, void* free_info) const;
+
+        // alloc and free are set to NULL, indicating that system
+        // malloc and free are to be used.
+        void setVlenMemManager() const;
+
+        // Gets the memory manager for variable-length datatype
+        // allocation in H5Dread and H5Tvlen_reclaim.
+        void getVlenMemManager(H5MM_allocate_t& alloc, void** alloc_info,
+                               H5MM_free_t& free, void** free_info) const;
+
+        // Sets the size of a contiguous block reserved for small data.
+        void setSmallDataBlockSize(hsize_t size) const;
+
+        // Returns the current small data block size setting.
+        hsize_t getSmallDataBlockSize() const;
+
+        // Sets number of I/O vectors to be read/written in hyperslab I/O.
+        void setHyperVectorSize(size_t vector_size) const;
+
+        // Returns the number of I/O vectors to be read/written in
+        // hyperslab I/O.
+        size_t getHyperVectorSize() const;
+
+        // Enables or disables error-detecting for a dataset reading
+        // process.
+        void setEDCCheck(H5Z_EDC_t check) const;
+
+        // Determines whether error-detection is enabled for dataset reads.
+        H5Z_EDC_t getEDCCheck() const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("DSetMemXferPropList"); }
+
+        // Copy constructor: makes a copy of a DSetMemXferPropList object.
+        DSetMemXferPropList(const DSetMemXferPropList& orig);
+
+        // Creates a copy of an existing dataset memory and transfer
+        // property list using the property list id.
+        DSetMemXferPropList(const hid_t plist_id);
+
+        // Noop destructor
+        virtual ~DSetMemXferPropList();
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+        // Deletes the global constant, should only be used by the library
+        static void deleteConstants();
+
+    private:
+        static DSetMemXferPropList* DEFAULT_;
+
+        // Creates the global constant, should only be used by the library
+        static DSetMemXferPropList* getConstant();
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end of DSetMemXferPropList
+} // namespace H5
+
+#endif // __H5DSetMemXferPropList_H
diff --git a/install/include/H5EApkg.h b/install/include/H5EApkg.h
new file mode 100644
index 0000000000..e162fab7e0
--- /dev/null
+++ b/install/include/H5EApkg.h
@@ -0,0 +1,483 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:      Quincey Koziol <koziol@hdfgroup.org>
+ *                  Tuesday, June 17, 2008
+ *
+ * Purpose:         This file contains declarations which are visible only
+ *                  within the H5EA package.  Source files outside the H5EA
+ *                  package should include H5EAprivate.h instead.
+ */
+#if !(defined(H5EA_FRIEND) | defined(H5EA_MODULE))
+#error "Do not include this file outside the H5EA package!"
+#endif
+
+#ifndef _H5EApkg_H
+#define _H5EApkg_H
+
+/* Get package's private header */
+#include "H5EAprivate.h"
+
+/* Other private headers needed by this file */
+#include "H5FLprivate.h"    /* Free Lists                           */
+
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* Fill value for extensible array test class */
+#ifdef H5EA_TESTING
+#define H5EA_TEST_FILL          ((uint64_t)ULLONG_MAX)
+#endif /* H5EA_TESTING */
+
+/* Size of checksum information (on disk) */
+#define H5EA_SIZEOF_CHKSUM      4
+
+/* "Standard" size of prefix information for extensible array metadata */
+#define H5EA_METADATA_PREFIX_SIZE(c) (                                        \
+    H5_SIZEOF_MAGIC   /* Signature */                                         \
+    + 1 /* Version */                                                         \
+    + 1 /* Array type */                                                      \
+    + ((c) ? H5EA_SIZEOF_CHKSUM : 0) /* Metadata checksum */                  \
+    )
+
+/* Size of the extensible array header on disk */
+#define H5EA_HEADER_SIZE(sizeof_addr, sizeof_size) (                          \
+    /* General metadata fields */                                             \
+    H5EA_METADATA_PREFIX_SIZE(TRUE)                                           \
+                                                                              \
+    /* General array information */                                           \
+    + 1 /* Element Size */                                                    \
+    + 1 /* Max. # of elements bits */                                         \
+    + 1 /* # of elements to store in index block */                           \
+    + 1 /* Min. # elements per data block */                                  \
+    + 1 /* Min. # of data block pointers for a super block */                 \
+    + 1 /* Log2(Max. # of elements in data block page) - i.e. # of bits needed to store max. # of elements in data block page */ \
+                                                                              \
+    /* Extensible Array statistics fields */                                  \
+    + (sizeof_size) /* Number of super blocks created */		      \
+    + (sizeof_size) /* Size of super blocks created */	        	      \
+    + (sizeof_size) /* Number of data blocks created */	        	      \
+    + (sizeof_size) /* Size of data blocks created */   		      \
+    + (sizeof_size) /* Max. index set */	       			      \
+    + (sizeof_size) /* Number of elements 'realized' */	        	      \
+                                                                              \
+    /* Extensible Array Header specific fields */                             \
+    + (sizeof_addr) /* File address of index block */   		      \
+    )
+
+/* Size of the extensible array header on disk (via file pointer) */
+#define H5EA_HEADER_SIZE_FILE(f)   (                                          \
+    H5EA_HEADER_SIZE(H5F_SIZEOF_ADDR(f), H5F_SIZEOF_SIZE(f))                  \
+    )
+
+/* Size of the extensible array header on disk (via extensible array header) */
+#define H5EA_HEADER_SIZE_HDR(h)   (                                           \
+    H5EA_HEADER_SIZE((h)->sizeof_addr, (h)->sizeof_size)                      \
+    )
+
+/* Size of the extensible array index block on disk */
+#define H5EA_IBLOCK_SIZE(i)     (                                             \
+    /* General metadata fields */                                             \
+    H5EA_METADATA_PREFIX_SIZE(TRUE)                                           \
+                                                                              \
+    /* Sanity-checking fields */                                              \
+    + (i)->hdr->sizeof_addr          /* File address of array owning the block */ \
+                                                                              \
+    /* Extensible Array Index Block specific fields */                        \
+    + ((size_t)(i)->hdr->cparam.idx_blk_elmts * (size_t)(i)->hdr->cparam.raw_elmt_size) /* Elements in index block  */ \
+    + ((i)->ndblk_addrs * (i)->hdr->sizeof_addr) /* Data block addresses in index block  */ \
+    + ((i)->nsblk_addrs * (i)->hdr->sizeof_addr) /* Super block addresses in index block  */ \
+    )
+
+/* Size of the extensible array super block on disk */
+#define H5EA_SBLOCK_SIZE(s)     (                                             \
+    /* General metadata fields */                                             \
+    H5EA_METADATA_PREFIX_SIZE(TRUE)                                           \
+                                                                              \
+    /* Sanity-checking fields */                                              \
+    + (s)->hdr->sizeof_addr          /* File address of array owning the block */ \
+    + (s)->hdr->arr_off_size         /* Offset of the block in the array */   \
+                                                                              \
+    /* Extensible Array Super Block specific fields */                        \
+    + ((s)->ndblks * (s)->dblk_page_init_size) /* Data block 'page init' bitmasks in super block (can be 0 if no pages) */ \
+    + ((s)->ndblks * (s)->hdr->sizeof_addr) /* Data block addresses in super block  */ \
+    )
+
+/* Size of the extensible array data block prefix on disk */
+#define H5EA_DBLOCK_PREFIX_SIZE(d)  (                                         \
+    /* General metadata fields */                                             \
+    H5EA_METADATA_PREFIX_SIZE(TRUE)                                           \
+                                                                              \
+    /* Sanity-checking fields */                                              \
+    + (d)->hdr->sizeof_addr          /* File address of array owning the block */ \
+    + (d)->hdr->arr_off_size         /* Offset of the block in the array */   \
+    )
+
+/* Size of the extensible array data block on disk */
+#define H5EA_DBLOCK_SIZE(d)     (                                             \
+    /* Data block prefix size  */                                             \
+    H5EA_DBLOCK_PREFIX_SIZE(d)                                                \
+                                                                              \
+    /* Extensible Array Data Block specific fields */                         \
+    + ((d)->nelmts * (size_t)(d)->hdr->cparam.raw_elmt_size) /* Elements in data block  */  \
+    + ((d)->npages * H5EA_SIZEOF_CHKSUM)        /* Checksum for each page */  \
+    )
+
+/* Size of the extensible array data block page on disk */
+#define H5EA_DBLK_PAGE_SIZE(h)     (					      \
+    + ((h)->dblk_page_nelmts * (size_t)(h)->cparam.raw_elmt_size) /* Elements in data block page */  \
+    + H5EA_SIZEOF_CHKSUM                        /* Checksum for each page */  \
+    )
+
+/* Compute the # of bytes required to store an offset into a given buffer size */
+#define H5EA_SIZEOF_OFFSET_BITS(b)      (((b) + 7) / 8)
+
+/* Compute the first super block index that will hold a certain # of data block pointers */
+#define H5EA_SBLK_FIRST_IDX(m)          (2 * H5VM_log2_of2((uint32_t)m))
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/* Information for each super block in extensible array */
+typedef struct H5EA_sblk_info_t {
+    size_t ndblks;              /* Number of data blocks for a super block */
+    size_t dblk_nelmts;         /* Number of elements in each data block for super block */
+    hsize_t start_idx;          /* Index of first element in super block */
+    hsize_t start_dblk;         /* Index of first data block in super block */
+} H5EA_sblk_info_t;
+
+/* The extensible array header information */
+/* (Each extensible array header has certain information that is shared across
+ * all the blocks in that extensible array)
+ */
+typedef struct H5EA_hdr_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* Extensible array configuration/creation parameters (stored in header) */
+    H5EA_create_t cparam;               /* Creation parameters for extensible array */
+
+    /* Index block information (stored in header) */
+    haddr_t idx_blk_addr;               /* Address of index block in header */
+
+    /* Statistics for array (stored in index block, actually) */
+    /* (header and index number/size fields not stored) */
+    H5EA_stat_t stats;                  /* Statistics for extensible array */
+
+    /* Data block element buffer factory info (not stored in header) */
+    struct {
+        size_t nalloc;                  /* Number of factories allocated */
+        H5FL_fac_head_t **fac;          /* Array of factories for data block element buffers */
+    } elmt_fac;
+
+    /* Computed/cached values (not stored in header) */
+    size_t rc;                          /* Reference count of heap's components using heap header */
+    haddr_t addr;                       /* Address of header in file */
+    size_t size;                        /* Size of header in file */
+    H5F_t *f;                           /* Pointer to file for extensible array */
+    size_t file_rc;                     /* Reference count of files using array header */
+    hbool_t pending_delete;             /* Array is pending deletion */
+    size_t sizeof_addr;                 /* Size of file addresses */
+    size_t sizeof_size;                 /* Size of file sizes */
+    unsigned char arr_off_size;         /* Size of array offsets (in bytes) */
+
+    /* Super block information (not stored) */
+    size_t nsblks;                      /* Number of superblocks needed for array */
+    H5EA_sblk_info_t *sblk_info;        /* Array of information for each super block */
+
+    /* Data block information (not stored) */
+    size_t dblk_page_nelmts;            /* # of elements per data block page */
+
+    /* Client information (not stored) */
+    void *cb_ctx;                       /* Callback context */
+
+    /* SWMR / Flush dependency information (not stored) */
+    hbool_t swmr_write;                 /* Flag indicating the file is opened with SWMR-write access */
+    H5AC_proxy_entry_t *top_proxy;      /* 'Top' proxy cache entry for all array entries */
+    void *parent;		        /* Pointer to 'top' proxy flush dependency
+                                         * parent, if it exists, otherwise NULL.
+                                         * If the extensible array is being used
+                                         * to index a chunked dataset and the
+                                         * dataset metadata is modified by a
+                                         * SWMR writer, this field will be set
+                                         * equal to the object header proxy
+                                         * that is the flush dependency parent
+                                         * of the extensible array header.
+ 					 *
+ 					 * The field is used to avoid duplicate
+					 * setups of the flush dependency 
+					 * relationship, and to allow the 
+					 * extensible array header to destroy
+					 * the flush dependency on receipt of 
+					 * an eviction notification from the
+					 * metadata cache.
+					 */
+} H5EA_hdr_t;
+
+/* The extensible array index block information */
+typedef struct H5EA_iblock_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* Extensible array information (stored) */
+    void        *elmts;         /* Buffer for elements stored in index block  */
+    haddr_t     *dblk_addrs;    /* Buffer for addresses of data blocks in index block */
+    haddr_t     *sblk_addrs;    /* Buffer for addresses of super blocks in index block */
+
+    /* Internal array information (not stored) */
+    H5EA_hdr_t	*hdr;	        /* Shared array header info                     */
+    haddr_t     addr;           /* Address of this index block on disk          */
+    size_t      size;           /* Size of index block on disk                  */
+
+    /* SWMR / Flush dependency information (not stored) */
+    H5AC_proxy_entry_t *top_proxy;      /* "Top" proxy cache entry for all array entries */
+
+    /* Computed/cached values (not stored) */
+    size_t      nsblks;         /* # of super blocks whose data block addresses are in index block */
+    size_t      ndblk_addrs;    /* Number of pointers to data blocks in index block */
+    size_t      nsblk_addrs;    /* Number of pointers to super blocks in index block */
+} H5EA_iblock_t;
+
+/* The extensible array super block information */
+typedef struct H5EA_sblock_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* Extensible array information (stored) */
+    hsize_t     block_off;      /* Offset of the block within the array's address space */
+    haddr_t     *dblk_addrs;    /* Addresses of data blocks in super block */
+    uint8_t     *page_init;     /* Bitmap of whether a data block page is initialized */
+
+    /* Internal array information (not stored) */
+    H5EA_hdr_t  *hdr;           /* Shared array header info                     */
+    haddr_t     addr;           /* Address of this index block on disk          */
+    size_t      size;           /* Size of index block on disk                  */
+
+    /* SWMR / Flush dependency information (not stored) */
+    hbool_t     has_hdr_depend; /* Whether this object has a flush dependency on the header */
+    H5AC_proxy_entry_t *top_proxy;      /* "Top" proxy cache entry for all array entries */
+    H5EA_iblock_t *parent;      /* Parent object for super block (index block)  */
+
+    /* Computed/cached values (not stored) */
+    unsigned    idx;            /* Super block index within the extensible array */
+    size_t      ndblks;         /* # of data block addresses that are in super block */
+    size_t      dblk_nelmts;    /* # of elements for data blocks reachable through this super block */
+    size_t      dblk_npages;    /* # of pages in each data block */
+    size_t      dblk_page_init_size;    /* Size of 'page init' bitmask for each data block */
+    size_t      dblk_page_size; /* Size of a data block page */
+} H5EA_sblock_t;
+
+/* The extensible array data block information */
+typedef struct H5EA_dblock_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* Extensible array information (stored) */
+    hsize_t     block_off;      /* Offset of the block within the array's address space */
+    void        *elmts;         /* Buffer for elements stored in data block  */
+
+    /* Internal array information (not stored) */
+    H5EA_hdr_t  *hdr;           /* Shared array header info                             */
+    haddr_t     addr;           /* Address of this data block on disk                   */
+    size_t      size;           /* Size of data block on disk                           */
+
+    /* SWMR / Flush dependency information (not stored) */
+    hbool_t     has_hdr_depend; /* Whether this object has a flush dependency on the header */
+    H5AC_proxy_entry_t *top_proxy;      /* 'Top' proxy cache entry for all array entries */
+    void        *parent;        /* Parent object for data block (index or super block)  */
+
+    /* Computed/cached values (not stored) */
+    size_t      nelmts;         /* Number of elements in block                */
+    size_t      npages;         /* Nummber of pages in a block (zero if not paged) */
+} H5EA_dblock_t;
+
+/* The extensible array data block page information */
+typedef struct H5EA_dbk_page_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* Extensible array information (stored) */
+    void        *elmts;         /* Buffer for elements stored in data block page */
+
+    /* Internal array information (not stored) */
+    H5EA_hdr_t  *hdr;           /* Shared array header info                         */
+    haddr_t     addr;           /* Address of this data block page on disk          */
+    size_t      size;           /* Size of data block page on disk                  */
+
+    /* SWMR / Flush dependency information (not stored) */
+    hbool_t     has_hdr_depend; /* Whether this object has a flush dependency on the header */
+    H5AC_proxy_entry_t *top_proxy;      /* "Top" proxy cache entry for all array entries */
+    H5EA_sblock_t *parent;      /* Parent object for data block page (super block)  */
+
+    /* Computed/cached values (not stored) */
+    /* <none> */
+} H5EA_dblk_page_t;
+
+/* Extensible array */
+struct H5EA_t {
+    H5EA_hdr_t  *hdr;           /* Pointer to internal extensible array header info */
+    H5F_t      *f;              /* Pointer to file for extensible array */
+};
+
+/* Metadata cache callback user data types */
+
+/* Info needed for loading header */
+typedef struct H5EA_hdr_cache_ud_t {
+    H5F_t      *f;              /* Pointer to file for extensible array */
+    haddr_t    addr;            /* Address of header on disk */
+    void       *ctx_udata;      /* User context for class */
+} H5EA_hdr_cache_ud_t;
+
+/* Info needed for loading super block */
+typedef struct H5EA_sblock_cache_ud_t {
+    H5EA_hdr_t    *hdr;         /* Shared extensible array information */
+    H5EA_iblock_t *parent;      /* Pointer to parent object for super block (index block) */
+    unsigned sblk_idx;          /* Index of super block */
+    haddr_t sblk_addr;          /* Address of super block */
+} H5EA_sblock_cache_ud_t;
+
+/* Info needed for loading data block */
+typedef struct H5EA_dblock_cache_ud_t {
+    H5EA_hdr_t    *hdr;         /* Shared extensible array information */
+    void *parent;               /* Pointer to parent object for data block (index or super block) */
+    size_t nelmts;              /* Number of elements in data block */
+    haddr_t dblk_addr;          /* Address of data block */
+} H5EA_dblock_cache_ud_t;
+
+/* Info needed for loading data block page */
+typedef struct H5EA_dblk_page_cache_ud_t {
+    H5EA_hdr_t    *hdr;         /* Shared extensible array information */
+    H5EA_sblock_t *parent;      /* Pointer to parent object for data block page (super block) */
+    haddr_t dblk_page_addr;     /* Address of data block page */
+} H5EA_dblk_page_cache_ud_t;
+
+#ifdef H5EA_TESTING
+typedef struct H5EA__ctx_cb_t {
+    herr_t (*encode)(const void *elmt, size_t nelmts, void *udata);   /* Perform action during encode step */
+    void *udata;                /* User data for encode action */
+} H5EA__ctx_cb_t;
+#endif /* H5EA_TESTING */
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+/* Internal extensible array testing class */
+H5_DLLVAR const H5EA_class_t H5EA_CLS_TEST[1];
+
+/* Array of extensible array client ID -> client class mappings */
+H5_DLLVAR const H5EA_class_t *const H5EA_client_class_g[H5EA_NUM_CLS_ID];
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+/* Generic routines */
+H5_DLL herr_t H5EA__create_flush_depend(H5AC_info_t *parent_entry,
+    H5AC_info_t *child_entry);
+H5_DLL herr_t H5EA__destroy_flush_depend(H5AC_info_t *parent_entry,
+    H5AC_info_t *child_entry);
+
+/* Header routines */
+H5_DLL H5EA_hdr_t *H5EA__hdr_alloc(H5F_t *f);
+H5_DLL herr_t H5EA__hdr_init(H5EA_hdr_t *hdr, void *ctx_udata);
+H5_DLL haddr_t H5EA__hdr_create(H5F_t *f, hid_t dxpl_id, const H5EA_create_t *cparam,
+    void *ctx_udata);
+H5_DLL void *H5EA__hdr_alloc_elmts(H5EA_hdr_t *hdr, size_t nelmts);
+H5_DLL herr_t H5EA__hdr_free_elmts(H5EA_hdr_t *hdr, size_t nelmts, void *elmts);
+H5_DLL herr_t H5EA__hdr_incr(H5EA_hdr_t *hdr);
+H5_DLL herr_t H5EA__hdr_decr(H5EA_hdr_t *hdr);
+H5_DLL herr_t H5EA__hdr_fuse_incr(H5EA_hdr_t *hdr);
+H5_DLL size_t H5EA__hdr_fuse_decr(H5EA_hdr_t *hdr);
+H5_DLL herr_t H5EA__hdr_modified(H5EA_hdr_t *hdr);
+H5_DLL H5EA_hdr_t *H5EA__hdr_protect(H5F_t *f, hid_t dxpl_id, haddr_t ea_addr,
+    void *ctx_udata, unsigned flags);
+H5_DLL herr_t H5EA__hdr_unprotect(H5EA_hdr_t *hdr, hid_t dxpl_id, unsigned cache_flags);
+H5_DLL herr_t H5EA__hdr_delete(H5EA_hdr_t *hdr, hid_t dxpl_id);
+H5_DLL herr_t H5EA__hdr_dest(H5EA_hdr_t *hdr);
+
+/* Index block routines */
+H5_DLL H5EA_iblock_t *H5EA__iblock_alloc(H5EA_hdr_t *hdr);
+H5_DLL haddr_t H5EA__iblock_create(H5EA_hdr_t *hdr, hid_t dxpl_id,
+    hbool_t *stats_changed);
+H5_DLL H5EA_iblock_t *H5EA__iblock_protect(H5EA_hdr_t *hdr, hid_t dxpl_id,
+    unsigned flags);
+H5_DLL herr_t H5EA__iblock_unprotect(H5EA_iblock_t *iblock, hid_t dxpl_id,
+    unsigned cache_flags);
+H5_DLL herr_t H5EA__iblock_delete(H5EA_hdr_t *hdr, hid_t dxpl_id);
+H5_DLL herr_t H5EA__iblock_dest(H5EA_iblock_t *iblock);
+
+/* Super block routines */
+H5_DLL H5EA_sblock_t *H5EA__sblock_alloc(H5EA_hdr_t *hdr, H5EA_iblock_t *parent,
+    unsigned sblk_idx);
+H5_DLL haddr_t H5EA__sblock_create(H5EA_hdr_t *hdr, hid_t dxpl_id,
+    H5EA_iblock_t *parent, hbool_t *stats_changed, unsigned sblk_idx);
+H5_DLL H5EA_sblock_t *H5EA__sblock_protect(H5EA_hdr_t *hdr, hid_t dxpl_id,
+    H5EA_iblock_t *parent, haddr_t sblk_addr, unsigned sblk_idx, 
+    unsigned flags);
+H5_DLL herr_t H5EA__sblock_unprotect(H5EA_sblock_t *sblock, hid_t dxpl_id,
+    unsigned cache_flags);
+H5_DLL herr_t H5EA__sblock_delete(H5EA_hdr_t *hdr, hid_t dxpl_id,
+    H5EA_iblock_t *parent, haddr_t sblk_addr, unsigned sblk_idx);
+H5_DLL herr_t H5EA__sblock_dest(H5EA_sblock_t *sblock);
+
+/* Data block routines */
+H5_DLL H5EA_dblock_t *H5EA__dblock_alloc(H5EA_hdr_t *hdr, void *parent,
+    size_t nelmts);
+H5_DLL haddr_t H5EA__dblock_create(H5EA_hdr_t *hdr, hid_t dxpl_id, void *parent,
+    hbool_t *stats_changed, hsize_t dblk_off, size_t nelmts);
+H5_DLL unsigned H5EA__dblock_sblk_idx(const H5EA_hdr_t *hdr, hsize_t idx);
+H5_DLL H5EA_dblock_t *H5EA__dblock_protect(H5EA_hdr_t *hdr, hid_t dxpl_id,
+    void *parent, haddr_t dblk_addr, size_t dblk_nelmts, unsigned flags);
+H5_DLL herr_t H5EA__dblock_unprotect(H5EA_dblock_t *dblock, hid_t dxpl_id,
+    unsigned cache_flags);
+H5_DLL herr_t H5EA__dblock_delete(H5EA_hdr_t *hdr, hid_t dxpl_id, void *parent,
+    haddr_t dblk_addr, size_t dblk_nelmts);
+H5_DLL herr_t H5EA__dblock_dest(H5EA_dblock_t *dblock);
+
+/* Data block page routines */
+H5_DLL H5EA_dblk_page_t *H5EA__dblk_page_alloc(H5EA_hdr_t *hdr, H5EA_sblock_t *parent);
+H5_DLL herr_t H5EA__dblk_page_create(H5EA_hdr_t *hdr, hid_t dxpl_id,
+    H5EA_sblock_t *parent, haddr_t addr);
+H5_DLL H5EA_dblk_page_t *H5EA__dblk_page_protect(H5EA_hdr_t *hdr, hid_t dxpl_id,
+    H5EA_sblock_t *parent, haddr_t dblk_page_addr, unsigned flags);
+H5_DLL herr_t H5EA__dblk_page_unprotect(H5EA_dblk_page_t *dblk_page,
+    hid_t dxpl_id, unsigned cache_flags);
+H5_DLL herr_t H5EA__dblk_page_dest(H5EA_dblk_page_t *dblk_page);
+
+/* Debugging routines for dumping file structures */
+H5_DLL herr_t H5EA__hdr_debug(H5F_t *f, hid_t dxpl_id, haddr_t addr,
+    FILE *stream, int indent, int fwidth, const H5EA_class_t *cls, haddr_t obj_addr);
+H5_DLL herr_t H5EA__iblock_debug(H5F_t *f, hid_t dxpl_id, haddr_t addr,
+    FILE *stream, int indent, int fwidth, const H5EA_class_t *cls,
+    haddr_t hdr_addr, haddr_t obj_addr);
+H5_DLL herr_t H5EA__sblock_debug(H5F_t *f, hid_t dxpl_id, haddr_t addr,
+    FILE *stream, int indent, int fwidth, const H5EA_class_t *cls,
+    haddr_t hdr_addr, unsigned sblk_idx, haddr_t obj_addr);
+H5_DLL herr_t H5EA__dblock_debug(H5F_t *f, hid_t dxpl_id, haddr_t addr,
+    FILE *stream, int indent, int fwidth, const H5EA_class_t *cls,
+    haddr_t hdr_addr, size_t dblk_nelmts, haddr_t obj_addr);
+
+/* Testing routines */
+#ifdef H5EA_TESTING
+H5_DLL herr_t H5EA_get_cparam_test(const H5EA_t *ea, H5EA_create_t *cparam);
+H5_DLL int H5EA_cmp_cparam_test(const H5EA_create_t *cparam1, const H5EA_create_t *cparam2);
+#endif /* H5EA_TESTING */
+
+#endif /* _H5EApkg_H */
+
diff --git a/install/include/H5Edefin.h b/install/include/H5Edefin.h
new file mode 100644
index 0000000000..28b4ef47dc
--- /dev/null
+++ b/install/include/H5Edefin.h
@@ -0,0 +1,230 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Generated automatically by bin/make_err -- do not edit */
+/* Add new errors to H5err.txt file */
+
+
+#ifndef _H5Edefin_H
+#define _H5Edefin_H
+
+/* Major error IDs */
+hid_t H5E_SOHM_g           = FAIL;      /* Shared Object Header Messages */
+hid_t H5E_OHDR_g           = FAIL;      /* Object header */
+hid_t H5E_PLINE_g          = FAIL;      /* Data filters */
+hid_t H5E_FUNC_g           = FAIL;      /* Function entry/exit */
+hid_t H5E_RS_g             = FAIL;      /* Reference Counted Strings */
+hid_t H5E_PLUGIN_g         = FAIL;      /* Plugin for dynamically loaded library */
+hid_t H5E_CACHE_g          = FAIL;      /* Object cache */
+hid_t H5E_PAGEBUF_g        = FAIL;      /* Page Buffering */
+hid_t H5E_LINK_g           = FAIL;      /* Links */
+hid_t H5E_INTERNAL_g       = FAIL;      /* Internal error (too specific to document in detail) */
+hid_t H5E_NONE_MAJOR_g     = FAIL;      /* No error */
+hid_t H5E_SLIST_g          = FAIL;      /* Skip Lists */
+hid_t H5E_DATATYPE_g       = FAIL;      /* Datatype */
+hid_t H5E_ATOM_g           = FAIL;      /* Object atom */
+hid_t H5E_PLIST_g          = FAIL;      /* Property lists */
+hid_t H5E_DATASET_g        = FAIL;      /* Dataset */
+hid_t H5E_ARGS_g           = FAIL;      /* Invalid arguments to routine */
+hid_t H5E_DATASPACE_g      = FAIL;      /* Dataspace */
+hid_t H5E_RESOURCE_g       = FAIL;      /* Resource unavailable */
+hid_t H5E_IO_g             = FAIL;      /* Low-level I/O */
+hid_t H5E_STORAGE_g        = FAIL;      /* Data storage */
+hid_t H5E_BTREE_g          = FAIL;      /* B-Tree node */
+hid_t H5E_TST_g            = FAIL;      /* Ternary Search Trees */
+hid_t H5E_REFERENCE_g      = FAIL;      /* References */
+hid_t H5E_ATTR_g           = FAIL;      /* Attribute */
+hid_t H5E_EARRAY_g         = FAIL;      /* Extensible Array */
+hid_t H5E_FSPACE_g         = FAIL;      /* Free Space Manager */
+hid_t H5E_FILE_g           = FAIL;      /* File accessibilty */
+hid_t H5E_EFL_g            = FAIL;      /* External file list */
+hid_t H5E_ERROR_g          = FAIL;      /* Error API */
+hid_t H5E_SYM_g            = FAIL;      /* Symbol table */
+hid_t H5E_FARRAY_g         = FAIL;      /* Fixed Array */
+hid_t H5E_HEAP_g           = FAIL;      /* Heap */
+hid_t H5E_VFL_g            = FAIL;      /* Virtual File Layer */
+
+/* Minor error IDs */
+
+/* Argument errors */
+hid_t H5E_UNINITIALIZED_g  = FAIL;      /* Information is uinitialized */
+hid_t H5E_UNSUPPORTED_g    = FAIL;      /* Feature is unsupported */
+hid_t H5E_BADTYPE_g        = FAIL;      /* Inappropriate type */
+hid_t H5E_BADRANGE_g       = FAIL;      /* Out of range */
+hid_t H5E_BADVALUE_g       = FAIL;      /* Bad value */
+
+/* Group related errors */
+hid_t H5E_CANTOPENOBJ_g    = FAIL;      /* Can't open object */
+hid_t H5E_CANTCLOSEOBJ_g   = FAIL;      /* Can't close object */
+hid_t H5E_COMPLEN_g        = FAIL;      /* Name component is too long */
+hid_t H5E_PATH_g           = FAIL;      /* Problem with path to object */
+
+/* Heap errors */
+hid_t H5E_CANTRESTORE_g    = FAIL;      /* Can't restore condition */
+hid_t H5E_CANTCOMPUTE_g    = FAIL;      /* Can't compute value */
+hid_t H5E_CANTEXTEND_g     = FAIL;      /* Can't extend heap's space */
+hid_t H5E_CANTATTACH_g     = FAIL;      /* Can't attach object */
+hid_t H5E_CANTUPDATE_g     = FAIL;      /* Can't update object */
+hid_t H5E_CANTOPERATE_g    = FAIL;      /* Can't operate on object */
+
+/* Link related errors */
+hid_t H5E_TRAVERSE_g       = FAIL;      /* Link traversal failure */
+hid_t H5E_NLINKS_g         = FAIL;      /* Too many soft links in path */
+hid_t H5E_NOTREGISTERED_g  = FAIL;      /* Link class not registered */
+hid_t H5E_CANTMOVE_g       = FAIL;      /* Can't move object */
+hid_t H5E_CANTSORT_g       = FAIL;      /* Can't sort objects */
+
+/* I/O pipeline errors */
+hid_t H5E_NOFILTER_g       = FAIL;      /* Requested filter is not available */
+hid_t H5E_CALLBACK_g       = FAIL;      /* Callback failed */
+hid_t H5E_CANAPPLY_g       = FAIL;      /* Error from filter 'can apply' callback */
+hid_t H5E_SETLOCAL_g       = FAIL;      /* Error from filter 'set local' callback */
+hid_t H5E_NOENCODER_g      = FAIL;      /* Filter present but encoding disabled */
+hid_t H5E_CANTFILTER_g     = FAIL;      /* Filter operation failed */
+
+/* No error */
+hid_t H5E_NONE_MINOR_g     = FAIL;      /* No error */
+
+/* Parallel MPI errors */
+hid_t H5E_MPI_g            = FAIL;      /* Some MPI function failed */
+hid_t H5E_MPIERRSTR_g      = FAIL;      /* MPI Error String */
+hid_t H5E_CANTRECV_g       = FAIL;      /* Can't receive data */
+
+/* Object header related errors */
+hid_t H5E_LINKCOUNT_g      = FAIL;      /* Bad object header link count */
+hid_t H5E_VERSION_g        = FAIL;      /* Wrong version number */
+hid_t H5E_ALIGNMENT_g      = FAIL;      /* Alignment error */
+hid_t H5E_BADMESG_g        = FAIL;      /* Unrecognized message */
+hid_t H5E_CANTDELETE_g     = FAIL;      /* Can't delete message */
+hid_t H5E_BADITER_g        = FAIL;      /* Iteration failed */
+hid_t H5E_CANTPACK_g       = FAIL;      /* Can't pack messages */
+hid_t H5E_CANTRESET_g      = FAIL;      /* Can't reset object */
+hid_t H5E_CANTRENAME_g     = FAIL;      /* Unable to rename object */
+
+/* Cache related errors */
+hid_t H5E_CANTFLUSH_g      = FAIL;      /* Unable to flush data from cache */
+hid_t H5E_CANTUNSERIALIZE_g = FAIL;      /* Unable to mark metadata as unserialized */
+hid_t H5E_CANTSERIALIZE_g  = FAIL;      /* Unable to serialize data from cache */
+hid_t H5E_CANTTAG_g        = FAIL;      /* Unable to tag metadata in the cache */
+hid_t H5E_CANTLOAD_g       = FAIL;      /* Unable to load metadata into cache */
+hid_t H5E_PROTECT_g        = FAIL;      /* Protected metadata error */
+hid_t H5E_NOTCACHED_g      = FAIL;      /* Metadata not currently cached */
+hid_t H5E_SYSTEM_g         = FAIL;      /* Internal error detected */
+hid_t H5E_CANTINS_g        = FAIL;      /* Unable to insert metadata into cache */
+hid_t H5E_CANTPROTECT_g    = FAIL;      /* Unable to protect metadata */
+hid_t H5E_CANTUNPROTECT_g  = FAIL;      /* Unable to unprotect metadata */
+hid_t H5E_CANTPIN_g        = FAIL;      /* Unable to pin cache entry */
+hid_t H5E_CANTUNPIN_g      = FAIL;      /* Unable to un-pin cache entry */
+hid_t H5E_CANTMARKDIRTY_g  = FAIL;      /* Unable to mark a pinned entry as dirty */
+hid_t H5E_CANTMARKCLEAN_g  = FAIL;      /* Unable to mark a pinned entry as clean */
+hid_t H5E_CANTMARKUNSERIALIZED_g = FAIL;      /* Unable to mark an entry as unserialized */
+hid_t H5E_CANTMARKSERIALIZED_g = FAIL;      /* Unable to mark an entry as serialized */
+hid_t H5E_CANTDIRTY_g      = FAIL;      /* Unable to mark metadata as dirty */
+hid_t H5E_CANTCLEAN_g      = FAIL;      /* Unable to mark metadata as clean */
+hid_t H5E_CANTEXPUNGE_g    = FAIL;      /* Unable to expunge a metadata cache entry */
+hid_t H5E_CANTRESIZE_g     = FAIL;      /* Unable to resize a metadata cache entry */
+hid_t H5E_CANTDEPEND_g     = FAIL;      /* Unable to create a flush dependency */
+hid_t H5E_CANTUNDEPEND_g   = FAIL;      /* Unable to destroy a flush dependency */
+hid_t H5E_CANTNOTIFY_g     = FAIL;      /* Unable to notify object about action */
+hid_t H5E_LOGFAIL_g        = FAIL;      /* Failure in the cache logging framework */
+hid_t H5E_CANTCORK_g       = FAIL;      /* Unable to cork an object */
+hid_t H5E_CANTUNCORK_g     = FAIL;      /* Unable to uncork an object */
+
+/* Dataspace errors */
+hid_t H5E_CANTCLIP_g       = FAIL;      /* Can't clip hyperslab region */
+hid_t H5E_CANTCOUNT_g      = FAIL;      /* Can't count elements */
+hid_t H5E_CANTSELECT_g     = FAIL;      /* Can't select hyperslab */
+hid_t H5E_CANTNEXT_g       = FAIL;      /* Can't move to next iterator location */
+hid_t H5E_BADSELECT_g      = FAIL;      /* Invalid selection */
+hid_t H5E_CANTCOMPARE_g    = FAIL;      /* Can't compare objects */
+hid_t H5E_CANTAPPEND_g     = FAIL;      /* Can't append object */
+
+/* Property list errors */
+hid_t H5E_CANTGET_g        = FAIL;      /* Can't get value */
+hid_t H5E_CANTSET_g        = FAIL;      /* Can't set value */
+hid_t H5E_DUPCLASS_g       = FAIL;      /* Duplicate class name in parent class */
+hid_t H5E_SETDISALLOWED_g  = FAIL;      /* Disallowed operation */
+
+/* System level errors */
+hid_t H5E_SYSERRSTR_g      = FAIL;      /* System error message */
+
+/* Free space errors */
+hid_t H5E_CANTMERGE_g      = FAIL;      /* Can't merge objects */
+hid_t H5E_CANTREVIVE_g     = FAIL;      /* Can't revive object */
+hid_t H5E_CANTSHRINK_g     = FAIL;      /* Can't shrink container */
+
+/* B-tree related errors */
+hid_t H5E_NOTFOUND_g       = FAIL;      /* Object not found */
+hid_t H5E_EXISTS_g         = FAIL;      /* Object already exists */
+hid_t H5E_CANTENCODE_g     = FAIL;      /* Unable to encode value */
+hid_t H5E_CANTDECODE_g     = FAIL;      /* Unable to decode value */
+hid_t H5E_CANTSPLIT_g      = FAIL;      /* Unable to split node */
+hid_t H5E_CANTREDISTRIBUTE_g = FAIL;      /* Unable to redistribute records */
+hid_t H5E_CANTSWAP_g       = FAIL;      /* Unable to swap records */
+hid_t H5E_CANTINSERT_g     = FAIL;      /* Unable to insert object */
+hid_t H5E_CANTLIST_g       = FAIL;      /* Unable to list node */
+hid_t H5E_CANTMODIFY_g     = FAIL;      /* Unable to modify record */
+hid_t H5E_CANTREMOVE_g     = FAIL;      /* Unable to remove object */
+
+/* Generic low-level file I/O errors */
+hid_t H5E_SEEKERROR_g      = FAIL;      /* Seek failed */
+hid_t H5E_READERROR_g      = FAIL;      /* Read failed */
+hid_t H5E_WRITEERROR_g     = FAIL;      /* Write failed */
+hid_t H5E_CLOSEERROR_g     = FAIL;      /* Close failed */
+hid_t H5E_OVERFLOW_g       = FAIL;      /* Address overflowed */
+hid_t H5E_FCNTL_g          = FAIL;      /* File control (fcntl) failed */
+
+/* Resource errors */
+hid_t H5E_NOSPACE_g        = FAIL;      /* No space available for allocation */
+hid_t H5E_CANTALLOC_g      = FAIL;      /* Can't allocate space */
+hid_t H5E_CANTCOPY_g       = FAIL;      /* Unable to copy object */
+hid_t H5E_CANTFREE_g       = FAIL;      /* Unable to free object */
+hid_t H5E_ALREADYEXISTS_g  = FAIL;      /* Object already exists */
+hid_t H5E_CANTLOCK_g       = FAIL;      /* Unable to lock object */
+hid_t H5E_CANTUNLOCK_g     = FAIL;      /* Unable to unlock object */
+hid_t H5E_CANTGC_g         = FAIL;      /* Unable to garbage collect */
+hid_t H5E_CANTGETSIZE_g    = FAIL;      /* Unable to compute size */
+hid_t H5E_OBJOPEN_g        = FAIL;      /* Object is already open */
+
+/* Object atom related errors */
+hid_t H5E_BADATOM_g        = FAIL;      /* Unable to find atom information (already closed?) */
+hid_t H5E_BADGROUP_g       = FAIL;      /* Unable to find ID group information */
+hid_t H5E_CANTREGISTER_g   = FAIL;      /* Unable to register new atom */
+hid_t H5E_CANTINC_g        = FAIL;      /* Unable to increment reference count */
+hid_t H5E_CANTDEC_g        = FAIL;      /* Unable to decrement reference count */
+hid_t H5E_NOIDS_g          = FAIL;      /* Out of IDs for group */
+
+/* Plugin errors */
+hid_t H5E_OPENERROR_g      = FAIL;      /* Can't open directory or file */
+
+/* Function entry/exit interface errors */
+hid_t H5E_CANTINIT_g       = FAIL;      /* Unable to initialize object */
+hid_t H5E_ALREADYINIT_g    = FAIL;      /* Object already initialized */
+hid_t H5E_CANTRELEASE_g    = FAIL;      /* Unable to release object */
+
+/* File accessibilty errors */
+hid_t H5E_FILEEXISTS_g     = FAIL;      /* File already exists */
+hid_t H5E_FILEOPEN_g       = FAIL;      /* File already open */
+hid_t H5E_CANTCREATE_g     = FAIL;      /* Unable to create file */
+hid_t H5E_CANTOPENFILE_g   = FAIL;      /* Unable to open file */
+hid_t H5E_CANTCLOSEFILE_g  = FAIL;      /* Unable to close file */
+hid_t H5E_NOTHDF5_g        = FAIL;      /* Not an HDF5 file */
+hid_t H5E_BADFILE_g        = FAIL;      /* Bad file ID accessed */
+hid_t H5E_TRUNCATED_g      = FAIL;      /* File has been truncated */
+hid_t H5E_MOUNT_g          = FAIL;      /* File mount error */
+
+/* Datatype conversion errors */
+hid_t H5E_CANTCONVERT_g    = FAIL;      /* Can't convert datatypes */
+hid_t H5E_BADSIZE_g        = FAIL;      /* Bad size for object */
+
+#endif /* H5Edefin_H */
diff --git a/install/include/H5Einit.h b/install/include/H5Einit.h
new file mode 100644
index 0000000000..b6346f3ea3
--- /dev/null
+++ b/install/include/H5Einit.h
@@ -0,0 +1,888 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Generated automatically by bin/make_err -- do not edit */
+/* Add new errors to H5err.txt file */
+
+
+#ifndef _H5Einit_H
+#define _H5Einit_H
+
+/*********************/
+/* Major error codes */
+/*********************/
+
+assert(H5E_SOHM_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Shared Object Header Messages"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_SOHM_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_OHDR_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Object header"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_OHDR_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_PLINE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Data filters"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_PLINE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_FUNC_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Function entry/exit"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_FUNC_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_RS_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Reference Counted Strings"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_RS_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_PLUGIN_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Plugin for dynamically loaded library"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_PLUGIN_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CACHE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Object cache"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CACHE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_PAGEBUF_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Page Buffering"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_PAGEBUF_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_LINK_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Links"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_LINK_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_INTERNAL_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Internal error (too specific to document in detail)"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_INTERNAL_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_NONE_MAJOR_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "No error"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_NONE_MAJOR_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_SLIST_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Skip Lists"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_SLIST_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_DATATYPE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Datatype"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_DATATYPE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_ATOM_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Object atom"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_ATOM_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_PLIST_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Property lists"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_PLIST_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_DATASET_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Dataset"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_DATASET_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_ARGS_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Invalid arguments to routine"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_ARGS_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_DATASPACE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Dataspace"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_DATASPACE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_RESOURCE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Resource unavailable"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_RESOURCE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_IO_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Low-level I/O"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_IO_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_STORAGE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Data storage"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_STORAGE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_BTREE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "B-Tree node"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_BTREE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_TST_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Ternary Search Trees"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_TST_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_REFERENCE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "References"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_REFERENCE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_ATTR_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Attribute"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_ATTR_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_EARRAY_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Extensible Array"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_EARRAY_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_FSPACE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Free Space Manager"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_FSPACE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_FILE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "File accessibilty"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_FILE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_EFL_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "External file list"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_EFL_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_ERROR_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Error API"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_ERROR_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_SYM_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Symbol table"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_SYM_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_FARRAY_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Fixed Array"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_FARRAY_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_HEAP_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Heap"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_HEAP_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_VFL_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MAJOR, "Virtual File Layer"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_VFL_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/*********************/
+/* Minor error codes */
+/*********************/
+
+
+/* Argument errors */
+assert(H5E_UNINITIALIZED_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Information is uinitialized"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_UNINITIALIZED_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_UNSUPPORTED_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Feature is unsupported"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_UNSUPPORTED_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_BADTYPE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Inappropriate type"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_BADTYPE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_BADRANGE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Out of range"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_BADRANGE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_BADVALUE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Bad value"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_BADVALUE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Group related errors */
+assert(H5E_CANTOPENOBJ_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't open object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTOPENOBJ_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTCLOSEOBJ_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't close object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTCLOSEOBJ_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_COMPLEN_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Name component is too long"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_COMPLEN_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_PATH_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Problem with path to object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_PATH_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Heap errors */
+assert(H5E_CANTRESTORE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't restore condition"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTRESTORE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTCOMPUTE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't compute value"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTCOMPUTE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTEXTEND_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't extend heap's space"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTEXTEND_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTATTACH_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't attach object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTATTACH_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTUPDATE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't update object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTUPDATE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTOPERATE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't operate on object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTOPERATE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Link related errors */
+assert(H5E_TRAVERSE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Link traversal failure"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_TRAVERSE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_NLINKS_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Too many soft links in path"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_NLINKS_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_NOTREGISTERED_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Link class not registered"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_NOTREGISTERED_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTMOVE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't move object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTMOVE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTSORT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't sort objects"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTSORT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* I/O pipeline errors */
+assert(H5E_NOFILTER_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Requested filter is not available"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_NOFILTER_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CALLBACK_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Callback failed"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CALLBACK_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANAPPLY_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Error from filter 'can apply' callback"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANAPPLY_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_SETLOCAL_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Error from filter 'set local' callback"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_SETLOCAL_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_NOENCODER_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Filter present but encoding disabled"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_NOENCODER_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTFILTER_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Filter operation failed"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTFILTER_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* No error */
+assert(H5E_NONE_MINOR_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "No error"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_NONE_MINOR_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Parallel MPI errors */
+assert(H5E_MPI_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Some MPI function failed"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_MPI_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_MPIERRSTR_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "MPI Error String"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_MPIERRSTR_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTRECV_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't receive data"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTRECV_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Object header related errors */
+assert(H5E_LINKCOUNT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Bad object header link count"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_LINKCOUNT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_VERSION_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Wrong version number"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_VERSION_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_ALIGNMENT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Alignment error"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_ALIGNMENT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_BADMESG_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unrecognized message"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_BADMESG_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTDELETE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't delete message"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTDELETE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_BADITER_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Iteration failed"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_BADITER_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTPACK_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't pack messages"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTPACK_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTRESET_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't reset object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTRESET_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTRENAME_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to rename object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTRENAME_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Cache related errors */
+assert(H5E_CANTFLUSH_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to flush data from cache"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTFLUSH_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTUNSERIALIZE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to mark metadata as unserialized"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTUNSERIALIZE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTSERIALIZE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to serialize data from cache"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTSERIALIZE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTTAG_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to tag metadata in the cache"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTTAG_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTLOAD_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to load metadata into cache"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTLOAD_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_PROTECT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Protected metadata error"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_PROTECT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_NOTCACHED_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Metadata not currently cached"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_NOTCACHED_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_SYSTEM_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Internal error detected"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_SYSTEM_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTINS_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to insert metadata into cache"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTINS_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTPROTECT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to protect metadata"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTPROTECT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTUNPROTECT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to unprotect metadata"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTUNPROTECT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTPIN_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to pin cache entry"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTPIN_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTUNPIN_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to un-pin cache entry"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTUNPIN_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTMARKDIRTY_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to mark a pinned entry as dirty"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTMARKDIRTY_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTMARKCLEAN_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to mark a pinned entry as clean"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTMARKCLEAN_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTMARKUNSERIALIZED_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to mark an entry as unserialized"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTMARKUNSERIALIZED_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTMARKSERIALIZED_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to mark an entry as serialized"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTMARKSERIALIZED_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTDIRTY_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to mark metadata as dirty"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTDIRTY_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTCLEAN_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to mark metadata as clean"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTCLEAN_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTEXPUNGE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to expunge a metadata cache entry"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTEXPUNGE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTRESIZE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to resize a metadata cache entry"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTRESIZE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTDEPEND_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to create a flush dependency"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTDEPEND_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTUNDEPEND_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to destroy a flush dependency"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTUNDEPEND_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTNOTIFY_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to notify object about action"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTNOTIFY_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_LOGFAIL_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Failure in the cache logging framework"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_LOGFAIL_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTCORK_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to cork an object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTCORK_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTUNCORK_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to uncork an object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTUNCORK_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Dataspace errors */
+assert(H5E_CANTCLIP_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't clip hyperslab region"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTCLIP_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTCOUNT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't count elements"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTCOUNT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTSELECT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't select hyperslab"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTSELECT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTNEXT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't move to next iterator location"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTNEXT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_BADSELECT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Invalid selection"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_BADSELECT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTCOMPARE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't compare objects"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTCOMPARE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTAPPEND_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't append object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTAPPEND_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Property list errors */
+assert(H5E_CANTGET_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't get value"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTGET_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTSET_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't set value"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTSET_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_DUPCLASS_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Duplicate class name in parent class"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_DUPCLASS_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_SETDISALLOWED_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Disallowed operation"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_SETDISALLOWED_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* System level errors */
+assert(H5E_SYSERRSTR_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "System error message"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_SYSERRSTR_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Free space errors */
+assert(H5E_CANTMERGE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't merge objects"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTMERGE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTREVIVE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't revive object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTREVIVE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTSHRINK_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't shrink container"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTSHRINK_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* B-tree related errors */
+assert(H5E_NOTFOUND_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Object not found"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_NOTFOUND_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_EXISTS_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Object already exists"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_EXISTS_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTENCODE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to encode value"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTENCODE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTDECODE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to decode value"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTDECODE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTSPLIT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to split node"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTSPLIT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTREDISTRIBUTE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to redistribute records"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTREDISTRIBUTE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTSWAP_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to swap records"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTSWAP_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTINSERT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to insert object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTINSERT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTLIST_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to list node"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTLIST_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTMODIFY_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to modify record"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTMODIFY_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTREMOVE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to remove object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTREMOVE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Generic low-level file I/O errors */
+assert(H5E_SEEKERROR_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Seek failed"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_SEEKERROR_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_READERROR_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Read failed"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_READERROR_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_WRITEERROR_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Write failed"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_WRITEERROR_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CLOSEERROR_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Close failed"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CLOSEERROR_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_OVERFLOW_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Address overflowed"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_OVERFLOW_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_FCNTL_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "File control (fcntl) failed"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_FCNTL_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Resource errors */
+assert(H5E_NOSPACE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "No space available for allocation"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_NOSPACE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTALLOC_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't allocate space"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTALLOC_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTCOPY_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to copy object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTCOPY_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTFREE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to free object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTFREE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_ALREADYEXISTS_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Object already exists"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_ALREADYEXISTS_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTLOCK_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to lock object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTLOCK_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTUNLOCK_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to unlock object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTUNLOCK_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTGC_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to garbage collect"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTGC_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTGETSIZE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to compute size"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTGETSIZE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_OBJOPEN_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Object is already open"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_OBJOPEN_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Object atom related errors */
+assert(H5E_BADATOM_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to find atom information (already closed?)"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_BADATOM_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_BADGROUP_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to find ID group information"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_BADGROUP_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTREGISTER_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to register new atom"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTREGISTER_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTINC_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to increment reference count"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTINC_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTDEC_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to decrement reference count"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTDEC_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_NOIDS_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Out of IDs for group"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_NOIDS_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Plugin errors */
+assert(H5E_OPENERROR_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't open directory or file"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_OPENERROR_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Function entry/exit interface errors */
+assert(H5E_CANTINIT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to initialize object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTINIT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_ALREADYINIT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Object already initialized"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_ALREADYINIT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTRELEASE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to release object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTRELEASE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* File accessibilty errors */
+assert(H5E_FILEEXISTS_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "File already exists"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_FILEEXISTS_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_FILEOPEN_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "File already open"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_FILEOPEN_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTCREATE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to create file"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTCREATE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTOPENFILE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to open file"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTOPENFILE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_CANTCLOSEFILE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Unable to close file"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTCLOSEFILE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_NOTHDF5_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Not an HDF5 file"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_NOTHDF5_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_BADFILE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Bad file ID accessed"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_BADFILE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_TRUNCATED_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "File has been truncated"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_TRUNCATED_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_MOUNT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "File mount error"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_MOUNT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+/* Datatype conversion errors */
+assert(H5E_CANTCONVERT_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Can't convert datatypes"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_CANTCONVERT_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+assert(H5E_BADSIZE_g==(-1));
+if((msg = H5E_create_msg(cls, H5E_MINOR, "Bad size for object"))==NULL)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTINIT, FAIL, "error message initialization failed")
+if((H5E_BADSIZE_g = H5I_register(H5I_ERROR_MSG, msg, FALSE))<0)
+    HGOTO_ERROR(H5E_ERROR, H5E_CANTREGISTER, FAIL, "can't register error message")
+
+#endif /* H5Einit_H */
diff --git a/install/include/H5EnumType.h b/install/include/H5EnumType.h
new file mode 100644
index 0000000000..fc8089e995
--- /dev/null
+++ b/install/include/H5EnumType.h
@@ -0,0 +1,83 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5EnumType_H
+#define __H5EnumType_H
+
+namespace H5 {
+
+/*! \class EnumType
+    \brief EnumType is a derivative of a DataType and operates on HDF5
+    enum datatypes.
+
+    Inheritance: DataType -> H5Object -> H5Location -> IdComponent
+*/
+class H5_DLLCPP EnumType : public DataType {
+
+   public:
+        // Creates an empty enumeration datatype based on a native signed
+        // integer type, whose size is given by size.
+        EnumType(size_t size);
+
+        // Gets the enum datatype of the specified dataset
+        EnumType(const DataSet& dataset);  // H5Dget_type
+
+        // Creates a new enum datatype based on an integer datatype
+        EnumType(const IntType& data_type);  // H5Tenum_create
+
+        // Constructors that open an enum datatype, given a location.
+        EnumType(const H5Location& loc, const char* name);
+        EnumType(const H5Location& loc, const H5std_string& name);
+
+        // Returns the number of members in this enumeration datatype.
+        int getNmembers () const;
+
+        // Returns the index of a member in this enumeration data type.
+        int getMemberIndex(const char* name) const;
+        int getMemberIndex(const H5std_string& name) const;
+
+        // Returns the value of an enumeration datatype member
+        void getMemberValue(unsigned memb_no, void *value) const;
+
+        // Inserts a new member to this enumeration type.
+        void insert(const char* name, void *value) const;
+        void insert(const H5std_string& name, void *value) const;
+
+        // Returns the symbol name corresponding to a specified member
+        // of this enumeration datatype.
+        H5std_string nameOf(void *value, size_t size) const;
+
+        // Returns the value corresponding to a specified member of this
+        // enumeration datatype.
+        void valueOf(const char* name, void *value) const;
+        void valueOf(const H5std_string& name, void *value) const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("EnumType"); }
+
+        // Default constructor
+        EnumType();
+
+        // Creates an enumeration datatype using an existing id
+        EnumType(const hid_t existing_id);
+
+        // Copy constructor: makes a copy of the original EnumType object.
+        EnumType(const EnumType& original);
+
+        virtual ~EnumType();
+
+}; // end of EnumType
+} // namespace H5
+
+#endif // __H5EnumType_H
diff --git a/install/include/H5Epkg.h b/install/include/H5Epkg.h
new file mode 100644
index 0000000000..90f4f80f5d
--- /dev/null
+++ b/install/include/H5Epkg.h
@@ -0,0 +1,149 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:	Quincey Koziol <koziol@hdfgroup.org>
+ *		Wednesday, April 11, 2007
+ *
+ * Purpose:	This file contains declarations which are visible only within
+ *		the H5E package.  Source files outside the H5E package should
+ *		include H5Eprivate.h instead.
+ */
+#if !(defined H5E_FRIEND || defined H5E_MODULE)
+#error "Do not include this file outside the H5E package!"
+#endif
+
+#ifndef _H5Epkg_H
+#define _H5Epkg_H
+
+/* Get package's private header */
+#include "H5Eprivate.h"
+
+/* Other private headers needed by this file */
+
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* Amount to indent each error */
+#define H5E_INDENT              2
+
+/* Number of slots in an error stack */
+#define H5E_NSLOTS	        32
+
+#ifdef H5_HAVE_THREADSAFE
+/*
+ * The per-thread error stack. pthread_once() initializes a special
+ * key that will be used by all threads to create a stack specific to
+ * each thread individually. The association of stacks to threads will
+ * be handled by the pthread library.
+ *
+ * In order for this macro to work, H5E_get_my_stack() must be preceeded
+ * by "H5E_t *estack =".
+ */
+#define H5E_get_my_stack()  H5E_get_stack()
+#else /* H5_HAVE_THREADSAFE */
+/*
+ * The current error stack.
+ */
+#define H5E_get_my_stack() (H5E_stack_g + 0)
+#endif /* H5_HAVE_THREADSAFE */
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/* Some syntactic sugar to make the compiler happy with two different kinds of callbacks */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+typedef struct {
+    unsigned    vers;       /* Which version callback to use */
+    hbool_t     is_default; /* If the printing function is the library's own. */
+    H5E_auto1_t func1;      /* Old-style callback, NO error stack param. */
+    H5E_auto2_t func2;      /* New-style callback, with error stack param. */
+    H5E_auto1_t func1_default;      /* The saved library's default function - old style. */
+    H5E_auto2_t func2_default;      /* The saved library's default function - new style. */
+} H5E_auto_op_t;
+#else /* H5_NO_DEPRECATED_SYMBOLS */
+typedef struct {
+    H5E_auto_t  func2;      /* Only the new style callback function is available. */
+} H5E_auto_op_t;
+#endif /* H5_NO_DEPRECATED_SYMBOLS */ 
+
+/* Some syntactic sugar to make the compiler happy with two different kinds of callbacks */
+typedef struct {
+    unsigned vers;              /* Which version callback to use */
+    union {
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+        H5E_walk1_t func1;      /* Old-style callback, NO error stack param. */
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+        H5E_walk2_t func2;      /* New-style callback, with error stack param. */
+    }u;
+} H5E_walk_op_t;
+
+/* Error class */
+typedef struct H5E_cls_t {
+    char *cls_name;             /* Name of error class */
+    char *lib_name;             /* Name of library within class */
+    char *lib_vers;             /* Version of library */
+} H5E_cls_t;
+
+/* Major or minor message */
+typedef struct H5E_msg_t {
+    char        *msg;           /* Message for error */
+    H5E_type_t   type;          /* Type of error (major or minor) */
+    H5E_cls_t   *cls;           /* Which error class this message belongs to */
+} H5E_msg_t;
+
+/* Error stack */
+struct H5E_t {
+    size_t nused;		        /* Num slots currently used in stack  */
+    H5E_error2_t slot[H5E_NSLOTS];	/* Array of error records	     */
+    H5E_auto_op_t auto_op;              /* Operator for 'automatic' error reporting */
+    void *auto_data;                    /* Callback data for 'automatic error reporting */
+};
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+#ifndef H5_HAVE_THREADSAFE
+/*
+ * The current error stack.
+ */
+H5_DLLVAR H5E_t	H5E_stack_g[1];
+#endif /* H5_HAVE_THREADSAFE */
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+H5_DLL herr_t H5E__term_deprec_interface(void);
+#ifdef H5_HAVE_THREADSAFE
+H5_DLL H5E_t *H5E_get_stack(void);
+#endif /* H5_HAVE_THREADSAFE */
+H5_DLL ssize_t H5E_get_msg(const H5E_msg_t *msg_ptr, H5E_type_t *type,
+    char *msg, size_t size);
+H5_DLL herr_t H5E_print(const H5E_t *estack, FILE *stream, hbool_t bk_compat);
+H5_DLL herr_t H5E_walk(const H5E_t *estack, H5E_direction_t direction,
+    const H5E_walk_op_t *op, void *client_data);
+H5_DLL herr_t H5E_get_auto(const H5E_t *estack, H5E_auto_op_t *op,
+    void **client_data);
+H5_DLL herr_t H5E_set_auto(H5E_t *estack, const H5E_auto_op_t *op,
+    void *client_data);
+H5_DLL herr_t H5E_pop(H5E_t *err_stack, size_t count);
+
+#endif /* _H5Epkg_H */
+
diff --git a/install/include/H5Epubgen.h b/install/include/H5Epubgen.h
new file mode 100644
index 0000000000..38653e00eb
--- /dev/null
+++ b/install/include/H5Epubgen.h
@@ -0,0 +1,406 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Generated automatically by bin/make_err -- do not edit */
+/* Add new errors to H5err.txt file */
+
+
+#ifndef _H5Epubgen_H
+#define _H5Epubgen_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************/
+/* Major error codes */
+/*********************/
+
+#define H5E_SOHM             (H5OPEN H5E_SOHM_g)
+#define H5E_OHDR             (H5OPEN H5E_OHDR_g)
+#define H5E_PLINE            (H5OPEN H5E_PLINE_g)
+#define H5E_FUNC             (H5OPEN H5E_FUNC_g)
+#define H5E_RS               (H5OPEN H5E_RS_g)
+#define H5E_PLUGIN           (H5OPEN H5E_PLUGIN_g)
+#define H5E_CACHE            (H5OPEN H5E_CACHE_g)
+#define H5E_PAGEBUF          (H5OPEN H5E_PAGEBUF_g)
+#define H5E_LINK             (H5OPEN H5E_LINK_g)
+#define H5E_INTERNAL         (H5OPEN H5E_INTERNAL_g)
+#define H5E_NONE_MAJOR       (H5OPEN H5E_NONE_MAJOR_g)
+#define H5E_SLIST            (H5OPEN H5E_SLIST_g)
+#define H5E_DATATYPE         (H5OPEN H5E_DATATYPE_g)
+#define H5E_ATOM             (H5OPEN H5E_ATOM_g)
+#define H5E_PLIST            (H5OPEN H5E_PLIST_g)
+#define H5E_DATASET          (H5OPEN H5E_DATASET_g)
+#define H5E_ARGS             (H5OPEN H5E_ARGS_g)
+#define H5E_DATASPACE        (H5OPEN H5E_DATASPACE_g)
+#define H5E_RESOURCE         (H5OPEN H5E_RESOURCE_g)
+#define H5E_IO               (H5OPEN H5E_IO_g)
+#define H5E_STORAGE          (H5OPEN H5E_STORAGE_g)
+#define H5E_BTREE            (H5OPEN H5E_BTREE_g)
+#define H5E_TST              (H5OPEN H5E_TST_g)
+#define H5E_REFERENCE        (H5OPEN H5E_REFERENCE_g)
+#define H5E_ATTR             (H5OPEN H5E_ATTR_g)
+#define H5E_EARRAY           (H5OPEN H5E_EARRAY_g)
+#define H5E_FSPACE           (H5OPEN H5E_FSPACE_g)
+#define H5E_FILE             (H5OPEN H5E_FILE_g)
+#define H5E_EFL              (H5OPEN H5E_EFL_g)
+#define H5E_ERROR            (H5OPEN H5E_ERROR_g)
+#define H5E_SYM              (H5OPEN H5E_SYM_g)
+#define H5E_FARRAY           (H5OPEN H5E_FARRAY_g)
+#define H5E_HEAP             (H5OPEN H5E_HEAP_g)
+#define H5E_VFL              (H5OPEN H5E_VFL_g)
+H5_DLLVAR hid_t H5E_SOHM_g;          /* Shared Object Header Messages */
+H5_DLLVAR hid_t H5E_OHDR_g;          /* Object header */
+H5_DLLVAR hid_t H5E_PLINE_g;         /* Data filters */
+H5_DLLVAR hid_t H5E_FUNC_g;          /* Function entry/exit */
+H5_DLLVAR hid_t H5E_RS_g;            /* Reference Counted Strings */
+H5_DLLVAR hid_t H5E_PLUGIN_g;        /* Plugin for dynamically loaded library */
+H5_DLLVAR hid_t H5E_CACHE_g;         /* Object cache */
+H5_DLLVAR hid_t H5E_PAGEBUF_g;       /* Page Buffering */
+H5_DLLVAR hid_t H5E_LINK_g;          /* Links */
+H5_DLLVAR hid_t H5E_INTERNAL_g;      /* Internal error (too specific to document in detail) */
+H5_DLLVAR hid_t H5E_NONE_MAJOR_g;    /* No error */
+H5_DLLVAR hid_t H5E_SLIST_g;         /* Skip Lists */
+H5_DLLVAR hid_t H5E_DATATYPE_g;      /* Datatype */
+H5_DLLVAR hid_t H5E_ATOM_g;          /* Object atom */
+H5_DLLVAR hid_t H5E_PLIST_g;         /* Property lists */
+H5_DLLVAR hid_t H5E_DATASET_g;       /* Dataset */
+H5_DLLVAR hid_t H5E_ARGS_g;          /* Invalid arguments to routine */
+H5_DLLVAR hid_t H5E_DATASPACE_g;     /* Dataspace */
+H5_DLLVAR hid_t H5E_RESOURCE_g;      /* Resource unavailable */
+H5_DLLVAR hid_t H5E_IO_g;            /* Low-level I/O */
+H5_DLLVAR hid_t H5E_STORAGE_g;       /* Data storage */
+H5_DLLVAR hid_t H5E_BTREE_g;         /* B-Tree node */
+H5_DLLVAR hid_t H5E_TST_g;           /* Ternary Search Trees */
+H5_DLLVAR hid_t H5E_REFERENCE_g;     /* References */
+H5_DLLVAR hid_t H5E_ATTR_g;          /* Attribute */
+H5_DLLVAR hid_t H5E_EARRAY_g;        /* Extensible Array */
+H5_DLLVAR hid_t H5E_FSPACE_g;        /* Free Space Manager */
+H5_DLLVAR hid_t H5E_FILE_g;          /* File accessibilty */
+H5_DLLVAR hid_t H5E_EFL_g;           /* External file list */
+H5_DLLVAR hid_t H5E_ERROR_g;         /* Error API */
+H5_DLLVAR hid_t H5E_SYM_g;           /* Symbol table */
+H5_DLLVAR hid_t H5E_FARRAY_g;        /* Fixed Array */
+H5_DLLVAR hid_t H5E_HEAP_g;          /* Heap */
+H5_DLLVAR hid_t H5E_VFL_g;           /* Virtual File Layer */
+
+/*********************/
+/* Minor error codes */
+/*********************/
+
+/* Argument errors */
+#define H5E_UNINITIALIZED    (H5OPEN H5E_UNINITIALIZED_g)
+#define H5E_UNSUPPORTED      (H5OPEN H5E_UNSUPPORTED_g)
+#define H5E_BADTYPE          (H5OPEN H5E_BADTYPE_g)
+#define H5E_BADRANGE         (H5OPEN H5E_BADRANGE_g)
+#define H5E_BADVALUE         (H5OPEN H5E_BADVALUE_g)
+H5_DLLVAR hid_t H5E_UNINITIALIZED_g; /* Information is uinitialized */
+H5_DLLVAR hid_t H5E_UNSUPPORTED_g;   /* Feature is unsupported */
+H5_DLLVAR hid_t H5E_BADTYPE_g;       /* Inappropriate type */
+H5_DLLVAR hid_t H5E_BADRANGE_g;      /* Out of range */
+H5_DLLVAR hid_t H5E_BADVALUE_g;      /* Bad value */
+
+/* Group related errors */
+#define H5E_CANTOPENOBJ      (H5OPEN H5E_CANTOPENOBJ_g)
+#define H5E_CANTCLOSEOBJ     (H5OPEN H5E_CANTCLOSEOBJ_g)
+#define H5E_COMPLEN          (H5OPEN H5E_COMPLEN_g)
+#define H5E_PATH             (H5OPEN H5E_PATH_g)
+H5_DLLVAR hid_t H5E_CANTOPENOBJ_g;   /* Can't open object */
+H5_DLLVAR hid_t H5E_CANTCLOSEOBJ_g;  /* Can't close object */
+H5_DLLVAR hid_t H5E_COMPLEN_g;       /* Name component is too long */
+H5_DLLVAR hid_t H5E_PATH_g;          /* Problem with path to object */
+
+/* Heap errors */
+#define H5E_CANTRESTORE      (H5OPEN H5E_CANTRESTORE_g)
+#define H5E_CANTCOMPUTE      (H5OPEN H5E_CANTCOMPUTE_g)
+#define H5E_CANTEXTEND       (H5OPEN H5E_CANTEXTEND_g)
+#define H5E_CANTATTACH       (H5OPEN H5E_CANTATTACH_g)
+#define H5E_CANTUPDATE       (H5OPEN H5E_CANTUPDATE_g)
+#define H5E_CANTOPERATE      (H5OPEN H5E_CANTOPERATE_g)
+H5_DLLVAR hid_t H5E_CANTRESTORE_g;   /* Can't restore condition */
+H5_DLLVAR hid_t H5E_CANTCOMPUTE_g;   /* Can't compute value */
+H5_DLLVAR hid_t H5E_CANTEXTEND_g;    /* Can't extend heap's space */
+H5_DLLVAR hid_t H5E_CANTATTACH_g;    /* Can't attach object */
+H5_DLLVAR hid_t H5E_CANTUPDATE_g;    /* Can't update object */
+H5_DLLVAR hid_t H5E_CANTOPERATE_g;   /* Can't operate on object */
+
+/* Link related errors */
+#define H5E_TRAVERSE         (H5OPEN H5E_TRAVERSE_g)
+#define H5E_NLINKS           (H5OPEN H5E_NLINKS_g)
+#define H5E_NOTREGISTERED    (H5OPEN H5E_NOTREGISTERED_g)
+#define H5E_CANTMOVE         (H5OPEN H5E_CANTMOVE_g)
+#define H5E_CANTSORT         (H5OPEN H5E_CANTSORT_g)
+H5_DLLVAR hid_t H5E_TRAVERSE_g;      /* Link traversal failure */
+H5_DLLVAR hid_t H5E_NLINKS_g;        /* Too many soft links in path */
+H5_DLLVAR hid_t H5E_NOTREGISTERED_g; /* Link class not registered */
+H5_DLLVAR hid_t H5E_CANTMOVE_g;      /* Can't move object */
+H5_DLLVAR hid_t H5E_CANTSORT_g;      /* Can't sort objects */
+
+/* I/O pipeline errors */
+#define H5E_NOFILTER         (H5OPEN H5E_NOFILTER_g)
+#define H5E_CALLBACK         (H5OPEN H5E_CALLBACK_g)
+#define H5E_CANAPPLY         (H5OPEN H5E_CANAPPLY_g)
+#define H5E_SETLOCAL         (H5OPEN H5E_SETLOCAL_g)
+#define H5E_NOENCODER        (H5OPEN H5E_NOENCODER_g)
+#define H5E_CANTFILTER       (H5OPEN H5E_CANTFILTER_g)
+H5_DLLVAR hid_t H5E_NOFILTER_g;      /* Requested filter is not available */
+H5_DLLVAR hid_t H5E_CALLBACK_g;      /* Callback failed */
+H5_DLLVAR hid_t H5E_CANAPPLY_g;      /* Error from filter 'can apply' callback */
+H5_DLLVAR hid_t H5E_SETLOCAL_g;      /* Error from filter 'set local' callback */
+H5_DLLVAR hid_t H5E_NOENCODER_g;     /* Filter present but encoding disabled */
+H5_DLLVAR hid_t H5E_CANTFILTER_g;    /* Filter operation failed */
+
+/* No error */
+#define H5E_NONE_MINOR       (H5OPEN H5E_NONE_MINOR_g)
+H5_DLLVAR hid_t H5E_NONE_MINOR_g;    /* No error */
+
+/* Parallel MPI errors */
+#define H5E_MPI              (H5OPEN H5E_MPI_g)
+#define H5E_MPIERRSTR        (H5OPEN H5E_MPIERRSTR_g)
+#define H5E_CANTRECV         (H5OPEN H5E_CANTRECV_g)
+H5_DLLVAR hid_t H5E_MPI_g;           /* Some MPI function failed */
+H5_DLLVAR hid_t H5E_MPIERRSTR_g;     /* MPI Error String */
+H5_DLLVAR hid_t H5E_CANTRECV_g;      /* Can't receive data */
+
+/* Object header related errors */
+#define H5E_LINKCOUNT        (H5OPEN H5E_LINKCOUNT_g)
+#define H5E_VERSION          (H5OPEN H5E_VERSION_g)
+#define H5E_ALIGNMENT        (H5OPEN H5E_ALIGNMENT_g)
+#define H5E_BADMESG          (H5OPEN H5E_BADMESG_g)
+#define H5E_CANTDELETE       (H5OPEN H5E_CANTDELETE_g)
+#define H5E_BADITER          (H5OPEN H5E_BADITER_g)
+#define H5E_CANTPACK         (H5OPEN H5E_CANTPACK_g)
+#define H5E_CANTRESET        (H5OPEN H5E_CANTRESET_g)
+#define H5E_CANTRENAME       (H5OPEN H5E_CANTRENAME_g)
+H5_DLLVAR hid_t H5E_LINKCOUNT_g;     /* Bad object header link count */
+H5_DLLVAR hid_t H5E_VERSION_g;       /* Wrong version number */
+H5_DLLVAR hid_t H5E_ALIGNMENT_g;     /* Alignment error */
+H5_DLLVAR hid_t H5E_BADMESG_g;       /* Unrecognized message */
+H5_DLLVAR hid_t H5E_CANTDELETE_g;    /* Can't delete message */
+H5_DLLVAR hid_t H5E_BADITER_g;       /* Iteration failed */
+H5_DLLVAR hid_t H5E_CANTPACK_g;      /* Can't pack messages */
+H5_DLLVAR hid_t H5E_CANTRESET_g;     /* Can't reset object */
+H5_DLLVAR hid_t H5E_CANTRENAME_g;    /* Unable to rename object */
+
+/* Cache related errors */
+#define H5E_CANTFLUSH        (H5OPEN H5E_CANTFLUSH_g)
+#define H5E_CANTUNSERIALIZE  (H5OPEN H5E_CANTUNSERIALIZE_g)
+#define H5E_CANTSERIALIZE    (H5OPEN H5E_CANTSERIALIZE_g)
+#define H5E_CANTTAG          (H5OPEN H5E_CANTTAG_g)
+#define H5E_CANTLOAD         (H5OPEN H5E_CANTLOAD_g)
+#define H5E_PROTECT          (H5OPEN H5E_PROTECT_g)
+#define H5E_NOTCACHED        (H5OPEN H5E_NOTCACHED_g)
+#define H5E_SYSTEM           (H5OPEN H5E_SYSTEM_g)
+#define H5E_CANTINS          (H5OPEN H5E_CANTINS_g)
+#define H5E_CANTPROTECT      (H5OPEN H5E_CANTPROTECT_g)
+#define H5E_CANTUNPROTECT    (H5OPEN H5E_CANTUNPROTECT_g)
+#define H5E_CANTPIN          (H5OPEN H5E_CANTPIN_g)
+#define H5E_CANTUNPIN        (H5OPEN H5E_CANTUNPIN_g)
+#define H5E_CANTMARKDIRTY    (H5OPEN H5E_CANTMARKDIRTY_g)
+#define H5E_CANTMARKCLEAN    (H5OPEN H5E_CANTMARKCLEAN_g)
+#define H5E_CANTMARKUNSERIALIZED (H5OPEN H5E_CANTMARKUNSERIALIZED_g)
+#define H5E_CANTMARKSERIALIZED (H5OPEN H5E_CANTMARKSERIALIZED_g)
+#define H5E_CANTDIRTY        (H5OPEN H5E_CANTDIRTY_g)
+#define H5E_CANTCLEAN        (H5OPEN H5E_CANTCLEAN_g)
+#define H5E_CANTEXPUNGE      (H5OPEN H5E_CANTEXPUNGE_g)
+#define H5E_CANTRESIZE       (H5OPEN H5E_CANTRESIZE_g)
+#define H5E_CANTDEPEND       (H5OPEN H5E_CANTDEPEND_g)
+#define H5E_CANTUNDEPEND     (H5OPEN H5E_CANTUNDEPEND_g)
+#define H5E_CANTNOTIFY       (H5OPEN H5E_CANTNOTIFY_g)
+#define H5E_LOGFAIL          (H5OPEN H5E_LOGFAIL_g)
+#define H5E_CANTCORK         (H5OPEN H5E_CANTCORK_g)
+#define H5E_CANTUNCORK       (H5OPEN H5E_CANTUNCORK_g)
+H5_DLLVAR hid_t H5E_CANTFLUSH_g;     /* Unable to flush data from cache */
+H5_DLLVAR hid_t H5E_CANTUNSERIALIZE_g; /* Unable to mark metadata as unserialized */
+H5_DLLVAR hid_t H5E_CANTSERIALIZE_g; /* Unable to serialize data from cache */
+H5_DLLVAR hid_t H5E_CANTTAG_g;       /* Unable to tag metadata in the cache */
+H5_DLLVAR hid_t H5E_CANTLOAD_g;      /* Unable to load metadata into cache */
+H5_DLLVAR hid_t H5E_PROTECT_g;       /* Protected metadata error */
+H5_DLLVAR hid_t H5E_NOTCACHED_g;     /* Metadata not currently cached */
+H5_DLLVAR hid_t H5E_SYSTEM_g;        /* Internal error detected */
+H5_DLLVAR hid_t H5E_CANTINS_g;       /* Unable to insert metadata into cache */
+H5_DLLVAR hid_t H5E_CANTPROTECT_g;   /* Unable to protect metadata */
+H5_DLLVAR hid_t H5E_CANTUNPROTECT_g; /* Unable to unprotect metadata */
+H5_DLLVAR hid_t H5E_CANTPIN_g;       /* Unable to pin cache entry */
+H5_DLLVAR hid_t H5E_CANTUNPIN_g;     /* Unable to un-pin cache entry */
+H5_DLLVAR hid_t H5E_CANTMARKDIRTY_g; /* Unable to mark a pinned entry as dirty */
+H5_DLLVAR hid_t H5E_CANTMARKCLEAN_g; /* Unable to mark a pinned entry as clean */
+H5_DLLVAR hid_t H5E_CANTMARKUNSERIALIZED_g; /* Unable to mark an entry as unserialized */
+H5_DLLVAR hid_t H5E_CANTMARKSERIALIZED_g; /* Unable to mark an entry as serialized */
+H5_DLLVAR hid_t H5E_CANTDIRTY_g;     /* Unable to mark metadata as dirty */
+H5_DLLVAR hid_t H5E_CANTCLEAN_g;     /* Unable to mark metadata as clean */
+H5_DLLVAR hid_t H5E_CANTEXPUNGE_g;   /* Unable to expunge a metadata cache entry */
+H5_DLLVAR hid_t H5E_CANTRESIZE_g;    /* Unable to resize a metadata cache entry */
+H5_DLLVAR hid_t H5E_CANTDEPEND_g;    /* Unable to create a flush dependency */
+H5_DLLVAR hid_t H5E_CANTUNDEPEND_g;  /* Unable to destroy a flush dependency */
+H5_DLLVAR hid_t H5E_CANTNOTIFY_g;    /* Unable to notify object about action */
+H5_DLLVAR hid_t H5E_LOGFAIL_g;       /* Failure in the cache logging framework */
+H5_DLLVAR hid_t H5E_CANTCORK_g;      /* Unable to cork an object */
+H5_DLLVAR hid_t H5E_CANTUNCORK_g;    /* Unable to uncork an object */
+
+/* Dataspace errors */
+#define H5E_CANTCLIP         (H5OPEN H5E_CANTCLIP_g)
+#define H5E_CANTCOUNT        (H5OPEN H5E_CANTCOUNT_g)
+#define H5E_CANTSELECT       (H5OPEN H5E_CANTSELECT_g)
+#define H5E_CANTNEXT         (H5OPEN H5E_CANTNEXT_g)
+#define H5E_BADSELECT        (H5OPEN H5E_BADSELECT_g)
+#define H5E_CANTCOMPARE      (H5OPEN H5E_CANTCOMPARE_g)
+#define H5E_CANTAPPEND       (H5OPEN H5E_CANTAPPEND_g)
+H5_DLLVAR hid_t H5E_CANTCLIP_g;      /* Can't clip hyperslab region */
+H5_DLLVAR hid_t H5E_CANTCOUNT_g;     /* Can't count elements */
+H5_DLLVAR hid_t H5E_CANTSELECT_g;    /* Can't select hyperslab */
+H5_DLLVAR hid_t H5E_CANTNEXT_g;      /* Can't move to next iterator location */
+H5_DLLVAR hid_t H5E_BADSELECT_g;     /* Invalid selection */
+H5_DLLVAR hid_t H5E_CANTCOMPARE_g;   /* Can't compare objects */
+H5_DLLVAR hid_t H5E_CANTAPPEND_g;    /* Can't append object */
+
+/* Property list errors */
+#define H5E_CANTGET          (H5OPEN H5E_CANTGET_g)
+#define H5E_CANTSET          (H5OPEN H5E_CANTSET_g)
+#define H5E_DUPCLASS         (H5OPEN H5E_DUPCLASS_g)
+#define H5E_SETDISALLOWED    (H5OPEN H5E_SETDISALLOWED_g)
+H5_DLLVAR hid_t H5E_CANTGET_g;       /* Can't get value */
+H5_DLLVAR hid_t H5E_CANTSET_g;       /* Can't set value */
+H5_DLLVAR hid_t H5E_DUPCLASS_g;      /* Duplicate class name in parent class */
+H5_DLLVAR hid_t H5E_SETDISALLOWED_g; /* Disallowed operation */
+
+/* System level errors */
+#define H5E_SYSERRSTR        (H5OPEN H5E_SYSERRSTR_g)
+H5_DLLVAR hid_t H5E_SYSERRSTR_g;     /* System error message */
+
+/* Free space errors */
+#define H5E_CANTMERGE        (H5OPEN H5E_CANTMERGE_g)
+#define H5E_CANTREVIVE       (H5OPEN H5E_CANTREVIVE_g)
+#define H5E_CANTSHRINK       (H5OPEN H5E_CANTSHRINK_g)
+H5_DLLVAR hid_t H5E_CANTMERGE_g;     /* Can't merge objects */
+H5_DLLVAR hid_t H5E_CANTREVIVE_g;    /* Can't revive object */
+H5_DLLVAR hid_t H5E_CANTSHRINK_g;    /* Can't shrink container */
+
+/* B-tree related errors */
+#define H5E_NOTFOUND         (H5OPEN H5E_NOTFOUND_g)
+#define H5E_EXISTS           (H5OPEN H5E_EXISTS_g)
+#define H5E_CANTENCODE       (H5OPEN H5E_CANTENCODE_g)
+#define H5E_CANTDECODE       (H5OPEN H5E_CANTDECODE_g)
+#define H5E_CANTSPLIT        (H5OPEN H5E_CANTSPLIT_g)
+#define H5E_CANTREDISTRIBUTE (H5OPEN H5E_CANTREDISTRIBUTE_g)
+#define H5E_CANTSWAP         (H5OPEN H5E_CANTSWAP_g)
+#define H5E_CANTINSERT       (H5OPEN H5E_CANTINSERT_g)
+#define H5E_CANTLIST         (H5OPEN H5E_CANTLIST_g)
+#define H5E_CANTMODIFY       (H5OPEN H5E_CANTMODIFY_g)
+#define H5E_CANTREMOVE       (H5OPEN H5E_CANTREMOVE_g)
+H5_DLLVAR hid_t H5E_NOTFOUND_g;      /* Object not found */
+H5_DLLVAR hid_t H5E_EXISTS_g;        /* Object already exists */
+H5_DLLVAR hid_t H5E_CANTENCODE_g;    /* Unable to encode value */
+H5_DLLVAR hid_t H5E_CANTDECODE_g;    /* Unable to decode value */
+H5_DLLVAR hid_t H5E_CANTSPLIT_g;     /* Unable to split node */
+H5_DLLVAR hid_t H5E_CANTREDISTRIBUTE_g; /* Unable to redistribute records */
+H5_DLLVAR hid_t H5E_CANTSWAP_g;      /* Unable to swap records */
+H5_DLLVAR hid_t H5E_CANTINSERT_g;    /* Unable to insert object */
+H5_DLLVAR hid_t H5E_CANTLIST_g;      /* Unable to list node */
+H5_DLLVAR hid_t H5E_CANTMODIFY_g;    /* Unable to modify record */
+H5_DLLVAR hid_t H5E_CANTREMOVE_g;    /* Unable to remove object */
+
+/* Generic low-level file I/O errors */
+#define H5E_SEEKERROR        (H5OPEN H5E_SEEKERROR_g)
+#define H5E_READERROR        (H5OPEN H5E_READERROR_g)
+#define H5E_WRITEERROR       (H5OPEN H5E_WRITEERROR_g)
+#define H5E_CLOSEERROR       (H5OPEN H5E_CLOSEERROR_g)
+#define H5E_OVERFLOW         (H5OPEN H5E_OVERFLOW_g)
+#define H5E_FCNTL            (H5OPEN H5E_FCNTL_g)
+H5_DLLVAR hid_t H5E_SEEKERROR_g;     /* Seek failed */
+H5_DLLVAR hid_t H5E_READERROR_g;     /* Read failed */
+H5_DLLVAR hid_t H5E_WRITEERROR_g;    /* Write failed */
+H5_DLLVAR hid_t H5E_CLOSEERROR_g;    /* Close failed */
+H5_DLLVAR hid_t H5E_OVERFLOW_g;      /* Address overflowed */
+H5_DLLVAR hid_t H5E_FCNTL_g;         /* File control (fcntl) failed */
+
+/* Resource errors */
+#define H5E_NOSPACE          (H5OPEN H5E_NOSPACE_g)
+#define H5E_CANTALLOC        (H5OPEN H5E_CANTALLOC_g)
+#define H5E_CANTCOPY         (H5OPEN H5E_CANTCOPY_g)
+#define H5E_CANTFREE         (H5OPEN H5E_CANTFREE_g)
+#define H5E_ALREADYEXISTS    (H5OPEN H5E_ALREADYEXISTS_g)
+#define H5E_CANTLOCK         (H5OPEN H5E_CANTLOCK_g)
+#define H5E_CANTUNLOCK       (H5OPEN H5E_CANTUNLOCK_g)
+#define H5E_CANTGC           (H5OPEN H5E_CANTGC_g)
+#define H5E_CANTGETSIZE      (H5OPEN H5E_CANTGETSIZE_g)
+#define H5E_OBJOPEN          (H5OPEN H5E_OBJOPEN_g)
+H5_DLLVAR hid_t H5E_NOSPACE_g;       /* No space available for allocation */
+H5_DLLVAR hid_t H5E_CANTALLOC_g;     /* Can't allocate space */
+H5_DLLVAR hid_t H5E_CANTCOPY_g;      /* Unable to copy object */
+H5_DLLVAR hid_t H5E_CANTFREE_g;      /* Unable to free object */
+H5_DLLVAR hid_t H5E_ALREADYEXISTS_g; /* Object already exists */
+H5_DLLVAR hid_t H5E_CANTLOCK_g;      /* Unable to lock object */
+H5_DLLVAR hid_t H5E_CANTUNLOCK_g;    /* Unable to unlock object */
+H5_DLLVAR hid_t H5E_CANTGC_g;        /* Unable to garbage collect */
+H5_DLLVAR hid_t H5E_CANTGETSIZE_g;   /* Unable to compute size */
+H5_DLLVAR hid_t H5E_OBJOPEN_g;       /* Object is already open */
+
+/* Object atom related errors */
+#define H5E_BADATOM          (H5OPEN H5E_BADATOM_g)
+#define H5E_BADGROUP         (H5OPEN H5E_BADGROUP_g)
+#define H5E_CANTREGISTER     (H5OPEN H5E_CANTREGISTER_g)
+#define H5E_CANTINC          (H5OPEN H5E_CANTINC_g)
+#define H5E_CANTDEC          (H5OPEN H5E_CANTDEC_g)
+#define H5E_NOIDS            (H5OPEN H5E_NOIDS_g)
+H5_DLLVAR hid_t H5E_BADATOM_g;       /* Unable to find atom information (already closed?) */
+H5_DLLVAR hid_t H5E_BADGROUP_g;      /* Unable to find ID group information */
+H5_DLLVAR hid_t H5E_CANTREGISTER_g;  /* Unable to register new atom */
+H5_DLLVAR hid_t H5E_CANTINC_g;       /* Unable to increment reference count */
+H5_DLLVAR hid_t H5E_CANTDEC_g;       /* Unable to decrement reference count */
+H5_DLLVAR hid_t H5E_NOIDS_g;         /* Out of IDs for group */
+
+/* Plugin errors */
+#define H5E_OPENERROR        (H5OPEN H5E_OPENERROR_g)
+H5_DLLVAR hid_t H5E_OPENERROR_g;     /* Can't open directory or file */
+
+/* Function entry/exit interface errors */
+#define H5E_CANTINIT         (H5OPEN H5E_CANTINIT_g)
+#define H5E_ALREADYINIT      (H5OPEN H5E_ALREADYINIT_g)
+#define H5E_CANTRELEASE      (H5OPEN H5E_CANTRELEASE_g)
+H5_DLLVAR hid_t H5E_CANTINIT_g;      /* Unable to initialize object */
+H5_DLLVAR hid_t H5E_ALREADYINIT_g;   /* Object already initialized */
+H5_DLLVAR hid_t H5E_CANTRELEASE_g;   /* Unable to release object */
+
+/* File accessibilty errors */
+#define H5E_FILEEXISTS       (H5OPEN H5E_FILEEXISTS_g)
+#define H5E_FILEOPEN         (H5OPEN H5E_FILEOPEN_g)
+#define H5E_CANTCREATE       (H5OPEN H5E_CANTCREATE_g)
+#define H5E_CANTOPENFILE     (H5OPEN H5E_CANTOPENFILE_g)
+#define H5E_CANTCLOSEFILE    (H5OPEN H5E_CANTCLOSEFILE_g)
+#define H5E_NOTHDF5          (H5OPEN H5E_NOTHDF5_g)
+#define H5E_BADFILE          (H5OPEN H5E_BADFILE_g)
+#define H5E_TRUNCATED        (H5OPEN H5E_TRUNCATED_g)
+#define H5E_MOUNT            (H5OPEN H5E_MOUNT_g)
+H5_DLLVAR hid_t H5E_FILEEXISTS_g;    /* File already exists */
+H5_DLLVAR hid_t H5E_FILEOPEN_g;      /* File already open */
+H5_DLLVAR hid_t H5E_CANTCREATE_g;    /* Unable to create file */
+H5_DLLVAR hid_t H5E_CANTOPENFILE_g;  /* Unable to open file */
+H5_DLLVAR hid_t H5E_CANTCLOSEFILE_g; /* Unable to close file */
+H5_DLLVAR hid_t H5E_NOTHDF5_g;       /* Not an HDF5 file */
+H5_DLLVAR hid_t H5E_BADFILE_g;       /* Bad file ID accessed */
+H5_DLLVAR hid_t H5E_TRUNCATED_g;     /* File has been truncated */
+H5_DLLVAR hid_t H5E_MOUNT_g;         /* File mount error */
+
+/* Datatype conversion errors */
+#define H5E_CANTCONVERT      (H5OPEN H5E_CANTCONVERT_g)
+#define H5E_BADSIZE          (H5OPEN H5E_BADSIZE_g)
+H5_DLLVAR hid_t H5E_CANTCONVERT_g;   /* Can't convert datatypes */
+H5_DLLVAR hid_t H5E_BADSIZE_g;       /* Bad size for object */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5Epubgen_H */
diff --git a/install/include/H5Epublic.h b/install/include/H5Epublic.h
new file mode 100644
index 0000000000..3eae2da0cb
--- /dev/null
+++ b/install/include/H5Epublic.h
@@ -0,0 +1,226 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5E module.
+ */
+#ifndef _H5Epublic_H
+#define _H5Epublic_H
+
+#include <stdio.h>              /*FILE arg of H5Eprint()                     */
+
+/* Public headers needed by this file */
+#include "H5public.h"
+#include "H5Ipublic.h"
+
+/* Value for the default error stack */
+#define H5E_DEFAULT             (hid_t)0
+
+/* Different kinds of error information */
+typedef enum H5E_type_t {
+    H5E_MAJOR,
+    H5E_MINOR
+} H5E_type_t;
+
+/* Information about an error; element of error stack */
+typedef struct H5E_error2_t {
+    hid_t       cls_id;         /*class ID                           */
+    hid_t       maj_num;	/*major error ID		     */
+    hid_t       min_num;	/*minor error number		     */
+    unsigned	line;		/*line in file where error occurs    */
+    const char	*func_name;   	/*function in which error occurred   */
+    const char	*file_name;	/*file in which error occurred       */
+    const char	*desc;		/*optional supplied description      */
+} H5E_error2_t;
+
+/* When this header is included from a private header, don't make calls to H5open() */
+#undef H5OPEN
+#ifndef _H5private_H
+#define H5OPEN          H5open(),
+#else   /* _H5private_H */
+#define H5OPEN
+#endif  /* _H5private_H */
+
+/* HDF5 error class */
+#define H5E_ERR_CLS		(H5OPEN H5E_ERR_CLS_g)
+H5_DLLVAR hid_t H5E_ERR_CLS_g;
+
+/* Include the automatically generated public header information */
+/* (This includes the list of major and minor error codes for the library) */
+#include "H5Epubgen.h"
+
+/*
+ * One often needs to temporarily disable automatic error reporting when
+ * trying something that's likely or expected to fail.  The code to try can
+ * be nested between calls to H5Eget_auto() and H5Eset_auto(), but it's
+ * easier just to use this macro like:
+ * 	H5E_BEGIN_TRY {
+ *	    ...stuff here that's likely to fail...
+ *      } H5E_END_TRY;
+ *
+ * Warning: don't break, return, or longjmp() from the body of the loop or
+ *	    the error reporting won't be properly restored!
+ *
+ * These two macros still use the old API functions for backward compatibility
+ * purpose.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+#define H5E_BEGIN_TRY {							      \
+    unsigned H5E_saved_is_v2;					              \
+    union {								      \
+        H5E_auto1_t efunc1;						      \
+        H5E_auto2_t efunc2;					              \
+    } H5E_saved;							      \
+    void *H5E_saved_edata;						      \
+								    	      \
+    (void)H5Eauto_is_v2(H5E_DEFAULT, &H5E_saved_is_v2);		              \
+    if(H5E_saved_is_v2) {						      \
+        (void)H5Eget_auto2(H5E_DEFAULT, &H5E_saved.efunc2, &H5E_saved_edata); \
+        (void)H5Eset_auto2(H5E_DEFAULT, NULL, NULL);		              \
+    } else {								      \
+        (void)H5Eget_auto1(&H5E_saved.efunc1, &H5E_saved_edata);		      \
+        (void)H5Eset_auto1(NULL, NULL);					      \
+    }
+
+#define H5E_END_TRY							      \
+    if(H5E_saved_is_v2)							      \
+        (void)H5Eset_auto2(H5E_DEFAULT, H5E_saved.efunc2, H5E_saved_edata);   \
+    else								      \
+        (void)H5Eset_auto1(H5E_saved.efunc1, H5E_saved_edata);		      \
+}
+#else /* H5_NO_DEPRECATED_SYMBOLS */
+#define H5E_BEGIN_TRY {							      \
+    H5E_auto_t saved_efunc;						      \
+    void *H5E_saved_edata;						      \
+								    	      \
+    (void)H5Eget_auto(H5E_DEFAULT, &saved_efunc, &H5E_saved_edata);	      \
+    (void)H5Eset_auto(H5E_DEFAULT, NULL, NULL);
+
+#define H5E_END_TRY							      \
+    (void)H5Eset_auto(H5E_DEFAULT, saved_efunc, H5E_saved_edata);	      \
+}
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+/*
+ * Public API Convenience Macros for Error reporting - Documented
+ */
+/* Use the Standard C __FILE__ & __LINE__ macros instead of typing them in */
+#define H5Epush_sim(func, cls, maj, min, str) H5Epush2(H5E_DEFAULT, __FILE__, func, __LINE__, cls, maj, min, str)
+
+/*
+ * Public API Convenience Macros for Error reporting - Undocumented
+ */
+/* Use the Standard C __FILE__ & __LINE__ macros instead of typing them in */
+/*  And return after pushing error onto stack */
+#define H5Epush_ret(func, cls, maj, min, str, ret) {			      \
+    H5Epush2(H5E_DEFAULT, __FILE__, func, __LINE__, cls, maj, min, str);      \
+    return(ret);							      \
+}
+
+/* Use the Standard C __FILE__ & __LINE__ macros instead of typing them in
+ * And goto a label after pushing error onto stack.
+ */
+#define H5Epush_goto(func, cls, maj, min, str, label) {			      \
+    H5Epush2(H5E_DEFAULT, __FILE__, func, __LINE__, cls, maj, min, str);      \
+    goto label;								      \
+}
+
+/* Error stack traversal direction */
+typedef enum H5E_direction_t {
+    H5E_WALK_UPWARD	= 0,		/*begin deep, end at API function    */
+    H5E_WALK_DOWNWARD	= 1		/*begin at API function, end deep    */
+} H5E_direction_t;
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Error stack traversal callback function pointers */
+typedef herr_t (*H5E_walk2_t)(unsigned n, const H5E_error2_t *err_desc,
+    void *client_data);
+typedef herr_t (*H5E_auto2_t)(hid_t estack, void *client_data);
+
+/* Public API functions */
+H5_DLL hid_t  H5Eregister_class(const char *cls_name, const char *lib_name,
+    const char *version);
+H5_DLL herr_t H5Eunregister_class(hid_t class_id);
+H5_DLL herr_t H5Eclose_msg(hid_t err_id);
+H5_DLL hid_t  H5Ecreate_msg(hid_t cls, H5E_type_t msg_type, const char *msg);
+H5_DLL hid_t  H5Ecreate_stack(void);
+H5_DLL hid_t  H5Eget_current_stack(void);
+H5_DLL herr_t H5Eclose_stack(hid_t stack_id);
+H5_DLL ssize_t H5Eget_class_name(hid_t class_id, char *name, size_t size);
+H5_DLL herr_t H5Eset_current_stack(hid_t err_stack_id);
+H5_DLL herr_t H5Epush2(hid_t err_stack, const char *file, const char *func, unsigned line,
+    hid_t cls_id, hid_t maj_id, hid_t min_id, const char *msg, ...);
+H5_DLL herr_t H5Epop(hid_t err_stack, size_t count);
+H5_DLL herr_t H5Eprint2(hid_t err_stack, FILE *stream);
+H5_DLL herr_t H5Ewalk2(hid_t err_stack, H5E_direction_t direction, H5E_walk2_t func,
+    void *client_data);
+H5_DLL herr_t H5Eget_auto2(hid_t estack_id, H5E_auto2_t *func, void **client_data);
+H5_DLL herr_t H5Eset_auto2(hid_t estack_id, H5E_auto2_t func, void *client_data);
+H5_DLL herr_t H5Eclear2(hid_t err_stack);
+H5_DLL herr_t H5Eauto_is_v2(hid_t err_stack, unsigned *is_stack);
+H5_DLL ssize_t H5Eget_msg(hid_t msg_id, H5E_type_t *type, char *msg,
+    size_t size);
+H5_DLL ssize_t H5Eget_num(hid_t error_stack_id);
+
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Typedefs */
+
+/* Alias major & minor error types to hid_t's, for compatibility with new
+ *      error API in v1.8
+ */
+typedef hid_t   H5E_major_t;
+typedef hid_t   H5E_minor_t;
+
+/* Information about an error element of error stack. */
+typedef struct H5E_error1_t {
+    H5E_major_t maj_num;                /*major error number                 */
+    H5E_minor_t min_num;                /*minor error number                 */
+    const char  *func_name;             /*function in which error occurred   */
+    const char  *file_name;             /*file in which error occurred       */
+    unsigned    line;                   /*line in file where error occurs    */
+    const char  *desc;                  /*optional supplied description      */
+} H5E_error1_t;
+
+/* Error stack traversal callback function pointers */
+typedef herr_t (*H5E_walk1_t)(int n, H5E_error1_t *err_desc, void *client_data);
+typedef herr_t (*H5E_auto1_t)(void *client_data);
+
+/* Function prototypes */
+H5_DLL herr_t H5Eclear1(void);
+H5_DLL herr_t H5Eget_auto1(H5E_auto1_t *func, void **client_data);
+H5_DLL herr_t H5Epush1(const char *file, const char *func, unsigned line,
+    H5E_major_t maj, H5E_minor_t min, const char *str);
+H5_DLL herr_t H5Eprint1(FILE *stream);
+H5_DLL herr_t H5Eset_auto1(H5E_auto1_t func, void *client_data);
+H5_DLL herr_t H5Ewalk1(H5E_direction_t direction, H5E_walk1_t func,
+    void *client_data);
+H5_DLL char *H5Eget_major(H5E_major_t maj);
+H5_DLL char *H5Eget_minor(H5E_minor_t min);
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end _H5Epublic_H */
+
diff --git a/install/include/H5Eterm.h b/install/include/H5Eterm.h
new file mode 100644
index 0000000000..e94756eb1b
--- /dev/null
+++ b/install/include/H5Eterm.h
@@ -0,0 +1,232 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Generated automatically by bin/make_err -- do not edit */
+/* Add new errors to H5err.txt file */
+
+
+#ifndef _H5Eterm_H
+#define _H5Eterm_H
+
+/* Reset major error IDs */
+    
+H5E_SOHM_g=    
+H5E_OHDR_g=    
+H5E_PLINE_g=    
+H5E_FUNC_g=    
+H5E_RS_g=    
+H5E_PLUGIN_g=    
+H5E_CACHE_g=    
+H5E_PAGEBUF_g=    
+H5E_LINK_g=    
+H5E_INTERNAL_g=    
+H5E_NONE_MAJOR_g=    
+H5E_SLIST_g=    
+H5E_DATATYPE_g=    
+H5E_ATOM_g=    
+H5E_PLIST_g=    
+H5E_DATASET_g=    
+H5E_ARGS_g=    
+H5E_DATASPACE_g=    
+H5E_RESOURCE_g=    
+H5E_IO_g=    
+H5E_STORAGE_g=    
+H5E_BTREE_g=    
+H5E_TST_g=    
+H5E_REFERENCE_g=    
+H5E_ATTR_g=    
+H5E_EARRAY_g=    
+H5E_FSPACE_g=    
+H5E_FILE_g=    
+H5E_EFL_g=    
+H5E_ERROR_g=    
+H5E_SYM_g=    
+H5E_FARRAY_g=    
+H5E_HEAP_g=    
+H5E_VFL_g= (-1);
+
+/* Reset minor error IDs */
+
+
+/* Argument errors */    
+H5E_UNINITIALIZED_g=    
+H5E_UNSUPPORTED_g=    
+H5E_BADTYPE_g=    
+H5E_BADRANGE_g=    
+H5E_BADVALUE_g=
+
+/* Group related errors */    
+H5E_CANTOPENOBJ_g=    
+H5E_CANTCLOSEOBJ_g=    
+H5E_COMPLEN_g=    
+H5E_PATH_g=
+
+/* Heap errors */    
+H5E_CANTRESTORE_g=    
+H5E_CANTCOMPUTE_g=    
+H5E_CANTEXTEND_g=    
+H5E_CANTATTACH_g=    
+H5E_CANTUPDATE_g=    
+H5E_CANTOPERATE_g=
+
+/* Link related errors */    
+H5E_TRAVERSE_g=    
+H5E_NLINKS_g=    
+H5E_NOTREGISTERED_g=    
+H5E_CANTMOVE_g=    
+H5E_CANTSORT_g=
+
+/* I/O pipeline errors */    
+H5E_NOFILTER_g=    
+H5E_CALLBACK_g=    
+H5E_CANAPPLY_g=    
+H5E_SETLOCAL_g=    
+H5E_NOENCODER_g=    
+H5E_CANTFILTER_g=
+
+/* No error */    
+H5E_NONE_MINOR_g=
+
+/* Parallel MPI errors */    
+H5E_MPI_g=    
+H5E_MPIERRSTR_g=    
+H5E_CANTRECV_g=
+
+/* Object header related errors */    
+H5E_LINKCOUNT_g=    
+H5E_VERSION_g=    
+H5E_ALIGNMENT_g=    
+H5E_BADMESG_g=    
+H5E_CANTDELETE_g=    
+H5E_BADITER_g=    
+H5E_CANTPACK_g=    
+H5E_CANTRESET_g=    
+H5E_CANTRENAME_g=
+
+/* Cache related errors */    
+H5E_CANTFLUSH_g=    
+H5E_CANTUNSERIALIZE_g=    
+H5E_CANTSERIALIZE_g=    
+H5E_CANTTAG_g=    
+H5E_CANTLOAD_g=    
+H5E_PROTECT_g=    
+H5E_NOTCACHED_g=    
+H5E_SYSTEM_g=    
+H5E_CANTINS_g=    
+H5E_CANTPROTECT_g=    
+H5E_CANTUNPROTECT_g=    
+H5E_CANTPIN_g=    
+H5E_CANTUNPIN_g=    
+H5E_CANTMARKDIRTY_g=    
+H5E_CANTMARKCLEAN_g=    
+H5E_CANTMARKUNSERIALIZED_g=    
+H5E_CANTMARKSERIALIZED_g=    
+H5E_CANTDIRTY_g=    
+H5E_CANTCLEAN_g=    
+H5E_CANTEXPUNGE_g=    
+H5E_CANTRESIZE_g=    
+H5E_CANTDEPEND_g=    
+H5E_CANTUNDEPEND_g=    
+H5E_CANTNOTIFY_g=    
+H5E_LOGFAIL_g=    
+H5E_CANTCORK_g=    
+H5E_CANTUNCORK_g=
+
+/* Dataspace errors */    
+H5E_CANTCLIP_g=    
+H5E_CANTCOUNT_g=    
+H5E_CANTSELECT_g=    
+H5E_CANTNEXT_g=    
+H5E_BADSELECT_g=    
+H5E_CANTCOMPARE_g=    
+H5E_CANTAPPEND_g=
+
+/* Property list errors */    
+H5E_CANTGET_g=    
+H5E_CANTSET_g=    
+H5E_DUPCLASS_g=    
+H5E_SETDISALLOWED_g=
+
+/* System level errors */    
+H5E_SYSERRSTR_g=
+
+/* Free space errors */    
+H5E_CANTMERGE_g=    
+H5E_CANTREVIVE_g=    
+H5E_CANTSHRINK_g=
+
+/* B-tree related errors */    
+H5E_NOTFOUND_g=    
+H5E_EXISTS_g=    
+H5E_CANTENCODE_g=    
+H5E_CANTDECODE_g=    
+H5E_CANTSPLIT_g=    
+H5E_CANTREDISTRIBUTE_g=    
+H5E_CANTSWAP_g=    
+H5E_CANTINSERT_g=    
+H5E_CANTLIST_g=    
+H5E_CANTMODIFY_g=    
+H5E_CANTREMOVE_g=
+
+/* Generic low-level file I/O errors */    
+H5E_SEEKERROR_g=    
+H5E_READERROR_g=    
+H5E_WRITEERROR_g=    
+H5E_CLOSEERROR_g=    
+H5E_OVERFLOW_g=    
+H5E_FCNTL_g=
+
+/* Resource errors */    
+H5E_NOSPACE_g=    
+H5E_CANTALLOC_g=    
+H5E_CANTCOPY_g=    
+H5E_CANTFREE_g=    
+H5E_ALREADYEXISTS_g=    
+H5E_CANTLOCK_g=    
+H5E_CANTUNLOCK_g=    
+H5E_CANTGC_g=    
+H5E_CANTGETSIZE_g=    
+H5E_OBJOPEN_g=
+
+/* Object atom related errors */    
+H5E_BADATOM_g=    
+H5E_BADGROUP_g=    
+H5E_CANTREGISTER_g=    
+H5E_CANTINC_g=    
+H5E_CANTDEC_g=    
+H5E_NOIDS_g=
+
+/* Plugin errors */    
+H5E_OPENERROR_g=
+
+/* Function entry/exit interface errors */    
+H5E_CANTINIT_g=    
+H5E_ALREADYINIT_g=    
+H5E_CANTRELEASE_g=
+
+/* File accessibilty errors */    
+H5E_FILEEXISTS_g=    
+H5E_FILEOPEN_g=    
+H5E_CANTCREATE_g=    
+H5E_CANTOPENFILE_g=    
+H5E_CANTCLOSEFILE_g=    
+H5E_NOTHDF5_g=    
+H5E_BADFILE_g=    
+H5E_TRUNCATED_g=    
+H5E_MOUNT_g=
+
+/* Datatype conversion errors */    
+H5E_CANTCONVERT_g=    
+H5E_BADSIZE_g= (-1);
+
+#endif /* H5Eterm_H */
diff --git a/install/include/H5Exception.h b/install/include/H5Exception.h
new file mode 100644
index 0000000000..2cc2dd68b5
--- /dev/null
+++ b/install/include/H5Exception.h
@@ -0,0 +1,179 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5Exception_H
+#define __H5Exception_H
+
+#include <string>
+
+namespace H5 {
+#ifdef H5_NO_STD
+    #define H5std_string ::string
+#else
+    #define H5std_string std::string
+#endif
+
+/*! \class Exception
+    \brief Exception provides wrappers of HDF5 error handling functions.
+
+    Many classes are derived from Exception for specific HDF5 C interfaces.
+*/
+class H5_DLLCPP Exception {
+   public:
+        // Creates an exception with a function name where the failure occurs
+        // and an optional detailed message
+        Exception(const H5std_string& func_name, const H5std_string& message = DEFAULT_MSG);
+
+        // Returns a character string that describes the error specified by
+        // a major error number.
+        H5std_string getMajorString(hid_t err_major_id) const;
+
+        // Returns a character string that describes the error specified by
+        // a minor error number.
+        H5std_string getMinorString(hid_t err_minor_id) const;
+
+        // Returns the detailed message set at the time the exception is thrown
+        H5std_string getDetailMsg() const;
+        const char* getCDetailMsg() const;   // C string of detailed message
+        H5std_string getFuncName() const;    // function name as a string object
+        const char* getCFuncName() const;    // function name as a char string
+
+        // Turns on the automatic error printing.
+        static void setAutoPrint(H5E_auto2_t& func, void* client_data);
+
+        // Turns off the automatic error printing.
+        static void dontPrint();
+
+        // Retrieves the current settings for the automatic error stack
+        // traversal function and its data.
+        static void getAutoPrint(H5E_auto2_t& func, void** client_data);
+
+        // Clears the error stack for the current thread.
+        static void clearErrorStack();
+
+        // Walks the error stack for the current thread, calling the
+        // specified function.
+        static void walkErrorStack(H5E_direction_t direction,
+                                   H5E_walk2_t func, void* client_data);
+
+        // Prints the error stack in a default manner.
+        static void printErrorStack(FILE* stream = stderr,
+                                    hid_t err_stack = H5E_DEFAULT);
+        virtual void printError(FILE* stream = NULL) const;
+
+        // Default constructor
+        Exception();
+
+        // copy constructor
+        Exception(const Exception& orig);
+
+        // virtual Destructor
+        virtual ~Exception() throw();
+
+   protected:
+        // Default value for detail_message
+        static const char DEFAULT_MSG[];
+
+   private:
+        H5std_string detail_message;
+        H5std_string func_name;
+};
+
+class H5_DLLCPP FileIException : public Exception {
+   public:
+        FileIException(const H5std_string& func_name, const H5std_string& message = DEFAULT_MSG);
+        FileIException();
+        virtual ~FileIException() throw();
+};
+
+class H5_DLLCPP GroupIException : public Exception {
+   public:
+        GroupIException(const H5std_string& func_name, const H5std_string& message = DEFAULT_MSG);
+        GroupIException();
+        virtual ~GroupIException() throw();
+};
+
+class H5_DLLCPP DataSpaceIException : public Exception {
+   public:
+        DataSpaceIException(const H5std_string& func_name, const H5std_string& message = DEFAULT_MSG);
+        DataSpaceIException();
+        virtual ~DataSpaceIException() throw();
+};
+
+class H5_DLLCPP DataTypeIException : public Exception {
+   public:
+        DataTypeIException(const H5std_string& func_name, const H5std_string& message = DEFAULT_MSG);
+        DataTypeIException();
+        virtual ~DataTypeIException() throw();
+};
+
+class H5_DLLCPP ObjHeaderIException : public Exception {
+   public:
+        ObjHeaderIException(const H5std_string& func_name, const H5std_string& message = DEFAULT_MSG);
+        ObjHeaderIException();
+        virtual ~ObjHeaderIException() throw();
+};
+
+class H5_DLLCPP PropListIException : public Exception {
+   public:
+        PropListIException(const H5std_string& func_name, const H5std_string& message = DEFAULT_MSG);
+        PropListIException();
+        virtual ~PropListIException() throw();
+};
+
+class H5_DLLCPP DataSetIException : public Exception {
+   public:
+        DataSetIException(const H5std_string& func_name, const H5std_string& message = DEFAULT_MSG);
+        DataSetIException();
+        virtual ~DataSetIException() throw();
+};
+
+class H5_DLLCPP AttributeIException : public Exception {
+   public:
+        AttributeIException(const H5std_string& func_name, const H5std_string& message = DEFAULT_MSG);
+        AttributeIException();
+        virtual ~AttributeIException() throw();
+};
+
+class H5_DLLCPP ReferenceException : public Exception {
+   public:
+        ReferenceException(const H5std_string& func_name, const H5std_string& message = DEFAULT_MSG);
+        ReferenceException();
+        virtual ~ReferenceException() throw();
+};
+
+class H5_DLLCPP LibraryIException : public Exception {
+   public:
+        LibraryIException(const H5std_string& func_name, const H5std_string& message = DEFAULT_MSG);
+        LibraryIException();
+        virtual ~LibraryIException() throw();
+};
+
+class H5_DLLCPP LocationException : public Exception {
+   public:
+        LocationException(const H5std_string& func_name, const H5std_string& message = DEFAULT_MSG);
+        LocationException();
+        virtual ~LocationException() throw();
+};
+
+class H5_DLLCPP IdComponentException : public Exception {
+   public:
+        IdComponentException(const H5std_string& func_name, const H5std_string& message = DEFAULT_MSG);
+        IdComponentException();
+        virtual ~IdComponentException() throw();
+
+}; // end of IdComponentException
+} // namespace H5
+
+#endif // __H5Exception_H
diff --git a/install/include/H5FApkg.h b/install/include/H5FApkg.h
new file mode 100644
index 0000000000..6f0a43ade2
--- /dev/null
+++ b/install/include/H5FApkg.h
@@ -0,0 +1,320 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:
+ *
+ * Purpose:    This file contains declarations which are visible only within
+ *        the H5FA package.  Source files outside the H5FA package should
+ *        include H5FAprivate.h instead.
+ */
+#if !(defined(H5FA_FRIEND) | defined(H5FA_MODULE))
+#error "Do not include this file outside the H5FA package!"
+#endif
+
+#ifndef _H5FApkg_H
+#define _H5FApkg_H
+
+/* Get package's private header */
+#include "H5FAprivate.h"
+
+/* Other private headers needed by this file */
+#include "H5ACprivate.h"    /* Metadata cache                       */
+#include "H5FLprivate.h"    /* Free Lists                           */
+
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* Define this to display debugging information for the Fixed Array layer */
+/* #define H5FA_DEBUG */
+
+
+/* Fill value for fixed array test class */
+#ifdef H5FA_TESTING
+#define H5FA_TEST_FILL          ((uint64_t)ULLONG_MAX)
+#endif /* H5FA_TESTING */
+
+/* Size of checksum information (on disk) */
+#define H5FA_SIZEOF_CHKSUM      4
+
+/* "Standard" size of prefix information for fixed array metadata */
+#define H5FA_METADATA_PREFIX_SIZE(c) (                                      \
+    H5_SIZEOF_MAGIC                     /* Signature            */          \
+    + 1                                 /* Version              */          \
+    + 1                                 /* Array type           */          \
+    + ((c) ? H5FA_SIZEOF_CHKSUM : 0)    /* Metadata checksum    */          \
+    )
+
+/* Size of the Fixed Array header on disk */
+#define H5FA_HEADER_SIZE(sizeof_addr, sizeof_size) (                          \
+    /* General metadata fields */                                             \
+    H5FA_METADATA_PREFIX_SIZE(TRUE)                                           \
+                                                                              \
+    /* General array information */                                           \
+    + 1 /* Element Size */                                                    \
+    + 1 /* Log2(Max. # of elements in data block page) - i.e. # of bits needed to store max. # of elements in data block page */ \
+                                                                              \
+    /* Fixed Array statistics fields */                                       \
+    + (sizeof_size) /* # of elements in the fixed array */    		      \
+                                                                              \
+    /* Fixed Array Header specific fields */                                  \
+    + (sizeof_addr) /* File address of Fixed Array data block */  	      \
+    )
+
+/* Size of the fixed array header on disk (via file pointer) */
+#define H5FA_HEADER_SIZE_FILE(f)   (                                          \
+    H5FA_HEADER_SIZE(H5F_SIZEOF_ADDR(f), H5F_SIZEOF_SIZE(f))                  \
+    )
+
+/* Size of the fixed array header on disk (via fixed array header) */
+#define H5FA_HEADER_SIZE_HDR(h)   (                                           \
+    H5FA_HEADER_SIZE((h)->sizeof_addr, (h)->sizeof_size)                      \
+    )
+
+/* Size of the Fixed Array data block prefix on disk */
+#define H5FA_DBLOCK_PREFIX_SIZE(d)  (                                       \
+    /* General metadata fields */                                           \
+    H5FA_METADATA_PREFIX_SIZE(TRUE)                                         \
+                                                                            \
+    /* Sanity-checking fields */                                            \
+    + (d)->hdr->sizeof_addr        /* File address of Fixed Array header owning the data block */   \
+                                                                            \
+    /* Fixed Array Data Block specific fields */                            \
+    + (d)->dblk_page_init_size /* Fixed array data block 'page init' bitmasks (can be 0 if no pages) */ \
+    )
+
+/* Size of the Fixed Array data block on disk */
+#define H5FA_DBLOCK_SIZE(d)  (                                              \
+    /* Data block prefix size  */                                           \
+    H5FA_DBLOCK_PREFIX_SIZE(d)                                              \
+                                                                            \
+    /* Fixed Array Elements|Pages of Elements*/                             \
+    + ((d)->hdr->cparam.nelmts * (size_t)(d)->hdr->cparam.raw_elmt_size)    \
+    + ((d)->npages * H5FA_SIZEOF_CHKSUM)        /* Checksum */              \
+    )
+
+/* Size of the Fixed Array data block page on disk */
+#define H5FA_DBLK_PAGE_SIZE(h, nelmts)     (                                  \
+    /* Fixed Array Data Block Page */					      \
+    + (nelmts * (size_t)(h)->cparam.raw_elmt_size) /* Elements in data block page */  \
+    + H5FA_SIZEOF_CHKSUM                        	/* Checksum for each page */  	   \
+    )
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/* The Fixed Array header information */
+typedef struct H5FA_hdr_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* Fixed array configuration/creation parameters (stored in header) */
+    H5FA_create_t cparam;               /* Creation parameters for Fixed Array */
+
+    /* Fixed Array data block information (stored in header) */
+    haddr_t dblk_addr;                   /* Address of Fixed Array Data block */
+
+    /* Statistics for Fixed Array (stored in header) */
+    H5FA_stat_t stats;                  /* Statistcs for Fixed Array */
+
+    /* Computed/cached values (not stored in header) */
+    size_t rc;                          /* Reference count of the header                                */
+    haddr_t addr;                       /* Address of header in file                                    */
+    size_t size;                        /* Size of header in file                                       */
+    H5F_t *f;                           /* Pointer to file for fixed array                              */
+    size_t file_rc;                     /* Reference count of files using array header                  */
+    hbool_t pending_delete;             /* Array is pending deletion                                    */
+    size_t sizeof_addr;                 /* Size of file addresses                                       */
+    size_t sizeof_size;                 /* Size of file sizes                                           */
+
+    /* Client information (not stored) */
+    void *cb_ctx;                       /* Callback context */
+
+    /* SWMR / Flush dependency information (not stored) */
+    hbool_t swmr_write;                 /* Flag indicating the file is opened with SWMR-write access    */
+    H5AC_proxy_entry_t *top_proxy;      /* 'Top' proxy cache entry for all array entries */
+    void *parent;		        /* Pointer to 'top' proxy flush dependency
+                                         * parent, if it exists, otherwise NULL.
+                                         * If the fixed array is being used
+                                         * to index a chunked dataset and the
+                                         * dataset metadata is modified by a
+                                         * SWMR writer, this field will be set
+                                         * equal to the object header proxy
+                                         * that is the flush dependency parent
+                                         * of the fixed array header.
+ 					 *
+ 					 * The field is used to avoid duplicate
+					 * setups of the flush dependency 
+					 * relationship, and to allow the 
+					 * fixed array header to destroy
+					 * the flush dependency on receipt of 
+					 * an eviction notification from the
+					 * metadata cache.
+					 */
+} H5FA_hdr_t;
+
+/* The fixed array data block information */
+typedef struct H5FA_dblock_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* Fixed array information (stored) */
+    uint8_t     *dblk_page_init;/* Bitmap of whether a data block page is initialized       */
+    void        *elmts;         /* Buffer for elements stored in data block                 */
+
+    /* Internal array information (not stored) */
+    H5FA_hdr_t    *hdr;            /* Shared array header info                              */
+
+    /* SWMR / Flush dependency information (not stored) */
+    H5AC_proxy_entry_t *top_proxy;      /* 'Top' proxy cache entry for all array entries */
+
+    /* Computed/cached values (not stored) */
+    haddr_t     addr;               /* Address of this data block on disk                   */
+    hsize_t     size;               /* Size of data block on disk                           */
+    size_t      npages;             /* Nummber of pages in data block (zero if not paged)   */
+    size_t      last_page_nelmts;   /* Nummber of elements in last page, if paged           */
+
+    /* Fixed Array data block information (not stored) */
+    size_t dblk_page_nelmts;        /* # of elements per data block page                    */
+    size_t dblk_page_size;          /* Size of a data block page                            */
+    size_t dblk_page_init_size;     /* Size of 'page init' bitmask                          */
+} H5FA_dblock_t;
+
+/* The fixed array data block page information */
+typedef struct H5FA_dbk_page_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* Fixed array information (stored) */
+    void        *elmts;         /* Buffer for elements stored in data block page */
+
+    /* Internal array information (not stored) */
+    H5FA_hdr_t    *hdr;         /* Shared array header info                     */
+
+    /* SWMR / Flush dependency information (not stored) */
+    H5AC_proxy_entry_t *top_proxy;      /* 'Top' proxy cache entry for all array entries */
+
+    /* Computed/cached values (not stored) */
+    haddr_t     addr;           /* Address of this data block page on disk      */
+    size_t      size;           /* Size of data block page on disk              */
+    size_t      nelmts;         /* Number of elements in data block page        */
+} H5FA_dblk_page_t;
+
+/* Fixed array */
+struct H5FA_t {
+    H5FA_hdr_t  *hdr;           /* Pointer to internal fixed array header info  */
+    H5F_t      *f;              /* Pointer to file for fixed array              */
+};
+
+
+/* Metadata cache callback user data types */
+
+/* Info needed for loading header */
+typedef struct H5FA_hdr_cache_ud_t {
+    H5F_t      *f;              /* Pointer to file for fixed array */
+    haddr_t    addr;            /* Address of header on disk */
+    void       *ctx_udata;      /* User context for class */
+} H5FA_hdr_cache_ud_t;
+
+/* Info needed for loading data block */
+typedef struct H5FA_dblock_cache_ud_t {
+    H5FA_hdr_t *hdr;            /* Shared fixed array information       */
+    haddr_t     dblk_addr;      /* Address of data block on disk        */
+} H5FA_dblock_cache_ud_t;
+
+/* Info needed for loading data block page */
+typedef struct H5FA_dblk_page_cache_ud_t {
+    H5FA_hdr_t *hdr;            /* Shared fixed array information           */
+    size_t nelmts;              /* Number of elements in data block page    */
+    haddr_t     dblk_page_addr; /* Address of data block page on disk */
+} H5FA_dblk_page_cache_ud_t;
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+/* Internal fixed array testing class */
+H5_DLLVAR const H5FA_class_t H5FA_CLS_TEST[1];
+
+/* Array of fixed array client ID -> client class mappings */
+H5_DLLVAR const H5FA_class_t *const H5FA_client_class_g[H5FA_NUM_CLS_ID];
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+/* Generic routines */
+H5_DLL herr_t H5FA__create_flush_depend(H5AC_info_t *parent_entry,
+    H5AC_info_t *child_entry);
+H5_DLL herr_t H5FA__destroy_flush_depend(H5AC_info_t *parent_entry,
+    H5AC_info_t *child_entry);
+
+/* Header routines */
+H5_DLL H5FA_hdr_t *H5FA__hdr_alloc(H5F_t *f);
+H5_DLL herr_t H5FA__hdr_init(H5FA_hdr_t *hdr, void *ctx_udata);
+H5_DLL haddr_t H5FA__hdr_create(H5F_t *f, hid_t dxpl_id, const H5FA_create_t *cparam, void *ctx_udata);
+H5_DLL void *H5FA__hdr_alloc_elmts(H5FA_hdr_t *hdr, size_t nelmts);
+H5_DLL herr_t H5FA__hdr_free_elmts(H5FA_hdr_t *hdr, size_t nelmts, void *elmts);
+H5_DLL herr_t H5FA__hdr_incr(H5FA_hdr_t *hdr);
+H5_DLL herr_t H5FA__hdr_decr(H5FA_hdr_t *hdr);
+H5_DLL herr_t H5FA__hdr_fuse_incr(H5FA_hdr_t *hdr);
+H5_DLL size_t H5FA__hdr_fuse_decr(H5FA_hdr_t *hdr);
+H5_DLL herr_t H5FA__hdr_modified(H5FA_hdr_t *hdr);
+H5_DLL H5FA_hdr_t *H5FA__hdr_protect(H5F_t *f, hid_t dxpl_id, haddr_t fa_addr,
+    void *ctx_udata, unsigned flags);
+H5_DLL herr_t H5FA__hdr_unprotect(H5FA_hdr_t *hdr, hid_t dxpl_id, unsigned cache_flags);
+H5_DLL herr_t H5FA__hdr_delete(H5FA_hdr_t *hdr, hid_t dxpl_id);
+H5_DLL herr_t H5FA__hdr_dest(H5FA_hdr_t *hdr);
+
+/* Data block routines */
+H5_DLL H5FA_dblock_t *H5FA__dblock_alloc(H5FA_hdr_t *hdr);
+H5_DLL haddr_t H5FA__dblock_create(H5FA_hdr_t *hdr, hid_t dxpl_id, hbool_t *hdr_dirty);
+H5_DLL unsigned H5FA__dblock_sblk_idx(const H5FA_hdr_t *hdr, hsize_t idx);
+H5_DLL H5FA_dblock_t *H5FA__dblock_protect(H5FA_hdr_t *hdr, hid_t dxpl_id,
+    haddr_t dblk_addr, unsigned flags);
+H5_DLL herr_t H5FA__dblock_unprotect(H5FA_dblock_t *dblock, hid_t dxpl_id,
+    unsigned cache_flags);
+H5_DLL herr_t H5FA__dblock_delete(H5FA_hdr_t *hdr, hid_t dxpl_id,
+    haddr_t dblk_addr);
+H5_DLL herr_t H5FA__dblock_dest(H5FA_dblock_t *dblock);
+
+/* Data block page routines */
+H5_DLL herr_t H5FA__dblk_page_create(H5FA_hdr_t *hdr, hid_t dxpl_id,
+    haddr_t addr, size_t nelmts);
+H5_DLL H5FA_dblk_page_t *H5FA__dblk_page_alloc(H5FA_hdr_t *hdr, size_t nelmts);
+H5_DLL H5FA_dblk_page_t *H5FA__dblk_page_protect(H5FA_hdr_t *hdr, hid_t dxpl_id,
+    haddr_t dblk_page_addr, size_t dblk_page_nelmts, unsigned flags);
+H5_DLL herr_t H5FA__dblk_page_unprotect(H5FA_dblk_page_t *dblk_page,
+    hid_t dxpl_id, unsigned cache_flags);
+H5_DLL herr_t H5FA__dblk_page_dest(H5FA_dblk_page_t *dblk_page);
+
+/* Debugging routines for dumping file structures */
+H5_DLL herr_t H5FA__hdr_debug(H5F_t *f, hid_t dxpl_id, haddr_t addr,
+    FILE *stream, int indent, int fwidth, const H5FA_class_t *cls, haddr_t obj_addr);
+H5_DLL herr_t H5FA__dblock_debug(H5F_t *f, hid_t dxpl_id, haddr_t addr,
+    FILE *stream, int indent, int fwidth, const H5FA_class_t *cls,
+    haddr_t hdr_addr, haddr_t obj_addr);
+
+/* Testing routines */
+#ifdef H5FA_TESTING
+H5_DLL herr_t H5FA_get_cparam_test(const H5FA_t *ea, H5FA_create_t *cparam);
+H5_DLL int H5FA_cmp_cparam_test(const H5FA_create_t *cparam1, const H5FA_create_t *cparam2);
+#endif /* H5FA_TESTING */
+
+#endif /* _H5FApkg_H */
+
diff --git a/install/include/H5FDcore.h b/install/include/H5FDcore.h
new file mode 100644
index 0000000000..5fe2912075
--- /dev/null
+++ b/install/include/H5FDcore.h
@@ -0,0 +1,38 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Robb Matzke <matzke@llnl.gov>
+ *              Monday, August  2, 1999
+ *
+ * Purpose:	The public header file for the core driver.
+ */
+#ifndef H5FDcore_H
+#define H5FDcore_H
+
+#define H5FD_CORE	(H5FD_core_init())
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+H5_DLL hid_t H5FD_core_init(void);
+H5_DLL herr_t H5Pset_fapl_core(hid_t fapl_id, size_t increment,
+				hbool_t backing_store);
+H5_DLL herr_t H5Pget_fapl_core(hid_t fapl_id, size_t *increment/*out*/,
+				hbool_t *backing_store/*out*/);
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/install/include/H5FDdirect.h b/install/include/H5FDdirect.h
new file mode 100644
index 0000000000..805f3be372
--- /dev/null
+++ b/install/include/H5FDdirect.h
@@ -0,0 +1,53 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Raymond Lu <slu@hdfgroup.uiuc.edu>
+ *              Wednesday, 20 September 2006
+ *
+ * Purpose:	The public header file for the direct driver.
+ */
+#ifndef H5FDdirect_H
+#define H5FDdirect_H
+
+#ifdef H5_HAVE_DIRECT
+#       define H5FD_DIRECT	(H5FD_direct_init())
+#else
+#       define H5FD_DIRECT      (-1)
+#endif /* H5_HAVE_DIRECT */
+
+#ifdef H5_HAVE_DIRECT
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Default values for memory boundary, file block size, and maximal copy buffer size.
+ * Application can set these values through the function H5Pset_fapl_direct. */
+#define MBOUNDARY_DEF		4096
+#define FBSIZE_DEF		4096
+#define CBSIZE_DEF		16*1024*1024
+
+H5_DLL hid_t H5FD_direct_init(void);
+H5_DLL herr_t H5Pset_fapl_direct(hid_t fapl_id, size_t alignment, size_t block_size,
+			size_t cbuf_size);
+H5_DLL herr_t H5Pget_fapl_direct(hid_t fapl_id, size_t *boundary/*out*/,
+			size_t *block_size/*out*/, size_t *cbuf_size/*out*/);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5_HAVE_DIRECT */
+
+#endif
+
diff --git a/install/include/H5FDfamily.h b/install/include/H5FDfamily.h
new file mode 100644
index 0000000000..1584cf6964
--- /dev/null
+++ b/install/include/H5FDfamily.h
@@ -0,0 +1,40 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Robb Matzke <matzke@llnl.gov>
+ *              Monday, August  4, 1999
+ *
+ * Purpose:	The public header file for the family driver.
+ */
+#ifndef H5FDfamily_H
+#define H5FDfamily_H
+
+#define H5FD_FAMILY	(H5FD_family_init())
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5_DLL hid_t H5FD_family_init(void);
+H5_DLL herr_t H5Pset_fapl_family(hid_t fapl_id, hsize_t memb_size,
+			  hid_t memb_fapl_id);
+H5_DLL herr_t H5Pget_fapl_family(hid_t fapl_id, hsize_t *memb_size/*out*/,
+			  hid_t *memb_fapl_id/*out*/);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/install/include/H5FDlog.h b/install/include/H5FDlog.h
new file mode 100644
index 0000000000..a69bb1877a
--- /dev/null
+++ b/install/include/H5FDlog.h
@@ -0,0 +1,72 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *              Monday, April 17, 2000
+ *
+ * Purpose:	The public header file for the log driver.
+ */
+#ifndef H5FDlog_H
+#define H5FDlog_H
+
+#define H5FD_LOG	(H5FD_log_init())
+
+/* Flags for H5Pset_fapl_log() */
+/* Flags for tracking 'meta' operations (truncate) */
+#define H5FD_LOG_TRUNCATE   0x00000001
+#define H5FD_LOG_META_IO    (H5FD_LOG_TRUNCATE)
+/* Flags for tracking where reads/writes/seeks occur */
+#define H5FD_LOG_LOC_READ   0x00000002
+#define H5FD_LOG_LOC_WRITE  0x00000004
+#define H5FD_LOG_LOC_SEEK   0x00000008
+#define H5FD_LOG_LOC_IO     (H5FD_LOG_LOC_READ|H5FD_LOG_LOC_WRITE|H5FD_LOG_LOC_SEEK)
+/* Flags for tracking number of times each byte is read/written */
+#define H5FD_LOG_FILE_READ  0x00000010
+#define H5FD_LOG_FILE_WRITE 0x00000020
+#define H5FD_LOG_FILE_IO    (H5FD_LOG_FILE_READ|H5FD_LOG_FILE_WRITE)
+/* Flag for tracking "flavor" (type) of information stored at each byte */
+#define H5FD_LOG_FLAVOR     0x00000040
+/* Flags for tracking total number of reads/writes/seeks/truncates */
+#define H5FD_LOG_NUM_READ   0x00000080
+#define H5FD_LOG_NUM_WRITE  0x00000100
+#define H5FD_LOG_NUM_SEEK   0x00000200
+#define H5FD_LOG_NUM_TRUNCATE 0x00000400
+#define H5FD_LOG_NUM_IO     (H5FD_LOG_NUM_READ|H5FD_LOG_NUM_WRITE|H5FD_LOG_NUM_SEEK|H5FD_LOG_NUM_TRUNCATE)
+/* Flags for tracking time spent in open/stat/read/write/seek/truncate/close */
+#define H5FD_LOG_TIME_OPEN  0x00000800
+#define H5FD_LOG_TIME_STAT  0x00001000
+#define H5FD_LOG_TIME_READ  0x00002000
+#define H5FD_LOG_TIME_WRITE 0x00004000
+#define H5FD_LOG_TIME_SEEK  0x00008000
+#define H5FD_LOG_TIME_TRUNCATE 0x00010000
+#define H5FD_LOG_TIME_CLOSE 0x00020000
+#define H5FD_LOG_TIME_IO    (H5FD_LOG_TIME_OPEN|H5FD_LOG_TIME_STAT|H5FD_LOG_TIME_READ|H5FD_LOG_TIME_WRITE|H5FD_LOG_TIME_SEEK|H5FD_LOG_TIME_TRUNCATE|H5FD_LOG_TIME_CLOSE)
+/* Flags for tracking allocation/release of space in file */
+#define H5FD_LOG_ALLOC      0x00040000
+#define H5FD_LOG_FREE       0x00080000
+#define H5FD_LOG_ALL        (H5FD_LOG_FREE|H5FD_LOG_ALLOC|H5FD_LOG_TIME_IO|H5FD_LOG_NUM_IO|H5FD_LOG_FLAVOR|H5FD_LOG_FILE_IO|H5FD_LOG_LOC_IO|H5FD_LOG_META_IO)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5_DLL hid_t H5FD_log_init(void);
+H5_DLL herr_t H5Pset_fapl_log(hid_t fapl_id, const char *logfile, unsigned long long flags, size_t buf_size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/install/include/H5FDmpi.h b/install/include/H5FDmpi.h
new file mode 100644
index 0000000000..2d62c790dd
--- /dev/null
+++ b/install/include/H5FDmpi.h
@@ -0,0 +1,60 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *              Friday, January 30, 2004
+ *
+ * Purpose:	The public header file for common items for all MPI VFL drivers
+ */
+#ifndef H5FDmpi_H
+#define H5FDmpi_H
+
+/***** Macros for One linked collective IO case. *****/
+/* The default value to do one linked collective IO for all chunks.
+   If the average number of chunks per process is greater than this value,
+      the library will create an MPI derived datatype to link all chunks to do collective IO.
+      The user can set this value through an API. */
+
+#define H5D_ONE_LINK_CHUNK_IO_THRESHOLD 0
+/***** Macros for multi-chunk collective IO case. *****/
+/* The default value of the threshold to do collective IO for this chunk.
+   If the average percentage of processes per chunk is greater than the default value,
+   collective IO is done for this chunk.
+*/
+
+#define H5D_MULTI_CHUNK_IO_COL_THRESHOLD 60
+/* Type of I/O for data transfer properties */
+typedef enum H5FD_mpio_xfer_t {
+    H5FD_MPIO_INDEPENDENT = 0, 		/*zero is the default*/
+    H5FD_MPIO_COLLECTIVE
+} H5FD_mpio_xfer_t;
+
+/* Type of chunked dataset I/O */
+typedef enum H5FD_mpio_chunk_opt_t {
+    H5FD_MPIO_CHUNK_DEFAULT = 0,
+    H5FD_MPIO_CHUNK_ONE_IO,  		/*zero is the default*/
+    H5FD_MPIO_CHUNK_MULTI_IO
+} H5FD_mpio_chunk_opt_t;
+
+/* Type of collective I/O */
+typedef enum H5FD_mpio_collective_opt_t {
+    H5FD_MPIO_COLLECTIVE_IO = 0,
+    H5FD_MPIO_INDIVIDUAL_IO  		/*zero is the default*/
+} H5FD_mpio_collective_opt_t;
+
+/* Include all the MPI VFL headers */
+#include "H5FDmpio.h"           /* MPI I/O file driver			*/
+
+#endif /* H5FDmpi_H */
+
diff --git a/install/include/H5FDmpio.h b/install/include/H5FDmpio.h
new file mode 100644
index 0000000000..6ee0a1aa35
--- /dev/null
+++ b/install/include/H5FDmpio.h
@@ -0,0 +1,64 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Robb Matzke <matzke@llnl.gov>
+ *              Monday, August  2, 1999
+ *
+ * Purpose:	The public header file for the mpio driver.
+ */
+#ifndef H5FDmpio_H
+#define H5FDmpio_H
+
+/* Macros */
+
+#ifdef H5_HAVE_PARALLEL
+#   define H5FD_MPIO	(H5FD_mpio_init())
+#else
+#   define H5FD_MPIO	(-1)
+#endif /* H5_HAVE_PARALLEL */
+
+#ifdef H5_HAVE_PARALLEL
+/*Turn on H5FDmpio_debug if H5F_DEBUG is on */
+#ifdef H5F_DEBUG
+#ifndef H5FDmpio_DEBUG
+#define H5FDmpio_DEBUG
+#endif
+#endif
+
+/* Global var whose value comes from environment variable */
+/* (Defined in H5FDmpio.c) */
+H5_DLLVAR hbool_t H5FD_mpi_opt_types_g;
+
+/* Function prototypes */
+#ifdef __cplusplus
+extern "C" {
+#endif
+H5_DLL hid_t H5FD_mpio_init(void);
+H5_DLL herr_t H5Pset_fapl_mpio(hid_t fapl_id, MPI_Comm comm, MPI_Info info);
+H5_DLL herr_t H5Pget_fapl_mpio(hid_t fapl_id, MPI_Comm *comm/*out*/,
+			MPI_Info *info/*out*/);
+H5_DLL herr_t H5Pset_dxpl_mpio(hid_t dxpl_id, H5FD_mpio_xfer_t xfer_mode);
+H5_DLL herr_t H5Pget_dxpl_mpio(hid_t dxpl_id, H5FD_mpio_xfer_t *xfer_mode/*out*/);
+H5_DLL herr_t H5Pset_dxpl_mpio_collective_opt(hid_t dxpl_id, H5FD_mpio_collective_opt_t opt_mode);
+H5_DLL herr_t H5Pset_dxpl_mpio_chunk_opt(hid_t dxpl_id, H5FD_mpio_chunk_opt_t opt_mode);
+H5_DLL herr_t H5Pset_dxpl_mpio_chunk_opt_num(hid_t dxpl_id, unsigned num_chunk_per_proc);
+H5_DLL herr_t H5Pset_dxpl_mpio_chunk_opt_ratio(hid_t dxpl_id, unsigned percent_num_proc_per_chunk);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5_HAVE_PARALLEL */
+
+#endif
+
diff --git a/install/include/H5FDmulti.h b/install/include/H5FDmulti.h
new file mode 100644
index 0000000000..0bd57182ec
--- /dev/null
+++ b/install/include/H5FDmulti.h
@@ -0,0 +1,43 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Robb Matzke <matzke@llnl.gov>
+ *              Monday, August  2, 1999
+ *
+ * Purpose:	The public header file for the "multi" driver.
+ */
+#ifndef H5FDmulti_H
+#define H5FDmulti_H
+
+#define H5FD_MULTI	(H5FD_multi_init())
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+H5_DLL hid_t H5FD_multi_init(void);
+H5_DLL herr_t H5Pset_fapl_multi(hid_t fapl_id, const H5FD_mem_t *memb_map,
+			 const hid_t *memb_fapl, const char * const *memb_name,
+			 const haddr_t *memb_addr, hbool_t relax);
+H5_DLL herr_t H5Pget_fapl_multi(hid_t fapl_id, H5FD_mem_t *memb_map/*out*/,
+			 hid_t *memb_fapl/*out*/, char **memb_name/*out*/,
+			 haddr_t *memb_addr/*out*/, hbool_t *relax/*out*/);
+H5_DLL herr_t H5Pset_fapl_split(hid_t fapl, const char *meta_ext,
+			 hid_t meta_plist_id, const char *raw_ext,
+			 hid_t raw_plist_id);
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/install/include/H5FDpkg.h b/install/include/H5FDpkg.h
new file mode 100644
index 0000000000..31dcf8db5d
--- /dev/null
+++ b/install/include/H5FDpkg.h
@@ -0,0 +1,64 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:	Quincey Koziol <koziol@hdfgroup.org>
+ *		Thursday, January  3, 2008
+ *
+ * Purpose:	This file contains declarations which are visible only within
+ *		the H5FD package.  Source files outside the H5FD package should
+ *		include H5FDprivate.h instead.
+ */
+#if !(defined H5FD_FRIEND || defined H5FD_MODULE)
+#error "Do not include this file outside the H5FD package!"
+#endif
+
+#ifndef _H5FDpkg_H
+#define _H5FDpkg_H
+
+/* Get package's private header */
+#include "H5FDprivate.h"	/* File drivers				*/
+
+/* Other private headers needed by this file */
+#include "H5FLprivate.h"	/* Free lists                           */
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+H5_DLL haddr_t H5FD_alloc_real(H5FD_t *file, hid_t dxpl_id, H5FD_mem_t type,
+    hsize_t size, haddr_t *align_addr, hsize_t *align_size);
+H5_DLL herr_t H5FD_free_real(H5FD_t *file, hid_t dxpl_id, H5FD_mem_t type,
+    haddr_t addr, hsize_t size);
+
+/* Testing functions */
+#ifdef H5FD_TESTING
+H5_DLL hbool_t H5FD_supports_swmr_test(const char *vfd_name);
+#endif /* H5FD_TESTING */
+
+#endif /* _H5FDpkg_H */
+
diff --git a/install/include/H5FDpublic.h b/install/include/H5FDpublic.h
new file mode 100644
index 0000000000..514d1bfba8
--- /dev/null
+++ b/install/include/H5FDpublic.h
@@ -0,0 +1,394 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Robb Matzke <matzke@llnl.gov>
+ *              Monday, July 26, 1999
+ */
+#ifndef _H5FDpublic_H
+#define _H5FDpublic_H
+
+#include "H5public.h"
+#include "H5Fpublic.h"		/*for H5F_close_degree_t */
+
+#define H5_HAVE_VFL 1 /*define a convenient app feature test*/
+#define H5FD_VFD_DEFAULT 0   /* Default VFL driver value */
+
+/* Types of allocation requests: see H5Fpublic.h  */
+typedef enum H5F_mem_t	H5FD_mem_t;
+
+/* Map "fractal heap" header blocks to 'ohdr' type file memory, since its
+ * a fair amount of work to add a new kind of file memory and they are similar
+ * enough to object headers and probably too minor to deserve their own type.
+ *
+ * Map "fractal heap" indirect blocks to 'ohdr' type file memory, since they
+ * are similar to fractal heap header blocks.
+ *
+ * Map "fractal heap" direct blocks to 'lheap' type file memory, since they
+ * will be replacing local heaps.
+ *
+ * Map "fractal heap" 'huge' objects to 'draw' type file memory, since they
+ * represent large objects that are directly stored in the file.
+ *
+ *      -QAK
+ */
+#define H5FD_MEM_FHEAP_HDR      H5FD_MEM_OHDR
+#define H5FD_MEM_FHEAP_IBLOCK   H5FD_MEM_OHDR
+#define H5FD_MEM_FHEAP_DBLOCK   H5FD_MEM_LHEAP
+#define H5FD_MEM_FHEAP_HUGE_OBJ H5FD_MEM_DRAW
+
+/* Map "free space" header blocks to 'ohdr' type file memory, since its
+ * a fair amount of work to add a new kind of file memory and they are similar
+ * enough to object headers and probably too minor to deserve their own type.
+ *
+ * Map "free space" serialized sections to 'lheap' type file memory, since they
+ * are similar enough to local heap info.
+ *
+ *      -QAK
+ */
+#define H5FD_MEM_FSPACE_HDR     H5FD_MEM_OHDR
+#define H5FD_MEM_FSPACE_SINFO   H5FD_MEM_LHEAP
+
+/* Map "shared object header message" master table to 'ohdr' type file memory,
+ * since its a fair amount of work to add a new kind of file memory and they are
+ * similar enough to object headers and probably too minor to deserve their own
+ * type.
+ *
+ * Map "shared object header message" indices to 'btree' type file memory,
+ * since they are similar enough to B-tree nodes.
+ *
+ *      -QAK
+ */
+#define H5FD_MEM_SOHM_TABLE     H5FD_MEM_OHDR
+#define H5FD_MEM_SOHM_INDEX     H5FD_MEM_BTREE
+
+/* Map "extensible array" header blocks to 'ohdr' type file memory, since its
+ * a fair amount of work to add a new kind of file memory and they are similar
+ * enough to object headers and probably too minor to deserve their own type.
+ *
+ * Map "extensible array" index blocks to 'ohdr' type file memory, since they
+ * are similar to extensible array header blocks.
+ *
+ * Map "extensible array" super blocks to 'btree' type file memory, since they
+ * are similar enough to B-tree nodes.
+ *
+ * Map "extensible array" data blocks & pages to 'lheap' type file memory, since
+ * they are similar enough to local heap info.
+ *
+ *      -QAK
+ */
+#define H5FD_MEM_EARRAY_HDR     H5FD_MEM_OHDR
+#define H5FD_MEM_EARRAY_IBLOCK  H5FD_MEM_OHDR
+#define H5FD_MEM_EARRAY_SBLOCK  H5FD_MEM_BTREE
+#define H5FD_MEM_EARRAY_DBLOCK  H5FD_MEM_LHEAP
+#define H5FD_MEM_EARRAY_DBLK_PAGE  H5FD_MEM_LHEAP
+
+/* Map "fixed array" header blocks to 'ohdr' type file memory, since its
+ * a fair amount of work to add a new kind of file memory and they are similar
+ * enough to object headers and probably too minor to deserve their own type.
+ *
+ * Map "fixed array" data blocks & pages to 'lheap' type file memory, since
+ * they are similar enough to local heap info.
+ *
+ */
+#define H5FD_MEM_FARRAY_HDR     H5FD_MEM_OHDR
+#define H5FD_MEM_FARRAY_DBLOCK  H5FD_MEM_LHEAP
+#define H5FD_MEM_FARRAY_DBLK_PAGE  H5FD_MEM_LHEAP
+
+/*
+ * A free-list map which maps all types of allocation requests to a single
+ * free list.  This is useful for drivers that don't really care about
+ * keeping different requests segregated in the underlying file and which
+ * want to make most efficient reuse of freed memory.  The use of the
+ * H5FD_MEM_SUPER free list is arbitrary.
+ */
+#define H5FD_FLMAP_SINGLE {						      \
+    H5FD_MEM_SUPER,			/*default*/			      \
+    H5FD_MEM_SUPER,			/*super*/			      \
+    H5FD_MEM_SUPER,			/*btree*/			      \
+    H5FD_MEM_SUPER,			/*draw*/			      \
+    H5FD_MEM_SUPER,			/*gheap*/			      \
+    H5FD_MEM_SUPER,			/*lheap*/			      \
+    H5FD_MEM_SUPER			/*ohdr*/			      \
+}
+
+/*
+ * A free-list map which segregates requests into `raw' or `meta' data
+ * pools.
+ */
+#define H5FD_FLMAP_DICHOTOMY {						      \
+    H5FD_MEM_SUPER,			/*default*/			      \
+    H5FD_MEM_SUPER,			/*super*/			      \
+    H5FD_MEM_SUPER,			/*btree*/			      \
+    H5FD_MEM_DRAW,			/*draw*/			      \
+    H5FD_MEM_DRAW,			/*gheap*/			      \
+    H5FD_MEM_SUPER,			/*lheap*/			      \
+    H5FD_MEM_SUPER			/*ohdr*/			      \
+}
+
+/*
+ * The default free list map which causes each request type to use it's own
+ * free-list.
+ */
+#define H5FD_FLMAP_DEFAULT {						      \
+    H5FD_MEM_DEFAULT,			/*default*/			      \
+    H5FD_MEM_DEFAULT,			/*super*/			      \
+    H5FD_MEM_DEFAULT,			/*btree*/			      \
+    H5FD_MEM_DEFAULT,			/*draw*/			      \
+    H5FD_MEM_DEFAULT,			/*gheap*/			      \
+    H5FD_MEM_DEFAULT,			/*lheap*/			      \
+    H5FD_MEM_DEFAULT			/*ohdr*/			      \
+}
+
+
+/* Define VFL driver features that can be enabled on a per-driver basis */
+/* These are returned with the 'query' function pointer in H5FD_class_t */
+    /*
+     * Defining H5FD_FEAT_AGGREGATE_METADATA for a VFL driver means that
+     * the library will attempt to allocate a larger block for metadata and
+     * then sub-allocate each metadata request from that larger block.
+     */
+#define H5FD_FEAT_AGGREGATE_METADATA    0x00000001
+    /*
+     * Defining H5FD_FEAT_ACCUMULATE_METADATA for a VFL driver means that
+     * the library will attempt to cache metadata as it is written to the file
+     * and build up a larger block of metadata to eventually pass to the VFL
+     * 'write' routine.
+     *
+     * Distinguish between updating the metadata accumulator on writes and
+     * reads.  This is particularly (perhaps only, even) important for MPI-I/O
+     * where we guarantee that writes are collective, but reads may not be.
+     * If we were to allow the metadata accumulator to be written during a
+     * read operation, the application would hang.
+     */
+#define H5FD_FEAT_ACCUMULATE_METADATA_WRITE     0x00000002
+#define H5FD_FEAT_ACCUMULATE_METADATA_READ      0x00000004
+#define H5FD_FEAT_ACCUMULATE_METADATA   (H5FD_FEAT_ACCUMULATE_METADATA_WRITE|H5FD_FEAT_ACCUMULATE_METADATA_READ)
+    /*
+     * Defining H5FD_FEAT_DATA_SIEVE for a VFL driver means that
+     * the library will attempt to cache raw data as it is read from/written to
+     * a file in a "data seive" buffer.  See Rajeev Thakur's papers:
+     *  http://www.mcs.anl.gov/~thakur/papers/romio-coll.ps.gz
+     *  http://www.mcs.anl.gov/~thakur/papers/mpio-high-perf.ps.gz
+     */
+#define H5FD_FEAT_DATA_SIEVE            0x00000008
+    /*
+     * Defining H5FD_FEAT_AGGREGATE_SMALLDATA for a VFL driver means that
+     * the library will attempt to allocate a larger block for "small" raw data
+     * and then sub-allocate "small" raw data requests from that larger block.
+     */
+#define H5FD_FEAT_AGGREGATE_SMALLDATA   0x00000010
+    /*
+     * Defining H5FD_FEAT_IGNORE_DRVRINFO for a VFL driver means that
+     * the library will ignore the driver info that is encoded in the file
+     * for the VFL driver.  (This will cause the driver info to be eliminated
+     * from the file when it is flushed/closed, if the file is opened R/W).
+     */
+#define H5FD_FEAT_IGNORE_DRVRINFO       0x00000020
+    /*
+     * Defining the H5FD_FEAT_DIRTY_DRVRINFO_LOAD for a VFL driver means that
+     * the library will mark the driver info dirty when the file is opened
+     * R/W.  This will cause the driver info to be re-encoded when the file
+     * is flushed/closed.
+     */
+#define H5FD_FEAT_DIRTY_DRVRINFO_LOAD   0x00000040
+    /*
+     * Defining H5FD_FEAT_POSIX_COMPAT_HANDLE for a VFL driver means that
+     * the handle for the VFD (returned with the 'get_handle' callback) is
+     * of type 'int' and is compatible with POSIX I/O calls.
+     */
+#define H5FD_FEAT_POSIX_COMPAT_HANDLE   0x00000080    
+    /*
+     * Defining H5FD_FEAT_HAS_MPI for a VFL driver means that
+     * the driver makes use of MPI communication and code may retrieve
+     * communicator/rank information from it
+     */
+#define H5FD_FEAT_HAS_MPI               0x00000100
+    /*
+     * Defining the H5FD_FEAT_ALLOCATE_EARLY for a VFL driver will force
+     * the library to use the H5D_ALLOC_TIME_EARLY on dataset create
+     * instead of the default H5D_ALLOC_TIME_LATE
+     */
+#define H5FD_FEAT_ALLOCATE_EARLY        0x00000200
+    /* 
+     * Defining H5FD_FEAT_ALLOW_FILE_IMAGE for a VFL driver means that
+     * the driver is able to use a file image in the fapl as the initial
+     * contents of a file.
+     */
+#define H5FD_FEAT_ALLOW_FILE_IMAGE      0x00000400
+    /*
+     * Defining H5FD_FEAT_CAN_USE_FILE_IMAGE_CALLBACKS for a VFL driver
+     * means that the driver is able to use callbacks to make a copy of the
+     * image to store in memory.
+     */
+#define H5FD_FEAT_CAN_USE_FILE_IMAGE_CALLBACKS 0x00000800
+    /*
+     * Defining H5FD_FEAT_SUPPORTS_SWMR_IO for a VFL driver means that the
+     * driver supports the single-writer/multiple-readers I/O pattern.
+     */
+#define H5FD_FEAT_SUPPORTS_SWMR_IO      0x00001000
+    /*
+     * Defining H5FD_FEAT_USE_ALLOC_SIZE for a VFL driver
+     * means that the library will just pass the allocation size to the
+     * the driver's allocation callback which will eventually handle alignment.
+     * This is specifically used for the multi/split driver.
+     */
+#define H5FD_FEAT_USE_ALLOC_SIZE	0x00002000
+    /*
+     * Defining H5FD_FEAT_PAGED_AGGR for a VFL driver
+     * means that the driver needs special file space mapping for paged aggregation.
+     * This is specifically used for the multi/split driver.
+     */
+#define H5FD_FEAT_PAGED_AGGR		0x00004000
+    /*
+     * Defining H5FD_FEAT_DEFAULT_VFD_COMPATIBLE for a VFL driver
+     * that creates a file which is compatible with the default VFD.
+     * Generally, this means that the VFD creates a single file that follows
+     * the canonical HDF5 file format.
+     */
+#define H5FD_FEAT_DEFAULT_VFD_COMPATIBLE        0x00008000
+
+
+/* Forward declaration */
+typedef struct H5FD_t H5FD_t;
+
+/* Class information for each file driver */
+typedef struct H5FD_class_t {
+    const char *name;
+    haddr_t maxaddr;
+    H5F_close_degree_t fc_degree;
+    herr_t  (*terminate)(void);
+    hsize_t (*sb_size)(H5FD_t *file);
+    herr_t  (*sb_encode)(H5FD_t *file, char *name/*out*/,
+                         unsigned char *p/*out*/);
+    herr_t  (*sb_decode)(H5FD_t *f, const char *name, const unsigned char *p);
+    size_t  fapl_size;
+    void *  (*fapl_get)(H5FD_t *file);
+    void *  (*fapl_copy)(const void *fapl);
+    herr_t  (*fapl_free)(void *fapl);
+    size_t  dxpl_size;
+    void *  (*dxpl_copy)(const void *dxpl);
+    herr_t  (*dxpl_free)(void *dxpl);
+    H5FD_t *(*open)(const char *name, unsigned flags, hid_t fapl,
+                    haddr_t maxaddr);
+    herr_t  (*close)(H5FD_t *file);
+    int     (*cmp)(const H5FD_t *f1, const H5FD_t *f2);
+    herr_t  (*query)(const H5FD_t *f1, unsigned long *flags);
+    herr_t  (*get_type_map)(const H5FD_t *file, H5FD_mem_t *type_map);
+    haddr_t (*alloc)(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, hsize_t size);
+    herr_t  (*free)(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id,
+                    haddr_t addr, hsize_t size);
+    haddr_t (*get_eoa)(const H5FD_t *file, H5FD_mem_t type);
+    herr_t  (*set_eoa)(H5FD_t *file, H5FD_mem_t type, haddr_t addr);
+    haddr_t (*get_eof)(const H5FD_t *file, H5FD_mem_t type);
+    herr_t  (*get_handle)(H5FD_t *file, hid_t fapl, void**file_handle);
+    herr_t  (*read)(H5FD_t *file, H5FD_mem_t type, hid_t dxpl,
+                    haddr_t addr, size_t size, void *buffer);
+    herr_t  (*write)(H5FD_t *file, H5FD_mem_t type, hid_t dxpl,
+                     haddr_t addr, size_t size, const void *buffer);
+    herr_t  (*flush)(H5FD_t *file, hid_t dxpl_id, hbool_t closing);
+    herr_t  (*truncate)(H5FD_t *file, hid_t dxpl_id, hbool_t closing);
+    herr_t  (*lock)(H5FD_t *file, hbool_t rw);
+    herr_t  (*unlock)(H5FD_t *file);
+    H5FD_mem_t fl_map[H5FD_MEM_NTYPES];
+} H5FD_class_t;
+
+/* A free list is a singly-linked list of address/size pairs. */
+typedef struct H5FD_free_t {
+    haddr_t		addr;
+    hsize_t		size;
+    struct H5FD_free_t	*next;
+} H5FD_free_t;
+
+/*
+ * The main datatype for each driver. Public fields common to all drivers
+ * are declared here and the driver appends private fields in memory.
+ */
+struct H5FD_t {
+    hid_t               driver_id;      /*driver ID for this file   */
+    const H5FD_class_t *cls;            /*constant class info       */
+    unsigned long       fileno;         /* File 'serial' number     */
+    unsigned            access_flags;   /* File access flags (from create or open) */
+    unsigned long       feature_flags;  /* VFL Driver feature Flags */
+    haddr_t             maxaddr;        /* For this file, overrides class */
+    haddr_t             base_addr;      /* Base address for HDF5 data w/in file */
+
+    /* Space allocation management fields */
+    hsize_t             threshold;      /* Threshold for alignment  */
+    hsize_t             alignment;      /* Allocation alignment     */
+    hbool_t             paged_aggr;     /* Paged aggregation for file space is enabled or not */
+};
+
+/* Define enum for the source of file image callbacks */
+typedef enum {
+    H5FD_FILE_IMAGE_OP_NO_OP,
+    H5FD_FILE_IMAGE_OP_PROPERTY_LIST_SET,     
+    H5FD_FILE_IMAGE_OP_PROPERTY_LIST_COPY,
+    H5FD_FILE_IMAGE_OP_PROPERTY_LIST_GET,
+    H5FD_FILE_IMAGE_OP_PROPERTY_LIST_CLOSE,
+    H5FD_FILE_IMAGE_OP_FILE_OPEN,
+    H5FD_FILE_IMAGE_OP_FILE_RESIZE,
+    H5FD_FILE_IMAGE_OP_FILE_CLOSE
+} H5FD_file_image_op_t;
+
+/* Define structure to hold file image callbacks */
+typedef struct {
+    void   *(*image_malloc)(size_t size, H5FD_file_image_op_t file_image_op, 
+                            void *udata);
+    void   *(*image_memcpy)(void *dest, const void *src, size_t size,
+                            H5FD_file_image_op_t file_image_op, void *udata);
+    void   *(*image_realloc)(void *ptr, size_t size, 
+                            H5FD_file_image_op_t file_image_op, void *udata);
+    herr_t  (*image_free)(void *ptr, H5FD_file_image_op_t file_image_op, 
+                          void *udata);
+    void   *(*udata_copy)(void *udata);
+    herr_t  (*udata_free)(void *udata);
+    void *udata;
+} H5FD_file_image_callbacks_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Function prototypes */
+H5_DLL hid_t H5FDregister(const H5FD_class_t *cls);
+H5_DLL herr_t H5FDunregister(hid_t driver_id);
+H5_DLL H5FD_t *H5FDopen(const char *name, unsigned flags, hid_t fapl_id,
+                        haddr_t maxaddr);
+H5_DLL herr_t H5FDclose(H5FD_t *file);
+H5_DLL int H5FDcmp(const H5FD_t *f1, const H5FD_t *f2);
+H5_DLL int H5FDquery(const H5FD_t *f, unsigned long *flags);
+H5_DLL haddr_t H5FDalloc(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, hsize_t size);
+H5_DLL herr_t H5FDfree(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id,
+                       haddr_t addr, hsize_t size);
+H5_DLL haddr_t H5FDget_eoa(H5FD_t *file, H5FD_mem_t type);
+H5_DLL herr_t H5FDset_eoa(H5FD_t *file, H5FD_mem_t type, haddr_t eoa);
+H5_DLL haddr_t H5FDget_eof(H5FD_t *file, H5FD_mem_t type);
+H5_DLL herr_t H5FDget_vfd_handle(H5FD_t *file, hid_t fapl, void**file_handle);
+H5_DLL herr_t H5FDread(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id,
+                       haddr_t addr, size_t size, void *buf/*out*/);
+H5_DLL herr_t H5FDwrite(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id,
+                        haddr_t addr, size_t size, const void *buf);
+H5_DLL herr_t H5FDflush(H5FD_t *file, hid_t dxpl_id, hbool_t closing);
+H5_DLL herr_t H5FDtruncate(H5FD_t *file, hid_t dxpl_id, hbool_t closing);
+H5_DLL herr_t H5FDlock(H5FD_t *file, hbool_t rw);
+H5_DLL herr_t H5FDunlock(H5FD_t *file);
+
+/* Allows querying a VFD ID for features before the file is opened */
+H5_DLL herr_t H5FDdriver_query(hid_t driver_id, unsigned long *flags/*out*/);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/install/include/H5FDsec2.h b/install/include/H5FDsec2.h
new file mode 100644
index 0000000000..a4ade0b354
--- /dev/null
+++ b/install/include/H5FDsec2.h
@@ -0,0 +1,37 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Robb Matzke <matzke@llnl.gov>
+ *              Monday, August  2, 1999
+ *
+ * Purpose:	The public header file for the sec2 driver.
+ */
+#ifndef H5FDsec2_H
+#define H5FDsec2_H
+
+#define H5FD_SEC2	(H5FD_sec2_init())
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5_DLL hid_t H5FD_sec2_init(void);
+H5_DLL herr_t H5Pset_fapl_sec2(hid_t fapl_id);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/install/include/H5FDstdio.h b/install/include/H5FDstdio.h
new file mode 100644
index 0000000000..f99aacf1f0
--- /dev/null
+++ b/install/include/H5FDstdio.h
@@ -0,0 +1,38 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Robb Matzke <matzke@llnl.gov>
+ *              Monday, August  2, 1999
+ *
+ * Purpose:	The public header file for the sec2 driver.
+ */
+#ifndef H5FDstdio_H
+#define H5FDstdio_H
+
+#include "H5Ipublic.h"
+
+#define H5FD_STDIO	(H5FD_stdio_init())
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5_DLL hid_t H5FD_stdio_init(void);
+H5_DLL herr_t H5Pset_fapl_stdio(hid_t fapl_id);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5FDwindows.h b/install/include/H5FDwindows.h
new file mode 100644
index 0000000000..5cf68a1ccc
--- /dev/null
+++ b/install/include/H5FDwindows.h
@@ -0,0 +1,37 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Scott Wegner <swegner@hdfgroup.org>
+ *				Based on code by Robb Matzke
+ *              Thursday, May 24 2007
+ *
+ * Purpose:	The public header file for the windows driver.
+ */
+#ifndef H5FDwindows_H
+#define H5FDwindows_H
+
+#define H5FD_WINDOWS	(H5FD_sec2_init())
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+H5_DLL herr_t H5Pset_fapl_windows(hid_t fapl_id);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* H5FDwindows_H */
+
diff --git a/install/include/H5FSpkg.h b/install/include/H5FSpkg.h
new file mode 100644
index 0000000000..df1d92f984
--- /dev/null
+++ b/install/include/H5FSpkg.h
@@ -0,0 +1,251 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Quincey Koziol <koziol@hdfgroup.org>
+ *              Tuesday, May  2, 2006
+ *
+ * Purpose:     This file contains declarations which are visible only within
+ *              the H5FS package.  Source files outside the H5FS package should
+ *              include H5FSprivate.h instead.
+ */
+#if !(defined H5FS_FRIEND || defined H5FS_MODULE)
+#error "Do not include this file outside the H5FS package!"
+#endif
+
+#ifndef _H5FSpkg_H
+#define _H5FSpkg_H
+
+/* Uncomment this macro to enable debugging output for free space manager */
+/* #define H5FS_DEBUG */
+
+/* Uncomment this macro to enable debugging output for free space sections */
+/* #define H5FS_SINFO_DEBUG */
+
+/* Uncomment this macro to enable extra sanity checking */
+/* #define H5FS_DEBUG_ASSERT */
+
+/* Get package's private header */
+#include "H5FSprivate.h"    /* File free space                      */
+
+/* Other private headers needed by this file */
+#include "H5ACprivate.h"    /* Metadata cache                       */
+#include "H5SLprivate.h"    /* Skip lists                           */
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* Size of checksum information (on disk) */
+#define H5FS_SIZEOF_CHKSUM      4
+
+/* "Standard" size of prefix information for free space metadata */
+#define H5FS_METADATA_PREFIX_SIZE (                                           \
+    H5_SIZEOF_MAGIC   /* Signature */                                         \
+    + 1 /* Version */                                                         \
+    + H5FS_SIZEOF_CHKSUM /* Metadata checksum */                              \
+    )
+
+/* Size of the fractal heap header on disk */
+#define H5FS_HEADER_SIZE(f) (                                                 \
+    /* General metadata fields */                                             \
+    H5FS_METADATA_PREFIX_SIZE                                                 \
+                                                                              \
+    /* Free space header specific fields */                                   \
+    + 1 /* Client ID */                                                       \
+    + (unsigned)H5F_SIZEOF_SIZE(f) /* Total free space tracked */                       \
+    + (unsigned)H5F_SIZEOF_SIZE(f) /* Total # of sections tracked */                    \
+    + (unsigned)H5F_SIZEOF_SIZE(f) /* # of serializable sections tracked */             \
+    + (unsigned)H5F_SIZEOF_SIZE(f) /* # of ghost sections tracked */                    \
+    + 2 /* Number of section classes */                                       \
+    + 2 /* Shrink percent */                                                  \
+    + 2 /* Expand percent */                                                  \
+    + 2 /* Size of address space for sections (log2 of value) */              \
+    + (unsigned)H5F_SIZEOF_SIZE(f) /* Max. size of section to track */                  \
+    + (unsigned)H5F_SIZEOF_ADDR(f) /* Address of serialized free space sections */      \
+    + (unsigned)H5F_SIZEOF_SIZE(f) /* Size of serialized free space sections used */    \
+    + (unsigned)H5F_SIZEOF_SIZE(f) /* Allocated size of serialized free space sections */ \
+    )
+
+/* Size of the free space serialized sections on disk */
+#define H5FS_SINFO_PREFIX_SIZE(f) (                                           \
+    /* General metadata fields */                                             \
+    H5FS_METADATA_PREFIX_SIZE                                                 \
+                                                                              \
+    /* Free space serialized sections specific fields */                      \
+    + (unsigned)H5F_SIZEOF_ADDR(f) /* Address of free space header for these sections */ \
+    )
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/* Callback info for loading a free space header into the cache */
+typedef struct H5FS_hdr_cache_ud_t {
+    H5F_t *f;                  /* File that free space header is within */
+    uint16_t nclasses;                            /* Number of section classes */
+    const H5FS_section_class_t **classes;       /* Array of section class info */
+    void *cls_init_udata;                       /* Pointer to class init user data */
+    haddr_t addr;              /* Address of header */
+} H5FS_hdr_cache_ud_t;
+
+/* Callback info for loading free space section info into the cache */
+typedef struct H5FS_sinfo_cache_ud_t {
+    H5F_t *f;                  /* File that free space section info is within */
+    H5FS_t *fspace;            /* free space manager */
+    hid_t dxpl_id;
+} H5FS_sinfo_cache_ud_t;
+
+/* Free space section bin info */
+typedef struct H5FS_bin_t {
+    size_t tot_sect_count;      /* Total # of sections in this bin */
+    size_t serial_sect_count;   /* # of serializable sections in this bin */
+    size_t ghost_sect_count;    /* # of un-serializable sections in this bin */
+    H5SL_t *bin_list;           /* Skip list of differently sized sections */
+} H5FS_bin_t;
+
+/* Free space node for free space sections of the same size */
+typedef struct H5FS_node_t {
+    hsize_t sect_size;          /* Size of all sections on list */
+    size_t serial_count;        /* # of serializable sections on list */
+    size_t ghost_count;         /* # of un-serializable sections on list */
+    H5SL_t *sect_list;          /* Skip list to hold pointers to actual free list section node */
+} H5FS_node_t;
+
+/* Free space section info */
+typedef struct H5FS_sinfo_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+/* Stored information */
+    H5FS_bin_t *bins;           /* Array of lists of lists of free sections   */
+
+/* Computed/cached values */
+    hbool_t dirty;              /* Whether this info in memory is out of sync w/info in file */
+    unsigned nbins;             /* Number of bins                             */
+    size_t serial_size;         /* Total size of all serializable sections    */
+    size_t tot_size_count;      /* Total number of differently sized sections */
+    size_t serial_size_count;   /* Total number of differently sized serializable sections */
+    size_t ghost_size_count;    /* Total number of differently sized un-serializable sections */
+    unsigned sect_prefix_size;  /* Size of the section serialization prefix (in bytes) */
+    unsigned sect_off_size;     /* Size of a section offset (in bytes)        */
+    unsigned sect_len_size;     /* Size of a section length (in bytes)        */
+    H5FS_t *fspace;             /* Pointer to free space manager that owns sections */
+
+/* Memory data structures (not stored directly) */
+    H5SL_t *merge_list;         /* Skip list to hold sections for detecting merges */
+} H5FS_sinfo_t;
+
+/* Free space header info */
+struct H5FS_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+/* Stored information */
+    /* Statistics about sections managed */
+    hsize_t tot_space;          /* Total amount of space tracked              */
+    hsize_t tot_sect_count;     /* Total # of sections tracked                */
+    hsize_t serial_sect_count;  /* # of serializable sections tracked         */
+    hsize_t ghost_sect_count;   /* # of un-serializable sections tracked      */
+
+    /* Creation parameters */
+    H5FS_client_t client;       /* Type of user of this free space manager    */
+    uint16_t nclasses;         /* Number of section classes handled          */
+    unsigned shrink_percent;    /* Percent of "normal" serialized size to shrink serialized space at */
+    unsigned expand_percent;    /* Percent of "normal" serialized size to expand serialized space at */
+    unsigned max_sect_addr;     /* Size of address space free sections are within (log2 of actual value) */
+    hsize_t max_sect_size;      /* Maximum size of section to track */
+
+    /* Serialized section information */
+    haddr_t sect_addr;          /* Address of the section info in the file    */
+    hsize_t sect_size;          /* Size of the section info in the file       */
+    hsize_t alloc_sect_size;    /* Allocated size of the section info in the file */
+
+/* Computed/cached values */
+    unsigned rc;                /* Count of outstanding references to struct  */
+    haddr_t addr;               /* Address of free space header on disk       */
+    size_t hdr_size;            /* Size of free space header on disk          */
+    H5FS_sinfo_t *sinfo;        /* Section information                        */
+    hbool_t swmr_write;         /* Flag indicating the file is opened with SWMR-write access */
+    unsigned sinfo_lock_count;  /* # of times the section info has been locked */
+    hbool_t sinfo_protected;    /* Whether the section info was protected when locked */
+    hbool_t sinfo_modified;     /* Whether the section info has been modified while locked */
+    unsigned sinfo_accmode;     /* Access mode for protecting the section info */
+                                /* must be either H5C__NO_FLAGS_SET (i.e r/w)  */
+				/* or H5AC__READ_ONLY_FLAG (i.e. r/o).         */
+    size_t max_cls_serial_size; /* Max. additional size of serialized form of section */
+    hsize_t    alignment;      	/* Alignment                            */
+    hsize_t    align_thres;     /* Threshold for alignment              */
+
+
+/* Memory data structures (not stored directly) */
+    H5FS_section_class_t *sect_cls; /* Array of section classes for this free list */
+};
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+/* Declare a free list to manage the H5FS_node_t struct */
+H5FL_EXTERN(H5FS_node_t);
+
+/* Declare a free list to manage the H5FS_bin_t sequence information */
+H5FL_SEQ_EXTERN(H5FS_bin_t);
+
+/* Declare a free list to manage the H5FS_sinfo_t struct */
+H5FL_EXTERN(H5FS_sinfo_t);
+
+/* Declare a free list to manage the H5FS_t struct */
+H5FL_EXTERN(H5FS_t);
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+/* Generic routines */
+H5_DLL herr_t H5FS__create_flush_depend(H5AC_info_t *parent_entry,
+    H5AC_info_t *child_entry);
+H5_DLL herr_t H5FS__destroy_flush_depend(H5AC_info_t *parent_entry,
+    H5AC_info_t *child_entry);
+
+/* Free space manager header routines */
+H5_DLL H5FS_t *H5FS__new(const H5F_t *f, uint16_t nclasses,
+    const H5FS_section_class_t *classes[], void *cls_init_udata);
+H5_DLL herr_t H5FS_incr(H5FS_t *fspace);
+H5_DLL herr_t H5FS_decr(H5FS_t *fspace);
+H5_DLL herr_t H5FS_dirty(H5FS_t *fspace);
+
+/* Free space section routines */
+H5_DLL H5FS_sinfo_t *H5FS_sinfo_new(H5F_t *f, H5FS_t *fspace);
+
+/* Routines for destroying structures */
+H5_DLL herr_t H5FS__hdr_dest(H5FS_t *hdr);
+H5_DLL herr_t H5FS_sinfo_dest(H5FS_sinfo_t *sinfo);
+
+/* Sanity check routines */
+#ifdef H5FS_DEBUG
+H5_DLL herr_t H5FS_assert(const H5FS_t *fspace, hid_t dxpl_id);
+H5_DLL herr_t H5FS_sect_assert(const H5FS_t *fspace, hid_t dxpl_id);
+#endif /* H5FS_DEBUG */
+
+/* Testing routines */
+#ifdef H5FS_TESTING
+H5_DLL herr_t H5FS_get_cparam_test(const H5FS_t *fh, H5FS_create_t *cparam);
+H5_DLL int H5FS_cmp_cparam_test(const H5FS_create_t *cparam1, const H5FS_create_t *cparam2);
+#endif /* H5FS_TESTING */
+
+#endif /* _H5FSpkg_H */
+
diff --git a/install/include/H5FSpublic.h b/install/include/H5FSpublic.h
new file mode 100644
index 0000000000..3090d0dd9f
--- /dev/null
+++ b/install/include/H5FSpublic.h
@@ -0,0 +1,52 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5FSpublic.h
+ *                      May  2 2006
+ *                      Quincey Koziol <koziol@hdfgroup.org>
+ *
+ * Purpose:             Public declarations for the file free space package.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#ifndef _H5FSpublic_H
+#define _H5FSpublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/**********************************/
+/* Public API Function Prototypes */
+/**********************************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _H5FSpublic_H */
+
diff --git a/install/include/H5FaccProp.h b/install/include/H5FaccProp.h
new file mode 100644
index 0000000000..25631638d3
--- /dev/null
+++ b/install/include/H5FaccProp.h
@@ -0,0 +1,166 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5FileAccPropList_H
+#define __H5FileAccPropList_H
+
+namespace H5 {
+
+/*! \class FileAccPropList
+    \brief Class FileAccPropList inherits from PropList and provides
+    wrappers for the HDF5 file access property list.
+
+    Inheritance: PropList -> IdComponent
+*/
+class H5_DLLCPP FileAccPropList : public PropList {
+   public:
+        ///\brief Default file access property list.
+        static const FileAccPropList& DEFAULT;
+
+        // Creates a file access property list.
+        FileAccPropList();
+
+        // Modifies this property list to use the H5FD_STDIO driver
+        void setStdio() const;
+
+        // Set file driver for this property list
+        void setDriver(hid_t new_driver_id, const void *new_driver_info) const;
+
+        // Returns a low-level file driver identifier.
+        hid_t getDriver() const;
+
+        // Sets offset for family driver.
+        void setFamilyOffset(hsize_t offset) const;
+
+        // Gets offset for family driver.
+        hsize_t getFamilyOffset() const;
+
+        // Modifies this file access property list to use the sec2 driver.
+        void setSec2() const;
+
+        // Modifies this file access property list to use the H5FD_CORE
+        // driver.
+        void setCore (size_t increment, hbool_t backing_store) const;
+
+        // Queries H5FD_CORE driver properties.
+        void getCore (size_t& increment, hbool_t& backing_store) const;
+
+        // Sets this file access properties list to the family driver.
+        void setFamily(hsize_t memb_size, const FileAccPropList& memb_plist) const;
+
+        // Returns information about the family file access property list.
+        void getFamily(hsize_t& memb_size, FileAccPropList& memb_plist) const;
+        FileAccPropList getFamily(hsize_t& memb_size) const;
+
+        // Emulates the old split file driver,
+        void setSplit(const FileAccPropList& meta_plist,
+                      const FileAccPropList& raw_plist,
+                      const char* meta_ext = ".meta",
+                      const char* raw_ext = ".raw") const;
+        void setSplit(const FileAccPropList& meta_plist,
+                      const FileAccPropList& raw_plist,
+                      const H5std_string& meta_ext = ".meta",
+                      const H5std_string& raw_ext = ".raw") const;
+
+        // Sets the maximum size of the data sieve buffer.
+        void setSieveBufSize(size_t bufsize) const;
+
+        // Returns the current settings for the data sieve buffer size
+        // property
+        size_t getSieveBufSize() const;
+
+        // Sets the minimum size of metadata block allocations.
+        void setMetaBlockSize(hsize_t &block_size) const;
+
+        // Returns the current metadata block size setting.
+        hsize_t getMetaBlockSize() const;
+
+        // Modifies this file access property list to use the logging driver.
+        void setLog(const char *logfile, unsigned flags, size_t buf_size) const;
+        void setLog(const H5std_string& logfile, unsigned flags, size_t buf_size) const;
+
+        // Sets alignment properties of this file access property list
+        void setAlignment(hsize_t threshold = 1, hsize_t alignment = 1) const;
+
+        // Retrieves the current settings for alignment properties from
+        // this property list.
+        void getAlignment(hsize_t& threshold, hsize_t& alignment) const;
+
+        // Sets data type for multi driver.
+        void setMultiType(H5FD_mem_t dtype) const;
+
+        // Returns the data type property for MULTI driver.
+        H5FD_mem_t getMultiType() const;
+
+        // Sets the meta data cache and raw data chunk cache parameters.
+        void setCache(int mdc_nelmts, size_t rdcc_nelmts, size_t rdcc_nbytes, double rdcc_w0) const;
+
+        // Queries the meta data cache and raw data chunk cache parameters.
+        void getCache(int& mdc_nelmts, size_t& rdcc_nelmts, size_t& rdcc_nbytes, double& rdcc_w0) const;
+
+        // Sets the degree for the file close behavior.
+        void setFcloseDegree(H5F_close_degree_t degree) const;
+
+        // Returns the degree for the file close behavior.
+        H5F_close_degree_t getFcloseDegree() const;
+
+        // Sets file access property list to use the H5FD_DIRECT driver.
+        void setFileAccDirect(size_t boundary, size_t block_size, size_t cbuf_size) const;
+
+        // Retrieves information about the direct file access property list.
+        void getFileAccDirect(size_t &boundary, size_t &block_size, size_t &cbuf_size) const;
+
+        // Sets garbage collecting references flag.
+        void setGcReferences(unsigned gc_ref = 0) const;
+
+        // Returns garbage collecting references setting.
+        unsigned getGcReferences() const;
+
+        // Sets bounds on versions of library format to be used when creating
+        // or writing objects.
+        void setLibverBounds(H5F_libver_t libver_low, H5F_libver_t libver_high) const;
+
+        // Gets the current settings for the library version format bounds.
+        void getLibverBounds(H5F_libver_t& libver_low, H5F_libver_t& libver_high) const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("FileAccPropList"); }
+
+        // Copy constructor: creates a copy of a FileAccPropList object.
+        FileAccPropList(const FileAccPropList& original);
+
+        // Creates a copy of an existing file access property list
+        // using the property list id.
+        FileAccPropList (const hid_t plist_id);
+
+        // Noop destructor
+        virtual ~FileAccPropList();
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+        // Deletes the global constant, should only be used by the library
+        static void deleteConstants();
+
+    private:
+        static FileAccPropList* DEFAULT_;
+
+        // Creates the global constant, should only be used by the library
+        static FileAccPropList* getConstant();
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end of FileAccPropList
+} // namespace H5
+
+#endif // __H5FileAccPropList_H
diff --git a/install/include/H5FcreatProp.h b/install/include/H5FcreatProp.h
new file mode 100644
index 0000000000..da620d4b1e
--- /dev/null
+++ b/install/include/H5FcreatProp.h
@@ -0,0 +1,109 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5FileCreatPropList_H
+#define __H5FileCreatPropList_H
+
+namespace H5 {
+
+/*! \class FileCreatPropList
+    \brief Class FileCreatPropList inherits from PropList and provides
+    wrappers for the HDF5 file create property list.
+
+    Inheritance: PropList -> IdComponent
+*/
+class H5_DLLCPP FileCreatPropList : public PropList {
+   public:
+        ///\brief Default file creation property list.
+        static const FileCreatPropList& DEFAULT;
+
+        // Creates a file create property list.
+        FileCreatPropList();
+
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+        // Retrieves version information for various parts of a file.
+        void getVersion(unsigned& super, unsigned& freelist, unsigned& stab, unsigned& shhdr) const;
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+        // Sets the userblock size field of a file creation property list.
+        void setUserblock(hsize_t size) const;
+
+        // Gets the size of a user block in this file creation property list.
+        hsize_t getUserblock() const;
+
+        // Retrieves the size-of address and size quantities stored in a
+        // file according to this file creation property list.
+        void getSizes(size_t& sizeof_addr, size_t& sizeof_size) const;
+
+        // Sets file size-of addresses and sizes.
+        void setSizes(size_t sizeof_addr = 4, size_t sizeof_size = 4) const;
+
+        // Retrieves the size of the symbol table B-tree 1/2 rank and the
+        // symbol table leaf node 1/2 size.
+        void getSymk(unsigned& int_nodes_k, unsigned& leaf_nodes_k) const;
+
+        // Sets the size of parameters used to control the symbol table nodes.
+        void setSymk(unsigned int_nodes_k, unsigned leaf_nodes_k) const;
+
+        // Returns the 1/2 rank of an indexed storage B-tree.
+        unsigned getIstorek() const;
+
+        // Sets the size of parameter used to control the B-trees for
+        // indexing chunked datasets.
+        void setIstorek(unsigned ik) const;
+
+        // Sets the strategy and the threshold value that the library will
+        // will employ in managing file space.
+        void setFileSpaceStrategy(H5F_fspace_strategy_t strategy, hbool_t persist, hsize_t threshold) const;
+
+        // Returns the strategy that the library uses in managing file space.
+        void getFileSpaceStrategy(H5F_fspace_strategy_t& strategy, hbool_t& persist, hsize_t& threshold) const;
+
+        // Sets the file space page size for paged aggregation.
+        void setFileSpacePagesize(hsize_t fsp_psize) const;
+
+        // Returns the threshold value that the library uses in tracking free
+        // space sections.
+        hsize_t getFileSpacePagesize() const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass() const { return("FileCreatPropList"); }
+
+        // Copy constructor: creates a copy of a FileCreatPropList object.
+        FileCreatPropList(const FileCreatPropList& orig);
+
+        // Creates a copy of an existing file create property list
+        // using the property list id.
+        FileCreatPropList(const hid_t plist_id);
+
+        // Noop destructor
+        virtual ~FileCreatPropList();
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+        // Deletes the global constant, should only be used by the library
+        static void deleteConstants();
+
+    private:
+        static FileCreatPropList* DEFAULT_;
+
+        // Creates the global constant, should only be used by the library
+        static FileCreatPropList* getConstant();
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end of FileCreatPropList
+} // namespace H5
+
+#endif // __H5FileCreatPropList_H
diff --git a/install/include/H5File.h b/install/include/H5File.h
new file mode 100644
index 0000000000..b428a4054b
--- /dev/null
+++ b/install/include/H5File.h
@@ -0,0 +1,127 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5File_H
+#define __H5File_H
+
+namespace H5 {
+
+/*! \class H5File
+    \brief Class H5File represents an HDF5 file and inherits from class Group
+    as file is a root group.
+
+    Inheritance: Group -> H5Object -> H5Location -> IdComponent
+*/
+class H5_DLLCPP H5File : public Group {
+   public:
+        // Creates or opens an HDF5 file.
+        H5File(const char* name, unsigned int flags,
+           const FileCreatPropList& create_plist = FileCreatPropList::DEFAULT,
+           const FileAccPropList& access_plist = FileAccPropList::DEFAULT);
+        H5File(const H5std_string& name, unsigned int flags,
+           const FileCreatPropList& create_plist = FileCreatPropList::DEFAULT,
+           const FileAccPropList& access_plist = FileAccPropList::DEFAULT);
+
+        // Open the file
+        void openFile(const H5std_string& name, unsigned int flags,
+            const FileAccPropList& access_plist = FileAccPropList::DEFAULT);
+        void openFile(const char* name, unsigned int flags,
+            const FileAccPropList& access_plist = FileAccPropList::DEFAULT);
+
+        // Close this file.
+        virtual void close();
+
+        // Gets the access property list of this file.
+        FileAccPropList getAccessPlist() const;
+
+        // Gets the creation property list of this file.
+        FileCreatPropList getCreatePlist() const;
+
+        // Gets general information about this file.
+        void getFileInfo(H5F_info2_t& file_info) const;
+
+        // Returns the amount of free space in the file.
+        hssize_t getFreeSpace() const;
+
+        // Returns the number of opened object IDs (files, datasets, groups
+        // and datatypes) in the same file.
+        ssize_t getObjCount(unsigned types = H5F_OBJ_ALL) const;
+
+        // Retrieves a list of opened object IDs (files, datasets, groups
+        // and datatypes) in the same file.
+        void getObjIDs(unsigned types, size_t max_objs, hid_t *oid_list) const;
+
+        // Returns the pointer to the file handle of the low-level file driver.
+        void getVFDHandle(void **file_handle) const;
+        void getVFDHandle(const FileAccPropList& fapl, void **file_handle) const;
+        //void getVFDHandle(FileAccPropList& fapl, void **file_handle) const; // removed from 1.8.18 and 1.10.1
+
+        // Returns the file size of the HDF5 file.
+        hsize_t getFileSize() const;
+
+        // Determines if a file, specified by its name, is in HDF5 format
+        static bool isHdf5(const char* name);
+        static bool isHdf5(const H5std_string& name);
+
+        // Reopens this file.
+        void reOpen();  // added for better name
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+        void reopen();  // obsolete in favor of reOpen()
+
+        // Creates an H5File using an existing file id.  Not recommended
+        // in applications.
+        H5File(hid_t existing_id);
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("H5File"); }
+
+        // Throw file exception.
+        virtual void throwException(const H5std_string& func_name, const H5std_string& msg) const;
+
+        // for CommonFG to get the file id.
+        virtual hid_t getLocId() const;
+
+        // Default constructor
+        H5File();
+
+        // Copy constructor: makes a copy of the original H5File object.
+        H5File(const H5File& original);
+
+        // Gets the HDF5 file id.
+        virtual hid_t getId() const;
+
+        // H5File destructor.
+        virtual ~H5File();
+
+   protected:
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+        // Sets the HDF5 file id.
+        virtual void p_setId(const hid_t new_id);
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+   private:
+        hid_t id;  // HDF5 file id
+
+        // This function is private and contains common code between the
+        // constructors taking a string or a char*
+        void p_get_file(const char* name, unsigned int flags, const FileCreatPropList& create_plist, const FileAccPropList& access_plist);
+
+}; // end of H5File
+} // namespace H5
+
+#endif // __H5File_H
+
diff --git a/install/include/H5FloatType.h b/install/include/H5FloatType.h
new file mode 100644
index 0000000000..e84f50bdd5
--- /dev/null
+++ b/install/include/H5FloatType.h
@@ -0,0 +1,80 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5FloatType_H
+#define __H5FloatType_H
+
+namespace H5 {
+
+/*! \class FloatType
+    \brief FloatType is a derivative of a DataType and operates on HDF5
+    floating point datatype.
+
+    Inheritance: AtomType -> DataType -> H5Object -> H5Location -> IdComponent
+*/
+class H5_DLLCPP FloatType : public AtomType {
+   public:
+        // Creates a floating-point type using a predefined type.
+        FloatType(const PredType& pred_type);
+
+        // Gets the floating-point datatype of the specified dataset.
+        FloatType(const DataSet& dataset);
+
+        // Constructors that open an HDF5 float datatype, given a location.
+        FloatType(const H5Location& loc, const char* name);
+        FloatType(const H5Location& loc, const H5std_string& name);
+
+        // Retrieves the exponent bias of a floating-point type.
+        size_t getEbias() const;
+
+        // Sets the exponent bias of a floating-point type.
+        void setEbias(size_t ebias) const;
+
+        // Retrieves floating point datatype bit field information.
+        void getFields(size_t& spos, size_t& epos, size_t& esize, size_t& mpos, size_t& msize) const;
+
+        // Sets locations and sizes of floating point bit fields.
+        void setFields(size_t spos, size_t epos, size_t esize, size_t mpos, size_t msize) const;
+
+        // Retrieves the internal padding type for unused bits in floating-point datatypes.
+        H5T_pad_t getInpad(H5std_string& pad_string) const;
+
+        // Fills unused internal floating point bits.
+        void setInpad(H5T_pad_t inpad) const;
+
+        // Retrieves mantissa normalization of a floating-point datatype.
+        H5T_norm_t getNorm(H5std_string& norm_string) const;
+
+        // Sets the mantissa normalization of a floating-point datatype.
+        void setNorm(H5T_norm_t norm) const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("FloatType"); }
+
+        // Default constructor
+        FloatType();
+
+        // Creates a floating-point datatype using an existing id.
+        FloatType(const hid_t existing_id);
+
+        // Copy constructor: makes a copy of the original FloatType object.
+        FloatType(const FloatType& original);
+
+        // Noop destructor.
+        virtual ~FloatType();
+
+}; // end of FloatType
+} // namespace H5
+
+#endif // __H5FloatType_H
diff --git a/install/include/H5Fpkg.h b/install/include/H5Fpkg.h
new file mode 100644
index 0000000000..7a5c126b95
--- /dev/null
+++ b/install/include/H5Fpkg.h
@@ -0,0 +1,472 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:	Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *		Thursday, September 28, 2000
+ *
+ * Purpose:	This file contains declarations which are visible only within
+ *		the H5F package.  Source files outside the H5F package should
+ *		include H5Fprivate.h instead.
+ */
+#if !(defined H5F_FRIEND || defined H5F_MODULE)
+#error "Do not include this file outside the H5F package!"
+#endif
+
+#ifndef _H5Fpkg_H
+#define _H5Fpkg_H
+
+/* Get package's private header */
+#include "H5Fprivate.h"
+
+/* Other public headers needed by this file */
+#include "H5Bpublic.h"          /* B-tree header, for H5B_NUM_BTREE_ID */
+
+/* Other private headers needed by this file */
+#include "H5private.h"		/* Generic Functions			*/
+#include "H5ACprivate.h"        /* Metadata cache                       */
+#include "H5FLprivate.h"	/* Free Lists                           */
+#include "H5FOprivate.h"        /* File objects                         */
+#include "H5FSprivate.h"	/* File free space                      */
+#include "H5Gprivate.h"		/* Groups 			  	*/
+#include "H5Oprivate.h"         /* Object header messages               */
+#include "H5PBprivate.h"        /* Page buffer                          */
+#include "H5UCprivate.h"	/* Reference counted object functions	*/
+
+
+/*
+ * Feature: Define this constant on the compiler command-line if you want to
+ *	    see some debugging messages on the debug stream.
+ */
+#ifdef NDEBUG
+#  undef H5F_DEBUG
+#endif
+
+/* Superblock status flags */
+#define H5F_SUPER_WRITE_ACCESS          0x01
+#define H5F_SUPER_FILE_OK               0x02
+#define H5F_SUPER_SWMR_WRITE_ACCESS     0x04
+#define H5F_SUPER_ALL_FLAGS             (H5F_SUPER_WRITE_ACCESS | H5F_SUPER_FILE_OK | H5F_SUPER_SWMR_WRITE_ACCESS)
+
+/* Mask for removing private file access flags */
+#define H5F_ACC_PUBLIC_FLAGS 	        0x007fu
+
+/* Free space section+aggregator merge flags */
+#define H5F_FS_MERGE_METADATA           0x01    /* Section can merge with metadata aggregator */
+#define H5F_FS_MERGE_RAWDATA            0x02    /* Section can merge with small 'raw' data aggregator */
+
+/* Macro to abstract checking whether file is using a free space manager */
+#define H5F_HAVE_FREE_SPACE_MANAGER(F)  \
+    ((F)->shared->fs_strategy == H5F_FSPACE_STRATEGY_FSM_AGGR ||                        \
+     (F)->shared->fs_strategy == H5F_FSPACE_STRATEGY_PAGE)
+
+/* Macros for encoding/decoding superblock */
+#define H5F_MAX_DRVINFOBLOCK_SIZE  1024         /* Maximum size of superblock driver info buffer */
+#define H5F_DRVINFOBLOCK_HDR_SIZE 16            /* Size of superblock driver info header */
+
+/* Superblock sizes for various versions */
+#define H5F_SIZEOF_CHKSUM 4     /* Checksum size in the file */
+
+/* Fixed-size portion at the beginning of all superblocks */
+#define H5F_SUPERBLOCK_FIXED_SIZE ( H5F_SIGNATURE_LEN                   \
+        + 1) /* superblock version */
+
+/* The H5F_SUPERBLOCK_MINIMAL_VARLEN_SIZE is the minimal amount of super block
+ * variable length data guarnateed to load the sizeof offsets and the sizeof 
+ * lengths fields in all versions of the superblock.
+ *
+ * This is necessary in the V3 cache, as on the initial load, we need to 
+ * get enough of the superblock to determine its version and size so that
+ * the metadata cache can load the correct amount of data from file to 
+ * allow the second deserialization attempt to succeed.
+ *
+ * The value selected will have to be revisited for each new version 
+ * of the super block.  Note that the current value is one byte larger
+ * than it needs to be. 
+ */
+#define H5F_SUPERBLOCK_MINIMAL_VARLEN_SIZE	7
+
+/* Macros for computing variable-size superblock size */
+#define H5F_SUPERBLOCK_VARLEN_SIZE_COMMON                               \
+        (2  /* freespace, and root group versions */			\
+        + 1 /* reserved */                                              \
+        + 3 /* shared header vers, size of address, size of lengths */  \
+        + 1 /* reserved */                                              \
+        + 4 /* group leaf k, group internal k */                        \
+        + 4) /* consistency flags */
+#define H5F_SUPERBLOCK_VARLEN_SIZE_V0(sizeof_addr, sizeof_size)         \
+        ( H5F_SUPERBLOCK_VARLEN_SIZE_COMMON /* Common variable-length info */ \
+        + (sizeof_addr) /* base address */                              \
+        + (sizeof_addr) /* <unused> */                                  \
+        + (sizeof_addr) /* EOF address */                               \
+        + (sizeof_addr) /* driver block address */                      \
+        + H5G_SIZEOF_ENTRY(sizeof_addr, sizeof_size)) /* root group ptr */
+#define H5F_SUPERBLOCK_VARLEN_SIZE_V1(sizeof_addr, sizeof_size)         \
+        ( H5F_SUPERBLOCK_VARLEN_SIZE_COMMON /* Common variable-length info */ \
+        + 2 /* indexed B-tree internal k */                             \
+        + 2 /* reserved */                                              \
+        + (sizeof_addr) /* base address */                              \
+        + (sizeof_addr) /* <unused> */                                  \
+        + (sizeof_addr) /* EOF address */                               \
+        + (sizeof_addr) /* driver block address */                      \
+        + H5G_SIZEOF_ENTRY(sizeof_addr, sizeof_size)) /* root group ptr */
+#define H5F_SUPERBLOCK_VARLEN_SIZE_V2(sizeof_addr)                      \
+        ( 2 /* size of address, size of lengths */                      \
+        + 1 /* consistency flags */                                     \
+        + (sizeof_addr) /* base address */                              \
+        + (sizeof_addr) /* superblock extension address */              \
+        + (sizeof_addr) /* EOF address */                               \
+        + (sizeof_addr) /* root group object header address */          \
+        + H5F_SIZEOF_CHKSUM) /* superblock checksum (keep this last) */
+#define H5F_SUPERBLOCK_VARLEN_SIZE(v, sizeof_addr, sizeof_size) (	\
+        (v == 0 ? H5F_SUPERBLOCK_VARLEN_SIZE_V0(sizeof_addr, sizeof_size) : 0) \
+        + (v == 1 ? H5F_SUPERBLOCK_VARLEN_SIZE_V1(sizeof_addr, sizeof_size) : 0) \
+        + (v >= 2 ? H5F_SUPERBLOCK_VARLEN_SIZE_V2(sizeof_addr) : 0))
+
+/* Total size of superblock, depends on superblock version */
+#define H5F_SUPERBLOCK_SIZE(s) ( H5F_SUPERBLOCK_FIXED_SIZE              \
+        + H5F_SUPERBLOCK_VARLEN_SIZE((s)->super_vers, (s)->sizeof_addr, (s)->sizeof_size))
+
+/* For superblock version 0 & 1:
+   Offset to the file consistency flags (status_flags) in the superblock (excluding H5F_SUPERBLOCK_FIXED_SIZE) */
+#define H5F_SUPER_STATUS_OFF_V01                                                \
+        (2  /* freespace, and root group versions */                    \
+        + 1 /* reserved */                                              \
+        + 3 /* shared header vers, size of address, size of lengths */  \
+        + 1 /* reserved */                                              \
+        + 4) /* group leaf k, group internal k */
+
+#define H5F_SUPER_STATUS_OFF(v)   (v >= 2 ? 2 : H5F_SUPER_STATUS_OFF_V01)
+
+/* Offset to the file consistency flags (status_flags) in the superblock */
+#define H5F_SUPER_STATUS_FLAGS_OFF(v) (H5F_SUPERBLOCK_FIXED_SIZE + H5F_SUPER_STATUS_OFF(v))
+
+/* Size of file consistency flags (status_flags) in the superblock */
+#define H5F_SUPER_STATUS_FLAGS_SIZE(v)        (v >= 2 ? 1 : 4)
+
+/* Forward declaration external file cache struct used below (defined in
+ * H5Fefc.c) */
+typedef struct H5F_efc_t H5F_efc_t;
+
+/* Structure for passing 'user data' to superblock cache callbacks */
+typedef struct H5F_superblock_cache_ud_t {
+/* IN: */
+    H5F_t *f;               /* Pointer to file */
+    hbool_t ignore_drvrinfo; /* Indicate if the driver info should be ignored */
+/* OUT: */
+    unsigned sym_leaf_k;    /* Symbol table leaf node's 'K' value */
+    unsigned btree_k[H5B_NUM_BTREE_ID]; /* B-tree key values for each type */
+    haddr_t stored_eof;     /* End-of-file in file */
+    hbool_t drvrinfo_removed; /* Indicate if the driver info was removed */
+    unsigned    super_vers;   /* Superblock version obtained in get_load_size callback. 
+			       * It will be used later in verify_chksum callback 
+			       */
+} H5F_superblock_cache_ud_t;
+
+/* Structure for passing 'user data' to driver info block cache callbacks */
+typedef struct H5F_drvrinfo_cache_ud_t {
+    H5F_t   *f;               /* Pointer to file */
+    haddr_t driver_addr;      /* address of driver info block */
+} H5F_drvrinfo_cache_ud_t;
+
+/* Structure for metadata & "small [raw] data" block aggregation fields */
+struct H5F_blk_aggr_t {
+    unsigned long       feature_flag;   /* Feature flag type */
+    hsize_t             alloc_size;     /* Size for allocating new blocks */
+    hsize_t             tot_size;       /* Total amount of bytes aggregated into block */
+    hsize_t             size;           /* Current size of block left */
+    haddr_t             addr;           /* Location of block left */
+};
+
+/* Structure for metadata accumulator fields */
+typedef struct H5F_meta_accum_t {
+    unsigned char      *buf;            /* Buffer to hold the accumulated metadata */
+    haddr_t             loc;            /* File location (offset) of the accumulated metadata */
+    size_t              size;           /* Size of the accumulated metadata buffer used (in bytes) */
+    size_t              alloc_size;     /* Size of the accumulated metadata buffer allocated (in bytes) */
+    size_t              dirty_off;      /* Offset of the dirty region in the accumulator buffer */
+    size_t              dirty_len;      /* Length of the dirty region in the accumulator buffer */
+    hbool_t             dirty;          /* Flag to indicate that the accumulated metadata is dirty */
+} H5F_meta_accum_t;
+
+/* A record of the mount table */
+typedef struct H5F_mount_t {
+    struct H5G_t	*group;	/* Mount point group held open		*/
+    struct H5F_t	*file;	/* File mounted at that point		*/
+} H5F_mount_t;
+
+/*
+ * The mount table describes what files are attached to (mounted on) the file
+ * to which this table belongs.
+ */
+typedef struct H5F_mtab_t {
+    unsigned		nmounts;/* Number of children which are mounted	*/
+    unsigned		nalloc;	/* Number of mount slots allocated	*/
+    H5F_mount_t		*child;	/* An array of mount records		*/
+} H5F_mtab_t;
+
+/* Structure specifically to store superblock. This was originally
+ * maintained entirely within H5F_file_t, but is now extracted
+ * here because the superblock is now handled by the cache */
+typedef struct H5F_super_t {
+    H5AC_info_t cache_info;     /* Cache entry information structure          */
+    unsigned    super_vers;     /* Superblock version                         */
+    uint8_t	sizeof_addr;	/* Size of addresses in file                  */
+    uint8_t	sizeof_size;	/* Size of offsets in file                    */
+    uint8_t     status_flags;   /* File status flags                          */
+    unsigned    sym_leaf_k;     /* Size of leaves in symbol tables            */
+    unsigned    btree_k[H5B_NUM_BTREE_ID]; /* B-tree key values for each type */
+    haddr_t     base_addr;      /* Absolute base address for rel.addrs.       */
+                                /* (superblock for file is at this offset)    */
+    haddr_t     ext_addr;       /* Relative address of superblock extension   */
+    haddr_t     driver_addr;    /* File driver information block address      */
+    haddr_t     root_addr;      /* Root group address                         */
+    H5G_entry_t *root_ent;      /* Root group symbol table entry              */
+} H5F_super_t;
+
+/*
+ * Define the structure to store the file information for HDF5 files. One of
+ * these structures is allocated per file, not per H5Fopen(). That is, set of
+ * H5F_t structs can all point to the same H5F_file_t struct. The `nrefs'
+ * count in this struct indicates the number of H5F_t structs which are
+ * pointing to this struct.
+ */
+struct H5F_file_t {
+    H5FD_t	*lf; 		/* Lower level file handle for I/O	*/
+    H5F_super_t *sblock;        /* Pointer to (pinned) superblock for file */
+    H5O_drvinfo_t *drvinfo;	/* Pointer to the (pinned) driver info 
+                                 * cache entry.  This field is only defined
+                                 * for older versions of the super block,
+                                 * and then only when a driver information
+                                 * block is present.  At all other times
+                                 * it should be NULL.
+                                 */
+    hbool_t drvinfo_sb_msg_exists;  /* Convenience field used to track 
+                                     * whether the driver info superblock 
+                                     * extension message has been created 
+                                     * yet. This field should be TRUE iff the
+                                     * superblock extension exists and contains
+                                     * a driver info message.  Under all other
+                                     * circumstances, it must be set to FALSE.
+                                     */
+    unsigned	nrefs;		/* Ref count for times file is opened	*/
+    unsigned	flags;		/* Access Permissions for file          */
+    H5F_mtab_t	mtab;		/* File mount table                     */
+    H5F_efc_t   *efc;           /* External file cache                  */
+
+    /* Cached values from FCPL/superblock */
+    uint8_t	sizeof_addr;	/* Size of addresses in file            */
+    uint8_t	sizeof_size;	/* Size of offsets in file              */
+    haddr_t	sohm_addr;	/* Relative address of shared object header message table */
+    unsigned	sohm_vers;	/* Version of shared message table on disk */
+    unsigned	sohm_nindexes;	/* Number of shared messages indexes in the table */
+    unsigned long feature_flags; /* VFL Driver feature Flags            */
+    haddr_t	maxaddr;	/* Maximum address for file             */
+
+    H5PB_t      *page_buf;                  /* The page buffer cache                */
+    H5AC_t      *cache;		/* The object cache	 		*/
+    H5AC_cache_config_t
+		mdc_initCacheCfg; /* initial configuration for the      */
+                                /* metadata cache.  This structure is   */
+                                /* fixed at creation time and should    */
+                                /* not change thereafter.               */
+    H5AC_cache_image_config_t 
+		mdc_initCacheImageCfg;  /* initial configuration for the */
+                                        /* generate metadata cache image on     */
+                                        /* close option.  This structure is     */
+                                        /* fixed at creation time and should    */
+                                        /* not change thereafter.               */
+    hbool_t     use_mdc_logging; /* Set when metadata logging is desired */
+    hbool_t     start_mdc_log_on_access; /* set when mdc logging should  */
+                                /* begin on file access/create          */
+    char        *mdc_log_location; /* location of mdc log               */
+    hid_t       fcpl_id;	/* File creation property list ID 	*/
+    H5F_close_degree_t fc_degree;   /* File close behavior degree	*/
+    hbool_t evict_on_close; /* If the file's objects should be evicted from the metadata cache on close */
+    size_t	rdcc_nslots;	/* Size of raw data chunk cache (slots)	*/
+    size_t	rdcc_nbytes;	/* Size of raw data chunk cache	(bytes)	*/
+    double	rdcc_w0;	/* Preempt read chunks first? [0.0..1.0]*/
+    size_t      sieve_buf_size; /* Size of the data sieve buffer allocated (in bytes) */
+    hsize_t	threshold;	/* Threshold for alignment		*/
+    hsize_t	alignment;	/* Alignment				*/
+    unsigned	gc_ref;		/* Garbage-collect references?		*/
+    unsigned	latest_flags;	/* The latest version support */
+    hbool_t	store_msg_crt_idx;  /* Store creation index for object header messages?	*/
+    unsigned	ncwfs;		/* Num entries on cwfs list		*/
+    struct H5HG_heap_t **cwfs;	/* Global heap cache			*/
+    struct H5G_t *root_grp;	/* Open root group			*/
+    H5FO_t *open_objs;          /* Open objects in file                 */
+    H5UC_t *grp_btree_shared;   /* Ref-counted group B-tree node info   */
+
+    /* File space allocation information */
+    H5F_fspace_strategy_t fs_strategy;      /* File space handling strategy	*/
+    hsize_t     fs_threshold;	/* Free space section threshold 	*/
+    hbool_t fs_persist;                     /* Free-space persist or not */
+    hbool_t     use_tmp_space;  /* Whether temp. file space allocation is allowed */
+    haddr_t	tmp_addr;       /* Next address to use for temp. space in the file */
+    hbool_t point_of_no_return;             /* flag to indicate that we can't go back and delete a freespace header when it's used up */
+
+    H5F_fs_state_t fs_state[H5F_MEM_PAGE_NTYPES];   /* State of free space manager for each type */
+    haddr_t fs_addr[H5F_MEM_PAGE_NTYPES];           /* Address of free space manager info for each type */
+    H5FS_t *fs_man[H5F_MEM_PAGE_NTYPES];            /* Free space manager for each file space type */
+    hbool_t first_alloc_dealloc;            /* TRUE iff free space managers   */
+                                            /* are persistant and have not    */
+                                            /* been used accessed for either  */
+                                            /* allocation or deallocation     */
+                                            /* since file open.               */
+    haddr_t eoa_pre_fsm_fsalloc;	    /* eoa pre file space allocation  */
+                                            /* for self referential FSMs      */
+    haddr_t eoa_post_fsm_fsalloc;           /* eoa post file space allocation */
+                                            /* for self referential FSMs      */
+    haddr_t eoa_post_mdci_fsalloc;          /* eoa past file space allocation */
+                                            /* for metadata cache image, or   */
+                                            /* HADDR_UNDEF if no cache image. */
+
+    /* Free-space aggregation info */
+    unsigned fs_aggr_merge[H5FD_MEM_NTYPES];    /* Flags for whether free space can merge with aggregator(s) */
+    H5FD_mem_t fs_type_map[H5FD_MEM_NTYPES];    /* Mapping of "real" file space type into tracked type */
+    H5F_blk_aggr_t meta_aggr;   	        /* Metadata aggregation info (if aggregating metadata allocations) */
+    H5F_blk_aggr_t sdata_aggr;                  /* "Small data" aggregation info (if aggregating "small data" allocations) */
+
+    /* Paged aggregation info */
+    hsize_t fs_page_size;                           /* File space page size */
+    size_t pgend_meta_thres;                        /* Do not track page end meta section <= this threshold */
+
+    /* Metadata accumulator information */
+    H5F_meta_accum_t accum;     /* Metadata accumulator info           	*/
+
+    /* Metadata retry info */
+    unsigned 		read_attempts;	/* The # of reads to try when reading metadata with checksum */
+    unsigned		retries_nbins;		/* # of bins for each retries[] */
+    uint32_t		*retries[H5AC_NTYPES];  /* Track # of read retries for metdata items with checksum */
+
+    /* Object flush info */
+    H5F_object_flush_t 	object_flush;		/* Information for object flush callback */
+};
+
+/*
+ * This is the top-level file descriptor.  One of these structures is
+ * allocated every time H5Fopen() is called although they may contain pointers
+ * to shared H5F_file_t structs.
+ */
+struct H5F_t {
+    char		*open_name;	/* Name used to open file	*/
+    char		*actual_name;	/* Actual name of the file, after resolving symlinks, etc. */
+    char               	*extpath;       /* Path for searching target external link file */
+    H5F_file_t		*shared;	/* The shared file info		*/
+    unsigned		nopen_objs;	/* Number of open object headers*/
+    H5FO_t              *obj_count;     /* # of time each object is opened through top file structure */
+    hid_t               file_id;        /* ID of this file              */
+    hbool_t             closing;        /* File is in the process of being closed */
+    struct H5F_t        *parent;        /* Parent file that this file is mounted to */
+    unsigned            nmounts;        /* Number of children mounted to this file */
+#ifdef H5_HAVE_PARALLEL
+    H5P_coll_md_read_flag_t coll_md_read;  /* Do all metadata reads collectively */
+    hbool_t             coll_md_write;  /* Do all metadata writes collectively */
+#endif /* H5_HAVE_PARALLEL */
+};
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+/* Declare a free list to manage the H5F_t struct */
+H5FL_EXTERN(H5F_t);
+
+/* Declare a free list to manage the H5F_file_t struct */
+H5FL_EXTERN(H5F_file_t);
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+/* General routines */
+H5F_t *H5F_new(H5F_file_t *shared, unsigned flags, hid_t fcpl_id,
+    hid_t fapl_id, H5FD_t *lf);
+H5_DLL herr_t H5F__dest(H5F_t *f, hid_t meta_dxpl_id, hid_t raw_dxpl_id, hbool_t flush);
+H5_DLL herr_t H5F__flush(H5F_t *f, hid_t meta_dxpl_id, hid_t raw_dxpl_id, hbool_t closing);
+H5_DLL htri_t H5F__is_hdf5(const char *name, hid_t meta_dxpl_id, hid_t raw_dxpl_id);
+H5_DLL herr_t H5F_get_objects(const H5F_t *f, unsigned types, size_t max_index, hid_t *obj_id_list, hbool_t app_ref, size_t *obj_id_count_ptr);
+H5_DLL ssize_t H5F_get_file_image(H5F_t *f, void *buf_ptr, size_t buf_len,
+    hid_t meta_dxpl_id, hid_t raw_dxpl_id);
+H5_DLL herr_t H5F_close(H5F_t *f);
+
+/* File mount related routines */
+H5_DLL herr_t H5F_close_mounts(H5F_t *f);
+H5_DLL int H5F_term_unmount_cb(void *obj_ptr, hid_t obj_id, void *key);
+H5_DLL herr_t H5F_mount_count_ids(H5F_t *f, unsigned *nopen_files, unsigned *nopen_objs);
+
+/* Superblock related routines */
+H5_DLL herr_t H5F__super_init(H5F_t *f, hid_t dxpl_id);
+H5_DLL herr_t H5F__super_read(H5F_t *f, hid_t meta_dxpl_id, hid_t raw_dxpl_id,
+    hbool_t initial_read);
+H5_DLL herr_t H5F__super_size(H5F_t *f, hid_t dxpl_id, hsize_t *super_size, hsize_t *super_ext_size);
+H5_DLL herr_t H5F__super_free(H5F_super_t *sblock);
+
+/* Superblock extension related routines */
+H5_DLL herr_t H5F_super_ext_open(H5F_t *f, haddr_t ext_addr, H5O_loc_t *ext_ptr);
+H5_DLL herr_t H5F_super_ext_write_msg(H5F_t *f, hid_t dxpl_id, unsigned id,
+    void *mesg, hbool_t may_create, unsigned mesg_flags);
+H5_DLL herr_t H5F_super_ext_remove_msg(H5F_t *f, hid_t dxpl_id, unsigned id);
+H5_DLL herr_t H5F_super_ext_close(H5F_t *f, H5O_loc_t *ext_ptr, hid_t dxpl_id,
+    hbool_t was_created);
+
+/* Metadata accumulator routines */
+H5_DLL herr_t H5F__accum_read(const H5F_io_info2_t *fio_info, H5FD_mem_t type,
+    haddr_t addr, size_t size, void *buf);
+H5_DLL herr_t H5F__accum_write(const H5F_io_info2_t *fio_info, H5FD_mem_t type,
+    haddr_t addr, size_t size, const void *buf);
+H5_DLL herr_t H5F__accum_free(const H5F_io_info2_t *fio_info, H5FD_mem_t type,
+    haddr_t addr, hsize_t size);
+H5_DLL herr_t H5F__accum_flush(const H5F_io_info2_t *fio_info);
+H5_DLL herr_t H5F__accum_reset(const H5F_io_info2_t *fio_info, hbool_t flush);
+
+/* Shared file list related routines */
+H5_DLL herr_t H5F_sfile_add(H5F_file_t *shared);
+H5_DLL H5F_file_t * H5F_sfile_search(H5FD_t *lf);
+H5_DLL herr_t H5F_sfile_remove(H5F_file_t *shared);
+
+/* External file cache routines */
+H5_DLL H5F_efc_t *H5F_efc_create(unsigned max_nfiles);
+H5_DLL unsigned H5F_efc_max_nfiles(H5F_efc_t *efc);
+H5_DLL herr_t H5F_efc_release(H5F_efc_t *efc);
+H5_DLL herr_t H5F_efc_destroy(H5F_efc_t *efc);
+H5_DLL herr_t H5F_efc_try_close(H5F_t *f);
+
+/* Space allocation routines */
+H5_DLL haddr_t H5F_alloc(H5F_t *f, hid_t dxpl_id, H5F_mem_t type, hsize_t size, haddr_t *frag_addr, hsize_t *frag_size);
+H5_DLL herr_t H5F_free(H5F_t *f, hid_t dxpl_id, H5F_mem_t type, haddr_t addr, hsize_t size);
+H5_DLL htri_t H5F_try_extend(H5F_t *f, hid_t dxpl_id, H5FD_mem_t type, 
+    haddr_t blk_end, hsize_t extra_requested);
+
+/* Functions that get/retrieve values from VFD layer */
+H5_DLL herr_t H5F__set_eoa(const H5F_t *f, H5F_mem_t type, haddr_t addr);
+H5_DLL herr_t H5F__set_base_addr(const H5F_t *f, haddr_t addr);
+H5_DLL herr_t H5F__set_paged_aggr(const H5F_t *f, hbool_t paged);
+
+/* Functions that flush or evict */
+H5_DLL herr_t H5F__evict_cache_entries(H5F_t *f, hid_t dxpl_id);
+
+/* Testing functions */
+#ifdef H5F_TESTING
+H5_DLL herr_t H5F_get_sohm_mesg_count_test(hid_t fid, unsigned type_id,
+    size_t *mesg_count);
+H5_DLL herr_t H5F_check_cached_stab_test(hid_t file_id);
+H5_DLL herr_t H5F_get_maxaddr_test(hid_t file_id, haddr_t *maxaddr);
+H5_DLL herr_t H5F_get_sbe_addr_test(hid_t file_id, haddr_t *sbe_addr);
+#endif /* H5F_TESTING */
+
+#endif /* _H5Fpkg_H */
+
diff --git a/install/include/H5Fpublic.h b/install/include/H5Fpublic.h
new file mode 100644
index 0000000000..1594cb2299
--- /dev/null
+++ b/install/include/H5Fpublic.h
@@ -0,0 +1,305 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5F module.
+ */
+#ifndef _H5Fpublic_H
+#define _H5Fpublic_H
+
+/* Public header files needed by this file */
+#include "H5public.h"
+#include "H5ACpublic.h"
+#include "H5Ipublic.h"
+
+/* When this header is included from a private header, don't make calls to H5check() */
+#undef H5CHECK
+#ifndef _H5private_H
+#define H5CHECK          H5check(),
+#else   /* _H5private_H */
+#define H5CHECK
+#endif  /* _H5private_H */
+
+/* When this header is included from a private HDF5 header, don't make calls to H5open() */
+#undef H5OPEN
+#ifndef _H5private_H
+#define H5OPEN        H5open(),
+#else   /* _H5private_H */
+#define H5OPEN
+#endif  /* _H5private_H */
+
+/*
+ * These are the bits that can be passed to the `flags' argument of
+ * H5Fcreate() and H5Fopen(). Use the bit-wise OR operator (|) to combine
+ * them as needed.  As a side effect, they call H5check_version() to make sure
+ * that the application is compiled with a version of the hdf5 header files
+ * which are compatible with the library to which the application is linked.
+ * We're assuming that these constants are used rather early in the hdf5
+ * session.
+ */
+#define H5F_ACC_RDONLY	(H5CHECK H5OPEN 0x0000u)	/*absence of rdwr => rd-only */
+#define H5F_ACC_RDWR	(H5CHECK H5OPEN 0x0001u)	/*open for read and write    */
+#define H5F_ACC_TRUNC	(H5CHECK H5OPEN 0x0002u)	/*overwrite existing files   */
+#define H5F_ACC_EXCL	(H5CHECK H5OPEN 0x0004u)	/*fail if file already exists*/
+/* NOTE: 0x0008u was H5F_ACC_DEBUG, now deprecated */
+#define H5F_ACC_CREAT	(H5CHECK H5OPEN 0x0010u)	/*create non-existing files  */
+#define H5F_ACC_SWMR_WRITE	(H5CHECK 0x0020u) /*indicate that this file is
+                                                 * open for writing in a
+                                                 * single-writer/multi-reader (SWMR)
+                                                 * scenario.  Note that the
+                                                 * process(es) opening the file
+                                                 * for reading must open the file
+                                                 * with RDONLY access, and use
+                                                 * the special "SWMR_READ" access
+                                                 * flag. */
+#define H5F_ACC_SWMR_READ	(H5CHECK 0x0040u) /*indicate that this file is
+                                                 * open for reading in a
+                                                 * single-writer/multi-reader (SWMR)
+                                                 * scenario.  Note that the
+                                                 * process(es) opening the file
+                                                 * for SWMR reading must also
+                                                 * open the file with the RDONLY
+                                                 * flag.  */
+
+/* Value passed to H5Pset_elink_acc_flags to cause flags to be taken from the
+ * parent file. */
+#define H5F_ACC_DEFAULT (H5CHECK H5OPEN 0xffffu)	/*ignore setting on lapl     */
+
+/* Flags for H5Fget_obj_count() & H5Fget_obj_ids() calls */
+#define H5F_OBJ_FILE	(0x0001u)       /* File objects */
+#define H5F_OBJ_DATASET	(0x0002u)       /* Dataset objects */
+#define H5F_OBJ_GROUP	(0x0004u)       /* Group objects */
+#define H5F_OBJ_DATATYPE (0x0008u)      /* Named datatype objects */
+#define H5F_OBJ_ATTR    (0x0010u)       /* Attribute objects */
+#define H5F_OBJ_ALL 	(H5F_OBJ_FILE|H5F_OBJ_DATASET|H5F_OBJ_GROUP|H5F_OBJ_DATATYPE|H5F_OBJ_ATTR)
+#define H5F_OBJ_LOCAL   (0x0020u)       /* Restrict search to objects opened through current file ID */
+                                        /* (as opposed to objects opened through any file ID accessing this file) */
+
+#define H5F_FAMILY_DEFAULT (hsize_t)0
+
+#ifdef H5_HAVE_PARALLEL
+/*
+ * Use this constant string as the MPI_Info key to set H5Fmpio debug flags.
+ * To turn on H5Fmpio debug flags, set the MPI_Info value with this key to
+ * have the value of a string consisting of the characters that turn on the
+ * desired flags.
+ */
+#define H5F_MPIO_DEBUG_KEY "H5F_mpio_debug_key"
+#endif /* H5_HAVE_PARALLEL */
+
+/* The difference between a single file and a set of mounted files */
+typedef enum H5F_scope_t {
+    H5F_SCOPE_LOCAL	= 0,	/*specified file handle only		*/
+    H5F_SCOPE_GLOBAL	= 1 	/*entire virtual file			*/
+} H5F_scope_t;
+
+/* Unlimited file size for H5Pset_external() */
+#define H5F_UNLIMITED	((hsize_t)(-1L))
+
+/* How does file close behave?
+ * H5F_CLOSE_DEFAULT - Use the degree pre-defined by underlining VFL
+ * H5F_CLOSE_WEAK    - file closes only after all opened objects are closed
+ * H5F_CLOSE_SEMI    - if no opened objects, file is close; otherwise, file
+		       close fails
+ * H5F_CLOSE_STRONG  - if there are opened objects, close them first, then
+		       close file
+ */
+typedef enum H5F_close_degree_t {
+    H5F_CLOSE_DEFAULT   = 0,
+    H5F_CLOSE_WEAK      = 1,
+    H5F_CLOSE_SEMI      = 2,
+    H5F_CLOSE_STRONG    = 3
+} H5F_close_degree_t;
+
+/* Current "global" information about file */
+typedef struct H5F_info2_t {
+    struct {
+	unsigned	version;	/* Superblock version # */
+	hsize_t		super_size;	/* Superblock size */
+	hsize_t		super_ext_size;	/* Superblock extension size */
+    } super;
+    struct {
+	unsigned	version;	/* Version # of file free space management */
+	hsize_t		meta_size;	/* Free space manager metadata size */
+	hsize_t		tot_space;	/* Amount of free space in the file */
+    } free;
+    struct {
+	unsigned	version;	/* Version # of shared object header info */
+	hsize_t		hdr_size;       /* Shared object header message header size */
+	H5_ih_info_t	msgs_info;      /* Shared object header message index & heap size */
+    } sohm;
+} H5F_info2_t;
+
+/*
+ * Types of allocation requests. The values larger than H5FD_MEM_DEFAULT
+ * should not change other than adding new types to the end. These numbers
+ * might appear in files.
+ *
+ * Note: please change the log VFD flavors array if you change this
+ * enumeration.
+ */
+typedef enum H5F_mem_t {
+    H5FD_MEM_NOLIST     = -1,   /* Data should not appear in the free list.
+                                 * Must be negative.
+                                 */
+    H5FD_MEM_DEFAULT    = 0,    /* Value not yet set.  Can also be the
+                                 * datatype set in a larger allocation
+                                 * that will be suballocated by the library.
+                                 * Must be zero.
+                                 */
+    H5FD_MEM_SUPER      = 1,    /* Superblock data */
+    H5FD_MEM_BTREE      = 2,    /* B-tree data */
+    H5FD_MEM_DRAW       = 3,    /* Raw data (content of datasets, etc.) */
+    H5FD_MEM_GHEAP      = 4,    /* Global heap data */
+    H5FD_MEM_LHEAP      = 5,    /* Local heap data */
+    H5FD_MEM_OHDR       = 6,    /* Object header data */
+
+    H5FD_MEM_NTYPES             /* Sentinel value - must be last */
+} H5F_mem_t;
+
+/* Free space section information */
+typedef struct H5F_sect_info_t {
+    haddr_t             addr;   /* Address of free space section */
+    hsize_t             size;   /* Size of free space section */
+} H5F_sect_info_t;
+
+/* Library's file format versions */
+typedef enum H5F_libver_t {
+    H5F_LIBVER_EARLIEST,        /* Use the earliest possible format for storing objects */
+    H5F_LIBVER_LATEST           /* Use the latest possible format available for storing objects*/
+} H5F_libver_t;
+
+/* File space handling strategy */
+typedef enum H5F_fspace_strategy_t {
+    H5F_FSPACE_STRATEGY_FSM_AGGR = 0,   /* Mechanisms: free-space managers, aggregators, and virtual file drivers */
+                                        /* This is the library default when not set */
+    H5F_FSPACE_STRATEGY_PAGE = 1,   /* Mechanisms: free-space managers with embedded paged aggregation and virtual file drivers */
+    H5F_FSPACE_STRATEGY_AGGR = 2,   /* Mechanisms: aggregators and virtual file drivers */
+    H5F_FSPACE_STRATEGY_NONE = 3,   /* Mechanisms: virtual file drivers */
+    H5F_FSPACE_STRATEGY_NTYPES      /* must be last */
+} H5F_fspace_strategy_t;
+
+/* Deprecated: File space handling strategy for release 1.10.0 */
+/* They are mapped to H5F_fspace_strategy_t as defined above from release 1.10.1 onwards */
+typedef enum H5F_file_space_type_t {
+    H5F_FILE_SPACE_DEFAULT = 0,     /* Default (or current) free space strategy setting */
+    H5F_FILE_SPACE_ALL_PERSIST = 1, /* Persistent free space managers, aggregators, virtual file driver */
+    H5F_FILE_SPACE_ALL = 2,	    /* Non-persistent free space managers, aggregators, virtual file driver */
+				    /* This is the library default */
+    H5F_FILE_SPACE_AGGR_VFD = 3,    /* Aggregators, Virtual file driver */
+    H5F_FILE_SPACE_VFD = 4,	    /* Virtual file driver */
+    H5F_FILE_SPACE_NTYPES	    /* must be last */
+} H5F_file_space_type_t;
+
+/* Data structure to report the collection of read retries for metadata items with checksum */
+/* Used by public routine H5Fget_metadata_read_retry_info() */
+#define H5F_NUM_METADATA_READ_RETRY_TYPES	21
+typedef struct H5F_retry_info_t {
+    unsigned nbins;
+    uint32_t *retries[H5F_NUM_METADATA_READ_RETRY_TYPES];
+} H5F_retry_info_t;
+
+/* Callback for H5Pset_object_flush_cb() in a file access property list */
+typedef herr_t (*H5F_flush_cb_t)(hid_t object_id, void *udata);
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Functions in H5F.c */
+H5_DLL htri_t H5Fis_hdf5(const char *filename);
+H5_DLL hid_t  H5Fcreate(const char *filename, unsigned flags,
+		  	  hid_t create_plist, hid_t access_plist);
+H5_DLL hid_t  H5Fopen(const char *filename, unsigned flags,
+		        hid_t access_plist);
+H5_DLL hid_t  H5Freopen(hid_t file_id);
+H5_DLL herr_t H5Fflush(hid_t object_id, H5F_scope_t scope);
+H5_DLL herr_t H5Fclose(hid_t file_id);
+H5_DLL hid_t  H5Fget_create_plist(hid_t file_id);
+H5_DLL hid_t  H5Fget_access_plist(hid_t file_id);
+H5_DLL herr_t H5Fget_intent(hid_t file_id, unsigned * intent);
+H5_DLL ssize_t H5Fget_obj_count(hid_t file_id, unsigned types);
+H5_DLL ssize_t H5Fget_obj_ids(hid_t file_id, unsigned types, size_t max_objs, hid_t *obj_id_list);
+H5_DLL herr_t H5Fget_vfd_handle(hid_t file_id, hid_t fapl, void **file_handle);
+H5_DLL herr_t H5Fmount(hid_t loc, const char *name, hid_t child, hid_t plist);
+H5_DLL herr_t H5Funmount(hid_t loc, const char *name);
+H5_DLL hssize_t H5Fget_freespace(hid_t file_id);
+H5_DLL herr_t H5Fget_filesize(hid_t file_id, hsize_t *size);
+H5_DLL ssize_t H5Fget_file_image(hid_t file_id, void * buf_ptr, size_t buf_len);
+H5_DLL herr_t H5Fget_mdc_config(hid_t file_id,
+				H5AC_cache_config_t * config_ptr);
+H5_DLL herr_t H5Fset_mdc_config(hid_t file_id,
+				H5AC_cache_config_t * config_ptr);
+H5_DLL herr_t H5Fget_mdc_hit_rate(hid_t file_id, double * hit_rate_ptr);
+H5_DLL herr_t H5Fget_mdc_size(hid_t file_id,
+                              size_t * max_size_ptr,
+                              size_t * min_clean_size_ptr,
+                              size_t * cur_size_ptr,
+                              int * cur_num_entries_ptr);
+H5_DLL herr_t H5Freset_mdc_hit_rate_stats(hid_t file_id);
+H5_DLL ssize_t H5Fget_name(hid_t obj_id, char *name, size_t size);
+H5_DLL herr_t H5Fget_info2(hid_t obj_id, H5F_info2_t *finfo);
+H5_DLL herr_t H5Fget_metadata_read_retry_info(hid_t file_id, H5F_retry_info_t *info);
+H5_DLL herr_t H5Fstart_swmr_write(hid_t file_id);
+H5_DLL ssize_t H5Fget_free_sections(hid_t file_id, H5F_mem_t type,
+    size_t nsects, H5F_sect_info_t *sect_info/*out*/);
+H5_DLL herr_t H5Fclear_elink_file_cache(hid_t file_id);
+H5_DLL herr_t H5Fset_latest_format(hid_t file_id, hbool_t latest_format);
+H5_DLL herr_t H5Fstart_mdc_logging(hid_t file_id);
+H5_DLL herr_t H5Fstop_mdc_logging(hid_t file_id);
+H5_DLL herr_t H5Fget_mdc_logging_status(hid_t file_id,
+                                        /*OUT*/ hbool_t *is_enabled,
+                                        /*OUT*/ hbool_t *is_currently_logging);
+H5_DLL herr_t H5Fformat_convert(hid_t fid);
+H5_DLL herr_t H5Freset_page_buffering_stats(hid_t file_id);
+H5_DLL herr_t H5Fget_page_buffering_stats(hid_t file_id, unsigned accesses[2],
+    unsigned hits[2], unsigned misses[2], unsigned evictions[2], unsigned bypasses[2]);
+H5_DLL herr_t H5Fget_mdc_image_info(hid_t file_id, haddr_t *image_addr, hsize_t *image_size);
+
+#ifdef H5_HAVE_PARALLEL
+H5_DLL herr_t H5Fset_mpi_atomicity(hid_t file_id, hbool_t flag);
+H5_DLL herr_t H5Fget_mpi_atomicity(hid_t file_id, hbool_t *flag);
+#endif /* H5_HAVE_PARALLEL */
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+#define H5F_ACC_DEBUG	(H5CHECK H5OPEN 0x0000u)	/*print debug info (deprecated)*/
+
+/* Typedefs */
+
+/* Current "global" information about file */
+typedef struct H5F_info1_t {
+    hsize_t		super_ext_size;	/* Superblock extension size */
+    struct {
+	hsize_t		hdr_size;       /* Shared object header message header size */
+	H5_ih_info_t	msgs_info;      /* Shared object header message index & heap size */
+    } sohm;
+} H5F_info1_t;
+
+
+/* Function prototypes */
+H5_DLL herr_t H5Fget_info1(hid_t obj_id, H5F_info1_t *finfo);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _H5Fpublic_H */
+
diff --git a/install/include/H5Gpkg.h b/install/include/H5Gpkg.h
new file mode 100644
index 0000000000..76bf08bc4b
--- /dev/null
+++ b/install/include/H5Gpkg.h
@@ -0,0 +1,531 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer: Robb Matzke <matzke@llnl.gov>
+ *             Thursday, September 18, 1997
+ *
+ * Purpose:     This file contains declarations which are visible
+ *              only within the H5G package. Source files outside the
+ *              H5G package should include H5Gprivate.h instead.
+ */
+#if !(defined H5G_FRIEND || defined H5G_MODULE)
+#error "Do not include this file outside the H5G package!"
+#endif
+
+#ifndef _H5Gpkg_H
+#define _H5Gpkg_H
+
+/* Get package's private header */
+#include "H5Gprivate.h"
+
+/* Other private headers needed by this file */
+#include "H5B2private.h"	/* v2 B-trees				*/
+#include "H5FLprivate.h"	/* Free Lists                           */
+#include "H5HFprivate.h"	/* Fractal heaps			*/
+#include "H5HLprivate.h"	/* Local Heaps				*/
+#include "H5Oprivate.h"		/* Object headers		  	*/
+#include "H5SLprivate.h"	/* Skip lists				*/
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* Standard length of fractal heap ID for link */
+#define H5G_DENSE_FHEAP_ID_LEN  7
+
+/* Size of a symbol table node on disk */
+#define H5G_NODE_SIZE(f)     (                                                \
+    /* General metadata fields */                                             \
+    H5_SIZEOF_MAGIC                                                           \
+    + 1         /* Version */                                                 \
+    + 1         /* Reserved */                                                \
+    + 2         /* Number of symbols */                                       \
+                                                                              \
+    /* Entries */                                                             \
+    + ((2 * H5F_SYM_LEAF_K(f)) * (unsigned)H5G_SIZEOF_ENTRY_FILE(f))                    \
+    )
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/*
+ * Various types of object header information can be cached in a symbol
+ * table entry (it's normal home is the object header to which the entry
+ * points).  This datatype determines what (if anything) is cached in the
+ * symbol table entry.
+ */
+typedef enum H5G_cache_type_t {
+    H5G_CACHED_ERROR	= -1, 	/*force enum to be signed		     */
+    H5G_NOTHING_CACHED  = 0,    /*nothing is cached, must be 0               */
+    H5G_CACHED_STAB     = 1,    /*symbol table, `stab'                       */
+    H5G_CACHED_SLINK	= 2, 	/*symbolic link				     */
+
+    H5G_NCACHED                 /*THIS MUST BE LAST                          */
+} H5G_cache_type_t;
+
+/*
+ * A symbol table entry caches these parameters from object header
+ * messages...  The values are entered into the symbol table when an object
+ * header is created (by hand) and are extracted from the symbol table with a
+ * callback function registered in H5O_init_interface().  Be sure to update
+ * H5G_ent_decode(), H5G_ent_encode(), and H5G__ent_debug() as well.
+ */
+typedef union H5G_cache_t {
+    struct {
+        haddr_t btree_addr;             /*file address of symbol table B-tree*/
+        haddr_t heap_addr;              /*file address of stab name heap     */
+    } stab;
+
+    struct {
+	size_t	lval_offset;		/*link value offset		     */
+    } slink;
+} H5G_cache_t;
+
+/*
+ * A symbol table entry.  The two important fields are `name_off' and
+ * `header'.  The remaining fields are used for caching information that
+ * also appears in the object header to which this symbol table entry
+ * points.
+ */
+struct H5G_entry_t {
+    H5G_cache_type_t type;              /*type of information cached         */
+    H5G_cache_t cache;                  /*cached data from object header     */
+    size_t      name_off;               /*offset of name within name heap    */
+    haddr_t     header;                 /*file address of object header      */
+};
+
+/*
+ * A symbol table node is a collection of symbol table entries.  It can
+ * be thought of as the lowest level of the B-link tree that points to
+ * a collection of symbol table entries that belong to a specific symbol
+ * table or group.
+ */
+typedef struct H5G_node_t {
+    H5AC_info_t cache_info;     /* Information for H5AC cache functions, _must_ be */
+                                /* first field in structure */
+    size_t node_size;           /* Size of node on disk              */
+    unsigned nsyms;             /* Number of symbols                 */
+    H5G_entry_t *entry;         /* Array of symbol table entries     */
+} H5G_node_t;
+
+/*
+ * Shared information for all open group objects
+ */
+struct H5G_shared_t {
+    int fo_count;                   /* open file object count */
+    hbool_t mounted;                /* Group is mount point */
+};
+
+/*
+ * A group handle passed around through layers of the library within and
+ * above the H5G layer.
+ */
+struct H5G_t {
+    H5G_shared_t *shared;               /* Shared file object data */
+    H5O_loc_t oloc;                     /* Object location for group */
+    H5G_name_t path;                    /* Group hierarchy path   */
+};
+
+/* Link iteration operator for internal library callbacks */
+typedef herr_t (*H5G_lib_iterate_t)(const H5O_link_t *lnk, void *op_data);
+
+/* Data structure to hold table of links for a group */
+typedef struct {
+    size_t      nlinks;         /* # of links in table */
+    H5O_link_t *lnks;           /* Pointer to array of links */
+} H5G_link_table_t;
+
+/*
+ * Common data exchange structure for symbol table nodes.  This structure is
+ * passed through the B-link tree layer to the methods for the objects
+ * to which the B-link tree points.
+ *
+ * It's also used for B-tree iterators which require no additional info.
+ *
+ */
+typedef struct H5G_bt_common_t {
+    /* downward */
+    const char  *name;                  /*points to temporary memory         */
+    H5HL_t *heap;                       /*symbol table heap		     */
+} H5G_bt_common_t;
+
+/*
+ * Data exchange structure for symbol table nodes.  This structure is
+ * passed through the B-link tree layer to the insert method for entries.
+ */
+typedef struct H5G_bt_ins_t {
+    /* downward */
+    H5G_bt_common_t common;             /* Common info for B-tree user data (must be first) */
+    const H5O_link_t *lnk;              /* Link to insert into table         */
+    H5O_type_t obj_type;                /* Type of object being inserted */
+    const void *crt_info;               /* Creation info for object being inserted */
+} H5G_bt_ins_t;
+
+/*
+ * Data exchange structure for symbol table nodes.  This structure is
+ * passed through the B-link tree layer to the remove method for entries.
+ */
+typedef struct H5G_bt_rm_t {
+    /* downward */
+    H5G_bt_common_t common;         /* Common info for B-tree user data (must be first) */
+    H5RS_str_t *grp_full_path_r;    /* Full path of group where link is removed */
+} H5G_bt_rm_t;
+
+/* Typedef for B-tree 'find' operation */
+typedef herr_t (*H5G_bt_find_op_t)(const H5G_entry_t *ent/*in*/, void *operator_data/*in,out*/);
+
+/*
+ * Data exchange structure for symbol table nodes.  This structure is
+ * passed through the B-link tree layer to the 'find' method for entries.
+ */
+typedef struct H5G_bt_lkp_t {
+    /* downward */
+    H5G_bt_common_t common;         /* Common info for B-tree user data (must be first) */
+    H5G_bt_find_op_t op;            /* Operator to call when correct entry is found */
+    void *op_data;                  /* Data to pass to operator */
+
+    /* upward */
+} H5G_bt_lkp_t;
+
+/*
+ * Data exchange structure to pass through the B-tree layer for the
+ * H5B_iterate function.
+ */
+typedef struct H5G_bt_it_it_t {
+    /* downward */
+    H5HL_t      *heap;          /*symbol table heap 			     */
+    hsize_t	skip;		/*initial entries to skip		     */
+    H5G_lib_iterate_t op;	/*iteration operator			     */
+    void	*op_data;	/*user-defined operator data		     */
+
+    /* upward */
+    hsize_t	*final_ent;	/*final entry looked at                      */
+} H5G_bt_it_it_t;
+
+/* Data passed through B-tree iteration for copying copy symbol table content */
+typedef struct H5G_bt_it_cpy_t {
+    const H5O_loc_t *src_oloc;  /* Source object location */
+    haddr_t     src_heap_addr;  /* Heap address of the source symbol table  */
+    H5F_t       *dst_file;      /* File of destination group */
+    const H5O_stab_t *dst_stab; /* Symbol table message for destination group */
+    H5O_copy_t  *cpy_info;      /* Information for copy operation */
+} H5G_bt_it_cpy_t;
+
+/* Common information for "by index" lookups in symbol tables */
+typedef struct H5G_bt_it_idx_common_t {
+    /* downward */
+    hsize_t     idx;            /* Index of group member to be queried */
+    hsize_t     num_objs;       /* The number of objects having been traversed */
+    H5G_bt_find_op_t op;        /* Operator to call when correct entry is found */
+} H5G_bt_it_idx_common_t;
+
+/* Data passed through B-tree iteration for building a table of the links */
+typedef struct H5G_bt_it_bt_t {
+    /* downward */
+    size_t alloc_nlinks;        /* Number of links allocated in table */
+    H5HL_t *heap;               /* Symbol table heap */
+
+    /* upward */
+    H5G_link_table_t *ltable;   /* Link table to add information to */
+} H5G_bt_it_bt_t;
+
+/* Typedefs for "new format" groups */
+/* (fractal heap & v2 B-tree info) */
+
+/* Typedef for native 'name' field index records in the v2 B-tree */
+/* (Keep 'id' field first so generic record handling in callbacks works) */
+typedef struct H5G_dense_bt2_name_rec_t {
+    uint8_t id[H5G_DENSE_FHEAP_ID_LEN]; /* Heap ID for link */
+    uint32_t hash;                      /* Hash of 'name' field value */
+} H5G_dense_bt2_name_rec_t;
+
+/* Typedef for native 'creation order' field index records in the v2 B-tree */
+/* (Keep 'id' field first so generic record handling in callbacks works) */
+typedef struct H5G_dense_bt2_corder_rec_t {
+    uint8_t id[H5G_DENSE_FHEAP_ID_LEN]; /* Heap ID for link */
+    int64_t corder;                     /* 'creation order' field value */
+} H5G_dense_bt2_corder_rec_t;
+
+/*
+ * Common data exchange structure for dense link storage.  This structure is
+ * passed through the v2 B-tree layer to the methods for the objects
+ * to which the v2 B-tree points.
+ */
+typedef struct H5G_bt2_ud_common_t {
+    /* downward */
+    H5F_t       *f;                     /* Pointer to file that fractal heap is in */
+    hid_t       dxpl_id;                /* DXPL for operation                */
+    H5HF_t      *fheap;                 /* Fractal heap handle               */
+    const char  *name;                  /* Name of link to compare           */
+    uint32_t    name_hash;              /* Hash of name of link to compare   */
+    int64_t     corder;                 /* Creation order value of link to compare   */
+    H5B2_found_t found_op;              /* Callback when correct link is found */
+    void        *found_op_data;         /* Callback data when correct link is found */
+} H5G_bt2_ud_common_t;
+
+/*
+ * Data exchange structure for dense link storage.  This structure is
+ * passed through the v2 B-tree layer when inserting links.
+ */
+typedef struct H5G_bt2_ud_ins_t {
+    /* downward */
+    H5G_bt2_ud_common_t common;         /* Common info for B-tree user data (must be first) */
+    uint8_t id[H5G_DENSE_FHEAP_ID_LEN]; /* Heap ID of link to insert         */
+} H5G_bt2_ud_ins_t;
+
+/* Typedef for group creation operation */
+typedef struct H5G_obj_create_t{
+    hid_t gcpl_id;              /* Group creation property list */
+    H5G_cache_type_t cache_type; /* Type of symbol table entry cache */
+    H5G_cache_t cache;          /* Cached data for symbol table entry */
+} H5G_obj_create_t;
+
+/* Callback information for copying groups */
+typedef struct H5G_copy_file_ud_t {
+    H5O_copy_file_ud_common_t common;   /* Shared information (must be first) */
+    H5G_cache_type_t cache_type;        /* Type of symbol table entry cache */
+    H5G_cache_t cache;                  /* Cached data for symbol table entry */
+} H5G_copy_file_ud_t;
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+/*
+ * This is the class identifier to give to the B-tree functions.
+ */
+H5_DLLVAR H5B_class_t H5B_SNODE[1];
+
+/* The v2 B-tree class for indexing 'name' field on links */
+H5_DLLVAR const H5B2_class_t H5G_BT2_NAME[1];
+
+/* The v2 B-tree class for indexing 'creation order' field on links */
+H5_DLLVAR const H5B2_class_t H5G_BT2_CORDER[1];
+
+/* Free list for managing H5G_t structs */
+H5FL_EXTERN(H5G_t);
+
+/* Free list for managing H5G_shared_t structs */
+H5FL_EXTERN(H5G_shared_t);
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+/*
+ * General group routines
+ */
+H5_DLL H5G_t *H5G__create(H5F_t *file, H5G_obj_create_t *gcrt_info,
+    hid_t dxpl_id);
+H5_DLL H5G_t *H5G__create_named(const H5G_loc_t *loc, const char *name,
+    hid_t lcpl_id, hid_t gcpl_id, hid_t gapl_id, hid_t dxpl_id);
+H5_DLL H5G_t *H5G__open_name(const H5G_loc_t *loc, const char *name,
+    hid_t gapl_id, hid_t dxpl_id);
+
+/*
+ * Group hierarchy traversal routines
+ */
+H5_DLL herr_t H5G__traverse_special(const H5G_loc_t *grp_loc,
+    const H5O_link_t *lnk, unsigned target, size_t *nlinks, hbool_t last_comp,
+    H5G_loc_t *obj_loc, hbool_t *obj_exists, hid_t lapl_id, hid_t dxpl_id);
+
+/*
+ * Utility functions
+ */
+H5_DLL const char *H5G__component(const char *name, size_t *size_p);
+
+/*
+ * Functions that understand symbol tables but not names.  The
+ * functions that understand names are exported to the rest of
+ * the library and appear in H5Gprivate.h.
+ */
+H5_DLL herr_t H5G__stab_create(H5O_loc_t *grp_oloc, hid_t dxpl_id,
+    const H5O_ginfo_t *ginfo, H5O_stab_t *stab);
+H5_DLL herr_t H5G__stab_create_components(H5F_t *f, H5O_stab_t *stab, size_t size_hint, hid_t dxpl_id);
+H5_DLL herr_t H5G__stab_insert(const H5O_loc_t *grp_oloc, const char *name,
+    H5O_link_t *obj_lnk, H5O_type_t obj_type, const void *crt_info,
+    hid_t dxpl_id);
+H5_DLL herr_t H5G__stab_insert_real(H5F_t *f, const H5O_stab_t *stab,
+    const char *name, H5O_link_t *obj_lnk, H5O_type_t obj_type,
+    const void *crt_info, hid_t dxpl_id);
+H5_DLL herr_t H5G__stab_delete(H5F_t *f, hid_t dxpl_id, const H5O_stab_t *stab);
+H5_DLL herr_t H5G__stab_iterate(const H5O_loc_t *oloc, hid_t dxpl_id, H5_iter_order_t order,
+    hsize_t skip, hsize_t *last_lnk, H5G_lib_iterate_t op, void *op_data);
+H5_DLL herr_t H5G__stab_count(struct H5O_loc_t *oloc, hsize_t *num_objs, hid_t dxpl_id);
+H5_DLL herr_t H5G__stab_bh_size(H5F_t *f, hid_t dxpl_id, const H5O_stab_t *stab,
+    H5_ih_info_t *bh_info);
+H5_DLL ssize_t H5G__stab_get_name_by_idx(const H5O_loc_t *oloc, H5_iter_order_t order,
+    hsize_t n, char* name, size_t size, hid_t dxpl_id);
+H5_DLL herr_t H5G__stab_remove(const H5O_loc_t *oloc, hid_t dxpl_id,
+    H5RS_str_t *grp_full_path_r, const char *name);
+H5_DLL herr_t H5G__stab_remove_by_idx(const H5O_loc_t *oloc, hid_t dxpl_id,
+    H5RS_str_t *grp_full_path_r, H5_iter_order_t order, hsize_t n);
+H5_DLL herr_t H5G__stab_lookup(const H5O_loc_t *grp_oloc, const char *name,
+    H5O_link_t *lnk, hid_t dxpl_id);
+H5_DLL herr_t H5G__stab_lookup_by_idx(const H5O_loc_t *grp_oloc, H5_iter_order_t order,
+    hsize_t n, H5O_link_t *lnk, hid_t dxpl_id);
+#ifndef H5_STRICT_FORMAT_CHECKS
+H5_DLL herr_t H5G__stab_valid(H5O_loc_t *grp_oloc, hid_t dxpl_id,
+    H5O_stab_t *alt_stab);
+#endif /* H5_STRICT_FORMAT_CHECKS */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+H5_DLL H5G_obj_t H5G__stab_get_type_by_idx(H5O_loc_t *oloc, hsize_t idx,
+    hid_t dxpl_id);
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+
+/*
+ * Functions that understand symbol table entries.
+ */
+H5_DLL void H5G__ent_copy(H5G_entry_t *dst, const H5G_entry_t *src,
+            H5_copy_depth_t depth);
+H5_DLL void H5G__ent_reset(H5G_entry_t *ent);
+H5_DLL herr_t H5G__ent_decode_vec(const H5F_t *f, const uint8_t **pp,
+				  H5G_entry_t *ent, unsigned n);
+H5_DLL herr_t H5G__ent_encode_vec(const H5F_t *f, uint8_t **pp,
+				  const H5G_entry_t *ent, unsigned n);
+H5_DLL herr_t H5G__ent_convert(H5F_t *f, hid_t dxpl_id, H5HL_t *heap,
+    const char *name, const H5O_link_t *lnk, H5O_type_t obj_type,
+    const void *crt_info, H5G_entry_t *ent);
+H5_DLL herr_t H5G__ent_debug(const H5G_entry_t *ent, FILE * stream, int indent,
+    int fwidth, const H5HL_t *heap);
+
+/* Functions that understand symbol table nodes */
+H5_DLL herr_t H5G__node_init(H5F_t *f);
+H5_DLL int H5G__node_iterate(H5F_t *f, hid_t dxpl_id, const void *_lt_key, haddr_t addr,
+		     const void *_rt_key, void *_udata);
+H5_DLL int H5G__node_sumup(H5F_t *f, hid_t dxpl_id, const void *_lt_key, haddr_t addr,
+		     const void *_rt_key, void *_udata);
+H5_DLL int H5G__node_by_idx(H5F_t *f, hid_t dxpl_id, const void *_lt_key, haddr_t addr,
+		     const void *_rt_key, void *_udata);
+H5_DLL int H5G__node_copy(H5F_t *f, hid_t dxpl_id, const void *_lt_key, haddr_t addr,
+		     const void *_rt_key, void *_udata);
+H5_DLL int H5G__node_build_table(H5F_t *f, hid_t dxpl_id, const void *_lt_key, haddr_t addr,
+		     const void *_rt_key, void *_udata);
+H5_DLL herr_t H5G__node_iterate_size(H5F_t *f, hid_t dxpl_id, const void *_lt_key, haddr_t addr,
+                     const void *_rt_key, void *_udata);
+H5_DLL herr_t H5G__node_free(H5G_node_t *sym);
+
+/* Functions that understand links in groups */
+H5_DLL herr_t H5G__ent_to_link(H5O_link_t *lnk, const H5HL_t *heap,
+    const H5G_entry_t *ent, const char *name);
+H5_DLL herr_t H5G__link_to_loc(const H5G_loc_t *grp_loc, const H5O_link_t *lnk,
+    H5G_loc_t *obj_loc);
+H5_DLL herr_t H5G__link_sort_table(H5G_link_table_t *ltable, H5_index_t idx_type,
+    H5_iter_order_t order);
+H5_DLL herr_t H5G__link_iterate_table(const H5G_link_table_t *ltable,
+    hsize_t skip, hsize_t *last_lnk, const H5G_lib_iterate_t op, void *op_data);
+H5_DLL herr_t H5G__link_release_table(H5G_link_table_t *ltable);
+H5_DLL herr_t H5G__link_name_replace(H5F_t *file, hid_t dxpl_id,
+    H5RS_str_t *grp_full_path_r, const H5O_link_t *lnk);
+
+/* Functions that understand "compact" link storage */
+H5_DLL herr_t H5G__compact_insert(const H5O_loc_t *grp_oloc, H5O_link_t *obj_lnk,
+    hid_t dxpl_id);
+H5_DLL ssize_t H5G__compact_get_name_by_idx(const H5O_loc_t *oloc, hid_t dxpl_id,
+    const H5O_linfo_t *linfo, H5_index_t idx_type, H5_iter_order_t order,
+    hsize_t idx, char *name, size_t size);
+H5_DLL herr_t H5G__compact_remove(const H5O_loc_t *oloc, hid_t dxpl_id,
+    H5RS_str_t *grp_full_path_r, const char *name);
+H5_DLL herr_t H5G__compact_remove_by_idx(const H5O_loc_t *oloc, hid_t dxpl_id,
+    const H5O_linfo_t *linfo, H5RS_str_t *grp_full_path_r, H5_index_t idx_type,
+    H5_iter_order_t order, hsize_t n);
+H5_DLL herr_t H5G__compact_iterate(const H5O_loc_t *oloc, hid_t dxpl_id,
+    const H5O_linfo_t *linfo, H5_index_t idx_type, H5_iter_order_t order,
+    hsize_t skip, hsize_t *last_lnk, H5G_lib_iterate_t op, void *op_data);
+H5_DLL htri_t H5G__compact_lookup(const H5O_loc_t *grp_oloc, const char *name,
+    H5O_link_t *lnk, hid_t dxpl_id);
+H5_DLL herr_t H5G__compact_lookup_by_idx(const H5O_loc_t *oloc, hid_t dxpl_id,
+    const H5O_linfo_t *linfo, H5_index_t idx_type, H5_iter_order_t order,
+    hsize_t n, H5O_link_t *lnk);
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+H5_DLL H5G_obj_t H5G__compact_get_type_by_idx(H5O_loc_t *oloc, hid_t dxpl_id,
+    const H5O_linfo_t *linfo, hsize_t idx);
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+/* Functions that understand "dense" link storage */
+H5_DLL herr_t H5G__dense_build_table(H5F_t *f, hid_t dxpl_id, const H5O_linfo_t *linfo,
+    H5_index_t idx_type, H5_iter_order_t order, H5G_link_table_t *ltable);
+H5_DLL herr_t H5G__dense_create(H5F_t *f, hid_t dxpl_id, H5O_linfo_t *linfo,
+    const H5O_pline_t *pline);
+H5_DLL herr_t H5G__dense_insert(H5F_t *f, hid_t dxpl_id,
+    const H5O_linfo_t *linfo, const H5O_link_t *lnk);
+H5_DLL htri_t H5G__dense_lookup(H5F_t *f, hid_t dxpl_id,
+    const H5O_linfo_t *linfo, const char *name, H5O_link_t *lnk);
+H5_DLL herr_t H5G__dense_lookup_by_idx(H5F_t *f, hid_t dxpl_id,
+    const H5O_linfo_t *linfo, H5_index_t idx_type, H5_iter_order_t order,
+    hsize_t n, H5O_link_t *lnk);
+H5_DLL herr_t H5G__dense_iterate(H5F_t *f, hid_t dxpl_id, const H5O_linfo_t *linfo,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t skip, hsize_t *last_lnk,
+    H5G_lib_iterate_t op, void *op_data);
+H5_DLL ssize_t H5G__dense_get_name_by_idx(H5F_t  *f, hid_t dxpl_id,
+    H5O_linfo_t *linfo, H5_index_t idx_type, H5_iter_order_t order, hsize_t n,
+    char *name, size_t size);
+H5_DLL herr_t H5G__dense_remove(H5F_t *f, hid_t dxpl_id, const H5O_linfo_t *linfo,
+    H5RS_str_t *grp_full_path_r, const char *name);
+H5_DLL herr_t H5G__dense_remove_by_idx(H5F_t *f, hid_t dxpl_id,
+    const H5O_linfo_t *linfo, H5RS_str_t *grp_full_path_r, H5_index_t idx_type,
+    H5_iter_order_t order, hsize_t n);
+H5_DLL herr_t H5G__dense_delete(H5F_t *f, hid_t dxpl_id, H5O_linfo_t *linfo,
+    hbool_t adj_link);
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+H5_DLL H5G_obj_t H5G__dense_get_type_by_idx(H5F_t  *f, hid_t dxpl_id,
+    H5O_linfo_t *linfo, hsize_t idx);
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+/* Functions that understand group objects */
+H5_DLL herr_t H5G__obj_create(H5F_t *f, hid_t dxpl_id,
+    H5G_obj_create_t *gcrt_info, H5O_loc_t *oloc/*out*/);
+H5_DLL herr_t H5G__obj_create_real(H5F_t *f, hid_t dxpl_id,
+    const H5O_ginfo_t *ginfo, const H5O_linfo_t *linfo,
+    const H5O_pline_t *pline, H5G_obj_create_t *gcrt_info,
+    H5O_loc_t *oloc/*out*/);
+H5_DLL htri_t H5G__obj_get_linfo(const H5O_loc_t *grp_oloc, H5O_linfo_t *linfo,
+    hid_t dxpl_id);
+H5_DLL herr_t H5G__obj_iterate(const H5O_loc_t *grp_oloc,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t skip, hsize_t *last_lnk,
+    H5G_lib_iterate_t op, void *op_data, hid_t dxpl_id);
+H5_DLL herr_t H5G__obj_info(H5O_loc_t *oloc, H5G_info_t *grp_info, hid_t dxpl_id);
+H5_DLL htri_t H5G__obj_lookup(const H5O_loc_t *grp_oloc, const char *name,
+    H5O_link_t *lnk, hid_t dxpl_id);
+
+/*
+ * These functions operate on group hierarchy names.
+ */
+H5_DLL herr_t H5G__name_init(H5G_name_t *name, const char *path);
+
+/*
+ * These functions operate on group "locations"
+ */
+H5_DLL herr_t H5G__loc_insert(H5G_loc_t *grp_loc, const char *name,
+    H5G_loc_t *obj_loc, H5O_type_t obj_type, const void *crt_info, hid_t dxpl_id);
+
+/* Testing functions */
+#ifdef H5G_TESTING
+H5_DLL htri_t H5G__is_empty_test(hid_t gid);
+H5_DLL htri_t H5G__has_links_test(hid_t gid, unsigned *nmsgs);
+H5_DLL htri_t H5G__has_stab_test(hid_t gid);
+H5_DLL htri_t H5G__is_new_dense_test(hid_t gid);
+H5_DLL herr_t H5G__new_dense_info_test(hid_t gid, hsize_t *name_count, hsize_t *corder_count);
+H5_DLL herr_t H5G__lheap_size_test(hid_t gid, size_t *lheap_size);
+H5_DLL herr_t H5G__user_path_test(hid_t obj_id, char *user_path, size_t *user_path_len, unsigned *user_path_hidden);
+H5_DLL herr_t H5G__verify_cached_stab_test(H5O_loc_t *grp_oloc, H5G_entry_t *ent);
+H5_DLL herr_t H5G__verify_cached_stabs_test(hid_t gid);
+#endif /* H5G_TESTING */
+
+#endif /* _H5Gpkg_H */
+
diff --git a/install/include/H5Gpublic.h b/install/include/H5Gpublic.h
new file mode 100644
index 0000000000..ab6f200a43
--- /dev/null
+++ b/install/include/H5Gpublic.h
@@ -0,0 +1,178 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5Gpublic.h
+ *                      Jul 11 1997
+ *                      Robb Matzke <matzke@llnl.gov>
+ *
+ * Purpose:             Public declarations for the H5G package
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef _H5Gpublic_H
+#define _H5Gpublic_H
+
+/* System headers needed by this file */
+#include <sys/types.h>
+
+/* Public headers needed by this file */
+#include "H5public.h"		/* Generic Functions			*/
+#include "H5Lpublic.h"		/* Links                                */
+#include "H5Opublic.h"		/* Object headers			*/
+#include "H5Tpublic.h"		/* Datatypes				*/
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/* Types of link storage for groups */
+typedef enum H5G_storage_type_t {
+    H5G_STORAGE_TYPE_UNKNOWN = -1,	/* Unknown link storage type	*/
+    H5G_STORAGE_TYPE_SYMBOL_TABLE,      /* Links in group are stored with a "symbol table" */
+                                        /* (this is sometimes called "old-style" groups) */
+    H5G_STORAGE_TYPE_COMPACT,		/* Links are stored in object header */
+    H5G_STORAGE_TYPE_DENSE 		/* Links are stored in fractal heap & indexed with v2 B-tree */
+} H5G_storage_type_t;
+
+/* Information struct for group (for H5Gget_info/H5Gget_info_by_name/H5Gget_info_by_idx) */
+typedef struct H5G_info_t {
+    H5G_storage_type_t 	storage_type;	/* Type of storage for links in group */
+    hsize_t 	nlinks;		        /* Number of links in group */
+    int64_t     max_corder;             /* Current max. creation order value for group */
+    hbool_t     mounted;                /* Whether group has a file mounted on it */
+} H5G_info_t;
+
+/********************/
+/* Public Variables */
+/********************/
+
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+H5_DLL hid_t H5Gcreate2(hid_t loc_id, const char *name, hid_t lcpl_id,
+    hid_t gcpl_id, hid_t gapl_id);
+H5_DLL hid_t H5Gcreate_anon(hid_t loc_id, hid_t gcpl_id, hid_t gapl_id);
+H5_DLL hid_t H5Gopen2(hid_t loc_id, const char *name, hid_t gapl_id);
+H5_DLL hid_t H5Gget_create_plist(hid_t group_id);
+H5_DLL herr_t H5Gget_info(hid_t loc_id, H5G_info_t *ginfo);
+H5_DLL herr_t H5Gget_info_by_name(hid_t loc_id, const char *name, H5G_info_t *ginfo,
+    hid_t lapl_id);
+H5_DLL herr_t H5Gget_info_by_idx(hid_t loc_id, const char *group_name,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t n, H5G_info_t *ginfo,
+    hid_t lapl_id);
+H5_DLL herr_t H5Gclose(hid_t group_id);
+H5_DLL herr_t H5Gflush(hid_t group_id);
+H5_DLL herr_t H5Grefresh(hid_t group_id);
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+
+/* Link definitions */
+#define H5G_SAME_LOC H5L_SAME_LOC
+#define H5G_LINK_ERROR H5L_TYPE_ERROR
+#define H5G_LINK_HARD H5L_TYPE_HARD
+#define H5G_LINK_SOFT H5L_TYPE_SOFT
+#define H5G_link_t H5L_type_t
+
+/* Macros for types of objects in a group (see H5G_obj_t definition) */
+#define H5G_NTYPES	256		/* Max possible number of types	*/
+#define H5G_NLIBTYPES	8		/* Number of internal types	*/
+#define H5G_NUSERTYPES	(H5G_NTYPES - H5G_NLIBTYPES)
+#define H5G_USERTYPE(X)	(8 + (X))	/* User defined types		*/
+
+
+/* Typedefs */
+
+/*
+ * An object has a certain type. The first few numbers are reserved for use
+ * internally by HDF5. Users may add their own types with higher values.  The
+ * values are never stored in the file -- they only exist while an
+ * application is running.  An object may satisfy the `isa' function for more
+ * than one type.
+ */
+typedef enum H5G_obj_t {
+    H5G_UNKNOWN = -1,		/* Unknown object type		*/
+    H5G_GROUP,		        /* Object is a group		*/
+    H5G_DATASET,		/* Object is a dataset		*/
+    H5G_TYPE,			/* Object is a named data type	*/
+    H5G_LINK,		        /* Object is a symbolic link	*/
+    H5G_UDLINK,		        /* Object is a user-defined link */
+    H5G_RESERVED_5,		/* Reserved for future use	*/
+    H5G_RESERVED_6,		/* Reserved for future use	*/
+    H5G_RESERVED_7		/* Reserved for future use	*/
+} H5G_obj_t;
+
+/* Prototype for H5Giterate() operator */
+typedef herr_t (*H5G_iterate_t)(hid_t group, const char *name, void *op_data);
+
+/* Information about an object */
+typedef struct H5G_stat_t {
+    unsigned long 	fileno[2];	/*file number			*/
+    unsigned long 	objno[2];	/*object number			*/
+    unsigned 		nlink;		/*number of hard links to object*/
+    H5G_obj_t 		type;		/*basic object type		*/
+    time_t		mtime;		/*modification time		*/
+    size_t		linklen;	/*symbolic link value length	*/
+    H5O_stat_t          ohdr;           /* Object header information    */
+} H5G_stat_t;
+
+
+/* Function prototypes */
+H5_DLL hid_t H5Gcreate1(hid_t loc_id, const char *name, size_t size_hint);
+H5_DLL hid_t H5Gopen1(hid_t loc_id, const char *name);
+H5_DLL herr_t H5Glink(hid_t cur_loc_id, H5G_link_t type, const char *cur_name,
+    const char *new_name);
+H5_DLL herr_t H5Glink2(hid_t cur_loc_id, const char *cur_name, H5G_link_t type,
+    hid_t new_loc_id, const char *new_name);
+H5_DLL herr_t H5Gmove(hid_t src_loc_id, const char *src_name,
+    const char *dst_name);
+H5_DLL herr_t H5Gmove2(hid_t src_loc_id, const char *src_name, hid_t dst_loc_id,
+    const char *dst_name);
+H5_DLL herr_t H5Gunlink(hid_t loc_id, const char *name);
+H5_DLL herr_t H5Gget_linkval(hid_t loc_id, const char *name, size_t size,
+    char *buf/*out*/);
+H5_DLL herr_t H5Gset_comment(hid_t loc_id, const char *name, const char *comment);
+H5_DLL int H5Gget_comment(hid_t loc_id, const char *name, size_t bufsize,
+    char *buf);
+H5_DLL herr_t H5Giterate(hid_t loc_id, const char *name, int *idx,
+        H5G_iterate_t op, void *op_data);
+H5_DLL herr_t H5Gget_num_objs(hid_t loc_id, hsize_t *num_objs);
+H5_DLL herr_t H5Gget_objinfo(hid_t loc_id, const char *name,
+    hbool_t follow_link, H5G_stat_t *statbuf/*out*/);
+H5_DLL ssize_t H5Gget_objname_by_idx(hid_t loc_id, hsize_t idx, char* name,
+    size_t size);
+H5_DLL H5G_obj_t H5Gget_objtype_by_idx(hid_t loc_id, hsize_t idx);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _H5Gpublic_H */
+
diff --git a/install/include/H5Group.h b/install/include/H5Group.h
new file mode 100644
index 0000000000..a7e1f7c14f
--- /dev/null
+++ b/install/include/H5Group.h
@@ -0,0 +1,90 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __Group_H
+#define __Group_H
+
+namespace H5 {
+
+/*! \class Group
+    \brief Class Group represents an HDF5 group.
+
+    Inheritance: H5Object -> H5Location -> IdComponent
+*/
+// Class forwarding
+class ArrayType;
+class VarLenType;
+
+class H5_DLLCPP Group : public H5Object, public CommonFG {
+   public:
+        // Group constructor to create a group or file (aka root group).
+        Group(const char* name, size_t size_hint = 0);
+        Group(const H5std_string& name, size_t size_hint = 0);
+
+        // Group constructor to open a group or file (aka root group).
+        Group(const char* name);
+        Group(const H5std_string& name);
+
+        // Close this group.
+        virtual void close();
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("Group"); }
+
+        // Throw group exception.
+        virtual void throwException(const H5std_string& func_name, const H5std_string& msg) const;
+
+        // for CommonFG to get the file id.
+        virtual hid_t getLocId() const;
+
+        // Creates a group by way of dereference.
+        Group(const H5Location& loc, const void* ref, H5R_type_t ref_type = H5R_OBJECT, const PropList& plist = PropList::DEFAULT);
+        // Removed in 1.10.1, because H5Location is baseclass
+//        Group(const Attribute& attr, const void* ref, H5R_type_t ref_type = H5R_OBJECT, const PropList& plist = PropList::DEFAULT);
+
+        // Opens an object within a group or a file, i.e., root group.
+        hid_t getObjId(const char* name, const PropList& plist = PropList::DEFAULT) const;
+        hid_t getObjId(const H5std_string& name, const PropList& plist = PropList::DEFAULT) const;
+
+        // Closes an object opened by getObjId().
+        void closeObjId(hid_t obj_id) const;
+
+        // default constructor
+        Group();
+
+        // Copy constructor: makes a copy of the original object
+        Group(const Group& original);
+
+        // Gets the group id.
+        virtual hid_t getId() const;
+
+        // Destructor
+        virtual ~Group();
+
+        // Creates a copy of an existing group using its id.
+        Group(const hid_t group_id);
+
+   protected:
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+        // Sets the group id.
+        virtual void p_setId(const hid_t new_id);
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+   private:
+        hid_t id;    // HDF5 group id
+
+}; // end of Group
+} // namespace H5
+
+#endif // __Group_H
diff --git a/install/include/H5HFpkg.h b/install/include/H5HFpkg.h
new file mode 100644
index 0000000000..d03c122277
--- /dev/null
+++ b/install/include/H5HFpkg.h
@@ -0,0 +1,839 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:	Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *		Friday, February 24, 2006
+ *
+ * Purpose:	This file contains declarations which are visible only within
+ *		the H5HF package.  Source files outside the H5HF package should
+ *		include H5HFprivate.h instead.
+ */
+#if !(defined H5HF_FRIEND || defined H5HF_MODULE)
+#error "Do not include this file outside the H5HF package!"
+#endif
+
+#ifndef _H5HFpkg_H
+#define _H5HFpkg_H
+
+/* Get package's private header */
+#include "H5HFprivate.h"
+
+/* Other private headers needed by this file */
+#include "H5ACprivate.h"	/* Metadata cache			*/
+#include "H5B2private.h"	/* v2 B-trees				*/
+#include "H5FLprivate.h"	/* Free Lists                           */
+#include "H5FSprivate.h"	/* Free space manager			*/
+#include "H5SLprivate.h"	/* Skip lists				*/
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* Size of checksum information (on disk) */
+#define H5HF_SIZEOF_CHKSUM      4
+
+/* "Standard" size of prefix information for fractal heap metadata */
+#define H5HF_METADATA_PREFIX_SIZE(c) (                                        \
+    H5_SIZEOF_MAGIC   /* Signature */                                         \
+    + (unsigned)1 /* Version */                                               \
+    + ((c) ? (unsigned)H5HF_SIZEOF_CHKSUM : (unsigned)0) /* Metadata checksum */ \
+    )
+
+/* Size of doubling-table information */
+#define H5HF_DTABLE_INFO_SIZE(h) (                                            \
+    (unsigned)2   /* Width of table (i.e. # of columns) */                    \
+    + (unsigned)(h)->sizeof_size /* Starting block size */                    \
+    + (unsigned)(h)->sizeof_size /* Maximum direct block size */              \
+    + (unsigned)2 /* Max. size of heap (log2 of actual value - i.e. the # of bits) */   \
+    + (unsigned)2 /* Starting # of rows in root indirect block */             \
+    + (unsigned)(h)->sizeof_addr /* File address of table managed */          \
+    + (unsigned)2 /* Current # of rows in root indirect block */              \
+    )
+
+/* Flags for status byte */
+#define H5HF_HDR_FLAGS_HUGE_ID_WRAPPED 0x01     /* "huge" object IDs have wrapped */
+#define H5HF_HDR_FLAGS_CHECKSUM_DBLOCKS 0x02    /* checksum direct blocks */
+
+/* Size of the fractal heap header on disk */
+/* (this is the fixed-len portion, the variable-len I/O filter information
+ *      follows this information, if there are I/O filters for the heap)
+ */
+#define H5HF_HEADER_SIZE(h)     (                                             \
+    /* General metadata fields */                                             \
+    H5HF_METADATA_PREFIX_SIZE(TRUE)                                           \
+                                                                              \
+    /* Fractal Heap Header specific fields */                                 \
+                                                                              \
+    /* General heap information */                                            \
+    + (unsigned)2 /* Heap ID len */                                           \
+    + (unsigned)2 /* I/O filters' encoded len */                              \
+    + (unsigned)1 /* Status flags */                                          \
+                                                                              \
+    /* "Huge" object fields */                                                \
+    + (unsigned)4 /* Max. size of "managed" object */                         \
+    + (unsigned)(h)->sizeof_size /* Next ID for "huge" object */              \
+    + (unsigned)(h)->sizeof_addr /* File address of "huge" object tracker B-tree  */    \
+                                                                              \
+    /* "Managed" object free space fields */                                  \
+    + (unsigned)(h)->sizeof_size /* Total man. free space */                  \
+    + (unsigned)(h)->sizeof_addr /* File address of free section header */    \
+                                                                              \
+    /* Statistics fields */                                                   \
+    + (unsigned)(h)->sizeof_size /* Size of man. space in heap */             \
+    + (unsigned)(h)->sizeof_size /* Size of man. space iterator offset in heap */ \
+    + (unsigned)(h)->sizeof_size /* Size of alloacted man. space in heap */   \
+    + (unsigned)(h)->sizeof_size /* Number of man. objects in heap */         \
+    + (unsigned)(h)->sizeof_size /* Size of huge space in heap */             \
+    + (unsigned)(h)->sizeof_size /* Number of huge objects in heap */         \
+    + (unsigned)(h)->sizeof_size /* Size of tiny space in heap */             \
+    + (unsigned)(h)->sizeof_size /* Number of tiny objects in heap */         \
+                                                                              \
+    /* "Managed" object doubling table info */                                \
+    + H5HF_DTABLE_INFO_SIZE(h) /* Size of managed obj. doubling-table info */ \
+    )
+
+/* Size of overhead for a direct block */
+#define H5HF_MAN_ABS_DIRECT_OVERHEAD(h) (                                     \
+    /* General metadata fields */                                             \
+    H5HF_METADATA_PREFIX_SIZE(h->checksum_dblocks)                            \
+                                                                              \
+    /* Fractal heap managed, absolutely mapped direct block specific fields */ \
+    + (unsigned)(h)->sizeof_addr          /* File address of heap owning the block */ \
+    + (unsigned)(h)->heap_off_size        /* Offset of the block in the heap */ \
+    )
+
+/* Size of managed indirect block entry for a child direct block */
+#define H5HF_MAN_INDIRECT_CHILD_DIR_ENTRY_SIZE(h) (                           \
+    ((h)->filter_len > 0 ?                                                    \
+        ((unsigned)(h)->sizeof_addr + (unsigned)(h)->sizeof_size + (unsigned)4) : /* Size of entries for filtered direct blocks */ \
+        (unsigned)(h)->sizeof_addr)             /* Size of entries for un-filtered direct blocks */ \
+    )
+
+/* Size of managed indirect block */
+#define H5HF_MAN_INDIRECT_SIZE(h, r) (                                        \
+    /* General metadata fields */                                             \
+    H5HF_METADATA_PREFIX_SIZE(TRUE)                                           \
+                                                                              \
+    /* Fractal heap managed, absolutely mapped indirect block specific fields */ \
+    + (unsigned)(h)->sizeof_addr          /* File address of heap owning the block */   \
+    + (unsigned)(h)->heap_off_size        /* Offset of the block in the heap */         \
+    + (MIN(r, (h)->man_dtable.max_direct_rows) * (h)->man_dtable.cparam.width * H5HF_MAN_INDIRECT_CHILD_DIR_ENTRY_SIZE(h)) /* Size of entries for direct blocks */ \
+    + (((r > (h)->man_dtable.max_direct_rows) ? (r - (h)->man_dtable.max_direct_rows) : 0)  * (h)->man_dtable.cparam.width * (h)->sizeof_addr) /* Size of entries for indirect blocks */ \
+    )
+
+/* Compute the # of bytes required to store an offset into a given buffer size */
+#define H5HF_SIZEOF_OFFSET_BITS(b)   (((b) + 7) / 8)
+#define H5HF_SIZEOF_OFFSET_LEN(l)   H5HF_SIZEOF_OFFSET_BITS(H5VM_log2_of2((unsigned)(l)))
+
+/* Heap ID bit flags */
+/* Heap ID version (2 bits: 6-7) */
+#define H5HF_ID_VERS_CURR       0x00    /* Current version of ID format */
+#define H5HF_ID_VERS_MASK       0xC0    /* Mask for getting the ID version from flags */
+/* Heap ID type (2 bits: 4-5) */
+#define H5HF_ID_TYPE_MAN        0x00    /* "Managed" object - stored in fractal heap blocks */
+#define H5HF_ID_TYPE_HUGE       0x10    /* "Huge" object - stored in file directly */
+#define H5HF_ID_TYPE_TINY       0x20    /* "Tiny" object - stored in heap ID directly */
+#define H5HF_ID_TYPE_RESERVED   0x30    /* "?" object - reserved for future use */
+#define H5HF_ID_TYPE_MASK       0x30    /* Mask for getting the ID type from flags */
+/* Heap ID bits 0-3 reserved for future use */
+
+/* Encode a "managed" heap ID */
+#define H5HF_MAN_ID_ENCODE(i, h, o, l)                                        \
+    *(i) = H5HF_ID_VERS_CURR | H5HF_ID_TYPE_MAN;                              \
+    (i)++;                                                                    \
+    UINT64ENCODE_VAR((i), (o), (h)->heap_off_size);                           \
+    UINT64ENCODE_VAR((i), (l), (h)->heap_len_size)
+
+/* Decode a "managed" heap ID */
+#define H5HF_MAN_ID_DECODE(i, h, f, o, l)                                     \
+    f = *(uint8_t *)i++;                                                      \
+    UINT64DECODE_VAR((i), (o), (h)->heap_off_size);                           \
+    UINT64DECODE_VAR((i), (l), (h)->heap_len_size)
+
+/* Free space section types for fractal heap */
+/* (values stored in free space data structures in file) */
+#define H5HF_FSPACE_SECT_SINGLE         0       /* Section is a range of actual bytes in a direct block */
+#define H5HF_FSPACE_SECT_FIRST_ROW      1       /* Section is first range of blocks in an indirect block row */
+#define H5HF_FSPACE_SECT_NORMAL_ROW     2       /* Section is a range of blocks in an indirect block row */
+#define H5HF_FSPACE_SECT_INDIRECT       3       /* Section is a span of blocks in an indirect block */
+
+/* Flags for 'op' operations */
+#define H5HF_OP_MODIFY          0x0001          /* Operation will modify object */
+#define H5HF_OP_FLAGS           (H5HF_OP_MODIFY)        /* Bit-wise OR of all op flags */
+
+/* Flags for 'root_iblock_flags' field in header */
+#define H5HF_ROOT_IBLOCK_PINNED         0x01
+#define H5HF_ROOT_IBLOCK_PROTECTED      0x02
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/* Doubling-table info */
+typedef struct H5HF_dtable_t {
+    /* Immutable, pre-set information for table */
+    H5HF_dtable_cparam_t    cparam;     /* Creation parameters for table */
+
+    /* Derived information (stored, varies during lifetime of table) */
+    haddr_t     table_addr;     /* Address of first block for table */
+                                /* Undefined if no space allocated for table */
+    unsigned    curr_root_rows; /* Current number of rows in the root indirect block */
+                                /* 0 indicates that the TABLE_ADDR field points
+                                 * to direct block (of START_BLOCK_SIZE) instead
+                                 * of indirect root block.
+                                 */
+
+    /* Computed information (not stored) */
+    unsigned    max_root_rows;      /* Maximum # of rows in root indirect block */
+    unsigned    max_direct_rows;    /* Maximum # of direct rows in any indirect block */
+    unsigned    start_bits;         /* # of bits for starting block size (i.e. log2(start_block_size)) */
+    unsigned    max_direct_bits;    /* # of bits for max. direct block size (i.e. log2(max_direct_size)) */
+    unsigned    max_dir_blk_off_size;   /* Max. size of offsets in direct blocks */
+    unsigned    first_row_bits;     /* # of bits in address of first row */
+    hsize_t     num_id_first_row;   /* Number of IDs in first row of table */
+    hsize_t     *row_block_size;    /* Block size per row of indirect block */
+    hsize_t     *row_block_off;     /* Cumulative offset per row of indirect block */
+    hsize_t     *row_tot_dblock_free;   /* Total free space in dblocks for this row */
+                                    /* (For indirect block rows, it's the total
+                                     * free space in all direct blocks referenced
+                                     * from the indirect block)
+                                     */
+    size_t      *row_max_dblock_free;   /* Max. free space in dblocks for this row */
+                                    /* (For indirect block rows, it's the maximum
+                                     * free space in a direct block referenced
+                                     * from the indirect block)
+                                     */
+} H5HF_dtable_t;
+
+/* Fractal heap free list info (forward decl - defined in H5HFflist.c) */
+typedef struct H5HF_freelist_t H5HF_freelist_t;
+
+/* Forward decl indirect block info */
+typedef struct H5HF_indirect_t H5HF_indirect_t;
+
+/* Fractal heap block location */
+typedef struct H5HF_block_loc_t {
+    /* Necessary table fields */
+    unsigned    row;            /* Row of block in doubling table             */
+    unsigned    col;            /* Column of block in doubling table          */
+
+    /* Derived/computed/cached table fields */
+    unsigned    entry;          /* Entry of block in doubling table           */
+
+    /* Infrastructure */
+    H5HF_indirect_t *context;   /* Pointer to the indirect block containing the block */
+    struct H5HF_block_loc_t *up;  /* Pointer to next level up in the stack of levels */
+} H5HF_block_loc_t;
+
+/* Fractal heap block iterator info */
+typedef struct H5HF_block_iter_t {
+    hbool_t ready;              /* Set if iterator is finished initializing   */
+    H5HF_block_loc_t *curr;     /* Pointer to the current level information for iterator */
+} H5HF_block_iter_t;
+
+/* Fractal heap free space section info */
+typedef struct H5HF_free_section_t {
+    H5FS_section_info_t sect_info;              /* Free space section information (must be first in struct) */
+    union {
+        struct {
+            H5HF_indirect_t *parent;            /* Indirect block parent for free section's direct block */
+            unsigned par_entry;                 /* Entry of free section's direct block in parent indirect block */
+        } single;
+        struct {
+            struct H5HF_free_section_t *under;  /* Pointer to indirect block underlying row section */
+            unsigned    row;                    /* Row for range of blocks */
+            unsigned    col;                    /* Column for range of blocks */
+            unsigned    num_entries;            /* Number of entries covered */
+
+            /* Fields that aren't stored */
+            hbool_t     checked_out;            /* Flag to indicate that a row section is temporarily out of the free space manager */
+        } row;
+        struct {
+            /* Holds either a pointer to an indirect block (if its "live") or
+             *  the block offset of it's indirect block (if its "serialized")
+             *  (This allows the indirect block that the section is within to
+             *          be compared with other sections, whether it's serialized
+             *          or not)
+             */
+            union {
+                H5HF_indirect_t *iblock;        /* Indirect block for free section */
+                hsize_t iblock_off;             /* Indirect block offset in "heap space" */
+            } u;
+            unsigned    row;                    /* Row for range of blocks */
+            unsigned    col;                    /* Column for range of blocks */
+            unsigned    num_entries;            /* Number of entries covered */
+
+            /* Fields that aren't stored */
+            struct H5HF_free_section_t *parent; /* Pointer to "parent" indirect section */
+            unsigned    par_entry;              /* Entry within parent indirect section */
+            hsize_t     span_size;              /* Size of space tracked, in "heap space" */
+            unsigned    iblock_entries;         /* Number of entries in indirect block where section is located */
+            unsigned    rc;                     /* Reference count of outstanding row & child indirect sections */
+            unsigned    dir_nrows;              /* Number of direct rows in section */
+            struct H5HF_free_section_t **dir_rows;  /* Array of pointers to outstanding row sections */
+            unsigned    indir_nents;            /* Number of indirect entries in section */
+            struct H5HF_free_section_t **indir_ents; /* Array of pointers to outstanding child indirect sections */
+        } indirect;
+    } u;
+} H5HF_free_section_t;
+
+/* The fractal heap header information */
+/* (Each fractal heap header has certain information that is shared across all
+ * the instances of blocks in that fractal heap)
+ */
+typedef struct H5HF_hdr_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* General header information (stored in header) */
+    unsigned    id_len;         /* Size of heap IDs (in bytes) */
+    unsigned    filter_len;     /* Size of I/O filter information (in bytes) */
+
+    /* Flags for heap settings (stored in status byte in header) */
+    hbool_t     debug_objs;     /* Is the heap storing objects in 'debug' format */
+    hbool_t     write_once;     /* Is heap being written in "write once" mode? */
+    hbool_t     huge_ids_wrapped; /* Have "huge" object IDs wrapped around? */
+    hbool_t     checksum_dblocks; /* Should the direct blocks in the heap be checksummed? */
+
+    /* Doubling table information (partially stored in header) */
+    /* (Partially set by user, partially derived/updated internally) */
+    H5HF_dtable_t man_dtable;   /* Doubling-table info for managed objects */
+
+    /* Free space information for managed objects (stored in header) */
+    hsize_t     total_man_free; /* Total amount of free space in managed blocks */
+    haddr_t     fs_addr;        /* Address of free space header on disk */
+
+    /* "Huge" object support (stored in header) */
+    uint32_t    max_man_size;   /* Max. size of object to manage in doubling table */
+    hsize_t     huge_next_id;   /* Next ID to use for indirectly tracked 'huge' object */
+    haddr_t     huge_bt2_addr;  /* Address of v2 B-tree for tracking "huge" object info */
+
+    /* I/O filter support (stored in header, if any are used) */
+    H5O_pline_t pline;          /* I/O filter pipeline for heap objects */
+    size_t      pline_root_direct_size;    /* Size of filtered root direct block */
+    unsigned    pline_root_direct_filter_mask; /* I/O filter mask for filtered root direct block */
+
+    /* Statistics for heap (stored in header) */
+    hsize_t     man_size;       /* Total amount of 'managed' space in heap */
+    hsize_t     man_alloc_size; /* Total amount of allocated 'managed' space in heap */
+    hsize_t     man_iter_off;   /* Offset of iterator in 'managed' heap space */
+    hsize_t     man_nobjs;      /* Number of 'managed' objects in heap */
+    hsize_t     huge_size;      /* Total size of 'huge' objects in heap */
+    hsize_t     huge_nobjs;     /* Number of 'huge' objects in heap */
+    hsize_t     tiny_size;      /* Total size of 'tiny' objects in heap */
+    hsize_t     tiny_nobjs;     /* Number of 'tiny' objects in heap */
+
+    /* Cached/computed values (not stored in header) */
+    size_t      rc;             /* Reference count of heap's components using heap header */
+    haddr_t     heap_addr;      /* Address of heap header in the file */
+    size_t      heap_size;      /* Size of heap header in the file */
+    unsigned    mode;           /* Access mode for heap */
+    H5F_t      *f;              /* Pointer to file for heap */
+    size_t      file_rc;        /* Reference count of files using heap header */
+    hbool_t     pending_delete; /* Heap is pending deletion */
+    uint8_t     sizeof_size;    /* Size of file sizes */
+    uint8_t     sizeof_addr;    /* Size of file addresses */
+    struct H5HF_indirect_t *root_iblock;    /* Pointer to root indirect block */
+    unsigned    root_iblock_flags;      /* Flags to indicate whether root indirect block is pinned/protected */
+    H5FS_t      *fspace;        /* Free space list for objects in heap */
+    H5HF_block_iter_t next_block;   /* Block iterator for searching for next block with space */
+    H5B2_t      *huge_bt2;      /* v2 B-tree handle for huge objects */
+    hsize_t     huge_max_id;    /* Max. 'huge' heap ID before rolling 'huge' heap IDs over */
+    uint8_t     huge_id_size;   /* Size of 'huge' heap IDs (in bytes) */
+    hbool_t     huge_ids_direct; /* Flag to indicate that 'huge' object's offset & length are stored directly in heap ID */
+    size_t      tiny_max_len;   /* Max. size of tiny objects for this heap */
+    hbool_t     tiny_len_extended; /* Flag to indicate that 'tiny' object's length is stored in extended form (i.e. w/extra byte) */
+    uint8_t     heap_off_size;  /* Size of heap offsets (in bytes) */
+    uint8_t     heap_len_size;  /* Size of heap ID lengths (in bytes) */
+    hbool_t     checked_filters; /* TRUE if pipeline passes can_apply checks */
+} H5HF_hdr_t;
+
+/* Common indirect block doubling table entry */
+/* (common between entries pointing to direct & indirect child blocks) */
+typedef struct H5HF_indirect_ent_t {
+    haddr_t     addr;           /* Direct block's address                     */
+} H5HF_indirect_ent_t;
+
+/* Extern indirect block doubling table entry for compressed direct blocks */
+/* (only exists for indirect blocks in heaps that have I/O filters) */
+typedef struct H5HF_indirect_filt_ent_t {
+    size_t     size;            /* Size of child direct block, after passing though I/O filters */
+    unsigned	filter_mask;	/* Excluded filters for child direct block */
+} H5HF_indirect_filt_ent_t;
+
+/* Fractal heap indirect block */
+struct H5HF_indirect_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* Internal heap information (not stored) */
+    size_t      rc;             /* Reference count of objects using this block */
+    H5HF_hdr_t	*hdr;	        /* Shared heap header info	              */
+    struct H5HF_indirect_t *parent;	/* Shared parent indirect block info  */
+    struct H5HF_indirect_t 
+		*fd_parent;	/* Saved copy of the parent pointer -- this   */
+				/* necessary as the parent field is sometimes */
+				/* nulled out before the eviction notify call */
+				/* is made from the metadata cache.  Since    */
+				/* this call cancels flush dependencies, it   */
+				/* needs this information.		      */
+    unsigned    par_entry;      /* Entry in parent's table                    */
+    haddr_t     addr;           /* Address of this indirect block on disk     */
+    size_t      size;           /* Size of indirect block on disk             */
+    unsigned    nrows;          /* Total # of rows in indirect block          */
+    unsigned    max_rows;       /* Max. # of rows in indirect block           */
+    unsigned    nchildren;      /* Number of child blocks                     */
+    unsigned    max_child;      /* Max. offset used in child entries          */
+    struct H5HF_indirect_t **child_iblocks; /* Array of pointers to pinned child indirect blocks */
+
+    /* Stored values */
+    hsize_t     block_off;      /* Offset of the block within the heap's address space */
+    H5HF_indirect_ent_t *ents;  /* Pointer to block entry table               */
+    H5HF_indirect_filt_ent_t *filt_ents;    /* Pointer to filtered information for direct blocks */
+};
+
+/* A fractal heap direct block */
+typedef struct H5HF_direct_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    /* Internal heap information */
+    H5HF_hdr_t	*hdr;	        /* Shared heap header info	              */
+    H5HF_indirect_t *parent;	/* Shared parent indirect block info          */
+    H5HF_indirect_t *fd_parent;	/* Saved copy of the parent pointer -- this   */
+				/* necessary as the parent field is sometimes */
+				/* nulled out before the eviction notify call */
+				/* is made from the metadata cache.  Since    */
+				/* this call cancels flush dependencies, it   */
+				/* needs this information.		      */
+    unsigned    par_entry;      /* Entry in parent's table                    */
+    size_t      size;           /* Size of direct block                       */
+    hsize_t     file_size;      /* Size of direct block in file (only valid when block's space is being freed) */
+    uint8_t     *blk;           /* Pointer to buffer containing block data    */
+    uint8_t	*write_buf;	/* Pointer to buffer containing the block data */
+                                /* in form ready to copy to the metadata       */
+                                /* cache's image buffer.                       */
+                                /*                                             */
+                                /* This field is used by                       */
+                                /* H5HF_cache_dblock_pre_serialize() to pass   */
+                                /* the serialized image of the direct block to */
+                                /* H5HF_cache_dblock_serialize().  It should   */
+                                /* NULL at all other times.                    */
+                                /*                                             */
+                                /* If I/O filters are enabled, the pre-        */
+                                /* the pre-serialize function will allocate    */
+                                /* a buffer, copy the filtered version of the  */
+                                /* direct block image into it, and place the   */
+                                /* base address of the buffer in this field.   */
+                                /* The serialize function must discard this    */
+                                /* buffer after it copies the contents into    */
+                                /* the image buffer provided by the metadata   */
+                                /* cache.                                      */
+                                /*                                             */
+                                /* If I/O filters are not enabled, the         */
+                                /* write_buf field is simply set equal to the  */
+                                /* blk field by the pre-serialize function,    */
+                                /* and back to NULL by the serialize function. */
+    size_t	write_size;     /* size of the buffer pointed to by write_buf. */
+
+    /* Stored values */
+    hsize_t     block_off;      /* Offset of the block within the heap's address space */
+} H5HF_direct_t;
+
+/* Fractal heap */
+struct H5HF_t {
+    H5HF_hdr_t  *hdr;           /* Pointer to internal fractal heap header info */
+    H5F_t      *f;              /* Pointer to file for heap */
+};
+
+/* Fractal heap "parent info" (for loading a block) */
+typedef struct H5HF_parent_t {
+    H5HF_hdr_t *hdr;                /* Pointer to heap header info */
+    H5HF_indirect_t *iblock;    /* Pointer to parent indirect block */
+    unsigned entry;             /* Location of block in parent's entry table */
+} H5HF_parent_t;
+
+/* Typedef for indirectly accessed 'huge' object's records in the v2 B-tree */
+typedef struct H5HF_huge_bt2_indir_rec_t {
+    haddr_t addr;       /* Address of the object in the file */
+    hsize_t len;        /* Length of the object in the file */
+    hsize_t id;         /* ID used for object (not used for 'huge' objects directly accessed) */
+} H5HF_huge_bt2_indir_rec_t;
+
+/* Typedef for indirectly accessed, filtered 'huge' object's records in the v2 B-tree */
+typedef struct H5HF_huge_bt2_filt_indir_rec_t {
+    haddr_t addr;       /* Address of the filtered object in the file */
+    hsize_t len;        /* Length of the filtered object in the file */
+    unsigned filter_mask;   /* I/O pipeline filter mask for filtered object in the file */
+    hsize_t obj_size;   /* Size of the de-filtered object in memory */
+    hsize_t id;         /* ID used for object (not used for 'huge' objects directly accessed) */
+} H5HF_huge_bt2_filt_indir_rec_t;
+
+/* Typedef for directly accessed 'huge' object's records in the v2 B-tree */
+typedef struct H5HF_huge_bt2_dir_rec_t {
+    haddr_t addr;       /* Address of the object in the file */
+    hsize_t len;        /* Length of the object in the file */
+} H5HF_huge_bt2_dir_rec_t;
+
+/* Typedef for directly accessed, filtered 'huge' object's records in the v2 B-tree */
+typedef struct H5HF_huge_bt2_filt_dir_rec_t {
+    haddr_t addr;       /* Address of the filtered object in the file */
+    hsize_t len;        /* Length of the filtered object in the file */
+    unsigned filter_mask;   /* I/O pipeline filter mask for filtered object in the file */
+    hsize_t obj_size;   /* Size of the de-filtered object in memory */
+} H5HF_huge_bt2_filt_dir_rec_t;
+
+/* User data for free space section 'add' callback */
+typedef struct {
+    H5HF_hdr_t *hdr;            /* Fractal heap header */
+    hid_t dxpl_id;              /* DXPL ID for operation */
+} H5HF_sect_add_ud_t;
+
+/* User data for v2 B-tree 'remove' callback on 'huge' objects */
+typedef struct {
+    H5HF_hdr_t *hdr;            /* Fractal heap header (in) */
+    hid_t dxpl_id;              /* DXPL ID for operation (in) */
+    hsize_t obj_len;            /* Length of object removed (out) */
+} H5HF_huge_remove_ud_t;
+
+/* User data for fractal heap header cache client callback */
+typedef struct H5HF_hdr_cache_ud_t {
+    H5F_t *f;                   /* File pointer */
+    hid_t dxpl_id;              /* DXPL ID for operation (in) */
+} H5HF_hdr_cache_ud_t;
+
+/* User data for fractal heap indirect block cache client callbacks */
+typedef struct H5HF_iblock_cache_ud_t {
+    H5HF_parent_t * par_info;   /* Parent info */
+    H5F_t * f;                  /* File pointer */
+    const unsigned *nrows;      /* Number of rows */
+} H5HF_iblock_cache_ud_t;
+
+/* User data for fractal heap direct block cache client callbacks */
+typedef struct H5HF_dblock_cache_ud_t {
+    H5HF_parent_t par_info;     /* Parent info */
+    H5F_t * f;                  /* File pointer */
+    size_t odi_size;		/* On disk image size of the direct block.
+				 * Note that there is no necessary relation
+				 * between this value, and the actual
+				 * direct block size, as conpression may
+				 * reduce the size of the on disk image,
+				 * and check sums may increase it.
+				 */
+    size_t dblock_size;		/* size of the direct block, which bears
+				 * no necessary relation to the block
+				 * odi_size -- the size of the on disk
+				 * image of the block.  Note that the
+				 * metadata cache is only interested
+				 * in the odi_size, and thus it is this
+				 * value that is passed to the cache in
+				 * calls to it.
+				 */
+    unsigned filter_mask;	/* Excluded filters for direct block */
+    uint8_t *dblk;  /* Pointer to the buffer containing the decompressed
+                     * direct block data obtained in verify_chksum callback.
+                     * It will be used later in deserialize callback.
+                     */
+    htri_t decompressed;    /* Indicate that the direct block has been
+                             * decompressed in verify_chksum callback.
+                             * It will be used later in deserialize callback.
+                             */
+} H5HF_dblock_cache_ud_t;
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+/* The v2 B-tree class for tracking indirectly accessed 'huge' objects */
+H5_DLLVAR const H5B2_class_t H5HF_HUGE_BT2_INDIR[1];
+
+/* The v2 B-tree class for tracking indirectly accessed filtered 'huge' objects */
+H5_DLLVAR const H5B2_class_t H5HF_HUGE_BT2_FILT_INDIR[1];
+
+/* The v2 B-tree class for tracking directly accessed 'huge' objects */
+H5_DLLVAR const H5B2_class_t H5HF_HUGE_BT2_DIR[1];
+
+/* The v2 B-tree class for tracking directly accessed filtered 'huge' objects */
+H5_DLLVAR const H5B2_class_t H5HF_HUGE_BT2_FILT_DIR[1];
+
+/* H5HF single section inherits serializable properties from H5FS_section_class_t */
+H5_DLLVAR H5FS_section_class_t H5HF_FSPACE_SECT_CLS_SINGLE[1];
+
+/* H5HF 'first' row section inherits serializable properties from H5FS_section_class_t */
+H5_DLLVAR H5FS_section_class_t H5HF_FSPACE_SECT_CLS_FIRST_ROW[1];
+
+/* H5HF 'normal' row section inherits serializable properties from H5FS_section_class_t */
+H5_DLLVAR H5FS_section_class_t H5HF_FSPACE_SECT_CLS_NORMAL_ROW[1];
+
+/* H5HF indirect section inherits serializable properties from H5FS_section_class_t */
+H5_DLLVAR H5FS_section_class_t H5HF_FSPACE_SECT_CLS_INDIRECT[1];
+
+/* Declare a free list to manage the H5HF_indirect_t struct */
+H5FL_EXTERN(H5HF_indirect_t);
+
+/* Declare a free list to manage the H5HF_indirect_ent_t sequence information */
+H5FL_SEQ_EXTERN(H5HF_indirect_ent_t);
+
+/* Declare a free list to manage the H5HF_indirect_filt_ent_t sequence information */
+H5FL_SEQ_EXTERN(H5HF_indirect_filt_ent_t);
+
+/* Declare a free list to manage the H5HF_indirect_t * sequence information */
+typedef H5HF_indirect_t *H5HF_indirect_ptr_t;
+H5FL_SEQ_EXTERN(H5HF_indirect_ptr_t);
+
+/* Declare a free list to manage the H5HF_direct_t struct */
+H5FL_EXTERN(H5HF_direct_t);
+
+/* Declare a free list to manage heap direct block data to/from disk */
+H5FL_BLK_EXTERN(direct_block);
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+/* Doubling table routines */
+H5_DLL herr_t H5HF_dtable_init(H5HF_dtable_t *dtable);
+H5_DLL herr_t H5HF_dtable_dest(H5HF_dtable_t *dtable);
+H5_DLL herr_t H5HF_dtable_lookup(const H5HF_dtable_t *dtable, hsize_t off,
+    unsigned *row, unsigned *col);
+H5_DLL unsigned H5HF_dtable_size_to_row(const H5HF_dtable_t *dtable, size_t block_size);
+H5_DLL unsigned H5HF_dtable_size_to_rows(const H5HF_dtable_t *dtable, hsize_t size);
+H5_DLL hsize_t H5HF_dtable_span_size(const H5HF_dtable_t *dtable, unsigned start_row,
+    unsigned start_col, unsigned num_entries);
+
+/* Heap header routines */
+H5_DLL H5HF_hdr_t * H5HF_hdr_alloc(H5F_t *f);
+H5_DLL haddr_t H5HF_hdr_create(H5F_t *f, hid_t dxpl_id, const H5HF_create_t *cparam);
+H5_DLL H5HF_hdr_t *H5HF_hdr_protect(H5F_t *f, hid_t dxpl_id, haddr_t addr,
+    unsigned flags);
+H5_DLL herr_t H5HF_hdr_finish_init_phase1(H5HF_hdr_t *hdr);
+H5_DLL herr_t H5HF_hdr_finish_init_phase2(H5HF_hdr_t *hdr);
+H5_DLL herr_t H5HF_hdr_finish_init(H5HF_hdr_t *hdr);
+H5_DLL herr_t H5HF_hdr_incr(H5HF_hdr_t *hdr);
+H5_DLL herr_t H5HF_hdr_decr(H5HF_hdr_t *hdr);
+H5_DLL herr_t H5HF_hdr_fuse_incr(H5HF_hdr_t *hdr);
+H5_DLL size_t H5HF_hdr_fuse_decr(H5HF_hdr_t *hdr);
+H5_DLL herr_t H5HF_hdr_dirty(H5HF_hdr_t *hdr);
+H5_DLL herr_t H5HF_hdr_adj_free(H5HF_hdr_t *hdr, ssize_t amt);
+H5_DLL herr_t H5HF_hdr_adjust_heap(H5HF_hdr_t *hdr, hsize_t new_size, hssize_t extra_free);
+H5_DLL herr_t H5HF_hdr_inc_alloc(H5HF_hdr_t *hdr, size_t alloc_size);
+H5_DLL herr_t H5HF_hdr_start_iter(H5HF_hdr_t *hdr, H5HF_indirect_t *iblock, hsize_t curr_off, unsigned curr_entry);
+H5_DLL herr_t H5HF_hdr_skip_blocks(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_indirect_t *iblock, unsigned start_entry, unsigned nentries);
+H5_DLL herr_t H5HF_hdr_update_iter(H5HF_hdr_t *hdr, hid_t dxpl_id, size_t min_dblock_size);
+H5_DLL herr_t H5HF_hdr_inc_iter(H5HF_hdr_t *hdr, hsize_t adv_size, unsigned nentries);
+H5_DLL herr_t H5HF_hdr_reverse_iter(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    haddr_t dblock_addr);
+H5_DLL herr_t H5HF_hdr_reset_iter(H5HF_hdr_t *hdr, hsize_t curr_off);
+H5_DLL herr_t H5HF_hdr_empty(H5HF_hdr_t *hdr);
+H5_DLL herr_t H5HF_hdr_free(H5HF_hdr_t *hdr);
+H5_DLL herr_t H5HF_hdr_delete(H5HF_hdr_t *hdr, hid_t dxpl_id);
+H5_DLL herr_t H5HF_hdr_dest(H5HF_hdr_t *hdr);
+
+/* Indirect block routines */
+H5_DLL herr_t H5HF_iblock_incr(H5HF_indirect_t *iblock);
+H5_DLL herr_t H5HF_iblock_decr(H5HF_indirect_t *iblock);
+H5_DLL herr_t H5HF_iblock_dirty(H5HF_indirect_t *iblock);
+H5_DLL herr_t H5HF_man_iblock_root_create(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    size_t min_dblock_size);
+H5_DLL herr_t H5HF_man_iblock_root_double(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    size_t min_dblock_size);
+H5_DLL herr_t H5HF_man_iblock_alloc_row(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_free_section_t **sec_node);
+H5_DLL herr_t H5HF_man_iblock_create(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_indirect_t *par_iblock, unsigned par_entry, unsigned nrows,
+    unsigned max_rows, haddr_t *addr_p);
+H5_DLL H5HF_indirect_t *H5HF_man_iblock_protect(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    haddr_t iblock_addr, unsigned iblock_nrows,
+    H5HF_indirect_t *par_iblock, unsigned par_entry, hbool_t must_protect,
+    unsigned flags, hbool_t *did_protect);
+H5_DLL herr_t H5HF_man_iblock_unprotect(H5HF_indirect_t *iblock, hid_t dxpl_id,
+    unsigned cache_flags, hbool_t did_protect);
+H5_DLL herr_t H5HF_man_iblock_attach(H5HF_indirect_t *iblock, unsigned entry,
+    haddr_t dblock_addr);
+H5_DLL herr_t H5HF_man_iblock_detach(H5HF_indirect_t *iblock, hid_t dxpl_id, unsigned entry);
+H5_DLL herr_t H5HF_man_iblock_entry_addr(H5HF_indirect_t *iblock, unsigned entry,
+    haddr_t *child_addr);
+H5_DLL herr_t H5HF_man_iblock_delete(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    haddr_t iblock_addr, unsigned iblock_nrows, H5HF_indirect_t *par_iblock,
+    unsigned par_entry);
+H5_DLL herr_t H5HF_man_iblock_size(H5F_t *f, hid_t dxpl_id, H5HF_hdr_t *hdr,
+    haddr_t iblock_addr, unsigned nrows, H5HF_indirect_t *par_iblock, unsigned par_entry, hsize_t *heap_size/*out*/);
+H5_DLL herr_t H5HF_man_iblock_dest(H5HF_indirect_t *iblock);
+
+/* Direct block routines */
+H5_DLL herr_t H5HF_man_dblock_new(H5HF_hdr_t *fh, hid_t dxpl_id, size_t request,
+    H5HF_free_section_t **ret_sec_node);
+H5_DLL herr_t H5HF_man_dblock_create(hid_t dxpl_id, H5HF_hdr_t *hdr,
+    H5HF_indirect_t *par_iblock, unsigned par_entry, haddr_t *addr_p,
+    H5HF_free_section_t **ret_sec_node);
+H5_DLL herr_t H5HF_man_dblock_destroy(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_direct_t *dblock, haddr_t dblock_addr);
+H5_DLL H5HF_direct_t *H5HF_man_dblock_protect(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    haddr_t dblock_addr, size_t dblock_size,
+    H5HF_indirect_t *par_iblock, unsigned par_entry,
+    unsigned flags);
+H5_DLL herr_t H5HF_man_dblock_locate(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    hsize_t obj_off, H5HF_indirect_t **par_iblock,
+    unsigned *par_entry, hbool_t *par_did_protect, unsigned flags);
+H5_DLL herr_t H5HF_man_dblock_delete(H5F_t *f, hid_t dxpl_id, haddr_t dblock_addr,
+    hsize_t dblock_size);
+H5_DLL herr_t H5HF_man_dblock_dest(H5HF_direct_t *dblock);
+
+/* Managed object routines */
+H5_DLL herr_t H5HF_man_insert(H5HF_hdr_t *fh, hid_t dxpl_id, size_t obj_size,
+    const void *obj, void *id);
+H5_DLL herr_t H5HF_man_get_obj_len(H5HF_hdr_t *hdr, const uint8_t *id,
+    size_t *obj_len_p);
+H5_DLL void H5HF__man_get_obj_off(const H5HF_hdr_t *hdr, const uint8_t *id,
+    hsize_t *obj_off_p);
+H5_DLL herr_t H5HF_man_read(H5HF_hdr_t *fh, hid_t dxpl_id, const uint8_t *id,
+    void *obj);
+H5_DLL herr_t H5HF_man_write(H5HF_hdr_t *hdr, hid_t dxpl_id, const uint8_t *id,
+    const void *obj);
+H5_DLL herr_t H5HF_man_op(H5HF_hdr_t *hdr, hid_t dxpl_id, const uint8_t *id,
+    H5HF_operator_t op, void *op_data);
+H5_DLL herr_t H5HF_man_remove(H5HF_hdr_t *hdr, hid_t dxpl_id, const uint8_t *id);
+
+/* 'Huge' object routines */
+H5_DLL herr_t H5HF_huge_init(H5HF_hdr_t *hdr);
+H5_DLL herr_t H5HF_huge_insert(H5HF_hdr_t *hdr, hid_t dxpl_id, size_t obj_size,
+    void *obj, void *id);
+H5_DLL herr_t H5HF_huge_get_obj_len(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    const uint8_t *id, size_t *obj_len_p);
+H5_DLL herr_t H5HF__huge_get_obj_off(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    const uint8_t *id, hsize_t *obj_off_p);
+H5_DLL herr_t H5HF_huge_read(H5HF_hdr_t *fh, hid_t dxpl_id, const uint8_t *id,
+    void *obj);
+H5_DLL herr_t H5HF_huge_write(H5HF_hdr_t *hdr, hid_t dxpl_id, const uint8_t *id,
+    const void *obj);
+H5_DLL herr_t H5HF_huge_op(H5HF_hdr_t *hdr, hid_t dxpl_id, const uint8_t *id,
+    H5HF_operator_t op, void *op_data);
+H5_DLL herr_t H5HF_huge_remove(H5HF_hdr_t *fh, hid_t dxpl_id, const uint8_t *id);
+H5_DLL herr_t H5HF_huge_term(H5HF_hdr_t *hdr, hid_t dxpl_id);
+H5_DLL herr_t H5HF_huge_delete(H5HF_hdr_t *hdr, hid_t dxpl_id);
+
+/* 'Huge' object v2 B-tree function callbacks */
+H5_DLL herr_t H5HF__huge_bt2_indir_found(const void *nrecord, void *op_data);
+H5_DLL herr_t H5HF__huge_bt2_indir_remove(const void *nrecord, void *op_data);
+H5_DLL herr_t H5HF__huge_bt2_filt_indir_found(const void *nrecord, void *op_data);
+H5_DLL herr_t H5HF__huge_bt2_filt_indir_remove(const void *nrecord, void *op_data);
+H5_DLL herr_t H5HF__huge_bt2_dir_remove(const void *nrecord, void *op_data);
+H5_DLL herr_t H5HF__huge_bt2_filt_dir_found(const void *nrecord, void *op_data);
+H5_DLL herr_t H5HF__huge_bt2_filt_dir_remove(const void *nrecord, void *op_data);
+
+/* 'Tiny' object routines */
+H5_DLL herr_t H5HF_tiny_init(H5HF_hdr_t *hdr);
+H5_DLL herr_t H5HF_tiny_insert(H5HF_hdr_t *hdr, size_t obj_size, const void *obj,
+    void *id);
+H5_DLL herr_t H5HF_tiny_get_obj_len(H5HF_hdr_t *hdr, const uint8_t *id,
+    size_t *obj_len_p);
+H5_DLL herr_t H5HF_tiny_read(H5HF_hdr_t *fh, const uint8_t *id, void *obj);
+H5_DLL herr_t H5HF_tiny_op(H5HF_hdr_t *hdr, const uint8_t *id,
+    H5HF_operator_t op, void *op_data);
+H5_DLL herr_t H5HF_tiny_remove(H5HF_hdr_t *fh, const uint8_t *id);
+
+/* Debugging routines for dumping file structures */
+H5_DLL void H5HF_hdr_print(const H5HF_hdr_t *hdr, hid_t dxpl_id,
+    hbool_t dump_internal, FILE *stream, int indent, int fwidth);
+H5_DLL herr_t H5HF_hdr_debug(H5F_t *f, hid_t dxpl_id, haddr_t addr,
+    FILE *stream, int indent, int fwidth);
+H5_DLL herr_t H5HF_dblock_debug(H5F_t *f, hid_t dxpl_id, haddr_t addr,
+    FILE *stream, int indent, int fwidth, haddr_t hdr_addr, size_t nrec);
+H5_DLL void H5HF_iblock_print(const H5HF_indirect_t *iblock, hbool_t dump_internal,
+    FILE *stream, int indent, int fwidth);
+H5_DLL herr_t H5HF_iblock_debug(H5F_t *f, hid_t dxpl_id, haddr_t addr,
+    FILE *stream, int indent, int fwidth, haddr_t hdr_addr, unsigned nrows);
+
+/* Block iteration routines */
+H5_DLL herr_t H5HF_man_iter_init(H5HF_block_iter_t *biter);
+H5_DLL herr_t H5HF_man_iter_start_offset(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_block_iter_t *biter, hsize_t offset);
+H5_DLL herr_t H5HF_man_iter_start_entry(H5HF_hdr_t *hdr, H5HF_block_iter_t *biter,
+    H5HF_indirect_t *iblock, unsigned start_entry);
+H5_DLL herr_t H5HF_man_iter_set_entry(const H5HF_hdr_t *hdr,
+    H5HF_block_iter_t *biter, unsigned entry);
+H5_DLL herr_t H5HF_man_iter_next(H5HF_hdr_t *hdr, H5HF_block_iter_t *biter,
+    unsigned nentries);
+H5_DLL herr_t H5HF_man_iter_up(H5HF_block_iter_t *biter);
+H5_DLL herr_t H5HF_man_iter_down(H5HF_block_iter_t *biter, H5HF_indirect_t *iblock);
+H5_DLL herr_t H5HF_man_iter_reset(H5HF_block_iter_t *biter);
+H5_DLL herr_t H5HF_man_iter_curr(H5HF_block_iter_t *biter, unsigned *row, unsigned *col,
+    unsigned *entry, H5HF_indirect_t **block);
+H5_DLL herr_t H5HF_man_iter_offset(H5HF_hdr_t *hdr, H5HF_block_iter_t *biter,
+    hsize_t *offset);
+H5_DLL hbool_t H5HF_man_iter_ready(H5HF_block_iter_t *biter);
+
+/* Free space manipulation routines */
+H5_DLL herr_t H5HF_space_start(H5HF_hdr_t *hdr, hid_t dxpl_id, hbool_t may_create);
+H5_DLL herr_t H5HF_space_add(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_free_section_t *node, unsigned flags);
+H5_DLL htri_t H5HF_space_find(H5HF_hdr_t *hdr, hid_t dxpl_id, hsize_t request,
+    H5HF_free_section_t **node);
+H5_DLL herr_t H5HF_space_revert_root(const H5HF_hdr_t *hdr, hid_t dxpl_id);
+H5_DLL herr_t H5HF_space_create_root(const H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_indirect_t *root_iblock);
+H5_DLL herr_t H5HF_space_size(H5HF_hdr_t *hdr, hid_t dxpl_id, hsize_t *fs_size);
+H5_DLL herr_t H5HF_space_remove(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_free_section_t *node);
+H5_DLL herr_t H5HF_space_close(H5HF_hdr_t *hdr, hid_t dxpl_id);
+H5_DLL herr_t H5HF_space_delete(H5HF_hdr_t *hdr, hid_t dxpl_id);
+H5_DLL herr_t H5HF_space_sect_change_class(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_free_section_t *sect, uint16_t new_class);
+
+/* Free space section routines */
+H5_DLL H5HF_free_section_t *H5HF_sect_single_new(hsize_t sect_off,
+    size_t sect_size, H5HF_indirect_t *parent, unsigned par_entry);
+H5_DLL herr_t H5HF_sect_single_revive(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_free_section_t *sect);
+H5_DLL herr_t H5HF_sect_single_dblock_info(H5HF_hdr_t *hdr,
+    H5HF_free_section_t *sect, haddr_t *dblock_addr, size_t *dblock_size);
+H5_DLL herr_t H5HF_sect_single_reduce(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_free_section_t *sect, size_t amt);
+H5_DLL herr_t H5HF_sect_row_revive(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_free_section_t *sect);
+H5_DLL herr_t H5HF_sect_row_reduce(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_free_section_t *sect, unsigned *entry_p);
+H5_DLL H5HF_indirect_t *H5HF_sect_row_get_iblock(H5HF_free_section_t *sect);
+H5_DLL herr_t H5HF_sect_indirect_add(H5HF_hdr_t *hdr, hid_t dxpl_id,
+    H5HF_indirect_t *iblock, unsigned start_entry, unsigned nentries);
+H5_DLL herr_t H5HF_sect_single_free(H5FS_section_info_t *sect);
+
+/* Internal operator callbacks */
+H5_DLL herr_t H5HF_op_read(const void *obj, size_t obj_len, void *op_data);
+H5_DLL herr_t H5HF_op_write(const void *obj, size_t obj_len, void *op_data);
+
+/* Testing routines */
+#ifdef H5HF_TESTING
+H5_DLL herr_t H5HF_get_cparam_test(const H5HF_t *fh, H5HF_create_t *cparam);
+H5_DLL int H5HF_cmp_cparam_test(const H5HF_create_t *cparam1, const H5HF_create_t *cparam2);
+H5_DLL unsigned H5HF_get_max_root_rows(const H5HF_t *fh);
+H5_DLL unsigned H5HF_get_dtable_width_test(const H5HF_t *fh);
+H5_DLL unsigned H5HF_get_dtable_max_drows_test(const H5HF_t *fh);
+H5_DLL unsigned H5HF_get_iblock_max_drows_test(const H5HF_t *fh, unsigned pos);
+H5_DLL hsize_t H5HF_get_dblock_size_test(const H5HF_t *fh, unsigned row);
+H5_DLL hsize_t H5HF_get_dblock_free_test(const H5HF_t *fh, unsigned row);
+H5_DLL herr_t H5HF_get_id_off_test(const H5HF_t *fh, const void *id, hsize_t *obj_off);
+H5_DLL herr_t H5HF_get_id_type_test(const void *id, unsigned char *obj_type);
+H5_DLL herr_t H5HF_get_tiny_info_test(const H5HF_t *fh, size_t *max_len,
+    hbool_t *len_extended);
+H5_DLL herr_t H5HF_get_huge_info_test(const H5HF_t *fh, hsize_t *next_id,
+    hbool_t *ids_direct);
+#endif /* H5HF_TESTING */
+
+#endif /* _H5HFpkg_H */
+
diff --git a/install/include/H5HFpublic.h b/install/include/H5HFpublic.h
new file mode 100644
index 0000000000..82cfc21375
--- /dev/null
+++ b/install/include/H5HFpublic.h
@@ -0,0 +1,52 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5HFpublic.h
+ *                      Feb 24 2006
+ *                      Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *
+ * Purpose:             Public declarations for the fractal heap package.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#ifndef _H5HFpublic_H
+#define _H5HFpublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/**********************************/
+/* Public API Function Prototypes */
+/**********************************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _H5HFpublic_H */
+
diff --git a/install/include/H5HGpkg.h b/install/include/H5HGpkg.h
new file mode 100644
index 0000000000..47760bf307
--- /dev/null
+++ b/install/include/H5HGpkg.h
@@ -0,0 +1,144 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer: Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *             Wednesday, July 9, 2003
+ *
+ * Purpose:     This file contains declarations which are visible
+ *              only within the H5HG package. Source files outside the
+ *              H5HG package should include H5HGprivate.h instead.
+ */
+#if !(defined H5HG_FRIEND || defined H5HG_MODULE)
+#error "Do not include this file outside the H5HG package!"
+#endif
+
+#ifndef _H5HGpkg_H
+#define _H5HGpkg_H
+
+/* Get package's private header */
+#include "H5HGprivate.h"
+
+/* Other private headers needed by this file */
+#include "H5ACprivate.h"	/* Metadata cache			*/
+#include "H5FLprivate.h"	/* Free lists                           */
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+/* Declare extern the free list to manage the H5HG_t struct */
+H5FL_EXTERN(H5HG_heap_t);
+
+/* Declare extern the free list to manage sequences of H5HG_obj_t's */
+H5FL_SEQ_EXTERN(H5HG_obj_t);
+
+/* Declare extern the PQ free list to manage heap chunks */
+H5FL_BLK_EXTERN(gheap_chunk);
+
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/*
+ * Global heap collection version.
+ */
+#define H5HG_VERSION	1
+
+/*
+ * All global heap collections are at least this big.  This allows us to read
+ * most collections with a single read() since we don't have to read a few
+ * bytes of header to figure out the size.  If the heap is larger than this
+ * then a second read gets the rest after we've decoded the header.
+ */
+#define H5HG_MINSIZE	4096
+
+/*
+ * Pad all global heap messages to a multiple of eight bytes so we can load
+ * the entire collection into memory and operate on it there.  Eight should
+ * be sufficient for machines that have alignment constraints because our
+ * largest data type is eight bytes.
+ */
+#define H5HG_ALIGNMENT	8
+#define H5HG_ALIGN(X)	(H5HG_ALIGNMENT*(((X)+H5HG_ALIGNMENT-1)/H5HG_ALIGNMENT))
+#define H5HG_ISALIGNED(X) ((X)==H5HG_ALIGN(X))
+
+/*
+ * The size of the collection header, always a multiple of the alignment so
+ * that the stuff that follows the header is aligned.
+ */
+#define H5HG_SIZEOF_HDR(f)						      \
+    (size_t)H5HG_ALIGN(4 +			/*magic number		*/ \
+                       1 +			/*version number	*/ \
+                       3 +			/*reserved		*/ \
+                       H5F_SIZEOF_SIZE(f))	/*collection size	*/
+
+/*
+ * The overhead associated with each object in the heap, always a multiple of
+ * the alignment so that the stuff that follows the header is aligned.
+ */
+#define H5HG_SIZEOF_OBJHDR(f)						      \
+    (size_t)H5HG_ALIGN(2 +			/*object id number	*/ \
+                       2 +			/*reference count	*/ \
+                       4 +			/*reserved		*/ \
+                       H5F_SIZEOF_SIZE(f))	/*object data size	*/
+
+/*
+ * The initial guess for the number of messages in a collection.  We assume
+ * that all objects in that collection are zero length, giving the maximum
+ * possible number of objects in the collection.  The collection itself has
+ * some overhead and each message has some overhead.  The `+2' accounts for
+ * rounding and for the free space object.
+ */
+#define H5HG_NOBJS(f,z) ((((z)-H5HG_SIZEOF_HDR(f))/		      \
+                          H5HG_SIZEOF_OBJHDR(f)+2))
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+typedef struct H5HG_obj_t {
+    int         nrefs;      /* reference count                  */
+    size_t      size;       /* total size of object             */
+    uint8_t     *begin;     /* ptr to object into heap->chunk   */
+} H5HG_obj_t;
+
+/* Forward declarations for fields */
+struct H5F_file_t;
+
+struct H5HG_heap_t {
+    H5AC_info_t cache_info; /* Information for H5AC cache functions, _must_ be */
+                            /* first field in structure */
+    haddr_t		addr;		/*collection address		*/
+    size_t		size;		/*total size of collection	*/
+    uint8_t		*chunk;		/*the collection, incl. header	*/
+    size_t		nalloc;		/*numb object slots allocated	*/
+    size_t		nused;		/*number of slots used		*/
+                                        /* If this value is >65535 then all indices */
+                                        /* have been used at some time and the */
+                                        /* correct new index should be searched for */
+    struct H5F_file_t   *shared;        /* shared file */
+    H5HG_obj_t	*obj;		/*array of object descriptions	*/
+};
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+H5_DLL herr_t H5HG_free(H5HG_heap_t *heap);
+H5_DLL H5HG_heap_t *H5HG_protect(H5F_t *f, hid_t dxpl_id, haddr_t addr, unsigned flags);
+
+#endif /* _H5HGpkg_H */
+
diff --git a/install/include/H5HGpublic.h b/install/include/H5HGpublic.h
new file mode 100644
index 0000000000..fcec5933bc
--- /dev/null
+++ b/install/include/H5HGpublic.h
@@ -0,0 +1,31 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Robb Matzke <matzke@llnl.gov>
+ *              Friday, March 27, 1998
+ */
+#ifndef _H5HGpublic_H
+#define _H5HGpublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/install/include/H5HLpkg.h b/install/include/H5HLpkg.h
new file mode 100644
index 0000000000..770b7c0736
--- /dev/null
+++ b/install/include/H5HLpkg.h
@@ -0,0 +1,152 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer: Quincey Koziol <koziol@hdfgroup.org>
+ *             Wednesday, July 9, 2003
+ *
+ * Purpose:     This file contains declarations which are visible
+ *              only within the H5HL package. Source files outside the
+ *              H5HL package should include H5HLprivate.h instead.
+ */
+#if !(defined H5HL_FRIEND || defined H5HL_MODULE)
+#error "Do not include this file outside the H5HL package!"
+#endif
+
+#ifndef _H5HLpkg_H
+#define _H5HLpkg_H
+
+/* Get package's private header */
+#include "H5HLprivate.h"
+
+/* Other private headers needed by this file */
+#include "H5FLprivate.h"    /* Free lists                           */
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+/* Declare extern the free list to manage the H5HL_free_t struct */
+H5FL_EXTERN(H5HL_free_t);
+
+/* Declare extern the PQ free list to manage the heap chunk information */
+H5FL_BLK_EXTERN(lheap_chunk);
+
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* If this package header is being included in one of the H5HL source files,
+ *      define the proper control macros for the generic FUNC_ENTER/LEAVE and
+ *      error reporting macros.
+ */
+#ifdef H5HL_PACKAGE
+#define H5_MY_PKG       H5HL
+#define H5_MY_PKG_ERR   H5E_HEAP
+#define H5_MY_PKG_INIT  NO
+#endif /* H5HL_PACKAGE */
+
+#define H5HL_SIZEOF_HDR(F)                                                  \
+    H5HL_ALIGN(H5_SIZEOF_MAGIC +    /* heap signature   */                  \
+        1 +                         /* version          */                  \
+        3 +	                        /* reserved         */                  \
+        H5F_SIZEOF_SIZE(F) +        /* data size        */                  \
+        H5F_SIZEOF_SIZE(F) +        /* free list head   */                  \
+        H5F_SIZEOF_ADDR(F))         /* data address     */
+
+/* Value indicating end of free list on disk */
+#define H5HL_FREE_NULL  1
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+typedef struct H5HL_free_t {
+    size_t              offset;     /* offset of free block         */
+    size_t              size;       /* size of free block           */
+    struct H5HL_free_t  *prev;      /* previous entry in free list  */
+    struct H5HL_free_t  *next;      /* next entry in free list      */
+} H5HL_free_t;
+
+/* Forward declarations */
+typedef struct H5HL_dblk_t H5HL_dblk_t;
+typedef struct H5HL_prfx_t H5HL_prfx_t;
+
+struct H5HL_t {
+    /* General heap-management fields */
+    size_t          rc;                 /* Ref. count for prefix & data block using this struct         */
+    size_t          prots;              /* # of times the heap has been protected                       */
+    size_t          sizeof_size;        /* Size of file sizes                                           */
+    size_t          sizeof_addr;        /* Size of file addresses                                       */
+    hbool_t         single_cache_obj;   /* Indicate if the heap is a single object in the cache         */
+    H5HL_free_t     *freelist;          /* the free list                                                */
+
+    /* Prefix-specific fields */
+    H5HL_prfx_t     *prfx;              /* The prefix object for the heap                       */
+    haddr_t         prfx_addr;          /* address of heap prefix                               */
+    size_t          prfx_size;          /* size of heap prefix                                  */
+    hsize_t         free_block;         /* Address of first free block                          */
+
+    /* Data block-specific fields */
+    H5HL_dblk_t     *dblk;              /* The data block object for the heap                   */
+    haddr_t         dblk_addr;          /* address of data block                                */
+    size_t          dblk_size;          /* size of heap data block on disk and in mem           */
+    uint8_t         *dblk_image;        /* The data block image                                 */
+};
+
+/* Struct for heap data block */
+struct H5HL_dblk_t {
+    H5AC_info_t     cache_info;         /* Information for H5AC cache functions, _must_ be      */
+                                        /* first field in structure                             */
+    H5HL_t          *heap;              /* Pointer to heap for data block                       */
+};
+
+/* Struct for heap prefix */
+struct H5HL_prfx_t {
+    H5AC_info_t     cache_info;         /* Information for H5AC cache functions, _must_ be      */
+                                        /* first field in structure                             */
+    H5HL_t          *heap;              /* Pointer to heap for prefix                           */
+};
+
+/* Callback information for loading local heap prefix from disk */
+typedef struct H5HL_cache_prfx_ud_t {
+    size_t sizeof_size;                 /* Size of file sizes */
+    size_t sizeof_addr;                 /* Size of file addresses */
+    haddr_t prfx_addr;                  /* Address of prefix */
+    size_t sizeof_prfx;                 /* Size of heap prefix */
+} H5HL_cache_prfx_ud_t;
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+/* Heap routines */
+H5_DLL H5HL_t *H5HL__new(size_t sizeof_size, size_t sizeof_addr, size_t prfx_size);
+H5_DLL herr_t H5HL__dest(H5HL_t *heap);
+H5_DLL herr_t H5HL__inc_rc(H5HL_t *heap);
+H5_DLL herr_t H5HL__dec_rc(H5HL_t *heap);
+
+/* Heap prefix routines */
+H5_DLL H5HL_prfx_t *H5HL__prfx_new(H5HL_t *heap);
+H5_DLL herr_t H5HL__prfx_dest(H5HL_prfx_t *prfx);
+
+/* Heap data block routines */
+H5_DLL H5HL_dblk_t *H5HL__dblk_new(H5HL_t *heap);
+H5_DLL herr_t H5HL__dblk_dest(H5HL_dblk_t *dblk);
+H5_DLL herr_t H5HL__dblk_realloc(H5F_t *f, hid_t dxpl_id, H5HL_t *heap, size_t new_heap_size);
+
+#endif /* _H5HLpkg_H */
diff --git a/install/include/H5HLpublic.h b/install/include/H5HLpublic.h
new file mode 100644
index 0000000000..143bb78692
--- /dev/null
+++ b/install/include/H5HLpublic.h
@@ -0,0 +1,37 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5HLpublic.h
+ *                      Jul 16 1997
+ *                      Robb Matzke <matzke@llnl.gov>
+ *
+ * Purpose:             Public declarations for the H5HL (local heap) package.
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef _H5HLpublic_H
+#define _H5HLpublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/install/include/H5IMpublic.h b/install/include/H5IMpublic.h
new file mode 100644
index 0000000000..a95e439855
--- /dev/null
+++ b/install/include/H5IMpublic.h
@@ -0,0 +1,85 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef _H5IMpublic_H
+#define _H5IMpublic_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+H5_HLDLL herr_t  H5IMmake_image_8bit( hid_t loc_id,
+                            const char *dset_name,
+                            hsize_t width,
+                            hsize_t height,
+                            const unsigned char *buffer );
+
+H5_HLDLL herr_t  H5IMmake_image_24bit( hid_t loc_id,
+                             const char *dset_name,
+                             hsize_t width,
+                             hsize_t height,
+                             const char *interlace,
+                             const unsigned char *buffer );
+
+H5_HLDLL herr_t  H5IMget_image_info( hid_t loc_id,
+                     const char *dset_name,
+                     hsize_t *width,
+                     hsize_t *height,
+                     hsize_t *planes,
+                     char    *interlace,
+                     hssize_t *npals );
+
+H5_HLDLL herr_t  H5IMread_image( hid_t loc_id,
+                       const char *dset_name,
+                       unsigned char *buffer );
+
+H5_HLDLL herr_t  H5IMmake_palette( hid_t loc_id,
+                         const char *pal_name,
+                         const hsize_t *pal_dims,
+                         const unsigned char *pal_data );
+
+H5_HLDLL herr_t  H5IMlink_palette( hid_t loc_id,
+                        const char *image_name,
+                        const char *pal_name );
+
+H5_HLDLL herr_t  H5IMunlink_palette( hid_t loc_id,
+                           const char *image_name,
+                           const char *pal_name );
+
+H5_HLDLL herr_t  H5IMget_npalettes( hid_t loc_id,
+                          const char *image_name,
+                          hssize_t *npals );
+
+H5_HLDLL herr_t  H5IMget_palette_info( hid_t loc_id,
+                        const char *image_name,
+                        int pal_number,
+                        hsize_t *pal_dims );
+
+H5_HLDLL herr_t  H5IMget_palette( hid_t loc_id,
+                        const char *image_name,
+                        int pal_number,
+                        unsigned char *pal_data );
+
+H5_HLDLL herr_t  H5IMis_image( hid_t loc_id,
+                     const char *dset_name );
+
+H5_HLDLL herr_t  H5IMis_palette( hid_t loc_id,
+                     const char *dset_name );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5IdComponent.h b/install/include/H5IdComponent.h
new file mode 100644
index 0000000000..baf939e70e
--- /dev/null
+++ b/install/include/H5IdComponent.h
@@ -0,0 +1,126 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __IdComponent_H
+#define __IdComponent_H
+
+namespace H5 {
+
+/*! \class IdComponent
+    \brief Class IdComponent provides wrappers of the C functions that
+     operate on an HDF5 identifier.
+
+    In most cases, the C library handles these operations and an application
+    rarely needs them.
+*/
+class H5_DLLCPP IdComponent {
+    public:
+
+        // Increment reference counter.
+        void incRefCount(const hid_t obj_id) const;
+        void incRefCount() const;
+
+        // Decrement reference counter.
+        void decRefCount(const hid_t obj_id) const;
+        void decRefCount() const;
+
+        // Get the reference counter to this identifier.
+        int getCounter(const hid_t obj_id) const;
+        int getCounter() const;
+
+        // Returns an HDF5 object type, given the object id.
+        static H5I_type_t getHDFObjType(const hid_t obj_id);
+
+        // Returns an HDF5 object type of this object.
+        H5I_type_t getHDFObjType() const;
+
+        // Returns the number of members in a type.
+        static hsize_t getNumMembers(H5I_type_t type);
+
+        // Checks if the given ID is valid.
+        static bool isValid(hid_t an_id);
+
+        // Determines if an type exists.
+        static bool typeExists(H5I_type_t type);
+
+        // Assignment operator.
+        IdComponent& operator=(const IdComponent& rhs);
+
+        // Sets the identifier of this object to a new value.
+        void setId(const hid_t new_id);
+
+        // *** Deprecation warning ***
+        // The following two constructors are no longer appropriate after the
+        // data member "id" had been moved to the sub-classes.
+        // The copy constructor is a noop and is removed in 1.8.15 and the
+        // other will be removed from 1.10 release, and then from 1.8 if its
+        // removal does not raise any problems in two 1.10 releases.
+
+        // Creates an object to hold an HDF5 identifier.
+        // IdComponent(const hid_t h5_id); - removed from 1.10.1
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+        // Copy constructor: makes copy of the original IdComponent object.
+        // IdComponent(const IdComponent& original); - removed from 1.8.15
+
+        // Gets the identifier of this object.
+        virtual hid_t getId () const = 0;
+
+        // Pure virtual function for there are various H5*close for the
+        // subclasses.
+        virtual void close() = 0;
+
+        // Makes and returns the string "<class-name>::<func_name>";
+        // <class-name> is returned by fromClass().
+        H5std_string inMemFunc(const char* func_name) const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass() const { return("IdComponent");}
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+        // Destructor
+        virtual ~IdComponent();
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+    protected:
+        // Default constructor.
+        IdComponent();
+
+        // Gets the name of the file, in which an HDF5 object belongs.
+        H5std_string p_get_file_name() const;
+
+        // Verifies that the given id is valid.
+        static bool p_valid_id(const hid_t obj_id);
+
+        // Sets the identifier of this object to a new value. - this one
+        // doesn't increment reference count
+        virtual void p_setId(const hid_t new_id) = 0;
+
+        // This flag is used to decide whether H5dont_atexit should be called
+        static bool H5dontAtexit_called;
+
+    private:
+        // This flag indicates whether H5Library::initH5cpp has been called
+        // to register various terminating functions with atexit()
+        static bool H5cppinit;
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end class IdComponent
+} // namespace H5
+
+#endif // __IdComponent_H
diff --git a/install/include/H5Include.h b/install/include/H5Include.h
new file mode 100644
index 0000000000..a18043033f
--- /dev/null
+++ b/install/include/H5Include.h
@@ -0,0 +1,40 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#include <hdf5.h>
+
+// Define bool type for platforms that don't support bool yet
+#ifdef BOOL_NOTDEFINED
+#ifdef false
+#undef false
+#endif
+#ifdef true
+#undef true
+#endif
+typedef int bool;
+const bool  false = 0;
+const bool  true  = 1;
+#endif
+
+// These are defined in H5Opkg.h, which should not be included in the C++ API,
+// so re-define them here for now.
+
+/* Initial version of the object header format */
+#define H5O_VERSION_1    1
+
+/* Revised version - leaves out reserved bytes and alignment padding, and adds
+ *      magic number as prefix and checksum as suffix for all chunks.
+ */
+#define H5O_VERSION_2    2
+
diff --git a/install/include/H5IntType.h b/install/include/H5IntType.h
new file mode 100644
index 0000000000..82a7cfd012
--- /dev/null
+++ b/install/include/H5IntType.h
@@ -0,0 +1,62 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5IntType_H
+#define __H5IntType_H
+
+namespace H5 {
+
+/*! \class IntType
+    \brief IntType is a derivative of a DataType and operates on HDF5
+    integer datatype.
+
+    Inheritance: AtomType -> DataType -> H5Object -> H5Location -> IdComponent
+*/
+class H5_DLLCPP IntType : public AtomType {
+   public:
+        // Creates an integer type using a predefined type
+        IntType(const PredType& pred_type);
+
+        // Gets the integer datatype of the specified dataset
+        IntType(const DataSet& dataset);
+
+        // Constructors that open an HDF5 integer datatype, given a location.
+        IntType(const H5Location& loc, const char* name);
+        IntType(const H5Location& loc, const H5std_string& name);
+
+        // Retrieves the sign type for an integer type
+        H5T_sign_t getSign() const;
+
+        // Sets the sign proprety for an integer type.
+        void setSign(H5T_sign_t sign) const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("IntType"); }
+
+        // Default constructor
+        IntType();
+
+        // Creates a integer datatype using an existing id
+        IntType(const hid_t existing_id);
+
+        // Copy constructor: makes copy of IntType object
+        IntType(const IntType& original);
+
+        // Noop destructor.
+        virtual ~IntType();
+
+}; // end of IntType
+} // namespace H5
+
+#endif // __H5IntType_H
diff --git a/install/include/H5Ipkg.h b/install/include/H5Ipkg.h
new file mode 100644
index 0000000000..16d7d6793b
--- /dev/null
+++ b/install/include/H5Ipkg.h
@@ -0,0 +1,74 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:	Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *		Thursday, May 15, 2003
+ *
+ * Purpose:	This file contains declarations which are visible only within
+ *		the H5I package.  Source files outside the H5I package should
+ *		include H5Iprivate.h instead.
+ */
+#if !(defined H5I_FRIEND || defined H5I_MODULE)
+#error "Do not include this file outside the H5I package!"
+#endif
+
+#ifndef _H5Ipkg_H
+#define _H5Ipkg_H
+
+/* Get package's private header */
+#include "H5Iprivate.h"
+
+/* Other private headers needed by this file */
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/*
+ * Number of bits to use for ID Type in each atom. Increase if more types
+ * are needed (though this will decrease the number of available IDs per
+ * type). This is the only number that must be changed since all other bit
+ * field sizes and masks are calculated from TYPE_BITS.
+ */
+#define TYPE_BITS	7
+#define TYPE_MASK	(((hid_t)1 << TYPE_BITS) - 1)
+
+#define H5I_MAX_NUM_TYPES TYPE_MASK
+
+/*
+ * Number of bits to use for the Atom index in each atom (assumes 8-bit
+ * bytes). We don't use the sign bit.
+ */
+#define ID_BITS		((sizeof(hid_t) * 8) - (TYPE_BITS + 1))
+#define ID_MASK		(((hid_t)1 << ID_BITS) - 1)
+
+/* Map an atom to an ID type number */
+#define H5I_TYPE(a)	((H5I_type_t)(((hid_t)(a) >> ID_BITS) & TYPE_MASK))
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+/* Testing functions */
+#ifdef H5I_TESTING
+H5_DLL ssize_t H5I_get_name_test(hid_t id, char *name/*out*/, size_t size,
+    hbool_t *cached);
+#endif /* H5I_TESTING */
+
+#endif /*_H5Ipkg_H*/
diff --git a/install/include/H5Ipublic.h b/install/include/H5Ipublic.h
new file mode 100644
index 0000000000..c737bbedff
--- /dev/null
+++ b/install/include/H5Ipublic.h
@@ -0,0 +1,104 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains function prototypes for each exported function in
+ * the H5I module.
+ */
+#ifndef _H5Ipublic_H
+#define _H5Ipublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+
+/*
+ * Library type values.  Start with `1' instead of `0' because it makes the
+ * tracing output look better when hid_t values are large numbers.  Change the
+ * TYPE_BITS in H5I.c if the MAXID gets larger than 32 (an assertion will
+ * fail otherwise).
+ *
+ * When adding types here, add a section to the 'misc19' test in test/tmisc.c
+ * to verify that the H5I{inc|dec|get}_ref() routines work correctly with it.
+ *
+ * NOTE: H5I_REFERENCE is not used by the library and has been deprecated
+ *       with a tentative removal version of 1.12.0. (DER, July 2017)
+ */
+typedef enum H5I_type_t {
+    H5I_UNINIT      = (-2),     /* uninitialized type                           */
+    H5I_BADID       = (-1),     /* invalid Type                                 */
+    H5I_FILE        = 1,        /* type ID for File objects                     */
+    H5I_GROUP,                  /* type ID for Group objects                    */
+    H5I_DATATYPE,               /* type ID for Datatype objects                 */
+    H5I_DATASPACE,              /* type ID for Dataspace objects                */
+    H5I_DATASET,                /* type ID for Dataset objects                  */
+    H5I_ATTR,                   /* type ID for Attribute objects                */
+    H5I_REFERENCE,              /* *DEPRECATED* type ID for Reference objects   */
+    H5I_VFL,                    /* type ID for virtual file layer               */
+    H5I_GENPROP_CLS,            /* type ID for generic property list classes    */
+    H5I_GENPROP_LST,            /* type ID for generic property lists           */
+    H5I_ERROR_CLASS,            /* type ID for error classes                    */
+    H5I_ERROR_MSG,              /* type ID for error messages                   */
+    H5I_ERROR_STACK,            /* type ID for error stacks                     */
+    H5I_NTYPES                  /* number of library types, MUST BE LAST!       */
+} H5I_type_t;
+
+/* Type of atoms to return to users */
+typedef int64_t hid_t;
+#define H5_SIZEOF_HID_T         H5_SIZEOF_INT64_T
+
+/* An invalid object ID. This is also negative for error return. */
+#define H5I_INVALID_HID         (-1)
+
+/*
+ * Function for freeing objects. This function will be called with an object
+ * ID type number and a pointer to the object. The function should free the
+ * object and return non-negative to indicate that the object
+ * can be removed from the ID type. If the function returns negative
+ * (failure) then the object will remain in the ID type.
+ */
+typedef herr_t (*H5I_free_t)(void*);
+
+/* Type of the function to compare objects & keys */
+typedef int (*H5I_search_func_t)(void *obj, hid_t id, void *key);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Public API functions */
+
+H5_DLL hid_t H5Iregister(H5I_type_t type, const void *object);
+H5_DLL void *H5Iobject_verify(hid_t id, H5I_type_t id_type);
+H5_DLL void *H5Iremove_verify(hid_t id, H5I_type_t id_type);
+H5_DLL H5I_type_t H5Iget_type(hid_t id);
+H5_DLL hid_t H5Iget_file_id(hid_t id);
+H5_DLL ssize_t H5Iget_name(hid_t id, char *name/*out*/, size_t size);
+H5_DLL int H5Iinc_ref(hid_t id);
+H5_DLL int H5Idec_ref(hid_t id);
+H5_DLL int H5Iget_ref(hid_t id);
+H5_DLL H5I_type_t H5Iregister_type(size_t hash_size, unsigned reserved, H5I_free_t free_func);
+H5_DLL herr_t H5Iclear_type(H5I_type_t type, hbool_t force);
+H5_DLL herr_t H5Idestroy_type(H5I_type_t type);
+H5_DLL int H5Iinc_type_ref(H5I_type_t type);
+H5_DLL int H5Idec_type_ref(H5I_type_t type);
+H5_DLL int H5Iget_type_ref(H5I_type_t type);
+H5_DLL void *H5Isearch(H5I_type_t type, H5I_search_func_t func, void *key);
+H5_DLL herr_t H5Inmembers(H5I_type_t type, hsize_t *num_members);
+H5_DLL htri_t H5Itype_exists(H5I_type_t type);
+H5_DLL htri_t H5Iis_valid(hid_t id);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _H5Ipublic_H */
+
diff --git a/install/include/H5LDpublic.h b/install/include/H5LDpublic.h
new file mode 100644
index 0000000000..e2bb74573e
--- /dev/null
+++ b/install/include/H5LDpublic.h
@@ -0,0 +1,31 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef _H5LDpublic_H
+#define _H5LDpublic_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5_HLDLL herr_t H5LDget_dset_dims(hid_t did, hsize_t *cur_dims);
+H5_HLDLL size_t H5LDget_dset_type_size(hid_t did, const char *fields);
+H5_HLDLL herr_t H5LDget_dset_elmts(hid_t did, const hsize_t *prev_dims,
+    const hsize_t *cur_dims, const char *fields, void *buf);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _H5LDpublic_H */
+
diff --git a/install/include/H5LTparse.h b/install/include/H5LTparse.h
new file mode 100644
index 0000000000..3d7b4e80f6
--- /dev/null
+++ b/install/include/H5LTparse.h
@@ -0,0 +1,129 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison interface for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_H5LTYY_HL_SRC_H5LTPARSE_H_INCLUDED
+# define YY_H5LTYY_HL_SRC_H5LTPARSE_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int H5LTyydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    H5T_STD_I8BE_TOKEN = 258,
+    H5T_STD_I8LE_TOKEN = 259,
+    H5T_STD_I16BE_TOKEN = 260,
+    H5T_STD_I16LE_TOKEN = 261,
+    H5T_STD_I32BE_TOKEN = 262,
+    H5T_STD_I32LE_TOKEN = 263,
+    H5T_STD_I64BE_TOKEN = 264,
+    H5T_STD_I64LE_TOKEN = 265,
+    H5T_STD_U8BE_TOKEN = 266,
+    H5T_STD_U8LE_TOKEN = 267,
+    H5T_STD_U16BE_TOKEN = 268,
+    H5T_STD_U16LE_TOKEN = 269,
+    H5T_STD_U32BE_TOKEN = 270,
+    H5T_STD_U32LE_TOKEN = 271,
+    H5T_STD_U64BE_TOKEN = 272,
+    H5T_STD_U64LE_TOKEN = 273,
+    H5T_NATIVE_CHAR_TOKEN = 274,
+    H5T_NATIVE_SCHAR_TOKEN = 275,
+    H5T_NATIVE_UCHAR_TOKEN = 276,
+    H5T_NATIVE_SHORT_TOKEN = 277,
+    H5T_NATIVE_USHORT_TOKEN = 278,
+    H5T_NATIVE_INT_TOKEN = 279,
+    H5T_NATIVE_UINT_TOKEN = 280,
+    H5T_NATIVE_LONG_TOKEN = 281,
+    H5T_NATIVE_ULONG_TOKEN = 282,
+    H5T_NATIVE_LLONG_TOKEN = 283,
+    H5T_NATIVE_ULLONG_TOKEN = 284,
+    H5T_IEEE_F32BE_TOKEN = 285,
+    H5T_IEEE_F32LE_TOKEN = 286,
+    H5T_IEEE_F64BE_TOKEN = 287,
+    H5T_IEEE_F64LE_TOKEN = 288,
+    H5T_NATIVE_FLOAT_TOKEN = 289,
+    H5T_NATIVE_DOUBLE_TOKEN = 290,
+    H5T_NATIVE_LDOUBLE_TOKEN = 291,
+    H5T_STRING_TOKEN = 292,
+    STRSIZE_TOKEN = 293,
+    STRPAD_TOKEN = 294,
+    CSET_TOKEN = 295,
+    CTYPE_TOKEN = 296,
+    H5T_VARIABLE_TOKEN = 297,
+    H5T_STR_NULLTERM_TOKEN = 298,
+    H5T_STR_NULLPAD_TOKEN = 299,
+    H5T_STR_SPACEPAD_TOKEN = 300,
+    H5T_CSET_ASCII_TOKEN = 301,
+    H5T_CSET_UTF8_TOKEN = 302,
+    H5T_C_S1_TOKEN = 303,
+    H5T_FORTRAN_S1_TOKEN = 304,
+    H5T_OPAQUE_TOKEN = 305,
+    OPQ_SIZE_TOKEN = 306,
+    OPQ_TAG_TOKEN = 307,
+    H5T_COMPOUND_TOKEN = 308,
+    H5T_ENUM_TOKEN = 309,
+    H5T_ARRAY_TOKEN = 310,
+    H5T_VLEN_TOKEN = 311,
+    STRING = 312,
+    NUMBER = 313
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 74 "hl/src/H5LTparse.y" /* yacc.c:1909  */
+
+    int     ival;         /*for integer token*/
+    char    *sval;        /*for name string*/
+    hid_t   hid;          /*for hid_t token*/
+
+#line 119 "hl/src/H5LTparse.h" /* yacc.c:1909  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE H5LTyylval;
+
+int H5LTyyparse (void);
+
+#endif /* !YY_H5LTYY_HL_SRC_H5LTPARSE_H_INCLUDED  */
diff --git a/install/include/H5LTpublic.h b/install/include/H5LTpublic.h
new file mode 100644
index 0000000000..47be98a96a
--- /dev/null
+++ b/install/include/H5LTpublic.h
@@ -0,0 +1,368 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef _H5LTpublic_H
+#define _H5LTpublic_H
+
+/* Flag definitions for H5LTopen_file_image() */
+#define H5LT_FILE_IMAGE_OPEN_RW      0x0001 /* Open image for read-write */
+#define H5LT_FILE_IMAGE_DONT_COPY    0x0002 /* The HDF5 lib won't copy   */
+/* user supplied image buffer. The same image is open with the core driver.  */
+#define H5LT_FILE_IMAGE_DONT_RELEASE 0x0004 /* The HDF5 lib won't        */
+/* deallocate user supplied image buffer. The user application is reponsible */
+/* for doing so.                                                             */ 
+#define H5LT_FILE_IMAGE_ALL          0x0007
+
+typedef enum H5LT_lang_t {
+    H5LT_LANG_ERR = -1, /*this is the first*/
+    H5LT_DDL      = 0,  /*for DDL*/
+    H5LT_C        = 1,  /*for C*/
+    H5LT_FORTRAN  = 2,  /*for Fortran*/
+    H5LT_NO_LANG  = 3   /*this is the last*/
+} H5LT_lang_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*-------------------------------------------------------------------------
+ *
+ * Make dataset functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+H5_HLDLL herr_t  H5LTmake_dataset( hid_t loc_id,
+                         const char *dset_name,
+                         int rank,
+                         const hsize_t *dims,
+                         hid_t type_id,
+                         const void *buffer );
+
+H5_HLDLL herr_t  H5LTmake_dataset_char( hid_t loc_id,
+                              const char *dset_name,
+                              int rank,
+                              const hsize_t *dims,
+                              const char *buffer );
+
+H5_HLDLL herr_t  H5LTmake_dataset_short( hid_t loc_id,
+                               const char *dset_name,
+                               int rank,
+                               const hsize_t *dims,
+                               const short *buffer );
+
+H5_HLDLL herr_t  H5LTmake_dataset_int( hid_t loc_id,
+                             const char *dset_name,
+                             int rank,
+                             const hsize_t *dims,
+                             const int *buffer );
+
+H5_HLDLL herr_t  H5LTmake_dataset_long( hid_t loc_id,
+                              const char *dset_name,
+                              int rank,
+                              const hsize_t *dims,
+                              const long *buffer );
+
+H5_HLDLL herr_t  H5LTmake_dataset_float( hid_t loc_id,
+                               const char *dset_name,
+                               int rank,
+                               const hsize_t *dims,
+                               const float *buffer );
+
+H5_HLDLL herr_t  H5LTmake_dataset_double( hid_t loc_id,
+                                const char *dset_name,
+                                int rank,
+                                const hsize_t *dims,
+                                const double *buffer );
+
+H5_HLDLL herr_t  H5LTmake_dataset_string( hid_t loc_id,
+                               const char *dset_name,
+                               const char *buf );
+
+
+/*-------------------------------------------------------------------------
+ *
+ * Read dataset functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+H5_HLDLL herr_t  H5LTread_dataset( hid_t loc_id,
+                         const char *dset_name,
+                         hid_t type_id,
+                         void *buffer );
+
+H5_HLDLL herr_t  H5LTread_dataset_char( hid_t loc_id,
+                              const char *dset_name,
+                              char *buffer );
+
+H5_HLDLL herr_t  H5LTread_dataset_short( hid_t loc_id,
+                               const char *dset_name,
+                               short *buffer );
+
+H5_HLDLL herr_t  H5LTread_dataset_int( hid_t loc_id,
+                             const char *dset_name,
+                             int *buffer );
+
+H5_HLDLL herr_t  H5LTread_dataset_long( hid_t loc_id,
+                              const char *dset_name,
+                              long *buffer );
+
+H5_HLDLL herr_t  H5LTread_dataset_float( hid_t loc_id,
+                               const char *dset_name,
+                               float *buffer );
+
+H5_HLDLL herr_t  H5LTread_dataset_double( hid_t loc_id,
+                                const char *dset_name,
+                                double *buffer );
+
+H5_HLDLL herr_t  H5LTread_dataset_string( hid_t loc_id,
+                                const char *dset_name,
+                                char *buf );
+
+/*-------------------------------------------------------------------------
+ *
+ * Query dataset functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+
+H5_HLDLL herr_t  H5LTget_dataset_ndims( hid_t loc_id,
+                             const char *dset_name,
+                             int *rank );
+
+H5_HLDLL herr_t  H5LTget_dataset_info( hid_t loc_id,
+                             const char *dset_name,
+                             hsize_t *dims,
+                             H5T_class_t *type_class,
+                             size_t *type_size );
+
+H5_HLDLL herr_t  H5LTfind_dataset( hid_t loc_id, const char *name );
+
+
+
+/*-------------------------------------------------------------------------
+ *
+ * Set attribute functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+
+H5_HLDLL herr_t  H5LTset_attribute_string( hid_t loc_id,
+                                 const char *obj_name,
+                                 const char *attr_name,
+                                 const char *attr_data );
+
+H5_HLDLL herr_t  H5LTset_attribute_char( hid_t loc_id,
+                               const char *obj_name,
+                               const char *attr_name,
+                               const char *buffer,
+                               size_t size );
+
+H5_HLDLL herr_t  H5LTset_attribute_uchar( hid_t loc_id,
+                               const char *obj_name,
+                               const char *attr_name,
+                               const unsigned char *buffer,
+                               size_t size );
+
+H5_HLDLL herr_t  H5LTset_attribute_short( hid_t loc_id,
+                              const char *obj_name,
+                              const char *attr_name,
+                              const short *buffer,
+                              size_t size );
+
+H5_HLDLL herr_t  H5LTset_attribute_ushort( hid_t loc_id,
+                              const char *obj_name,
+                              const char *attr_name,
+                              const unsigned short *buffer,
+                              size_t size );
+
+H5_HLDLL herr_t  H5LTset_attribute_int( hid_t loc_id,
+                              const char *obj_name,
+                              const char *attr_name,
+                              const int *buffer,
+                              size_t size );
+
+H5_HLDLL herr_t  H5LTset_attribute_uint( hid_t loc_id,
+                              const char *obj_name,
+                              const char *attr_name,
+                              const unsigned int *buffer,
+                              size_t size );
+
+H5_HLDLL herr_t  H5LTset_attribute_long( hid_t loc_id,
+                               const char *obj_name,
+                               const char *attr_name,
+                               const long *buffer,
+                               size_t size );
+
+H5_HLDLL herr_t  H5LTset_attribute_long_long( hid_t loc_id,
+                               const char *obj_name,
+                               const char *attr_name,
+                               const long long *buffer,
+                               size_t size );
+
+H5_HLDLL herr_t  H5LTset_attribute_ulong( hid_t loc_id,
+                               const char *obj_name,
+                               const char *attr_name,
+                               const unsigned long *buffer,
+                               size_t size );
+
+H5_HLDLL herr_t  H5LTset_attribute_float( hid_t loc_id,
+                                const char *obj_name,
+                                const char *attr_name,
+                                const float *buffer,
+                                size_t size );
+
+H5_HLDLL herr_t  H5LTset_attribute_double( hid_t loc_id,
+                                 const char *obj_name,
+                                 const char *attr_name,
+                                 const double *buffer,
+                                 size_t size );
+
+/*-------------------------------------------------------------------------
+ *
+ * Get attribute functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+H5_HLDLL herr_t  H5LTget_attribute( hid_t loc_id,
+                          const char *obj_name,
+                          const char *attr_name,
+                          hid_t mem_type_id,
+                          void *data );
+
+H5_HLDLL herr_t  H5LTget_attribute_string( hid_t loc_id,
+                                 const char *obj_name,
+                                 const char *attr_name,
+                                 char *data );
+
+H5_HLDLL herr_t  H5LTget_attribute_char( hid_t loc_id,
+                               const char *obj_name,
+                               const char *attr_name,
+                               char *data );
+
+H5_HLDLL herr_t  H5LTget_attribute_uchar( hid_t loc_id,
+                               const char *obj_name,
+                               const char *attr_name,
+                               unsigned char *data );
+
+H5_HLDLL herr_t  H5LTget_attribute_short( hid_t loc_id,
+                                const char *obj_name,
+                                const char *attr_name,
+                                short *data );
+
+H5_HLDLL herr_t  H5LTget_attribute_ushort( hid_t loc_id,
+                                const char *obj_name,
+                                const char *attr_name,
+                                unsigned short *data );
+
+H5_HLDLL herr_t  H5LTget_attribute_int( hid_t loc_id,
+                              const char *obj_name,
+                              const char *attr_name,
+                              int *data );
+
+H5_HLDLL herr_t  H5LTget_attribute_uint( hid_t loc_id,
+                              const char *obj_name,
+                              const char *attr_name,
+                              unsigned int *data );
+
+H5_HLDLL herr_t  H5LTget_attribute_long( hid_t loc_id,
+                               const char *obj_name,
+                               const char *attr_name,
+                               long *data );
+
+H5_HLDLL herr_t  H5LTget_attribute_long_long( hid_t loc_id,
+                               const char *obj_name,
+                               const char *attr_name,
+                               long long *data );
+
+H5_HLDLL herr_t  H5LTget_attribute_ulong( hid_t loc_id,
+                               const char *obj_name,
+                               const char *attr_name,
+                               unsigned long *data );
+
+H5_HLDLL herr_t  H5LTget_attribute_float( hid_t loc_id,
+                                const char *obj_name,
+                                const char *attr_name,
+                                float *data );
+
+H5_HLDLL herr_t  H5LTget_attribute_double( hid_t loc_id,
+                                 const char *obj_name,
+                                 const char *attr_name,
+                                 double *data );
+
+
+/*-------------------------------------------------------------------------
+ *
+ * Query attribute functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+
+H5_HLDLL herr_t  H5LTget_attribute_ndims( hid_t loc_id,
+                                const char *obj_name,
+                                const char *attr_name,
+                                int *rank );
+
+H5_HLDLL herr_t  H5LTget_attribute_info( hid_t loc_id,
+                               const char *obj_name,
+                               const char *attr_name,
+                               hsize_t *dims,
+                               H5T_class_t *type_class,
+                               size_t *type_size );
+
+
+
+
+
+/*-------------------------------------------------------------------------
+ *
+ * General functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+H5_HLDLL hid_t H5LTtext_to_dtype(const char *text, H5LT_lang_t lang_type);
+H5_HLDLL herr_t H5LTdtype_to_text(hid_t dtype, char *str, H5LT_lang_t lang_type, size_t *len);
+
+
+/*-------------------------------------------------------------------------
+ *
+ * Utility functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+H5_HLDLL herr_t H5LTfind_attribute( hid_t loc_id, const char *name );
+
+H5_HLDLL htri_t H5LTpath_valid(hid_t loc_id, const char *path, hbool_t check_object_valid);
+
+/*-------------------------------------------------------------------------
+ *
+ * File image operations functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+H5_HLDLL hid_t H5LTopen_file_image(void *buf_ptr, size_t buf_size, unsigned flags);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/install/include/H5LaccProp.h b/install/include/H5LaccProp.h
new file mode 100644
index 0000000000..9772cde513
--- /dev/null
+++ b/install/include/H5LaccProp.h
@@ -0,0 +1,73 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+// Class LinkAccPropList represents the HDF5 file access property list and
+// inherits from DataType.
+
+#ifndef __H5LinkAccPropList_H
+#define __H5LinkAccPropList_H
+
+namespace H5 {
+
+/*! \class LinkAccPropList
+    \brief Class LinkAccPropList inherits from PropList and provides
+    wrappers for the HDF5 file access property list.
+
+    Inheritance: PropList -> IdComponent
+*/
+class H5_DLLCPP LinkAccPropList : public PropList {
+   public:
+        ///\brief Default file access property list.
+        static const LinkAccPropList& DEFAULT;
+
+        // Creates a file access property list.
+        LinkAccPropList();
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("LinkAccPropList"); }
+
+        // Copy constructor: creates a copy of a LinkAccPropList object.
+        LinkAccPropList(const LinkAccPropList& original);
+
+        // Creates a copy of an existing file access property list
+        // using the property list id.
+        LinkAccPropList (const hid_t plist_id);
+
+        // Sets the number of soft or user-defined links that can be
+        // traversed before a failure occurs.
+        void setNumLinks(size_t nlinks) const;
+
+        // Gets the number of soft or user-defined link traversals allowed
+        size_t getNumLinks() const;
+
+        // Noop destructor
+        virtual ~LinkAccPropList();
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+        // Deletes the global constant, should only be used by the library
+        static void deleteConstants();
+
+    private:
+        static LinkAccPropList* DEFAULT_;
+
+        // Creates the global constant, should only be used by the library
+        static LinkAccPropList* getConstant();
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end of LinkAccPropList
+} // namespace H5
+
+#endif // __H5LinkAccPropList_H
diff --git a/install/include/H5Library.h b/install/include/H5Library.h
new file mode 100644
index 0000000000..9b4150ea42
--- /dev/null
+++ b/install/include/H5Library.h
@@ -0,0 +1,73 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5Library_H
+#define __H5Library_H
+
+namespace H5 {
+
+/*! \class H5Library
+    \brief Class H5Library operates the HDF5 library globably.
+
+    It is not neccessary to construct an instance of H5Library to use the
+    methods.
+*/
+class H5_DLLCPP H5Library {
+   public:
+        // Initializes the HDF5 library.
+        static void open();
+
+        // Flushes all data to disk, closes files, and cleans up memory.
+        static void close();
+
+        // Instructs library not to install atexit cleanup routine
+        static void dontAtExit();
+
+        // Returns the HDF library release number.
+        static void getLibVersion(unsigned& majnum, unsigned& minnum, unsigned& relnum);
+
+        // Verifies that the arguments match the version numbers compiled
+        // into the library
+        static void checkVersion(unsigned majnum, unsigned minnum, unsigned relnum);
+
+        // Walks through all the garbage collection routines for the library,
+        // which are supposed to free any unused memory they have allocated.
+        static void garbageCollect();
+
+        // Sets limits on the different kinds of free lists.
+        static void setFreeListLimits(int reg_global_lim, int reg_list_lim, int
+        arr_global_lim, int arr_list_lim, int blk_global_lim, int blk_list_lim);
+
+        // Initializes C++ library and registers terminating functions at exit.
+        // Only for the library functions, not for user-defined functions.
+        static void initH5cpp(void);
+
+        // Sends request for terminating the HDF5 library.
+        static void termH5cpp(void);
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+   private:
+
+        // Default constructor - no instance ever created from outsiders
+        H5Library();
+
+        // Destructor
+        ~H5Library();
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end of H5Library
+} // namespace H5
+
+#endif // __H5Library_H
diff --git a/install/include/H5Location.h b/install/include/H5Location.h
new file mode 100644
index 0000000000..a57d3ed80c
--- /dev/null
+++ b/install/include/H5Location.h
@@ -0,0 +1,225 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5Location_H
+#define __H5Location_H
+
+#include "H5Classes.h"        // constains forward class declarations
+
+namespace H5 {
+
+/*! \class H5Location
+    \brief H5Location is an abstract base class, added in version 1.8.12.
+
+    It provides a collection of wrappers for the C functions that take a
+    location identifier to specify the HDF5 object.  The location identifier
+    can be either file, group, dataset, attribute, or named datatype.
+    Wrappers for H5A functions stay in H5Object.
+
+    Inheritance: IdComponent
+*/
+// Class forwarding
+class H5_DLLCPP ArrayType;
+class H5_DLLCPP LinkAccPropList;
+class H5_DLLCPP VarLenType;
+class H5_DLLCPP H5Location : public IdComponent {
+   public:
+        // Checks if a link of a given name exists in a location
+        bool exists(const char* name, const LinkAccPropList& lapl = LinkAccPropList::DEFAULT) const;
+        bool exists(const H5std_string& name, const LinkAccPropList& lapl = LinkAccPropList::DEFAULT) const;
+
+        // Flushes all buffers associated with this location to disk.
+        void flush(H5F_scope_t scope) const;
+
+        // Gets the name of the file, specified by this location.
+        H5std_string getFileName() const;
+
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+        // Retrieves the type of object that an object reference points to.
+        H5G_obj_t getObjType(void *ref, H5R_type_t ref_type = H5R_OBJECT) const;
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+        // Retrieves the type of object that an object reference points to.
+        H5O_type_t getRefObjType(void *ref, H5R_type_t ref_type = H5R_OBJECT) const;
+        // Note: getRefObjType deprecates getObjType, but getObjType's name is
+        // misleading, so getRefObjType is used in the new function instead.
+
+        // Sets the comment for an HDF5 object specified by its name.
+        void setComment(const char* name, const char* comment) const;
+        void setComment(const H5std_string& name, const H5std_string& comment) const;
+        void setComment(const char* comment) const;
+        void setComment(const H5std_string& comment) const;
+
+        // Retrieves comment for the HDF5 object specified by its name.
+        ssize_t getComment(const char* name, size_t buf_size, char* comment) const;
+        H5std_string getComment(const char* name, size_t buf_size=0) const;
+        H5std_string getComment(const H5std_string& name, size_t buf_size=0) const;
+
+        // Removes the comment for the HDF5 object specified by its name.
+        void removeComment(const char* name) const;
+        void removeComment(const H5std_string& name) const;
+
+        // Creates a reference to a named object or to a dataset region
+        // in this object.
+        void reference(void* ref, const char* name, 
+                        H5R_type_t ref_type = H5R_OBJECT) const;
+        void reference(void* ref, const H5std_string& name,
+                        H5R_type_t ref_type = H5R_OBJECT) const;
+        void reference(void* ref, const char* name, const DataSpace& dataspace,
+                        H5R_type_t ref_type = H5R_DATASET_REGION) const;
+        void reference(void* ref, const H5std_string& name, const DataSpace& dataspace,
+                        H5R_type_t ref_type = H5R_DATASET_REGION) const;
+
+        // Open a referenced object whose location is specified by either
+        // a file, an HDF5 object, or an attribute.
+        void dereference(const H5Location& loc, const void* ref, H5R_type_t ref_type = H5R_OBJECT, const PropList& plist = PropList::DEFAULT);
+        // Removed in 1.10.1, because H5Location is baseclass
+        //void dereference(const Attribute& attr, const void* ref, H5R_type_t ref_type = H5R_OBJECT, const PropList& plist = PropList::DEFAULT);
+
+        // Retrieves a dataspace with the region pointed to selected.
+        DataSpace getRegion(void *ref, H5R_type_t ref_type = H5R_DATASET_REGION) const;
+
+// From CommonFG
+        // Creates a new group at this location which can be a file
+        // or another group.
+        Group createGroup(const char* name, size_t size_hint = 0) const;
+        Group createGroup(const H5std_string& name, size_t size_hint = 0) const;
+
+        // Opens an existing group in a location which can be a file
+        // or another group.
+        Group openGroup(const char* name) const;
+        Group openGroup(const H5std_string& name) const;
+
+        // Creates a new dataset in this group.
+        DataSet createDataSet(const char* name, const DataType& data_type, const DataSpace& data_space, const DSetCreatPropList& create_plist = DSetCreatPropList::DEFAULT) const;
+        DataSet createDataSet(const H5std_string& name, const DataType& data_type, const DataSpace& data_space, const DSetCreatPropList& create_plist = DSetCreatPropList::DEFAULT) const;
+
+        // Opens an existing dataset at this location.
+        DataSet openDataSet(const char* name) const;
+        DataSet openDataSet(const H5std_string& name) const;
+
+        // Returns the value of a symbolic link.
+        H5std_string getLinkval(const char* link_name, size_t size=0) const;
+        H5std_string getLinkval(const H5std_string& link_name, size_t size=0) const;
+
+        // Returns the number of objects in this group.
+        hsize_t getNumObjs() const;
+
+        // Retrieves the name of an object in this group, given the
+        // object's index.
+        H5std_string getObjnameByIdx(hsize_t idx) const;
+        ssize_t getObjnameByIdx(hsize_t idx, char* name, size_t size) const;
+        ssize_t getObjnameByIdx(hsize_t idx, H5std_string& name, size_t size) const;
+
+        // Retrieves the type of an object in this file or group, given the
+        // object's name
+        H5O_type_t childObjType(const H5std_string& objname) const;
+        H5O_type_t childObjType(const char* objname) const;
+        H5O_type_t childObjType(hsize_t index, H5_index_t index_type=H5_INDEX_NAME, H5_iter_order_t order=H5_ITER_INC, const char* objname=".") const;
+
+        // Returns the object header version of an object in this file or group,
+        // given the object's name.
+        unsigned childObjVersion(const char* objname) const;
+        unsigned childObjVersion(const H5std_string& objname) const;
+
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+        // Returns the type of an object in this group, given the
+        // object's index.
+        H5G_obj_t getObjTypeByIdx(hsize_t idx) const;
+        H5G_obj_t getObjTypeByIdx(hsize_t idx, char* type_name) const;
+        H5G_obj_t getObjTypeByIdx(hsize_t idx, H5std_string& type_name) const;
+
+        // Returns information about an HDF5 object, given by its name,
+        // at this location.
+        void getObjinfo(const char* name, hbool_t follow_link, H5G_stat_t& statbuf) const;
+        void getObjinfo(const H5std_string& name, hbool_t follow_link, H5G_stat_t& statbuf) const;
+        void getObjinfo(const char* name, H5G_stat_t& statbuf) const;
+        void getObjinfo(const H5std_string& name, H5G_stat_t& statbuf) const;
+
+        // Iterates over the elements of this group - not implemented in
+        // C++ style yet.
+        int iterateElems(const char* name, int *idx, H5G_iterate_t op, void *op_data);
+        int iterateElems(const H5std_string& name, int *idx, H5G_iterate_t op, void *op_data);
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+        // Creates a link of the specified type from new_name to current_name;
+        // both names are interpreted relative to the specified location id.
+        void link(H5L_type_t link_type, const char* curr_name, const char* new_name) const;
+        void link(H5L_type_t link_type, const H5std_string& curr_name, const H5std_string& new_name) const;
+
+        // Removes the specified name at this location.
+        void unlink(const char* name) const;
+        void unlink(const H5std_string& name) const;
+
+        // Mounts the file 'child' onto this location.
+        void mount(const char* name, const H5File& child, const PropList& plist) const;
+        //void mount(const char* name, H5File& child, PropList& plist) const; // removed from 1.8.18 and 1.10.1
+        void mount(const H5std_string& name, const H5File& child, const PropList& plist) const;
+        //void mount(const H5std_string& name, H5File& child, PropList& plist) const; // removed from 1.8.18 and 1.10.1
+
+        // Unmounts the file named 'name' from this parent location.
+        void unmount(const char* name) const;
+        void unmount(const H5std_string& name) const;
+
+        // Renames an object at this location.
+        void move(const char* src, const char* dst) const;
+        void move(const H5std_string& src, const H5std_string& dst) const;
+
+// end From CommonFG
+
+        /// For subclasses, H5File and Group, to throw appropriate exception.
+        virtual void throwException(const H5std_string& func_name, const H5std_string& msg) const;
+
+        // Default constructor
+        H5Location();
+
+   protected:
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+        // *** Deprecation warning ***
+        // The following two constructors are no longer appropriate after the
+        // data member "id" had been moved to the sub-classes.
+        // The copy constructor is a noop and is removed in 1.8.15 and the
+        // other will be removed from 1.10 release, and then from 1.8 if its
+        // removal does not raise any problems in two 1.10 releases.
+
+        // Creates a copy of an existing object giving the location id.
+        H5Location(const hid_t loc_id);
+
+        // Creates a reference to an HDF5 object or a dataset region.
+        void p_reference(void* ref, const char* name, hid_t space_id, H5R_type_t ref_type) const;
+
+        // Dereferences a ref into an HDF5 id.
+        hid_t p_dereference(hid_t loc_id, const void* ref, H5R_type_t ref_type, const PropList& plist, const char* from_func);
+
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+        // Retrieves the type of object that an object reference points to.
+        H5G_obj_t p_get_obj_type(void *ref, H5R_type_t ref_type) const;
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+        // Retrieves the type of object that an object reference points to.
+        H5O_type_t p_get_ref_obj_type(void *ref, H5R_type_t ref_type) const;
+
+        // Sets the identifier of this object to a new value. - this one
+        // doesn't increment reference count
+        //virtual void p_setId(const hid_t new_id);
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+        // Noop destructor.
+        virtual ~H5Location();
+
+}; // end of H5Location
+} // namespace H5
+
+#endif // __H5Location_H
diff --git a/install/include/H5Lpkg.h b/install/include/H5Lpkg.h
new file mode 100644
index 0000000000..39e3197fd4
--- /dev/null
+++ b/install/include/H5Lpkg.h
@@ -0,0 +1,62 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer: James Laird <matzke@llnl.gov>
+ *             Friday, December 1, 2005
+ *
+ * Purpose:     This file contains declarations which are visible
+ *              only within the H5L package. Source files outside the
+ *              H5L package should include H5Lprivate.h instead.
+ */
+#if !(defined H5L_FRIEND || defined H5L_MODULE)
+#error "Do not include this file outside the H5L package!"
+#endif
+
+#ifndef _H5Lpkg_H
+#define _H5Lpkg_H
+
+/* Get package's private header */
+#include "H5Lprivate.h"
+
+/* Other private headers needed by this file */
+
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+H5_DLL herr_t H5L_create_ud(const H5G_loc_t *link_loc, const char *link_name,
+    const void * ud_data, size_t ud_data_size, H5L_type_t type,
+    hid_t lcpl_id, hid_t lapl_id, hid_t dxpl_id);
+H5_DLL herr_t H5L_link_copy_file(H5F_t *dst_file, hid_t dxpl_id,
+    const H5O_link_t *_src_lnk, const H5O_loc_t *src_oloc, H5O_link_t *dst_lnk,
+    H5O_copy_t *cpy_info);
+
+#endif /* _H5Lpkg_H */
+
diff --git a/install/include/H5Lpublic.h b/install/include/H5Lpublic.h
new file mode 100644
index 0000000000..9d1643ebd4
--- /dev/null
+++ b/install/include/H5Lpublic.h
@@ -0,0 +1,200 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5Lpublic.h
+ *                      Dec 1 2005
+ *                      James Laird
+ *
+ * Purpose:             Public declarations for the H5L package (links)
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef _H5Lpublic_H
+#define _H5Lpublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"		/* Generic Functions			*/
+#include "H5Ipublic.h"		/* IDs			  		*/
+#include "H5Tpublic.h"		/* Datatypes				*/
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* Maximum length of a link's name */
+/* (encoded in a 32-bit unsigned integer) */
+#define H5L_MAX_LINK_NAME_LEN   ((uint32_t)(-1))  /* (4GB - 1) */
+
+/* Macro to indicate operation occurs on same location */
+#define H5L_SAME_LOC (hid_t)0
+
+/* Current version of the H5L_class_t struct */
+#define H5L_LINK_CLASS_T_VERS 0
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/* Link class types.
+ * Values less than 64 are reserved for the HDF5 library's internal use.
+ * Values 64 to 255 are for "user-defined" link class types; these types are
+ * defined by HDF5 but their behavior can be overridden by users.
+ * Users who want to create new classes of links should contact the HDF5
+ * development team at hdfhelp@ncsa.uiuc.edu .
+ * These values can never change because they appear in HDF5 files.
+ */
+typedef enum {
+    H5L_TYPE_ERROR = (-1),      /* Invalid link type id         */
+    H5L_TYPE_HARD = 0,          /* Hard link id                 */
+    H5L_TYPE_SOFT = 1,          /* Soft link id                 */
+    H5L_TYPE_EXTERNAL = 64,     /* External link id             */
+    H5L_TYPE_MAX = 255	        /* Maximum link type id         */
+} H5L_type_t;
+#define H5L_TYPE_BUILTIN_MAX H5L_TYPE_SOFT      /* Maximum value link value for "built-in" link types */
+#define H5L_TYPE_UD_MIN      H5L_TYPE_EXTERNAL  /* Link ids at or above this value are "user-defined" link types. */
+
+/* Information struct for link (for H5Lget_info/H5Lget_info_by_idx) */
+typedef struct {
+    H5L_type_t          type;           /* Type of link                   */
+    hbool_t             corder_valid;   /* Indicate if creation order is valid */
+    int64_t             corder;         /* Creation order                 */
+    H5T_cset_t          cset;           /* Character set of link name     */
+    union {
+        haddr_t         address;        /* Address hard link points to    */
+        size_t          val_size;       /* Size of a soft link or UD link value */
+    } u;
+} H5L_info_t;
+
+/* The H5L_class_t struct can be used to override the behavior of a
+ * "user-defined" link class. Users should populate the struct with callback
+ * functions defined below.
+ */
+/* Callback prototypes for user-defined links */
+/* Link creation callback */
+typedef herr_t (*H5L_create_func_t)(const char *link_name, hid_t loc_group,
+    const void *lnkdata, size_t lnkdata_size, hid_t lcpl_id);
+
+/* Callback for when the link is moved */
+typedef herr_t (*H5L_move_func_t)(const char *new_name, hid_t new_loc,
+    const void *lnkdata, size_t lnkdata_size);
+
+/* Callback for when the link is copied */
+typedef herr_t (*H5L_copy_func_t)(const char *new_name, hid_t new_loc,
+    const void *lnkdata, size_t lnkdata_size);
+
+/* Callback during link traversal */
+typedef hid_t (*H5L_traverse_func_t)(const char *link_name, hid_t cur_group,
+    const void *lnkdata, size_t lnkdata_size, hid_t lapl_id);
+
+/* Callback for when the link is deleted */
+typedef herr_t (*H5L_delete_func_t)(const char *link_name, hid_t file,
+    const void *lnkdata, size_t lnkdata_size);
+
+/* Callback for querying the link */
+/* Returns the size of the buffer needed */
+typedef ssize_t (*H5L_query_func_t)(const char *link_name, const void *lnkdata,
+    size_t lnkdata_size, void *buf /*out*/, size_t buf_size);
+
+/* User-defined link types */
+typedef struct {
+    int version;                    /* Version number of this struct        */
+    H5L_type_t id;                  /* Link type ID                         */
+    const char *comment;            /* Comment for debugging                */
+    H5L_create_func_t create_func;  /* Callback during link creation        */
+    H5L_move_func_t move_func;      /* Callback after moving link           */
+    H5L_copy_func_t copy_func;      /* Callback after copying link          */
+    H5L_traverse_func_t trav_func;  /* Callback during link traversal       */
+    H5L_delete_func_t del_func;     /* Callback for link deletion           */
+    H5L_query_func_t query_func;    /* Callback for queries                 */
+} H5L_class_t;
+
+/* Prototype for H5Literate/H5Literate_by_name() operator */
+typedef herr_t (*H5L_iterate_t)(hid_t group, const char *name, const H5L_info_t *info,
+    void *op_data);
+
+/* Callback for external link traversal */
+typedef herr_t (*H5L_elink_traverse_t)(const char *parent_file_name,
+    const char *parent_group_name, const char *child_file_name,
+    const char *child_object_name, unsigned *acc_flags, hid_t fapl_id,
+    void *op_data);
+
+
+/********************/
+/* Public Variables */
+/********************/
+
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+H5_DLL herr_t H5Lmove(hid_t src_loc, const char *src_name, hid_t dst_loc,
+    const char *dst_name, hid_t lcpl_id, hid_t lapl_id);
+H5_DLL herr_t H5Lcopy(hid_t src_loc, const char *src_name, hid_t dst_loc,
+    const char *dst_name, hid_t lcpl_id, hid_t lapl_id);
+H5_DLL herr_t H5Lcreate_hard(hid_t cur_loc, const char *cur_name,
+    hid_t dst_loc, const char *dst_name, hid_t lcpl_id, hid_t lapl_id);
+H5_DLL herr_t H5Lcreate_soft(const char *link_target, hid_t link_loc_id,
+    const char *link_name, hid_t lcpl_id, hid_t lapl_id);
+H5_DLL herr_t H5Ldelete(hid_t loc_id, const char *name, hid_t lapl_id);
+H5_DLL herr_t H5Ldelete_by_idx(hid_t loc_id, const char *group_name,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t n, hid_t lapl_id);
+H5_DLL herr_t H5Lget_val(hid_t loc_id, const char *name, void *buf/*out*/,
+    size_t size, hid_t lapl_id);
+H5_DLL herr_t H5Lget_val_by_idx(hid_t loc_id, const char *group_name,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t n,
+    void *buf/*out*/, size_t size, hid_t lapl_id);
+H5_DLL htri_t H5Lexists(hid_t loc_id, const char *name, hid_t lapl_id);
+H5_DLL herr_t H5Lget_info(hid_t loc_id, const char *name,
+    H5L_info_t *linfo /*out*/, hid_t lapl_id);
+H5_DLL herr_t H5Lget_info_by_idx(hid_t loc_id, const char *group_name,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t n,
+    H5L_info_t *linfo /*out*/, hid_t lapl_id);
+H5_DLL ssize_t H5Lget_name_by_idx(hid_t loc_id, const char *group_name,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t n,
+    char *name /*out*/, size_t size, hid_t lapl_id);
+H5_DLL herr_t H5Literate(hid_t grp_id, H5_index_t idx_type,
+    H5_iter_order_t order, hsize_t *idx, H5L_iterate_t op, void *op_data);
+H5_DLL herr_t H5Literate_by_name(hid_t loc_id, const char *group_name,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t *idx,
+    H5L_iterate_t op, void *op_data, hid_t lapl_id);
+H5_DLL herr_t H5Lvisit(hid_t grp_id, H5_index_t idx_type, H5_iter_order_t order,
+    H5L_iterate_t op, void *op_data);
+H5_DLL herr_t H5Lvisit_by_name(hid_t loc_id, const char *group_name,
+    H5_index_t idx_type, H5_iter_order_t order, H5L_iterate_t op,
+    void *op_data, hid_t lapl_id);
+
+/* UD link functions */
+H5_DLL herr_t H5Lcreate_ud(hid_t link_loc_id, const char *link_name,
+    H5L_type_t link_type, const void *udata, size_t udata_size, hid_t lcpl_id,
+    hid_t lapl_id);
+H5_DLL herr_t H5Lregister(const H5L_class_t *cls);
+H5_DLL herr_t H5Lunregister(H5L_type_t id);
+H5_DLL htri_t H5Lis_registered(H5L_type_t id);
+
+/* External link functions */
+H5_DLL herr_t H5Lunpack_elink_val(const void *ext_linkval/*in*/, size_t link_size,
+   unsigned *flags, const char **filename/*out*/, const char **obj_path /*out*/);
+H5_DLL herr_t H5Lcreate_external(const char *file_name, const char *obj_name,
+    hid_t link_loc_id, const char *link_name, hid_t lcpl_id, hid_t lapl_id);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _H5Lpublic_H */
+
diff --git a/install/include/H5MMpublic.h b/install/include/H5MMpublic.h
new file mode 100644
index 0000000000..4e54c33829
--- /dev/null
+++ b/install/include/H5MMpublic.h
@@ -0,0 +1,45 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5MMproto.h
+ *                      Jul 10 1997
+ *                      Robb Matzke <matzke@llnl.gov>
+ *
+ * Purpose:             Public declarations for the H5MM (memory management)
+ *                      package.
+ *
+ * Modifications:
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef _H5MMpublic_H
+#define _H5MMpublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+
+/* These typedefs are currently used for VL datatype allocation/freeing */
+typedef void *(*H5MM_allocate_t)(size_t size, void *alloc_info);
+typedef void (*H5MM_free_t)(void *mem, void *free_info);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _H5MMpublic_H */
+
diff --git a/install/include/H5MPpkg.h b/install/include/H5MPpkg.h
new file mode 100644
index 0000000000..29a25fa56b
--- /dev/null
+++ b/install/include/H5MPpkg.h
@@ -0,0 +1,104 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:	Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *		Monday, May  2, 2005
+ *
+ * Purpose:	This file contains declarations which are visible only within
+ *		the H5MP package.  Source files outside the H5MP package should
+ *		include H5MPprivate.h instead.
+ */
+#if !(defined H5MP_FRIEND || defined H5MP_MODULE)
+#error "Do not include this file outside the H5MP package!"
+#endif
+
+#ifndef _H5MPpkg_H
+#define _H5MPpkg_H
+
+/* Get package's private header */
+#include "H5MPprivate.h"	/* Memory Pools				*/
+
+/* Other private headers needed by this file */
+#include "H5FLprivate.h"	/* Free Lists                           */
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* Alignment macros */
+/* (Ideas from Apache APR :-) */
+
+/* Default alignment necessary */
+#define H5MP_BLOCK_ALIGNMENT    8
+
+/* General alignment macro */
+/* (this only works for aligning to power of 2 boundary) */
+#define H5MP_ALIGN(x, a) \
+       (((x) + ((size_t)(a)) - 1) & ~(((size_t)(a)) - 1))
+
+/* Default alignment */
+#define H5MP_BLOCK_ALIGN(x) H5MP_ALIGN(x, H5MP_BLOCK_ALIGNMENT)
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/* Free block in pool */
+typedef struct H5MP_page_blk_t {
+    size_t size;                        /* Size of block (includes this H5MP_page_blk_t info) */
+    unsigned is_free:1;                 /* Flag to indicate the block is free */
+    struct H5MP_page_t *page;           /* Pointer to page block is located in */
+    struct H5MP_page_blk_t *prev;       /* Pointer to previous block in page */
+    struct H5MP_page_blk_t *next;       /* Pointer to next block in page */
+} H5MP_page_blk_t;
+
+/* Memory pool page */
+typedef struct H5MP_page_t {
+    size_t free_size;                   /* Total amount of free space in page */
+    unsigned fac_alloc:1;               /* Flag to indicate the page was allocated by the pool's factory */
+    H5MP_page_blk_t *free_blk;          /* Pointer to first free block in page */
+    struct H5MP_page_t *next;           /* Pointer to next page in pool */
+    struct H5MP_page_t *prev;           /* Pointer to previous page in pool */
+} H5MP_page_t;
+
+/* Memory pool header */
+struct H5MP_pool_t {
+    H5FL_fac_head_t *page_fac;  /* Free-list factory for pages */
+    size_t page_size;           /* Page size for pool */
+    size_t free_size;           /* Total amount of free space in pool */
+    size_t max_size;            /* Maximum block that will fit in a standard page */
+    H5MP_page_t *first;         /* Pointer to first page in pool */
+    unsigned flags;             /* Bit flags for pool settings */
+};
+
+
+/*****************************************/
+/* Package Private Variable Declarations */
+/*****************************************/
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+#ifdef H5MP_TESTING
+H5_DLL herr_t H5MP_get_pool_free_size (const H5MP_pool_t *mp, size_t *free_size);
+H5_DLL htri_t H5MP_pool_is_free_size_correct(const H5MP_pool_t *mp);
+H5_DLL herr_t H5MP_get_pool_first_page(const H5MP_pool_t *mp, H5MP_page_t **page);
+H5_DLL herr_t H5MP_get_page_free_size(const H5MP_page_t *mp, size_t *page);
+H5_DLL herr_t H5MP_get_page_next_page(const H5MP_page_t *page, H5MP_page_t **next_page);
+#endif /* H5MP_TESTING */
+
+#endif /* _H5MPpkg_H */
+
diff --git a/install/include/H5Object.h b/install/include/H5Object.h
new file mode 100644
index 0000000000..fdaead28da
--- /dev/null
+++ b/install/include/H5Object.h
@@ -0,0 +1,135 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5Object_H
+#define __H5Object_H
+
+namespace H5 {
+
+/*! \class H5Object
+    \brief Class H5Object is a bridge between H5Location and DataSet, DataType,
+     and Group.
+
+    Modification:
+        Sept 18, 2012: Added class H5Location in between IdComponent and
+                H5Object.  An H5File now inherits from H5Location.  All HDF5
+                wrappers in H5Object are moved up to H5Location.  H5Object
+                is left mostly empty for future wrappers that are only for
+                group, dataset, and named datatype.  Note that the reason for
+                adding H5Location instead of simply moving H5File to be under
+                H5Object is H5File is not an HDF5 object, and renaming H5Object
+                to H5Location will risk breaking user applications.
+                -BMR
+        Apr 2, 2014: Added wrapper getObjName for H5Iget_name 
+        Sep 21, 2016: Rearranging classes (HDFFV-9920) moved H5A wrappers back
+                into H5Object.  This way, C functions that takes attribute id
+                can be in H5Location and those that cannot take attribute id
+                can be in H5Object.
+
+    Inheritance: H5Location -> IdComponent
+*/
+// Class forwarding
+class H5_DLLCPP H5Object;
+class H5_DLLCPP Attribute;
+
+// Define the operator function pointer for H5Aiterate().
+typedef void (*attr_operator_t)(H5Object& loc/*in*/,
+                                 const H5std_string attr_name/*in*/,
+                                 void *operator_data/*in,out*/);
+
+// User data for attribute iteration
+class UserData4Aiterate {
+    public:
+        attr_operator_t op;
+        void* opData;
+        H5Object* location;
+};
+
+class H5_DLLCPP H5Object : public H5Location {
+   public:
+        // Creates an attribute for the specified object
+        // PropList is currently not used, so always be default.
+        Attribute createAttribute(const char* name, const DataType& type, const DataSpace& space, const PropList& create_plist = PropList::DEFAULT) const;
+        Attribute createAttribute(const H5std_string& name, const DataType& type, const DataSpace& space, const PropList& create_plist = PropList::DEFAULT) const;
+
+        // Given its name, opens the attribute that belongs to an object at
+        // this location.
+        Attribute openAttribute(const char* name) const;
+        Attribute openAttribute(const H5std_string& name) const;
+
+        // Given its index, opens the attribute that belongs to an object at
+        // this location.
+        Attribute openAttribute(const unsigned int idx) const;
+
+        // Iterate user's function over the attributes of this object.
+        int iterateAttrs(attr_operator_t user_op, unsigned* idx = NULL, void* op_data = NULL);
+
+        // Returns the object header version of an object
+        unsigned objVersion() const;
+
+        // Determines the number of attributes belong to this object.
+        int getNumAttrs() const;
+
+        // Checks whether the named attribute exists for this object.
+        bool attrExists(const char* name) const;
+        bool attrExists(const H5std_string& name) const;
+
+        // Renames the named attribute to a new name.
+        void renameAttr(const char* oldname, const char* newname) const;
+        void renameAttr(const H5std_string& oldname, const H5std_string& newname) const;
+
+        // Removes the named attribute from this object.
+        void removeAttr(const char* name) const;
+        void removeAttr(const H5std_string& name) const;
+
+        // Returns an identifier.
+        virtual hid_t getId() const = 0;
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+        // Gets the name of this HDF5 object, i.e., Group, DataSet, or
+        // DataType.  These should have const but are retiring anyway.
+        ssize_t getObjName(char *obj_name, size_t buf_size = 0) const;
+        ssize_t getObjName(H5std_string& obj_name, size_t len = 0) const;
+        H5std_string getObjName() const;
+
+   protected:
+        // Default constructor
+        H5Object();
+
+        // *** Deprecation warning ***
+        // The following two constructors are no longer appropriate after the
+        // data member "id" had been moved to the sub-classes.
+        // The copy constructor is a noop and is removed in 1.8.15 and the
+        // other will be removed from 1.10 release, and then from 1.8 if its
+        // removal does not raise any problems in two 1.10 releases.
+
+        // Creates a copy of an existing object giving the object id
+        H5Object(const hid_t object_id);
+
+        // Copy constructor: makes copy of an H5Object object.
+        // H5Object(const H5Object& original);
+
+        // Sets the identifier of this object to a new value. - this one
+        // doesn't increment reference count
+        virtual void p_setId(const hid_t new_id) = 0;
+
+        // Noop destructor.
+        virtual ~H5Object();
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end of H5Object
+} // namespace H5
+
+#endif // __H5Object_H
diff --git a/install/include/H5OcreatProp.h b/install/include/H5OcreatProp.h
new file mode 100644
index 0000000000..878c67aa44
--- /dev/null
+++ b/install/include/H5OcreatProp.h
@@ -0,0 +1,76 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5ObjCreatPropList_H
+#define __H5ObjCreatPropList_H
+
+namespace H5 {
+
+/*! \class ObjCreatPropList
+    \brief Class ObjCreatPropList inherits from PropList and provides
+    wrappers for the HDF5 file create property list.
+
+    Inheritance: PropList -> IdComponent
+*/
+class H5_DLLCPP ObjCreatPropList : public PropList {
+   public:
+        ///\brief Default object creation property list.
+        static const ObjCreatPropList& DEFAULT;
+
+        // Creates a object creation property list.
+        ObjCreatPropList();
+
+        // Sets attribute storage phase change thresholds.
+        void setAttrPhaseChange(unsigned max_compact = 8, unsigned min_dense = 6) const;
+
+        // Gets attribute storage phase change thresholds.
+        void getAttrPhaseChange(unsigned& max_compact, unsigned& min_dense) const;
+
+        // Sets tracking and indexing of attribute creation order.
+        void setAttrCrtOrder(unsigned crt_order_flags) const;
+
+        // Gets tracking and indexing settings for attribute creation order.
+        unsigned getAttrCrtOrder() const;
+
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("ObjCreatPropList"); }
+
+        // Copy constructor: creates a copy of a ObjCreatPropList object.
+        ObjCreatPropList(const ObjCreatPropList& original);
+
+        // Creates a copy of an existing object creation property list
+        // using the property list id.
+        ObjCreatPropList (const hid_t plist_id);
+
+        // Noop destructor
+        virtual ~ObjCreatPropList();
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+        // Deletes the global constant, should only be used by the library
+        static void deleteConstants();
+
+    private:
+        static ObjCreatPropList* DEFAULT_;
+
+        // Creates the global constant, should only be used by the library
+        static ObjCreatPropList* getConstant();
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end of ObjCreatPropList
+} // namespace H5
+
+#endif // __H5ObjCreatPropList_H
diff --git a/install/include/H5Opkg.h b/install/include/H5Opkg.h
new file mode 100644
index 0000000000..b0c67d18c3
--- /dev/null
+++ b/install/include/H5Opkg.h
@@ -0,0 +1,666 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#if !(defined H5O_FRIEND || defined H5O_MODULE)
+#error "Do not include this file outside the H5O package!"
+#endif
+
+#ifndef _H5Opkg_H
+#define _H5Opkg_H
+
+/* Get package's private header */
+#include "H5Oprivate.h"		/* Object headers		  	*/
+
+/* Other private headers needed by this file */
+#include "H5ACprivate.h"        /* Metadata cache                       */
+#include "H5FLprivate.h"	/* Free Lists                           */
+
+/* Object header macros */
+#define H5O_NMESGS	8 		/*initial number of messages	     */
+#define H5O_NCHUNKS	2		/*initial number of chunks	     */
+#define H5O_MIN_SIZE	22		/* Min. obj header data size (must be big enough for a message prefix and a continuation message) */
+#define H5O_MSG_TYPES   27              /* # of types of messages            */
+#define H5O_MAX_CRT_ORDER_IDX 65535     /* Max. creation order index value   */
+
+/* Versions of object header structure */
+
+/* Initial version of the object header format */
+#define H5O_VERSION_1		1
+
+/* Revised version - leaves out reserved bytes and alignment padding, and adds
+ *      magic number as prefix and checksum as suffix for all chunks.
+ */
+#define H5O_VERSION_2		2
+
+/* The latest version of the format.  Look through the 'flush'
+ *      and 'size' callback for places to change when updating this. */
+#define H5O_VERSION_LATEST	H5O_VERSION_2
+
+/*
+ * Align messages on 8-byte boundaries because we would like to copy the
+ * object header chunks directly into memory and operate on them there, even
+ * on 64-bit architectures.  This allows us to reduce the number of disk I/O
+ * requests with a minimum amount of mem-to-mem copies.
+ *
+ * Note: We no longer attempt to do this. - QAK, 10/16/06
+ */
+#define H5O_ALIGN_OLD(X)	(8 * (((X) + 7) / 8))
+#define H5O_ALIGN_VERS(V, X)						      \
+    (((V) == H5O_VERSION_1) ?						      \
+		H5O_ALIGN_OLD(X)					      \
+        :								      \
+		(X)							      \
+    )
+#define H5O_ALIGN_OH(O, X)						      \
+     H5O_ALIGN_VERS((O)->version, X)
+#define H5O_ALIGN_F(F, X)						      \
+     H5O_ALIGN_VERS((H5F_USE_LATEST_FLAGS(F, H5F_LATEST_OBJ_HEADER) ? H5O_VERSION_LATEST : H5O_VERSION_1), X)
+
+/* Size of checksum (on disk) */
+#define H5O_SIZEOF_CHKSUM               4
+
+/* ========= Object Creation properties ============ */
+/* Default values for some of the object creation properties */
+/* NOTE: The H5O_CRT_ATTR_MAX_COMPACT_DEF & H5O_CRT_ATTR_MIN_DENSE_DEF values
+ *      are "built into" the file format, make certain existing files with
+ *      default attribute phase change storage are handled correctly if they
+ *      are changed.
+ */
+#define H5O_CRT_ATTR_MAX_COMPACT_DEF    8
+#define H5O_CRT_ATTR_MIN_DENSE_DEF      6
+#define H5O_CRT_OHDR_FLAGS_DEF          H5O_HDR_STORE_TIMES
+
+/* Object header status flag definitions */
+#define H5O_HDR_CHUNK0_1                0x00    /* Use 1-byte value for chunk #0 size */
+#define H5O_HDR_CHUNK0_2                0x01    /* Use 2-byte value for chunk #0 size */
+#define H5O_HDR_CHUNK0_4                0x02    /* Use 4-byte value for chunk #0 size */
+#define H5O_HDR_CHUNK0_8                0x03    /* Use 8-byte value for chunk #0 size */
+
+/*
+ * Size of object header prefix.
+ */
+#define H5O_SIZEOF_HDR(O)						      \
+    (((O)->version == H5O_VERSION_1)  					      \
+        ?								      \
+            H5O_ALIGN_OLD(1 +	/*version number	*/		      \
+                1 +		/*reserved 		*/		      \
+                2 +		/*number of messages	*/		      \
+                4 +		/*reference count	*/		      \
+                4)		/*chunk data size	*/		      \
+        :								      \
+            (H5_SIZEOF_MAGIC +	/*magic number  	*/		      \
+                1 +		/*version number 	*/		      \
+                1 +		/*flags		 	*/		      \
+                (((O)->flags & H5O_HDR_STORE_TIMES) ? (			      \
+                  4 +		/*access time		*/		      \
+                  4 +		/*modification time	*/		      \
+                  4 +		/*change time		*/		      \
+                  4		/*birth time		*/		      \
+                ) : 0) +						      \
+                (((O)->flags & H5O_HDR_ATTR_STORE_PHASE_CHANGE) ? (	      \
+                  2 +		/*max compact attributes */		      \
+                  2		/*min dense attributes	*/		      \
+                ) : 0) +						      \
+                (1 << ((O)->flags & H5O_HDR_CHUNK0_SIZE)) + /*chunk 0 data size */ \
+                H5O_SIZEOF_CHKSUM) /*checksum size	*/		      \
+    )
+
+/*
+ * Size of object header message prefix
+ */
+#define H5O_SIZEOF_MSGHDR_VERS(V,C)					      \
+    (((V) == H5O_VERSION_1)  						      \
+        ?								      \
+            H5O_ALIGN_OLD(2 +	/*message type		*/		      \
+                2 +		/*sizeof message data	*/		      \
+                1 +		/*flags              	*/		      \
+                3)		/*reserved		*/		      \
+        :								      \
+            (1 +		/*message type		*/		      \
+                2 + 		/*sizeof message data	*/		      \
+                1 +		/*flags              	*/		      \
+                ((C) ? (						      \
+                  2		/*creation index     	*/		      \
+                ) : 0))							      \
+    )
+#define H5O_SIZEOF_MSGHDR_OH(O)						      \
+    H5O_SIZEOF_MSGHDR_VERS((O)->version, (O)->flags & H5O_HDR_ATTR_CRT_ORDER_TRACKED)
+#define H5O_SIZEOF_MSGHDR_F(F, C)						      \
+    H5O_SIZEOF_MSGHDR_VERS((H5F_USE_LATEST_FLAGS(F, H5F_LATEST_OBJ_HEADER) || H5F_STORE_MSG_CRT_IDX(F)) ? H5O_VERSION_LATEST : H5O_VERSION_1, (C))
+
+/*
+ * Size of chunk "header" for each chunk
+ */
+#define H5O_SIZEOF_CHKHDR_VERS(V)					      \
+    (((V) == H5O_VERSION_1)  						      \
+        ?								      \
+            0 +		/*no magic #  */				      \
+                0 	/*no checksum */				      \
+        :								      \
+            H5_SIZEOF_MAGIC + 		/*magic #  */			      \
+                H5O_SIZEOF_CHKSUM 	/*checksum */			      \
+    )
+#define H5O_SIZEOF_CHKHDR_OH(O)						      \
+    H5O_SIZEOF_CHKHDR_VERS((O)->version)
+
+/*
+ * Size of checksum for each chunk
+ */
+#define H5O_SIZEOF_CHKSUM_VERS(V)					      \
+    (((V) == H5O_VERSION_1)  						      \
+        ?								      \
+            0 		/*no checksum */				      \
+        :								      \
+            H5O_SIZEOF_CHKSUM 		/*checksum */			      \
+    )
+#define H5O_SIZEOF_CHKSUM_OH(O)						      \
+    H5O_SIZEOF_CHKSUM_VERS((O)->version)
+
+/* Input/output flags for decode functions */
+#define H5O_DECODEIO_NOCHANGE           0x01u   /* IN: do not modify values */
+#define H5O_DECODEIO_DIRTY              0x02u   /* OUT: message has been changed */
+
+/* Macro to incremend ndecode_dirtied (only if we are debugging) */
+#ifndef NDEBUG
+#define INCR_NDECODE_DIRTIED(OH) (OH)->ndecode_dirtied++;
+#else /* NDEBUG */
+#define INCR_NDECODE_DIRTIED(OH) ;
+#endif /* NDEBUG */
+
+/* Load native information for a message, if it's not already present */
+/* (Only works for messages with decode callback) */
+#define H5O_LOAD_NATIVE(F, DXPL, IOF, OH, MSG, ERR)                           \
+    if(NULL == (MSG)->native) {                                               \
+        const H5O_msg_class_t	*msg_type = (MSG)->type;                      \
+        unsigned                ioflags = (IOF);                              \
+                                                                              \
+        /* Decode the message */                                              \
+        HDassert(msg_type->decode);                                           \
+        if(NULL == ((MSG)->native = (msg_type->decode)((F), (DXPL), (OH), (MSG)->flags, &ioflags, (MSG)->raw))) \
+            HGOTO_ERROR(H5E_OHDR, H5E_CANTDECODE, ERR, "unable to decode message") \
+                                                                              \
+        /* Mark the message dirty if it was changed by decoding */            \
+        if((ioflags & H5O_DECODEIO_DIRTY) && (H5F_get_intent((F)) & H5F_ACC_RDWR)) { \
+            (MSG)->dirty = TRUE;                                              \
+            /* Increment the count of messages dirtied by decoding, but */    \
+            /* only ifndef NDEBUG */                                          \
+            INCR_NDECODE_DIRTIED(OH)                                          \
+        }                                                                     \
+                                                                              \
+        /* Set the message's "shared info", if it's shareable */	      \
+        if((MSG)->flags & H5O_MSG_FLAG_SHAREABLE) {                           \
+            HDassert(msg_type->share_flags & H5O_SHARE_IS_SHARABLE);          \
+            H5O_UPDATE_SHARED((H5O_shared_t *)(MSG)->native, H5O_SHARE_TYPE_HERE, (F), msg_type->id, (MSG)->crt_idx, (OH)->chunk[0].addr) \
+        } /* end if */                                                        \
+                                                                              \
+        /* Set the message's "creation index", if it has one */		      \
+        if(msg_type->set_crt_index) {				      	      \
+            /* Set the creation index for the message */		      \
+            if((msg_type->set_crt_index)((MSG)->native, (MSG)->crt_idx) < 0)  \
+                HGOTO_ERROR(H5E_OHDR, H5E_CANTSET, ERR, "unable to set creation index") \
+        } /* end if */							      \
+    } /* end if */
+
+/* Flags for a message class's "sharability" */
+#define H5O_SHARE_IS_SHARABLE   0x01
+#define H5O_SHARE_IN_OHDR       0x02
+
+/* Set the object header size to speculatively read in */
+/* (needs to be more than the object header prefix size to work at all and
+ *      should be larger than the largest object type's default object header
+ *      size to save the extra I/O operations) */
+#define H5O_SPEC_READ_SIZE 512
+
+
+/* The "message class" type */
+struct H5O_msg_class_t {
+    unsigned	id;				/*message type ID on disk   */
+    const char	*name;				/*for debugging             */
+    size_t	native_size;			/*size of native message    */
+    unsigned    share_flags;			/* Message sharing settings */
+    void	*(*decode)(H5F_t *, hid_t, H5O_t *, unsigned, unsigned *, const uint8_t *);
+    herr_t	(*encode)(H5F_t *, hbool_t, uint8_t *, const void *);
+    void	*(*copy)(const void *, void *);	/*copy native value         */
+    size_t	(*raw_size)(const H5F_t *, hbool_t, const void *);/*sizeof encoded message	*/
+    herr_t	(*reset)(void *);		/*free nested data structs  */
+    herr_t	(*free)(void *);		/*free main data struct  */
+    herr_t	(*del)(H5F_t *, hid_t, H5O_t *, void *);    /* Delete space in file referenced by this message */
+    herr_t	(*link)(H5F_t *, hid_t, H5O_t *, void *);   /* Increment any links in file reference by this message */
+    herr_t	(*set_share)(void*, const H5O_shared_t*);   /* Set shared information */
+    htri_t	(*can_share)(const void *);	/* Is message allowed to be shared? */
+    herr_t	(*pre_copy_file)(H5F_t *, const void *, hbool_t *, const H5O_copy_t *, void *); /*"pre copy" action when copying native value to file */
+    void	*(*copy_file)(H5F_t *, void *, H5F_t *, hbool_t *, unsigned *, H5O_copy_t *, void *, hid_t); /*copy native value to file */
+    herr_t	(*post_copy_file)(const H5O_loc_t *, const void *, H5O_loc_t *, void *, unsigned *, hid_t, H5O_copy_t *); /*"post copy" action when copying native value to file */
+    herr_t      (*get_crt_index)(const void *, H5O_msg_crt_idx_t *);	/* Get message's creation index */
+    herr_t      (*set_crt_index)(void *, H5O_msg_crt_idx_t);	/* Set message's creation index */
+    herr_t	(*debug)(H5F_t*, hid_t, const void*, FILE*, int, int);
+};
+
+struct H5O_mesg_t {
+    const H5O_msg_class_t	*type;	/*type of message		     */
+    hbool_t		dirty;		/*raw out of date wrt native	     */
+    uint8_t		flags;		/*message flags			     */
+    H5O_msg_crt_idx_t   crt_idx;        /*message creation index	     */
+    unsigned		chunkno;	/*chunk number for this mesg	     */
+    void		*native;	/*native format message		     */
+    uint8_t		*raw;		/*ptr to raw data		     */
+    size_t		raw_size;	/*size with alignment		     */
+};
+
+/* Struct for storing information about "best" message to move to new chunk */
+typedef struct H5O_msg_alloc_info_t {
+    int msgno;                      /* Index in message array */
+    unsigned id;		    /* Message type ID on disk */
+    unsigned chunkno;               /* Index in chunk array */
+    size_t gap_size;                /* Size of any "gap" in the chunk immediately after message */
+    size_t null_size;               /* Size of any null message in the chunk immediately after message */
+    size_t total_size;              /* Total size of "available" space around message */
+    unsigned null_msgno;            /* Message index of null message immediately after message */
+} H5O_msg_alloc_info_t;
+
+typedef struct H5O_chunk_t {
+    haddr_t	addr;			/*chunk file address		     */
+    size_t	size;			/*chunk size			     */
+    size_t	gap;			/*space at end of chunk too small for null message */
+    uint8_t	*image;			/*image of file			     */
+    struct H5O_chunk_proxy_t *chunk_proxy;    /* Pointer to a chunk's proxy when chunk protected */
+} H5O_chunk_t;
+
+struct H5O_t {
+    H5AC_info_t cache_info; /* Information for metadata cache functions, _must_ be */
+                            /* first field in structure */
+
+    /* File-specific information (not stored) */
+    size_t      sizeof_size;            /* Size of file sizes 		     */
+    size_t      sizeof_addr;            /* Size of file addresses	     */
+    hbool_t     swmr_write;             /* Whether we are doing SWMR writes  */
+
+    /* Debugging information (not stored) */
+#ifdef H5O_ENABLE_BAD_MESG_COUNT
+    hbool_t     store_bad_mesg_count;   /* Flag to indicate that a bad message count should be stored */
+                                        /* (This is to simulate a bug in earlier
+                                         *      versions of the library)
+                                         */
+#endif /* H5O_ENABLE_BAD_MESG_COUNT */
+#ifndef NDEBUG
+    size_t      ndecode_dirtied;        /* Number of messages dirtied by decoding */
+#endif /* NDEBUG */
+
+    /* Chunk management information (not stored) */
+    size_t      rc;                     /* Reference count of [continuation] chunks using this structure */
+
+    /* Object information (stored) */
+    hbool_t     has_refcount_msg;       /* Whether the object has a ref. count message */
+    unsigned	nlink;			/*link count			     */
+    uint8_t	version;		/*version number		     */
+    uint8_t	flags;			/*flags				     */
+
+    /* Time information (stored, for versions > 1 & H5O_HDR_STORE_TIMES flag set) */
+    time_t      atime;                  /*access time 			     */
+    time_t      mtime;                  /*modification time 		     */
+    time_t      ctime;                  /*change time 			     */
+    time_t      btime;                  /*birth time 			     */
+
+    /* Attribute information (stored, for versions > 1) */
+    unsigned	max_compact;		/* Maximum # of compact attributes   */
+    unsigned	min_dense;		/* Minimum # of "dense" attributes   */
+
+    /* Message management (stored, encoded in chunks) */
+    size_t	nmesgs;			/*number of messages		     */
+    size_t	alloc_nmesgs;		/*number of message slots	     */
+    H5O_mesg_t	*mesg;			/*array of messages		     */
+    size_t      link_msgs_seen;         /* # of link messages seen when loading header */
+    size_t      attr_msgs_seen;         /* # of attribute messages seen when loading header */
+
+    /* Chunk management (not stored) */
+    size_t	nchunks;		/*number of chunks		     */
+    size_t	alloc_nchunks;		/*chunks allocated		     */
+    H5O_chunk_t *chunk;			/*array of chunks		     */
+    hbool_t     chunks_pinned;          /* Whether chunks are pinned from ohdr protect */
+
+    /* Object header proxy information (not stored) */
+    H5AC_proxy_entry_t *proxy;          /* Proxy cache entry for all ohdr entries */
+};
+
+/* Class for types of objects in file */
+typedef struct H5O_obj_class_t {
+    H5O_type_t	type;				/*object type on disk	     */
+    const char	*name;				/*for debugging		     */
+    void       *(*get_copy_file_udata)(void);	/*retrieve user data for 'copy file' operation */
+    void	(*free_copy_file_udata)(void *); /*free user data for 'copy file' operation */
+    htri_t	(*isa)(H5O_t *);		/*if a header matches an object class */
+    hid_t	(*open)(const H5G_loc_t *, hid_t, hid_t, hbool_t );	/*open an object of this class */
+    void	*(*create)(H5F_t *, void *, H5G_loc_t *, hid_t );	/*create an object of this class */
+    H5O_loc_t	*(*get_oloc)(hid_t );		/*get the object header location for an object */
+    herr_t      (*bh_info)(const H5O_loc_t *loc, hid_t dxpl_id, H5O_t *oh, H5_ih_info_t *bh_info); /*get the index & heap info for an object */
+    herr_t      (*flush)(void *obj_ptr, hid_t dxpl_id); /*flush an opened object of this class */
+} H5O_obj_class_t;
+
+/* Node in skip list to map addresses from one file to another during object header copy */
+typedef struct H5O_addr_map_t {
+    H5_obj_t    src_obj_pos;            /* Location of source object */
+    haddr_t     dst_addr;               /* Address of object in destination file */
+    hbool_t     is_locked;              /* Indicate that the destination object is locked currently */
+    hsize_t     inc_ref_count;          /* Number of deferred increments to reference count */
+    const H5O_obj_class_t *obj_class;   /* Object class */
+    void        *udata;                 /* Object class copy file udata */
+} H5O_addr_map_t;
+
+/* Stack of continuation messages to interpret */
+typedef struct H5O_cont_msgs_t {
+    size_t      nmsgs;                  /* Number of continuation messages found so far */
+    size_t	alloc_nmsgs;		/* Continuation messages allocated */
+    H5O_cont_t *msgs;			/* Array of continuation messages */
+} H5O_cont_msgs_t;
+
+/* Common callback information for loading object header prefix from disk */
+typedef struct H5O_common_cache_ud_t {
+    H5F_t *f;                           /* Pointer to file for object header/chunk */
+    hid_t dxpl_id;                      /* DXPL for operation */
+    unsigned file_intent;               /* Read/write intent for file */
+    unsigned merged_null_msgs;          /* Number of null messages merged together */
+    H5O_cont_msgs_t *cont_msg_info;     /* Pointer to continuation messages to work on */
+    haddr_t addr;                       /* Address of the prefix or chunk */
+} H5O_common_cache_ud_t;
+
+/* Callback information for loading object header prefix from disk */
+typedef struct H5O_cache_ud_t {
+    hbool_t made_attempt;               /* Whether the deserialize routine was already attempted */
+    unsigned v1_pfx_nmesgs;             /* Number of messages from v1 prefix header */
+    size_t chunk0_size;                 /* Size of serialized first chunk    */
+    H5O_t *oh;                          /* Partially deserialized object header, for later use */
+    H5O_common_cache_ud_t common;       /* Common object header cache callback info */
+} H5O_cache_ud_t;
+
+/* Structure representing each chunk in the cache */
+typedef struct H5O_chunk_proxy_t {
+    H5AC_info_t cache_info;    /* Information for metadata cache functions, _must_ be */
+                                /* first field in structure */
+
+    H5F_t *f;                           /* Pointer to file for object header/chunk */
+    H5O_t       *oh;                    /* Object header for this chunk */
+    unsigned    chunkno;                /* Chunk number for this chunk */
+    unsigned    cont_chunkno;           /* Chunk number for the chunk containing the continuation message that points to this chunk */
+
+    /* Flush depencency parent information (not stored) 
+     *
+     * The following field is used to store a pointer 
+     * to the in-core representation of the chunk proxy's flush dependency
+     * parent -- if it exists.  If it does not exist, this field will
+     * contain NULL.
+     *
+     * If the file is opened in SWMR write mode, the flush dependency 
+     * parent of the chunk proxy will be either its object header 
+     * (if cont_chunkno == 0) or the chunk proxy indicated by the 
+     * cont_chunkno field (if cont_chunkno > 0).
+     */
+    void *parent;                       /* Pointer to flush dependency parent */
+} H5O_chunk_proxy_t;
+
+/* Callback information for loading object header chunk from disk */
+typedef struct H5O_chk_cache_ud_t {
+    hbool_t decoding;                   /* Whether the object header is being decoded */
+    H5O_t *oh;                          /* Object header for this chunk */
+    unsigned chunkno;                   /* Index of chunk being brought in (for re-loads) */
+    size_t size;                        /* Size of chunk in the file */
+    H5O_common_cache_ud_t common;       /* Common object header cache callback info */
+} H5O_chk_cache_ud_t;
+
+
+/* Header message ID to class mapping */
+H5_DLLVAR const H5O_msg_class_t *const H5O_msg_class_g[H5O_MSG_TYPES];
+
+/* Declare external the free list for H5O_t's */
+H5FL_EXTERN(H5O_t);
+
+/* Declare external the free list for H5O_mesg_t sequences */
+H5FL_SEQ_EXTERN(H5O_mesg_t);
+
+/* Declare external the free list for H5O_chunk_t sequences */
+H5FL_SEQ_EXTERN(H5O_chunk_t);
+
+/* Declare external the free list for chunk_image blocks */
+H5FL_BLK_EXTERN(chunk_image);
+
+/*
+ * Object header messages
+ */
+
+/* Null Message. (0x0000) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_NULL[1];
+
+/* Simple Dataspace Message. (0x0001) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_SDSPACE[1];
+
+/* Link Information Message. (0x0002) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_LINFO[1];
+
+/* Datatype Message. (0x0003) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_DTYPE[1];
+
+/* Old Fill Value Message. (0x0004) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_FILL[1];
+
+/* New Fill Value Message. (0x0005) */
+/*
+ * The new fill value message is fill value plus
+ * space allocation time and fill value writing time and whether fill
+ * value is defined.
+ */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_FILL_NEW[1];
+
+/* Link Message. (0x0006) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_LINK[1];
+
+/* External File List Message. (0x0007) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_EFL[1];
+
+/* Data Layout Message. (0x0008) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_LAYOUT[1];
+
+#ifdef H5O_ENABLE_BOGUS
+/* "Bogus valid" Message. (0x0009) */
+/* "Bogus invalid" Message. (0x0019) */
+/*
+ * Used for debugging - should never be found in valid HDF5 file.
+ */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_BOGUS_VALID[1];
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_BOGUS_INVALID[1];
+#endif /* H5O_ENABLE_BOGUS */
+
+/* Group Information Message. (0x000a) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_GINFO[1];
+
+/* Filter pipeline message. (0x000b) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_PLINE[1];
+
+/* Attribute Message. (0x000c) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_ATTR[1];
+
+/* Object name message. (0x000d) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_NAME[1];
+
+/* Modification Time Message. (0x000e) */
+/*
+ * The message is just a `time_t'.
+ * (See also the "new" modification time message)
+ */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_MTIME[1];
+
+/* Shared Message information message (0x000f)
+ * A message for the superblock extension, holding information about
+ * the file-wide shared message "SOHM" table
+ */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_SHMESG[1];
+
+/* Object Header Continuation Message. (0x0010) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_CONT[1];
+
+/* Symbol Table Message. (0x0011) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_STAB[1];
+
+/* New Modification Time Message. (0x0012) */
+/*
+ * The message is just a `time_t'.
+ */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_MTIME_NEW[1];
+
+/* v1 B-tree 'K' value message (0x0013)
+ * A message for the superblock extension, holding information about
+ * the file-wide v1 B-tree 'K' values.
+ */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_BTREEK[1];
+
+/* Driver info message (0x0014)
+ * A message for the superblock extension, holding information about
+ * the file driver settings
+ */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_DRVINFO[1];
+
+/* Attribute Information Message. (0x0015) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_AINFO[1];
+
+/* Reference Count Message. (0x0016) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_REFCOUNT[1];
+
+/* Free-space Manager Info message. (0x0017) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_FSINFO[1];
+
+/* Metadata Cache Image message. (0x0018) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_MDCI[1];
+
+/* Placeholder for unknown message. (0x0019) */
+H5_DLLVAR const H5O_msg_class_t H5O_MSG_UNKNOWN[1];
+
+
+/*
+ * Object header "object" types
+ */
+
+/* Group Object. (H5O_TYPE_GROUP - 0) */
+H5_DLLVAR const H5O_obj_class_t H5O_OBJ_GROUP[1];
+
+/* Dataset Object. (H5O_TYPE_DATASET - 1) */
+H5_DLLVAR const H5O_obj_class_t H5O_OBJ_DATASET[1];
+
+/* Datatype Object. (H5O_TYPE_NAMED_DATATYPE - 2) */
+H5_DLLVAR const H5O_obj_class_t H5O_OBJ_DATATYPE[1];
+
+
+/* Package-local function prototypes */
+H5_DLL herr_t H5O_msg_flush(H5F_t *f, H5O_t *oh, H5O_mesg_t *mesg);
+H5_DLL herr_t H5O_flush_msgs(H5F_t *f, H5O_t *oh);
+H5_DLL hid_t H5O_open_by_loc(const H5G_loc_t *obj_loc, hid_t lapl_id, hid_t dxpl_id, hbool_t app_ref);
+H5_DLL herr_t H5O_delete_mesg(H5F_t *f, hid_t dxpl_id, H5O_t *open_oh, H5O_mesg_t *mesg);
+H5_DLL const H5O_obj_class_t * H5O_obj_class(const H5O_loc_t *loc, hid_t dxpl_id);
+H5_DLL int H5O_link_oh(H5F_t *f, int adjust, hid_t dxpl_id, H5O_t *oh, hbool_t *deleted);
+H5_DLL herr_t H5O_inc_rc(H5O_t *oh);
+H5_DLL herr_t H5O_dec_rc(H5O_t *oh);
+H5_DLL herr_t H5O__free(H5O_t *oh);
+
+/* Object header message routines */
+H5_DLL herr_t H5O_msg_alloc(H5F_t *f, hid_t dxpl_id, H5O_t *oh,
+    const H5O_msg_class_t *type, unsigned *mesg_flags, void *mesg,
+    size_t *mesg_idx);
+H5_DLL herr_t H5O_msg_append_real(H5F_t *f, hid_t dxpl_id, H5O_t *oh,
+    const H5O_msg_class_t *type, unsigned mesg_flags, unsigned update_flags,
+    void *mesg);
+H5_DLL herr_t H5O_msg_write_real(H5F_t *f, hid_t dxpl_id, H5O_t *oh,
+    const H5O_msg_class_t *type, unsigned mesg_flags, unsigned update_flags,
+    void *mesg);
+H5_DLL void *H5O_msg_free_real(const H5O_msg_class_t *type, void *mesg);
+H5_DLL herr_t H5O_msg_free_mesg(H5O_mesg_t *mesg);
+H5_DLL unsigned H5O_msg_count_real(const H5O_t *oh, const H5O_msg_class_t *type);
+H5_DLL herr_t H5O_msg_remove_real(H5F_t *f, H5O_t *oh, const H5O_msg_class_t *type,
+    int sequence, H5O_operator_t op, void *op_data, hbool_t adj_link, hid_t dxpl_id);
+H5_DLL void *H5O_msg_copy_file(const H5O_msg_class_t *type, H5F_t *file_src,
+    void *mesg_src, H5F_t *file_dst, hbool_t *recompute_size,
+    unsigned *mesg_flags, H5O_copy_t *cpy_info, void *udata, hid_t dxpl_id);
+H5_DLL herr_t H5O_msg_iterate_real(H5F_t *f, H5O_t *oh, const H5O_msg_class_t *type,
+    const H5O_mesg_operator_t *op, void *op_data, hid_t dxpl_id);
+
+/* Object header chunk routines */
+H5_DLL herr_t H5O_chunk_add(H5F_t *f, hid_t dxpl_id, H5O_t *oh, unsigned idx,
+    unsigned cont_chunkno);
+H5_DLL H5O_chunk_proxy_t *H5O_chunk_protect(H5F_t *f, hid_t dxpl_id, H5O_t *oh,
+    unsigned idx);
+H5_DLL herr_t H5O_chunk_unprotect(H5F_t *f, hid_t dxpl_id,
+    H5O_chunk_proxy_t *chk_proxy, hbool_t chk_dirtied);
+H5_DLL herr_t H5O_chunk_update_idx(H5F_t *f, hid_t dxpl_id, H5O_t *oh, unsigned idx);
+H5_DLL herr_t H5O_chunk_resize(H5O_t *oh, H5O_chunk_proxy_t *chk_proxy);
+H5_DLL herr_t H5O_chunk_delete(H5F_t *f, hid_t dxpl_id, H5O_t *oh, unsigned idx);
+H5_DLL herr_t H5O__chunk_dest(H5O_chunk_proxy_t *chunk_proxy);
+
+/* Collect storage info for btree and heap */
+H5_DLL herr_t H5O_attr_bh_info(H5F_t *f, hid_t dxpl_id, H5O_t *oh,
+    H5_ih_info_t *bh_info);
+
+/* Object header allocation routines */
+H5_DLL herr_t H5O_alloc_msgs(H5O_t *oh, size_t min_alloc);
+H5_DLL herr_t H5O__alloc_chunk(H5F_t *f, hid_t dxpl_id, H5O_t *oh, size_t size,
+    size_t found_null, const H5O_msg_alloc_info_t *found_msg, size_t *new_idx);
+H5_DLL herr_t  H5O_alloc(H5F_t *f, hid_t dxpl_id, H5O_t *oh,
+    const H5O_msg_class_t *type, const void *mesg, size_t *mesg_idx);
+H5_DLL herr_t H5O_condense_header(H5F_t *f, H5O_t *oh, hid_t dxpl_id);
+H5_DLL herr_t H5O_release_mesg(H5F_t *f, hid_t dxpl_id, H5O_t *oh,
+    H5O_mesg_t *mesg, hbool_t adj_link);
+
+/* Shared object operators */
+H5_DLL void * H5O_shared_decode(H5F_t *f, hid_t dxpl_id, H5O_t *open_oh,
+    unsigned *ioflags, const uint8_t *buf, const H5O_msg_class_t *type);
+H5_DLL herr_t H5O_shared_encode(const H5F_t *f, uint8_t *buf/*out*/, const H5O_shared_t *sh_mesg);
+H5_DLL size_t H5O_shared_size(const H5F_t *f, const H5O_shared_t *sh_mesg);
+H5_DLL herr_t H5O_shared_delete(H5F_t *f, hid_t dxpl_id, H5O_t *open_oh,
+    const H5O_msg_class_t *mesg_type, H5O_shared_t *sh_mesg);
+H5_DLL herr_t H5O_shared_link(H5F_t *f, hid_t dxpl_id, H5O_t *open_oh,
+    const H5O_msg_class_t *mesg_type, H5O_shared_t *sh_mesg);
+H5_DLL herr_t H5O_shared_copy_file(H5F_t *file_src, H5F_t *file_dst,
+    const H5O_msg_class_t *mesg_type, const void *_native_src, void *_native_dst,
+    hbool_t *recompute_size, unsigned *mesg_flags, H5O_copy_t *cpy_info,
+    void *udata, hid_t dxpl_id);
+H5_DLL herr_t H5O_shared_post_copy_file (H5F_t *f,
+    const H5O_msg_class_t *mesg_type, const H5O_shared_t *shared_src,
+    H5O_shared_t *shared_dst, unsigned *mesg_flags, hid_t dxpl_id,
+    H5O_copy_t *cpy_info);
+H5_DLL herr_t H5O_shared_debug(const H5O_shared_t *mesg, FILE *stream,
+    int indent, int fwidth);
+
+/* Attribute message operators */
+H5_DLL herr_t H5O_attr_reset(void *_mesg);
+H5_DLL herr_t H5O_attr_delete(H5F_t *f, hid_t dxpl_id, H5O_t *open_oh, void *_mesg);
+H5_DLL herr_t H5O_attr_link(H5F_t *f, hid_t dxpl_id, H5O_t *open_oh, void *_mesg);
+H5_DLL herr_t H5O_attr_count_real(H5F_t *f, hid_t dxpl_id, H5O_t *oh,
+    hsize_t *nattrs);
+
+/* Testing functions */
+#ifdef H5O_TESTING
+H5_DLL htri_t H5O_is_attr_empty_test(hid_t oid);
+H5_DLL htri_t H5O_is_attr_dense_test(hid_t oid);
+H5_DLL herr_t H5O_num_attrs_test(hid_t oid, hsize_t *nattrs);
+H5_DLL herr_t H5O_attr_dense_info_test(hid_t oid, hsize_t *name_count, hsize_t *corder_count);
+H5_DLL herr_t H5O_check_msg_marked_test(hid_t oid, hbool_t flag_val);
+H5_DLL herr_t H5O_expunge_chunks_test(const H5O_loc_t *oloc, hid_t dxpl_id);
+H5_DLL herr_t H5O_get_rc(const H5O_loc_t *oloc, hid_t dxpl_id, unsigned *rc);
+H5_DLL herr_t H5O_msg_get_chunkno_test(hid_t oid, unsigned msg_type,
+    unsigned *chunk_num);
+H5_DLL herr_t H5O_msg_move_to_new_chunk_test(hid_t oid, unsigned msg_type);
+#endif /* H5O_TESTING */
+
+/* Object header debugging routines */
+#ifdef H5O_DEBUG
+H5_DLL herr_t H5O_assert(const H5O_t *oh);
+#endif /* H5O_DEBUG */
+H5_DLL herr_t H5O_debug_real(H5F_t *f, hid_t dxpl_id, H5O_t *oh, haddr_t addr, FILE *stream, int indent, int fwidth);
+
+#endif /* _H5Opkg_H */
+
diff --git a/install/include/H5Opublic.h b/install/include/H5Opublic.h
new file mode 100644
index 0000000000..8d6dda425b
--- /dev/null
+++ b/install/include/H5Opublic.h
@@ -0,0 +1,215 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5Opublic.h
+ *                      Aug  5 1997
+ *                      Robb Matzke <matzke@llnl.gov>
+ *
+ * Purpose:             Public declarations for the H5O (object header)
+ *                      package.
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef _H5Opublic_H
+#define _H5Opublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"		/* Generic Functions			*/
+#include "H5Ipublic.h"		/* IDs			  		*/
+#include "H5Lpublic.h"		/* Links		  		*/
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* Flags for object copy (H5Ocopy) */
+#define H5O_COPY_SHALLOW_HIERARCHY_FLAG (0x0001u)   /* Copy only immediate members */
+#define H5O_COPY_EXPAND_SOFT_LINK_FLAG  (0x0002u)   /* Expand soft links into new objects */
+#define H5O_COPY_EXPAND_EXT_LINK_FLAG   (0x0004u)   /* Expand external links into new objects */
+#define H5O_COPY_EXPAND_REFERENCE_FLAG	(0x0008u)   /* Copy objects that are pointed by references */
+#define H5O_COPY_WITHOUT_ATTR_FLAG      (0x0010u)   /* Copy object without copying attributes */
+#define H5O_COPY_PRESERVE_NULL_FLAG     (0x0020u)   /* Copy NULL messages (empty space) */
+#define H5O_COPY_MERGE_COMMITTED_DTYPE_FLAG (0x0040u)   /* Merge committed datatypes in dest file */
+#define H5O_COPY_ALL                    (0x007Fu)   /* All object copying flags (for internal checking) */
+
+/* Flags for shared message indexes.
+ * Pass these flags in using the mesg_type_flags parameter in
+ * H5P_set_shared_mesg_index.
+ * (Developers: These flags correspond to object header message type IDs,
+ * but we need to assign each kind of message to a different bit so that
+ * one index can hold multiple types.)
+ */
+#define H5O_SHMESG_NONE_FLAG    0x0000          /* No shared messages */
+#define H5O_SHMESG_SDSPACE_FLAG ((unsigned)1 << 0x0001) /* Simple Dataspace Message.  */
+#define H5O_SHMESG_DTYPE_FLAG   ((unsigned)1 << 0x0003) /* Datatype Message.  */
+#define H5O_SHMESG_FILL_FLAG    ((unsigned)1 << 0x0005) /* Fill Value Message. */
+#define H5O_SHMESG_PLINE_FLAG   ((unsigned)1 << 0x000b) /* Filter pipeline message.  */
+#define H5O_SHMESG_ATTR_FLAG    ((unsigned)1 << 0x000c) /* Attribute Message.  */
+#define H5O_SHMESG_ALL_FLAG     (H5O_SHMESG_SDSPACE_FLAG | H5O_SHMESG_DTYPE_FLAG | H5O_SHMESG_FILL_FLAG | H5O_SHMESG_PLINE_FLAG | H5O_SHMESG_ATTR_FLAG)
+
+/* Object header status flag definitions */
+#define H5O_HDR_CHUNK0_SIZE             0x03    /* 2-bit field indicating # of bytes to store the size of chunk 0's data */
+#define H5O_HDR_ATTR_CRT_ORDER_TRACKED  0x04    /* Attribute creation order is tracked */
+#define H5O_HDR_ATTR_CRT_ORDER_INDEXED  0x08    /* Attribute creation order has index */
+#define H5O_HDR_ATTR_STORE_PHASE_CHANGE 0x10    /* Non-default attribute storage phase change values stored */
+#define H5O_HDR_STORE_TIMES             0x20    /* Store access, modification, change & birth times for object */
+#define H5O_HDR_ALL_FLAGS       (H5O_HDR_CHUNK0_SIZE | H5O_HDR_ATTR_CRT_ORDER_TRACKED | H5O_HDR_ATTR_CRT_ORDER_INDEXED | H5O_HDR_ATTR_STORE_PHASE_CHANGE | H5O_HDR_STORE_TIMES)
+
+/* Maximum shared message values.  Number of indexes is 8 to allow room to add
+ * new types of messages.
+ */
+#define H5O_SHMESG_MAX_NINDEXES 8
+#define H5O_SHMESG_MAX_LIST_SIZE 5000
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/* Types of objects in file */
+typedef enum H5O_type_t {
+    H5O_TYPE_UNKNOWN = -1,	/* Unknown object type		*/
+    H5O_TYPE_GROUP,	        /* Object is a group		*/
+    H5O_TYPE_DATASET,		/* Object is a dataset		*/
+    H5O_TYPE_NAMED_DATATYPE, 	/* Object is a named data type	*/
+    H5O_TYPE_NTYPES             /* Number of different object types (must be last!) */
+} H5O_type_t;
+
+/* Information struct for object header metadata (for H5Oget_info/H5Oget_info_by_name/H5Oget_info_by_idx) */
+typedef struct H5O_hdr_info_t {
+    unsigned version;		/* Version number of header format in file */
+    unsigned nmesgs;		/* Number of object header messages */
+    unsigned nchunks;		/* Number of object header chunks */
+    unsigned flags;             /* Object header status flags */
+    struct {
+        hsize_t total;		/* Total space for storing object header in file */
+        hsize_t meta;		/* Space within header for object header metadata information */
+        hsize_t mesg;		/* Space within header for actual message information */
+        hsize_t free;		/* Free space within object header */
+    } space;
+    struct {
+        uint64_t present;	/* Flags to indicate presence of message type in header */
+        uint64_t shared;	/* Flags to indicate message type is shared in header */
+    } mesg;
+} H5O_hdr_info_t;
+
+/* Information struct for object (for H5Oget_info/H5Oget_info_by_name/H5Oget_info_by_idx) */
+typedef struct H5O_info_t {
+    unsigned long 	fileno;		/* File number that object is located in */
+    haddr_t 		addr;		/* Object address in file	*/
+    H5O_type_t 		type;		/* Basic object type (group, dataset, etc.) */
+    unsigned 		rc;		/* Reference count of object    */
+    time_t		atime;		/* Access time			*/
+    time_t		mtime;		/* Modification time		*/
+    time_t		ctime;		/* Change time			*/
+    time_t		btime;		/* Birth time			*/
+    hsize_t 		num_attrs;	/* # of attributes attached to object */
+    H5O_hdr_info_t      hdr;            /* Object header information */
+    /* Extra metadata storage for obj & attributes */
+    struct {
+        H5_ih_info_t   obj;             /* v1/v2 B-tree & local/fractal heap for groups, B-tree for chunked datasets */
+        H5_ih_info_t   attr;            /* v2 B-tree & heap for attributes */
+    } meta_size;
+} H5O_info_t;
+
+/* Typedef for message creation indexes */
+typedef uint32_t H5O_msg_crt_idx_t;
+
+/* Prototype for H5Ovisit/H5Ovisit_by_name() operator */
+typedef herr_t (*H5O_iterate_t)(hid_t obj, const char *name, const H5O_info_t *info,
+    void *op_data);
+
+typedef enum H5O_mcdt_search_ret_t {
+    H5O_MCDT_SEARCH_ERROR = -1,	/* Abort H5Ocopy */
+    H5O_MCDT_SEARCH_CONT,	/* Continue the global search of all committed datatypes in the destination file */
+    H5O_MCDT_SEARCH_STOP	/* Stop the search, but continue copying.  The committed datatype will be copied but not merged. */
+} H5O_mcdt_search_ret_t;
+
+/* Callback to invoke when completing the search for a matching committed datatype from the committed dtype list */
+typedef H5O_mcdt_search_ret_t (*H5O_mcdt_search_cb_t)(void *op_data);
+
+/********************/
+/* Public Variables */
+/********************/
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+H5_DLL hid_t H5Oopen(hid_t loc_id, const char *name, hid_t lapl_id);
+H5_DLL hid_t H5Oopen_by_addr(hid_t loc_id, haddr_t addr);
+H5_DLL hid_t H5Oopen_by_idx(hid_t loc_id, const char *group_name,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t n, hid_t lapl_id);
+H5_DLL htri_t H5Oexists_by_name(hid_t loc_id, const char *name, hid_t lapl_id);
+H5_DLL herr_t H5Oget_info(hid_t loc_id, H5O_info_t *oinfo);
+H5_DLL herr_t H5Oget_info_by_name(hid_t loc_id, const char *name, H5O_info_t *oinfo,
+    hid_t lapl_id);
+H5_DLL herr_t H5Oget_info_by_idx(hid_t loc_id, const char *group_name,
+    H5_index_t idx_type, H5_iter_order_t order, hsize_t n, H5O_info_t *oinfo,
+    hid_t lapl_id);
+H5_DLL herr_t H5Olink(hid_t obj_id, hid_t new_loc_id, const char *new_name,
+    hid_t lcpl_id, hid_t lapl_id);
+H5_DLL herr_t H5Oincr_refcount(hid_t object_id);
+H5_DLL herr_t H5Odecr_refcount(hid_t object_id);
+H5_DLL herr_t H5Ocopy(hid_t src_loc_id, const char *src_name, hid_t dst_loc_id,
+    const char *dst_name, hid_t ocpypl_id, hid_t lcpl_id);
+H5_DLL herr_t H5Oset_comment(hid_t obj_id, const char *comment);
+H5_DLL herr_t H5Oset_comment_by_name(hid_t loc_id, const char *name,
+    const char *comment, hid_t lapl_id);
+H5_DLL ssize_t H5Oget_comment(hid_t obj_id, char *comment, size_t bufsize);
+H5_DLL ssize_t H5Oget_comment_by_name(hid_t loc_id, const char *name,
+    char *comment, size_t bufsize, hid_t lapl_id);
+H5_DLL herr_t H5Ovisit(hid_t obj_id, H5_index_t idx_type, H5_iter_order_t order,
+    H5O_iterate_t op, void *op_data);
+H5_DLL herr_t H5Ovisit_by_name(hid_t loc_id, const char *obj_name,
+    H5_index_t idx_type, H5_iter_order_t order, H5O_iterate_t op,
+    void *op_data, hid_t lapl_id);
+H5_DLL herr_t H5Oclose(hid_t object_id);
+H5_DLL herr_t H5Oflush(hid_t obj_id);
+H5_DLL herr_t H5Orefresh(hid_t oid);
+H5_DLL herr_t H5Odisable_mdc_flushes(hid_t object_id);
+H5_DLL herr_t H5Oenable_mdc_flushes(hid_t object_id);
+H5_DLL herr_t H5Oare_mdc_flushes_disabled(hid_t object_id, hbool_t *are_disabled);
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+
+/* Typedefs */
+
+/* A struct that's part of the H5G_stat_t structure (deprecated) */
+typedef struct H5O_stat_t {
+    hsize_t size;               /* Total size of object header in file */
+    hsize_t free;               /* Free space within object header */
+    unsigned nmesgs;            /* Number of object header messages */
+    unsigned nchunks;           /* Number of object header chunks */
+} H5O_stat_t;
+
+/* Function prototypes */
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _H5Opublic_H */
+
diff --git a/install/include/H5Oshared.h b/install/include/H5Oshared.h
new file mode 100644
index 0000000000..2465e656b9
--- /dev/null
+++ b/install/include/H5Oshared.h
@@ -0,0 +1,489 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:	Quincey Koziol <koziol@hdfgroup.org>
+ *		Friday, January 19, 2007
+ *
+ * Purpose:	This file contains inline definitions for "generic" routines
+ *		supporting a "shared message interface" (ala Java) for object
+ *		header messages that can be shared.  This interface is
+ *              dependent on a bunch of macros being defined which define
+ *              the name of the interface and "real" methods which need to
+ *              be implemented for each message class that supports the
+ *              shared message interface.
+ */
+
+#ifndef H5Oshared_H
+#define H5Oshared_H
+
+

+/*-------------------------------------------------------------------------
+ * Function:    H5O_SHARED_DECODE
+ *
+ * Purpose:     Decode an object header message that may be shared.
+ *
+ * Note:	The actual name of this routine can be different in each source
+ *		file that this header file is included in, and must be defined
+ *		prior to including this header file.
+ *
+ * Return:      Success:        Pointer to the new message in native form
+ *              Failure:        NULL
+ *
+ * Programmer:  Quincey Koziol
+ *              Friday, January 19, 2007
+ *
+ *-------------------------------------------------------------------------
+ */
+static H5_INLINE void *
+H5O_SHARED_DECODE(H5F_t *f, hid_t dxpl_id, H5O_t *open_oh, unsigned mesg_flags,
+    unsigned *ioflags, const uint8_t *p)
+{
+    void *ret_value = NULL;     /* Return value */
+
+    FUNC_ENTER_NOAPI_NOINIT
+
+#ifndef H5O_SHARED_TYPE
+#error "Need to define H5O_SHARED_TYPE macro!"
+#endif /* H5O_SHARED_TYPE */
+#ifndef H5O_SHARED_DECODE
+#error "Need to define H5O_SHARED_DECODE macro!"
+#endif /* H5O_SHARED_DECODE */
+#ifndef H5O_SHARED_DECODE_REAL
+#error "Need to define H5O_SHARED_DECODE_REAL macro!"
+#endif /* H5O_SHARED_DECODE_REAL */
+
+    /* Check for shared message */
+    if(mesg_flags & H5O_MSG_FLAG_SHARED) {
+        /* Retrieve native message info indirectly through shared message */
+        if(NULL == (ret_value = H5O_shared_decode(f, dxpl_id, open_oh, ioflags, p, H5O_SHARED_TYPE)))
+	    HGOTO_ERROR(H5E_OHDR, H5E_CANTDECODE, NULL, "unable to decode shared message")
+
+        /* We currently do not support automatically fixing shared messages */
+#ifdef H5_STRICT_FORMAT_CHECKS
+        if(*ioflags & H5O_DECODEIO_DIRTY)
+            HGOTO_ERROR(H5E_OHDR, H5E_UNSUPPORTED, NULL, "unable to mark shared message dirty")
+#else /* H5_STRICT_FORMAT_CHECKS */
+        *ioflags &= ~H5O_DECODEIO_DIRTY;
+#endif /* H5_STRICT_FORMAT_CHECKS */
+    } /* end if */
+    else {
+        /* Decode native message directly */
+        if(NULL == (ret_value = H5O_SHARED_DECODE_REAL(f, dxpl_id, open_oh, mesg_flags, ioflags, p)))
+	    HGOTO_ERROR(H5E_OHDR, H5E_CANTDECODE, NULL, "unable to decode native message")
+    } /* end else */
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5O_SHARED_DECODE() */
+
+

+/*-------------------------------------------------------------------------
+ * Function:    H5O_SHARED_ENCODE
+ *
+ * Purpose:     Encode an object header message that may be shared.
+ *
+ * Note:	The actual name of this routine can be different in each source
+ *		file that this header file is included in, and must be defined
+ *		prior to including this header file.
+ *
+ * Return:      Success:        Non-negative
+ *              Failure:        Negative
+ *
+ * Programmer:  Quincey Koziol
+ *              Friday, January 19, 2007
+ *
+ *-------------------------------------------------------------------------
+ */
+static H5_INLINE herr_t
+H5O_SHARED_ENCODE(H5F_t *f, hbool_t disable_shared, uint8_t *p, const void *_mesg)
+{
+    const H5O_shared_t *sh_mesg = (const H5O_shared_t *)_mesg;     /* Pointer to shared message portion of actual message */
+    herr_t ret_value = SUCCEED;         /* Return value */
+
+    FUNC_ENTER_NOAPI_NOINIT
+
+#ifndef H5O_SHARED_TYPE
+#error "Need to define H5O_SHARED_TYPE macro!"
+#endif /* H5O_SHARED_TYPE */
+#ifndef H5O_SHARED_ENCODE
+#error "Need to define H5O_SHARED_ENCODE macro!"
+#endif /* H5O_SHARED_ENCODE */
+#ifndef H5O_SHARED_ENCODE_REAL
+#error "Need to define H5O_SHARED_ENCODE_REAL macro!"
+#endif /* H5O_SHARED_ENCODE_REAL */
+
+    /* Sanity check */
+    HDassert(sh_mesg->type == H5O_SHARE_TYPE_UNSHARED || sh_mesg->msg_type_id == H5O_SHARED_TYPE->id);
+
+    /* Check for message stored elsewhere */
+    if(H5O_IS_STORED_SHARED(sh_mesg->type) && !disable_shared) {
+        /* Encode shared message into buffer */
+        if(H5O_shared_encode(f, p, sh_mesg) < 0)
+	    HGOTO_ERROR(H5E_OHDR, H5E_CANTENCODE, FAIL, "unable to encode shared message")
+    } /* end if */
+    else {
+        /* Encode native message directly */
+        if(H5O_SHARED_ENCODE_REAL(f, p, _mesg) < 0)
+	    HGOTO_ERROR(H5E_OHDR, H5E_CANTENCODE, FAIL, "unable to encode native message")
+    } /* end else */
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5O_SHARED_ENCODE() */
+
+

+/*-------------------------------------------------------------------------
+ * Function:    H5O_SHARED_SIZE
+ *
+ * Purpose:	Returns the length of an encoded message.
+ *
+ * Note:	The actual name of this routine can be different in each source
+ *		file that this header file is included in, and must be defined
+ *		prior to including this header file.
+ *
+ * Return:	Success:	Length
+ *		Failure:	0
+ *
+ * Programmer:  Quincey Koziol
+ *              Friday, January 19, 2007
+ *
+ *-------------------------------------------------------------------------
+ */
+static H5_INLINE size_t
+H5O_SHARED_SIZE(const H5F_t *f, hbool_t disable_shared, const void *_mesg)
+{
+    const H5O_shared_t *sh_mesg = (const H5O_shared_t *)_mesg;     /* Pointer to shared message portion of actual message */
+    size_t ret_value = 0;       /* Return value */
+
+    FUNC_ENTER_NOAPI_NOINIT
+
+#ifndef H5O_SHARED_TYPE
+#error "Need to define H5O_SHARED_TYPE macro!"
+#endif /* H5O_SHARED_TYPE */
+#ifndef H5O_SHARED_SIZE
+#error "Need to define H5O_SHARED_SIZE macro!"
+#endif /* H5O_SHARED_SIZE */
+#ifndef H5O_SHARED_SIZE_REAL
+#error "Need to define H5O_SHARED_SIZE_REAL macro!"
+#endif /* H5O_SHARED_SIZE_REAL */
+
+    /* Check for message stored elsewhere */
+    if(H5O_IS_STORED_SHARED(sh_mesg->type) && !disable_shared) {
+        /* Retrieve encoded size of shared message */
+        if(0 == (ret_value = H5O_shared_size(f, sh_mesg)))
+	    HGOTO_ERROR(H5E_OHDR, H5E_CANTGET, 0, "unable to retrieve encoded size of shared message")
+    } /* end if */
+    else {
+        /* Retrieve size of native message directly */
+        if(0 == (ret_value = H5O_SHARED_SIZE_REAL(f, _mesg)))
+	    HGOTO_ERROR(H5E_OHDR, H5E_CANTGET, 0, "unable to retrieve encoded size of native message")
+    } /* end else */
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5O_SHARED_SIZE() */
+
+

+/*-------------------------------------------------------------------------
+ * Function:    H5O_SHARED_DELETE
+ *
+ * Purpose:     Decrement reference count on any objects referenced by
+ *              message
+ *
+ * Note:	The actual name of this routine can be different in each source
+ *		file that this header file is included in, and must be defined
+ *		prior to including this header file.
+ *
+ * Return:	Success:	Non-negative
+ *		Failure:	Negative
+ *
+ * Programmer:  Quincey Koziol
+ *              Friday, January 19, 2007
+ *
+ *-------------------------------------------------------------------------
+ */
+static H5_INLINE herr_t
+H5O_SHARED_DELETE(H5F_t *f, hid_t dxpl_id, H5O_t *open_oh, void *_mesg)
+{
+    H5O_shared_t *sh_mesg = (H5O_shared_t *)_mesg;     /* Pointer to shared message portion of actual message */
+    herr_t ret_value = SUCCEED;         /* Return value */
+
+    FUNC_ENTER_NOAPI_NOINIT
+
+#ifndef H5O_SHARED_TYPE
+#error "Need to define H5O_SHARED_TYPE macro!"
+#endif /* H5O_SHARED_TYPE */
+#ifndef H5O_SHARED_DELETE
+#error "Need to define H5O_SHARED_DELETE macro!"
+#endif /* H5O_SHARED_DELETE */
+
+    /* Check for message tracked elsewhere */
+    if(H5O_IS_TRACKED_SHARED(sh_mesg->type)) {
+        /* Decrement the reference count on the shared message/object */
+        if(H5O_shared_delete(f, dxpl_id, open_oh, H5O_SHARED_TYPE, sh_mesg) < 0)
+	    HGOTO_ERROR(H5E_OHDR, H5E_CANTDEC, FAIL, "unable to decrement ref count for shared message")
+    } /* end if */
+#ifdef H5O_SHARED_DELETE_REAL
+    else {
+        /* Decrement the reference count on the native message directly */
+        if(H5O_SHARED_DELETE_REAL(f, dxpl_id, open_oh, _mesg) < 0)
+	    HGOTO_ERROR(H5E_OHDR, H5E_CANTDEC, FAIL, "unable to decrement ref count for native message")
+    } /* end else */
+#endif /* H5O_SHARED_DELETE_REAL */
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5O_SHARED_DELETE() */
+
+

+/*-------------------------------------------------------------------------
+ * Function:    H5O_SHARED_LINK
+ *
+ * Purpose:     Increment reference count on any objects referenced by
+ *              message
+ *
+ * Note:	The actual name of this routine can be different in each source
+ *		file that this header file is included in, and must be defined
+ *		prior to including this header file.
+ *
+ * Return:	Success:	Non-negative
+ *		Failure:	Negative
+ *
+ * Programmer:  Quincey Koziol
+ *              Friday, January 19, 2007
+ *
+ *-------------------------------------------------------------------------
+ */
+static H5_INLINE herr_t
+H5O_SHARED_LINK(H5F_t *f, hid_t dxpl_id, H5O_t *open_oh, void *_mesg)
+{
+    H5O_shared_t *sh_mesg = (H5O_shared_t *)_mesg;     /* Pointer to shared message portion of actual message */
+    herr_t ret_value = SUCCEED;         /* Return value */
+
+    FUNC_ENTER_NOAPI_NOINIT
+
+#ifndef H5O_SHARED_TYPE
+#error "Need to define H5O_SHARED_TYPE macro!"
+#endif /* H5O_SHARED_TYPE */
+#ifndef H5O_SHARED_LINK
+#error "Need to define H5O_SHARED_LINK macro!"
+#endif /* H5O_SHARED_LINK */
+
+    /* Check for message tracked elsewhere */
+    if(H5O_IS_TRACKED_SHARED(sh_mesg->type)) {
+        /* Increment the reference count on the shared message/object */
+        if(H5O_shared_link(f, dxpl_id, open_oh, H5O_SHARED_TYPE, sh_mesg) < 0)
+	    HGOTO_ERROR(H5E_OHDR, H5E_CANTINC, FAIL, "unable to increment ref count for shared message")
+    } /* end if */
+#ifdef H5O_SHARED_LINK_REAL
+    else {
+        /* Increment the reference count on the native message directly */
+        if(H5O_SHARED_LINK_REAL(f, dxpl_id, open_oh, _mesg) < 0)
+	    HGOTO_ERROR(H5E_OHDR, H5E_CANTINC, FAIL, "unable to increment ref count for native message")
+    } /* end else */
+#endif /* H5O_SHARED_LINK_REAL */
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5O_SHARED_LINK() */
+
+

+/*-------------------------------------------------------------------------
+ * Function:    H5O_SHARED_COPY_FILE
+ *
+ * Purpose:     Copies a message from _SRC to _DEST in file
+ *
+ * Note:	The actual name of this routine can be different in each source
+ *		file that this header file is included in, and must be defined
+ *		prior to including this header file.
+ *
+ * Return:	Success:	Non-negative
+ *		Failure:	Negative
+ *
+ * Programmer:  Quincey Koziol
+ *              Friday, January 19, 2007
+ *
+ *-------------------------------------------------------------------------
+ */
+static H5_INLINE void *
+H5O_SHARED_COPY_FILE(H5F_t *file_src, void *_native_src, H5F_t *file_dst,
+    hbool_t *recompute_size, unsigned *mesg_flags, H5O_copy_t *cpy_info,
+    void *udata, hid_t dxpl_id)
+{
+    void *dst_mesg = NULL;      /* Destination message */
+    void *ret_value = NULL;     /* Return value */
+
+    FUNC_ENTER_NOAPI_NOINIT
+
+#ifndef H5O_SHARED_TYPE
+#error "Need to define H5O_SHARED_TYPE macro!"
+#endif /* H5O_SHARED_TYPE */
+#ifndef H5O_SHARED_COPY_FILE
+#error "Need to define H5O_SHARED_COPY_FILE macro!"
+#endif /* H5O_SHARED_COPY_FILE */
+
+#ifdef H5O_SHARED_COPY_FILE_REAL
+    /* Call native message's copy file callback to copy the message */
+    if(NULL == (dst_mesg = H5O_SHARED_COPY_FILE_REAL(file_src, H5O_SHARED_TYPE, _native_src, file_dst, recompute_size, cpy_info, udata, dxpl_id)))
+        HGOTO_ERROR(H5E_OHDR, H5E_CANTCOPY, NULL, "unable to copy native message to another file")
+#else /* H5O_SHARED_COPY_FILE_REAL */
+    /* No copy file callback defined, just copy the message itself */
+    if(NULL == (dst_mesg = (H5O_SHARED_TYPE->copy)(_native_src, NULL)))
+        HGOTO_ERROR(H5E_OHDR, H5E_CANTCOPY, NULL, "unable to copy native message")
+#endif /* H5O_SHARED_COPY_FILE_REAL */
+
+    /* Reset shared message info for new message */
+    HDmemset(dst_mesg, 0, sizeof(H5O_shared_t));
+
+    /* Handle sharing destination message */
+    if(H5O_shared_copy_file(file_src, file_dst, H5O_SHARED_TYPE, _native_src,
+            dst_mesg, recompute_size, mesg_flags, cpy_info, udata, dxpl_id) < 0)
+        HGOTO_ERROR(H5E_OHDR, H5E_WRITEERROR, NULL, "unable to determine if message should be shared")
+
+    /* Set return value */
+    ret_value = dst_mesg;
+
+done:
+    if(!ret_value)
+        if(dst_mesg)
+            H5O_msg_free(H5O_SHARED_TYPE->id, dst_mesg);
+
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5O_SHARED_COPY_FILE() */
+
+

+/*-------------------------------------------------------------------------
+ * Function:    H5O_SHARED_POST_COPY_FILE
+ *
+ * Purpose:     Copies a message from _SRC to _DEST in file
+ *
+ * Note:        The actual name of this routine can be different in each source
+ *              file that this header file is included in, and must be defined
+ *              prior to including this header file.
+ *
+ * Return:      Success:        Non-negative
+ *              Failure:        Negative
+ *
+ * Programmer:  Peter Cao
+ *              May 25, 2007
+ *
+ *-------------------------------------------------------------------------
+ */
+static H5_INLINE herr_t
+H5O_SHARED_POST_COPY_FILE(const H5O_loc_t *oloc_src, const void *mesg_src,
+    H5O_loc_t *oloc_dst, void *mesg_dst, unsigned *mesg_flags, hid_t dxpl_id,
+    H5O_copy_t *cpy_info)
+{
+    const H5O_shared_t  *shared_src = (const H5O_shared_t *)mesg_src; /* Alias to shared info in native source */
+    H5O_shared_t        *shared_dst = (H5O_shared_t *)mesg_dst; /* Alias to shared info in native destination */
+    herr_t              ret_value = SUCCEED;         /* Return value */
+
+    FUNC_ENTER_NOAPI_NOINIT
+
+    HDassert(oloc_src->file);
+    HDassert(oloc_dst->file);
+    HDassert(mesg_src);
+    HDassert(mesg_dst);
+    HDassert(cpy_info);
+
+#ifndef H5O_SHARED_TYPE
+#error "Need to define H5O_SHARED_TYPE macro!"
+#endif /* H5O_SHARED_TYPE */
+#ifndef H5O_SHARED_POST_COPY_FILE
+#error "Need to define H5O_SHARED_POST_COPY_FILE macro!"
+#endif /* H5O_SHARED_POST_COPY_FILE */
+
+#ifdef H5O_SHARED_POST_COPY_FILE_REAL
+    /* Call native message's post copy file callback to copy the message */
+    if(H5O_SHARED_POST_COPY_FILE_REAL(oloc_src, mesg_src, oloc_dst, mesg_dst, dxpl_id, cpy_info) <0 )
+        HGOTO_ERROR(H5E_OHDR, H5E_CANTCOPY, FAIL, "unable to copy native message to another file")
+#endif /* H5O_SHARED_POST_COPY_FILE_REAL */
+
+    /* Update shared message after the post copy - will short circuit in
+     * production if the DEFER pass determined it will not be shared; debug mode
+     * verifies that it is indeed the case */
+    if(H5O_shared_post_copy_file(oloc_dst->file, H5O_SHARED_TYPE,
+            shared_src, shared_dst, mesg_flags, dxpl_id, cpy_info) < 0)
+        HGOTO_ERROR(H5E_OHDR, H5E_WRITEERROR, FAIL, "unable to fix shared message in post copy")
+
+#ifdef H5O_SHARED_POST_COPY_FILE_UPD
+    /* Call native message's post copy file update callback to update the
+     * message */
+    if(H5O_SHARED_POST_COPY_FILE_UPD(oloc_src, mesg_src, oloc_dst, mesg_dst, dxpl_id, cpy_info) < 0)
+        HGOTO_ERROR(H5E_OHDR, H5E_CANTCOPY, FAIL, "unable to update native message")
+#endif /* H5O_SHARED_POST_COPY_FILE_UPD */
+
+    /* Make sure that if the the source or destination is committed, both are
+     * committed */
+    HDassert((shared_src->type == H5O_SHARE_TYPE_COMMITTED)
+            == (shared_dst->type == H5O_SHARE_TYPE_COMMITTED));
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5O_SHARED_POST_COPY_FILE() */
+
+

+/*-------------------------------------------------------------------------
+ * Function:    H5O_SHARED_DEBUG
+ *
+ * Purpose:     Prints debugging info for a potentially shared message.
+ *
+ * Note:	The actual name of this routine can be different in each source
+ *		file that this header file is included in, and must be defined
+ *		prior to including this header file.
+ *
+ * Return:	Success:	Non-negative
+ *		Failure:	Negative
+ *
+ * Programmer:  Quincey Koziol
+ *              Saturday, February  3, 2007
+ *
+ *-------------------------------------------------------------------------
+ */
+static H5_INLINE herr_t
+H5O_SHARED_DEBUG(H5F_t *f, hid_t dxpl_id, const void *_mesg, FILE *stream,
+    int indent, int fwidth)
+{
+    const H5O_shared_t *sh_mesg = (const H5O_shared_t *)_mesg;     /* Pointer to shared message portion of actual message */
+    herr_t ret_value = SUCCEED;           /* Return value */
+
+    FUNC_ENTER_NOAPI_NOINIT
+
+#ifndef H5O_SHARED_TYPE
+#error "Need to define H5O_SHARED_TYPE macro!"
+#endif /* H5O_SHARED_TYPE */
+#ifndef H5O_SHARED_DEBUG
+#error "Need to define H5O_SHARED_DEBUG macro!"
+#endif /* H5O_SHARED_DEBUG */
+#ifndef H5O_SHARED_DEBUG_REAL
+#error "Need to define H5O_SHARED_DEBUG_REAL macro!"
+#endif /* H5O_SHARED_DEBUG_REAL */
+
+    /* Check for message stored elsewhere */
+    if(H5O_IS_STORED_SHARED(sh_mesg->type)) {
+        /* Print shared message information */
+        if(H5O_shared_debug(sh_mesg, stream, indent, fwidth) < 0)
+            HGOTO_ERROR(H5E_OHDR, H5E_WRITEERROR, FAIL, "unable to display shared message info")
+    } /* end if */
+
+    /* Call native message's debug callback */
+    if(H5O_SHARED_DEBUG_REAL(f, dxpl_id, _mesg, stream, indent, fwidth) < 0)
+        HGOTO_ERROR(H5E_OHDR, H5E_WRITEERROR, FAIL, "unable to display native message info")
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5O_SHARED_DEBUG() */
+
+#endif /* H5Oshared_H */
+
diff --git a/install/include/H5PBpkg.h b/install/include/H5PBpkg.h
new file mode 100644
index 0000000000..6b9168b84d
--- /dev/null
+++ b/install/include/H5PBpkg.h
@@ -0,0 +1,58 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#if !(defined H5PB_FRIEND || defined H5PB_MODULE)
+#error "Do not include this file outside the H5PB package!"
+#endif
+
+#ifndef _H5PBpkg_H
+#define _H5PBpkg_H
+
+/* Get package's private header */
+#include "H5PBprivate.h"
+
+/* Other private headers needed by this file */
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+typedef struct H5PB_entry_t {
+    void            *page_buf_ptr;      /* Pointer to the buffer containing the data */
+    haddr_t	    addr;               /* Address of the page in the file */
+    H5F_mem_page_t  type;               /* Type of the page entry (H5F_MEM_PAGE_RAW/META) */
+    hbool_t         is_dirty;           /* Flag indicating whether the page has dirty data or not */
+
+    /* Fields supporting replacement policies */
+    struct H5PB_entry_t     *next;      /* next pointer in the LRU list */
+    struct H5PB_entry_t     *prev;      /* previous pointer in the LRU list */
+} H5PB_entry_t;
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+
+#endif /* _H5PBpkg_H */
+
diff --git a/install/include/H5PLextern.h b/install/include/H5PLextern.h
new file mode 100644
index 0000000000..cd5464d101
--- /dev/null
+++ b/install/include/H5PLextern.h
@@ -0,0 +1,44 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5. The full HDF5 copyright notice, including      *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:     Header file for writing external HDF5 plugins.
+ */
+
+#ifndef _H5PLextern_H
+#define _H5PLextern_H
+
+/* Include HDF5 header */
+#include "hdf5.h"
+
+/* plugins always export */
+#if defined (_MSC_VER)  /* MSVC Compiler Case */
+  #define H5PLUGIN_DLL __declspec(dllexport)
+#elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+  #define H5PLUGIN_DLL __attribute__ ((visibility("default")))
+#else
+  #define H5PLUGIN_DLL
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5PLUGIN_DLL H5PL_type_t H5PLget_plugin_type(void);
+H5PLUGIN_DLL const void *H5PLget_plugin_info(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _H5PLextern_H */
+
diff --git a/install/include/H5PLpkg.h b/install/include/H5PLpkg.h
new file mode 100644
index 0000000000..0d1c271a9f
--- /dev/null
+++ b/install/include/H5PLpkg.h
@@ -0,0 +1,159 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose: This file contains declarations which are visible only within
+ *          the H5PL package.  Source files outside the H5PL package should
+ *          include H5PLprivate.h instead.
+ */
+
+#if !(defined H5PL_FRIEND || defined H5PL_MODULE)
+#error "Do not include this file outside the H5PL package!"
+#endif
+
+#ifndef _H5PLpkg_H
+#define _H5PLpkg_H
+
+/* Include private header file */
+#include "H5PLprivate.h"          /* Filter functions                */
+
+/* Other private headers needed by this file */
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+/* Whether to pre-load pathnames for plugin libraries */
+#define H5PL_DEFAULT_PATH       H5_DEFAULT_PLUGINDIR
+
+
+/****************************/
+/* Macros for supporting    */
+/* both Windows and POSIX   */
+/****************************/
+
+/*******************/
+/* Windows support */
+/*******************/
+/*
+ * SPECIAL WINDOWS NOTE
+ *
+ * Some of the Win32 API functions expand to fooA or fooW depending on
+ * whether UNICODE or _UNICODE are defined. You MUST explicitly use
+ * the A version of the functions to force char * behavior until we
+ * work out a scheme for proper Windows Unicode support.
+ *
+ * If you do not do this, people will be unable to incorporate our
+ * source code into their own CMake builds if they define UNICODE.
+ */
+#ifdef H5_HAVE_WIN32_API
+
+    /* The path separator on this platform */
+#   define H5PL_PATH_SEPARATOR      ";"
+
+    /* Handle for dynamic library */
+#   define H5PL_HANDLE HINSTANCE
+
+    /* Get a handle to a plugin library.  Windows: TEXT macro handles Unicode strings */
+#   define H5PL_OPEN_DLIB(S) LoadLibraryExA(S, NULL, LOAD_WITH_ALTERED_SEARCH_PATH)
+
+    /* Get the address of a symbol in dynamic library */
+#   define H5PL_GET_LIB_FUNC(H,N) GetProcAddress(H,N)
+
+    /* Close dynamic library */
+#   define H5PL_CLOSE_LIB(H) FreeLibrary(H)
+
+    /* Clear error - nothing to do */
+#   define H5PL_CLR_ERROR
+
+    /* maximum size for expanding env vars */
+#   define H5PL_EXPAND_BUFFER_SIZE 32767
+
+    typedef const void *(__cdecl *H5PL_get_plugin_info_t)(void);
+
+#else /* H5_HAVE_WIN32_API */
+
+    /*****************/
+    /* POSIX support */
+    /*****************/
+
+    /* The path separator on this platform */
+#   define H5PL_PATH_SEPARATOR     ":"
+
+    /* Handle for dynamic library */
+#   define H5PL_HANDLE void *
+
+    /* Get a handle to a plugin library.  Windows: TEXT macro handles Unicode strings */
+#   define H5PL_OPEN_DLIB(S) dlopen(S, RTLD_LAZY)
+
+    /* Get the address of a symbol in dynamic library */
+#   define H5PL_GET_LIB_FUNC(H,N) dlsym(H,N)
+
+    /* Close dynamic library */
+#   define H5PL_CLOSE_LIB(H) dlclose(H)
+
+    /* Clear error */
+#   define H5PL_CLR_ERROR HERROR(H5E_PLUGIN, H5E_CANTGET, "can't dlopen:%s", dlerror())
+
+    typedef const void *(*H5PL_get_plugin_info_t)(void);
+#endif /* H5_HAVE_WIN32_API */
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/* Data used to search for plugins */
+typedef struct H5PL_search_params_t {
+    H5PL_type_t     type;
+    int             id;
+} H5PL_search_params_t;
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+/* Accessors to global variables and flags */
+H5_DLL herr_t H5PL__get_plugin_control_mask(unsigned int *mask /*out*/);
+H5_DLL herr_t H5PL__set_plugin_control_mask(unsigned int mask);
+
+/* Plugin search and manipulation */
+H5_DLL herr_t H5PL__open(const char *libname, H5PL_type_t type, int id, hbool_t *success /*out*/, const void **plugin_info /*out*/);
+H5_DLL herr_t H5PL__close(H5PL_HANDLE handle);
+
+/* Plugin cache calls */
+H5_DLL herr_t H5PL__create_plugin_cache(void);
+H5_DLL herr_t H5PL__close_plugin_cache(hbool_t *already_closed /*out*/);
+H5_DLL herr_t H5PL__add_plugin(H5PL_type_t type, int id, H5PL_HANDLE handle);
+H5_DLL herr_t H5PL__find_plugin_in_cache(const H5PL_search_params_t *search_params, hbool_t *found /*out*/, const void **plugin_info /*out*/);
+
+/* Plugin search path calls */
+H5_DLL herr_t H5PL__create_path_table(void);
+H5_DLL herr_t H5PL__close_path_table(void);
+H5_DLL unsigned H5PL__get_num_paths(void);
+H5_DLL herr_t H5PL__append_path(const char *path);
+H5_DLL herr_t H5PL__prepend_path(const char *path);
+H5_DLL herr_t H5PL__replace_path(const char *path, unsigned int index);
+H5_DLL herr_t H5PL__insert_path(const char *path, unsigned int index);
+H5_DLL herr_t H5PL__remove_path(unsigned int index);
+H5_DLL const char *H5PL__get_path(unsigned int index);
+H5_DLL herr_t H5PL__find_plugin_in_path_table(const H5PL_search_params_t *search_params, hbool_t *found /*out*/, const void **plugin_info /*out*/);
+
+#endif /* _H5PLpkg_H */
+
diff --git a/install/include/H5PLpublic.h b/install/include/H5PLpublic.h
new file mode 100644
index 0000000000..3b36ccde07
--- /dev/null
+++ b/install/include/H5PLpublic.h
@@ -0,0 +1,62 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5. The full HDF5 copyright notice, including      *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5PL module.
+ */
+
+#ifndef _H5PLpublic_H
+#define _H5PLpublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"          /* Generic Functions                    */
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/* Special string to indicate no plugin loading.
+ */
+#define H5PL_NO_PLUGIN          "::"
+
+/* Plugin type used by the plugin library */
+typedef enum H5PL_type_t {
+    H5PL_TYPE_ERROR         = -1,   /* Error                    */
+    H5PL_TYPE_FILTER        = 0,    /* Filter                   */
+    H5PL_TYPE_NONE          = 1     /* This must be last!       */
+} H5PL_type_t;
+
+/* Common dynamic plugin type flags used by the set/get_loading_state functions */
+#define H5PL_FILTER_PLUGIN      0x0001
+#define H5PL_ALL_PLUGIN         0xFFFF
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* plugin state */
+H5_DLL herr_t H5PLset_loading_state(unsigned int plugin_control_mask);
+H5_DLL herr_t H5PLget_loading_state(unsigned int *plugin_control_mask /*out*/);
+H5_DLL herr_t H5PLappend(const char *search_path);
+H5_DLL herr_t H5PLprepend(const char *search_path);
+H5_DLL herr_t H5PLreplace(const char *search_path, unsigned int index);
+H5_DLL herr_t H5PLinsert(const char *search_path, unsigned int index);
+H5_DLL herr_t H5PLremove(unsigned int index);
+H5_DLL ssize_t H5PLget(unsigned int index, char *path_buf /*out*/, size_t buf_size);
+H5_DLL herr_t H5PLsize(unsigned int *num_paths /*out*/);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _H5PLpublic_H */
+
diff --git a/install/include/H5PTpublic.h b/install/include/H5PTpublic.h
new file mode 100644
index 0000000000..8a12c8cad2
--- /dev/null
+++ b/install/include/H5PTpublic.h
@@ -0,0 +1,107 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef _H5PTpublic_H
+#define _H5PTpublic_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*-------------------------------------------------------------------------
+ * Create/Open/Close functions
+ *-------------------------------------------------------------------------
+ */
+/* NOTE: H5PTcreate is replacing H5PTcreate_fl for better name due to the
+   removal of H5PTcreate_vl.  H5PTcreate_fl may be retired in 1.8.19. */
+H5_HLDLL hid_t H5PTcreate(hid_t loc_id, const char *dset_name,
+			hid_t dtype_id, hsize_t chunk_size, hid_t plist_id);
+
+H5_HLDLL hid_t H5PTopen(hid_t loc_id, const char *dset_name);
+
+H5_HLDLL herr_t H5PTclose(hid_t table_id);
+
+/* This function may be removed from the packet table in release 1.8.19. */
+H5_HLDLL hid_t H5PTcreate_fl(hid_t loc_id, const char *dset_name,
+			hid_t dtype_id, hsize_t chunk_size, int compression);
+
+
+/*-------------------------------------------------------------------------
+ * Write functions
+ *-------------------------------------------------------------------------
+ */
+H5_HLDLL herr_t H5PTappend(hid_t table_id, size_t nrecords, const void *data);
+
+/*-------------------------------------------------------------------------
+ * Read functions
+ *-------------------------------------------------------------------------
+ */
+H5_HLDLL herr_t H5PTget_next(hid_t table_id, size_t nrecords, void * data);
+
+H5_HLDLL herr_t H5PTread_packets(hid_t table_id, hsize_t start,
+			size_t nrecords, void *data);
+
+/*-------------------------------------------------------------------------
+ * Inquiry functions
+ *-------------------------------------------------------------------------
+ */
+H5_HLDLL herr_t H5PTget_num_packets(hid_t table_id, hsize_t *nrecords);
+
+H5_HLDLL herr_t H5PTis_valid(hid_t table_id);
+
+H5_HLDLL herr_t H5PTis_varlen(hid_t table_id);
+
+/*-------------------------------------------------------------------------
+ *
+ * Accessor functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+H5_HLDLL hid_t H5PTget_dataset(hid_t table_id);
+
+H5_HLDLL hid_t H5PTget_type(hid_t table_id);
+
+/*-------------------------------------------------------------------------
+ *
+ * Packet Table "current index" functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+H5_HLDLL herr_t  H5PTcreate_index( hid_t table_id );
+
+H5_HLDLL herr_t  H5PTset_index( hid_t table_id,
+                             hsize_t pt_index );
+
+H5_HLDLL herr_t  H5PTget_index( hid_t table_id,
+                             hsize_t *pt_index );
+
+/*-------------------------------------------------------------------------
+ *
+ * Memory Management functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+H5_HLDLL herr_t  H5PTfree_vlen_buff( hid_t table_id,
+                               size_t bufflen,
+                               void * buff );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/install/include/H5PacketTable.h b/install/include/H5PacketTable.h
new file mode 100644
index 0000000000..26659844b7
--- /dev/null
+++ b/install/include/H5PacketTable.h
@@ -0,0 +1,217 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Packet Table wrapper classes
+ *
+ * Wraps the H5PT Packet Table C functions in C++ objects
+ *
+ * Nat Furrer and James Laird
+ * February 2004
+ */
+
+#ifndef H5PTWRAP_H
+#define H5PTWRAP_H
+
+/* Public HDF5 header */
+#include "hdf5.h"
+
+#include "H5PTpublic.h"
+#include "H5api_adpt.h"
+
+class H5_HLCPPDLL  PacketTable
+{
+public:
+    /* Null constructor
+     * Sets table_id to "invalid"
+     */
+    PacketTable() {table_id = H5I_BADID;}
+
+    /* "Open" Constructor
+     * Opens an existing packet table, which can contain either fixed-length or
+     * variable-length packets.
+     */
+    PacketTable(hid_t fileID, const char* name);
+
+    /* "Open" Constructor - will be deprecated because of char* name */
+    PacketTable(hid_t fileID, char* name);
+
+    /* Destructor
+     * Cleans up the packet table
+     */
+    virtual ~PacketTable();
+
+    /* IsValid
+     * Returns true if this packet table is valid, false otherwise.
+     * Use this after the constructor to ensure HDF did not have
+     * any trouble making or opening the packet table.
+     */
+    bool IsValid();
+
+    /* IsVariableLength
+     * Return 1 if this packet table uses variable-length datatype,
+     * return 0 if it is Fixed Length.  Returns -1 if the table is
+     * invalid (not open).
+     */
+    int IsVariableLength();
+
+    /* ResetIndex
+     * Sets the "current packet" index to point to the first packet in the
+     * packet table
+     */
+    void ResetIndex();
+
+    /* SetIndex
+     * Sets the current packet to point to the packet specified by index.
+     * Returns 0 on success, negative on failure (if index is out of bounds)
+     */
+    int SetIndex(hsize_t index);
+
+    /* GetIndex
+     * Returns the position of the current packet.
+     * On failure, returns 0 and error is set to negative.
+     */
+    hsize_t GetIndex(int& error);
+
+    /* GetPacketCount
+     * Returns the number of packets in the packet table.  Error
+     * is set to 0 on success.  On failure, returns 0 and
+     * error is set to negative.
+     */
+    hsize_t GetPacketCount(int& error);
+
+    hsize_t GetPacketCount()
+    {
+        int ignoreError;
+        return GetPacketCount(ignoreError);
+    }
+
+    /* GetTableId
+     * Returns the identifier of the packet table.
+     */
+    hid_t GetTableId();
+
+    /* GetDatatype
+     * Returns the datatype identifier used by the packet table, on success,
+     * or FAIL, on failure.
+     * Note: it is best to avoid using this identifier in applications, unless
+     * the desired functionality cannot be performed via the packet table ID.
+     */
+    hid_t GetDatatype();
+
+    /* GetDataset
+     * Returns the dataset identifier associated with the packet table, on
+     * success, or FAIL, on failure.
+     * Note: it is best to avoid using this identifier in applications, unless
+     * the desired functionality cannot be performed via the packet table ID.
+     */
+    hid_t GetDataset();
+
+    /* FreeBuff
+     * Frees the buffers created when variable-length packets are read.
+     * Takes the number of hvl_t structs to be freed and a pointer to their
+     * location in memory.
+     * Returns 0 on success, negative on error.
+     */
+    int FreeBuff(size_t numStructs, hvl_t * buffer);
+
+protected:
+    hid_t table_id;
+};
+
+class H5_HLCPPDLL FL_PacketTable : virtual public PacketTable
+{
+public:
+    /* Constructor
+     * Creates a packet table to store either fixed- or variable-length packets.
+     * Takes the ID of the file the packet table will be created in, the ID of
+     * the property list to specify compression, the name of the packet table,
+     * the ID of the datatype, and the size of a memory chunk used in chunking.
+     */
+    FL_PacketTable(hid_t fileID, const char* name, hid_t dtypeID, hsize_t chunkSize = 0, hid_t plistID = H5P_DEFAULT);
+
+    /* Constructors - deprecated
+     * Creates a packet table in which to store fixed length packets.
+     * Takes the ID of the file the packet table will be created in, the name of
+     * the packet table, the ID of the datatype of the set, the size
+     * of a memory chunk used in chunking, and the desired compression level
+     * (0-9, or -1 for no compression).
+     * Note: these overloaded constructors will be deprecated in favor of the
+     * constructor above.
+     */
+    FL_PacketTable(hid_t fileID, hid_t plist_id, const char* name, hid_t dtypeID, hsize_t chunkSize);
+    FL_PacketTable(hid_t fileID, char* name, hid_t dtypeID, hsize_t chunkSize, int compression = 0);
+
+    /* "Open" Constructor
+     * Opens an existing fixed-length packet table.
+     * Fails if the packet table specified is variable-length.
+     */
+    FL_PacketTable(hid_t fileID, const char* name);
+
+    /* "Open" Constructor - will be deprecated because of char* name */
+    FL_PacketTable(hid_t fileID, char* name);
+
+    /* Destructor
+     * Cleans up the packet table
+     */
+    virtual ~FL_PacketTable() {};
+
+    /* AppendPacket
+     * Adds a single packet to the packet table.  Takes a pointer
+     * to the location of the data in memory.
+     * Returns 0 on success, negative on failure
+     */
+    int AppendPacket(void * data);
+
+    /* AppendPackets (multiple packets)
+     * Adds multiple packets to the packet table.  Takes the number of packets
+     * to be added and a pointer to their location in memory.
+     * Returns 0 on success, -1 on failure.
+     */
+    int AppendPackets(size_t numPackets, void * data);
+
+    /* GetPacket (indexed)
+     * Gets a single packet from the packet table.  Takes the index
+     * of the packet (with 0 being the first packet) and a pointer
+     * to memory where the data should be stored.
+     * Returns 0 on success, negative on failure
+     */
+    int GetPacket(hsize_t index, void * data);
+
+    /* GetPackets (multiple packets)
+     * Gets multiple packets at once, all packets between
+     * startIndex and endIndex inclusive.  Also takes a pointer to
+     * the memory where these packets should be stored.
+     * Returns 0 on success, negative on failure.
+     */
+    int GetPackets(hsize_t startIndex, hsize_t endIndex, void * data);
+
+    /* GetNextPacket (single packet)
+     * Gets the next packet in the packet table.  Takes a pointer to
+     * memory where the packet should be stored.
+     * Returns 0 on success, negative on failure.  Index
+     * is not advanced to the next packet on failure.
+     */
+    int GetNextPacket(void * data);
+
+    /* GetNextPackets (multiple packets)
+     * Gets the next numPackets packets in the packet table.  Takes a
+     * pointer to memory where these packets should be stored.
+     * Returns 0 on success, negative on failure.  Index
+     * is not advanced on failure.
+     */
+    int GetNextPackets(size_t numPackets, void * data);
+};
+
+/* Removed "#ifdef VLPT_REMOVED" block.  03/08/2016, -BMR */
+
+#endif /* H5PTWRAP_H */
diff --git a/install/include/H5Ppkg.h b/install/include/H5Ppkg.h
new file mode 100644
index 0000000000..13463ae073
--- /dev/null
+++ b/install/include/H5Ppkg.h
@@ -0,0 +1,208 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:	Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *		Friday, November 16, 2001
+ *
+ * Purpose:	This file contains declarations which are visible only within
+ *		the H5P package.  Source files outside the H5P package should
+ *		include H5Pprivate.h instead.
+ */
+#if !(defined H5P_FRIEND || defined H5P_MODULE)
+#error "Do not include this file outside the H5P package!"
+#endif
+
+#ifndef _H5Ppkg_H
+#define _H5Ppkg_H
+
+/* Get package's private header */
+#include "H5Pprivate.h"
+
+/* Other private headers needed by this file */
+#include "H5SLprivate.h"	/* Skip lists				*/
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+/* Define enum for type of object that property is within */
+typedef enum {
+    H5P_PROP_WITHIN_UNKNOWN=0,  /* Property container is unknown */
+    H5P_PROP_WITHIN_LIST,       /* Property is within a list */
+    H5P_PROP_WITHIN_CLASS       /* Property is within a class */
+} H5P_prop_within_t;
+
+/* Define enum for modifications to class */
+typedef enum {
+    H5P_MOD_ERR=(-1),   /* Indicate an error */
+    H5P_MOD_INC_CLS,    /* Increment the dependant class count*/
+    H5P_MOD_DEC_CLS,    /* Decrement the dependant class count*/
+    H5P_MOD_INC_LST,    /* Increment the dependant list count*/
+    H5P_MOD_DEC_LST,    /* Decrement the dependant list count*/
+    H5P_MOD_INC_REF,    /* Increment the ID reference count*/
+    H5P_MOD_DEC_REF,    /* Decrement the ID reference count*/
+    H5P_MOD_MAX         /* Upper limit on class modifications */
+} H5P_class_mod_t;
+
+/* Define structure to hold property information */
+typedef struct H5P_genprop_t {
+    /* Values for this property */
+    char *name;         /* Name of property */
+    size_t size;        /* Size of property value */
+    void *value;        /* Pointer to property value */
+    H5P_prop_within_t type;     /* Type of object the property is within */
+    hbool_t shared_name;   /* Whether the name is shared or not */
+
+    /* Callback function pointers & info */
+    H5P_prp_create_func_t create;   /* Function to call when a property is created */
+    H5P_prp_set_func_t set; /* Function to call when a property value is set */
+    H5P_prp_get_func_t get; /* Function to call when a property value is retrieved */
+    H5P_prp_encode_func_t encode; /* Function to call when a property is encoded */
+    H5P_prp_decode_func_t decode; /* Function to call when a property is decoded */
+    H5P_prp_delete_func_t del; /* Function to call when a property is deleted */
+    H5P_prp_copy_func_t copy;  /* Function to call when a property is copied */
+    H5P_prp_compare_func_t cmp; /* Function to call when a property is compared */
+    H5P_prp_close_func_t close; /* Function to call when a property is closed */
+} H5P_genprop_t;
+
+/* Define structure to hold class information */
+struct H5P_genclass_t {
+    struct H5P_genclass_t *parent;     /* Pointer to parent class */
+    char      *name;       /* Name of property list class */
+    H5P_plist_type_t type; /* Type of property */
+    size_t     nprops;     /* Number of properties in class */
+    unsigned   plists;     /* Number of property lists that have been created since the last modification to the class */
+    unsigned   classes;    /* Number of classes that have been derived since the last modification to the class */
+    unsigned   ref_count;  /* Number of oustanding ID's open on this class object */
+    hbool_t    deleted;    /* Whether this class has been deleted and is waiting for dependent classes & proplists to close */
+    unsigned   revision;   /* Revision number of a particular class (global) */
+    H5SL_t    *props;      /* Skip list containing properties */
+
+    /* Callback function pointers & info */
+    H5P_cls_create_func_t create_func;  /* Function to call when a property list is created */
+    void *create_data;     /* Pointer to user data to pass along to create callback */
+    H5P_cls_copy_func_t copy_func;      /* Function to call when a property list is copied */
+    void *copy_data;       /* Pointer to user data to pass along to copy callback */
+    H5P_cls_close_func_t close_func;    /* Function to call when a property list is closed */
+    void *close_data;      /* Pointer to user data to pass along to close callback */
+};
+
+/* Define structure to hold property list information */
+struct H5P_genplist_t {
+    H5P_genclass_t *pclass; /* Pointer to class info */
+    hid_t   plist_id;   /* Copy of the property list ID (for use in close callback) */
+    size_t  nprops;     /* Number of properties in class */
+    hbool_t class_init; /* Whether the class initialization callback finished successfully */
+    H5SL_t *del;        /* Skip list containing names of deleted properties */
+    H5SL_t *props;      /* Skip list containing properties */
+};
+
+/* Property list/class iterator callback function pointer */
+typedef int (*H5P_iterate_int_t)(H5P_genprop_t *prop, void *udata);
+
+/* Forward declarations (for prototypes & struct definitions) */
+struct H5Z_filter_info_t;
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+/* Private functions, not part of the publicly documented API */
+H5_DLL H5P_genclass_t *H5P_create_class(H5P_genclass_t *par_class,
+    const char *name, H5P_plist_type_t type,
+    H5P_cls_create_func_t cls_create, void *create_data,
+    H5P_cls_copy_func_t cls_copy, void *copy_data,
+    H5P_cls_close_func_t cls_close, void *close_data);
+H5_DLL H5P_genclass_t *H5P_copy_pclass(H5P_genclass_t *pclass);
+H5_DLL herr_t H5P_register_real(H5P_genclass_t *pclass, const char *name, size_t size,
+    const void *def_value, H5P_prp_create_func_t prp_create,
+    H5P_prp_set_func_t prp_set, H5P_prp_get_func_t prp_get,
+    H5P_prp_encode_func_t prp_encode, H5P_prp_decode_func_t prp_decode,
+    H5P_prp_delete_func_t prp_delete,
+    H5P_prp_copy_func_t prp_copy, H5P_prp_compare_func_t prp_cmp,
+    H5P_prp_close_func_t prp_close);
+H5_DLL herr_t H5P_register(H5P_genclass_t **pclass, const char *name, size_t size,
+    const void *def_value, H5P_prp_create_func_t prp_create,
+    H5P_prp_set_func_t prp_set, H5P_prp_get_func_t prp_get,
+    H5P_prp_encode_func_t prp_encode, H5P_prp_decode_func_t prp_decode,
+    H5P_prp_delete_func_t prp_delete,
+    H5P_prp_copy_func_t prp_copy, H5P_prp_compare_func_t prp_cmp,
+    H5P_prp_close_func_t prp_close);
+H5_DLL herr_t H5P_add_prop(H5SL_t *props, H5P_genprop_t *prop);
+H5_DLL herr_t H5P_access_class(H5P_genclass_t *pclass, H5P_class_mod_t mod);
+H5_DLL htri_t H5P_exist_pclass(H5P_genclass_t *pclass, const char *name);
+H5_DLL herr_t H5P_get_size_plist(const H5P_genplist_t *plist, const char *name,
+    size_t *size);
+H5_DLL herr_t H5P_get_size_pclass(H5P_genclass_t *pclass, const char *name,
+    size_t *size);
+H5_DLL herr_t H5P_get_nprops_plist(const H5P_genplist_t *plist, size_t *nprops);
+H5_DLL int H5P_cmp_class(const H5P_genclass_t *pclass1, const H5P_genclass_t *pclass2);
+H5_DLL herr_t H5P_cmp_plist(const H5P_genplist_t *plist1, const H5P_genplist_t *plist2,
+    int *cmp_ret);
+H5_DLL int H5P_iterate_plist(const H5P_genplist_t *plist, hbool_t iter_all_prop,
+    int *idx, H5P_iterate_int_t iter_func, void *iter_data);
+H5_DLL int H5P_iterate_pclass(const H5P_genclass_t *pclass, int *idx,
+    H5P_iterate_int_t iter_func, void *iter_data);
+H5_DLL herr_t H5P_copy_prop_plist(hid_t dst_id, hid_t src_id, const char *name);
+H5_DLL herr_t H5P_copy_prop_pclass(hid_t dst_id, hid_t src_id, const char *name);
+H5_DLL herr_t H5P_unregister(H5P_genclass_t *pclass, const char *name);
+H5_DLL char *H5P_get_class_path(H5P_genclass_t *pclass);
+H5_DLL H5P_genclass_t *H5P_open_class_path(const char *path);
+H5_DLL H5P_genclass_t *H5P_get_class_parent(const H5P_genclass_t *pclass);
+H5_DLL herr_t H5P_close_class(void *_pclass);
+H5_DLL H5P_genprop_t *H5P__find_prop_plist(const H5P_genplist_t *plist, const char *name);
+H5_DLL hid_t H5P__new_plist_of_type(H5P_plist_type_t type);
+
+/* Encode/decode routines */
+H5_DLL herr_t H5P__encode(const H5P_genplist_t *plist, hbool_t enc_all_prop,
+    void *buf, size_t *nalloc);
+H5_DLL hid_t H5P__decode(const void *buf);
+H5_DLL herr_t H5P__encode_hsize_t(const void *value, void **_pp, size_t *size);
+H5_DLL herr_t H5P__encode_size_t(const void *value, void **_pp, size_t *size);
+H5_DLL herr_t H5P__encode_unsigned(const void *value, void **_pp, size_t *size);
+H5_DLL herr_t H5P__encode_uint8_t(const void *value, void **_pp, size_t *size);
+H5_DLL herr_t H5P__encode_hbool_t(const void *value, void **_pp, size_t *size);
+H5_DLL herr_t H5P__encode_double(const void *value, void **_pp, size_t *size);
+H5_DLL herr_t H5P__decode_hsize_t(const void **_pp, void *value);
+H5_DLL herr_t H5P__decode_size_t(const void **_pp, void *value);
+H5_DLL herr_t H5P__decode_unsigned(const void **_pp, void *value);
+H5_DLL herr_t H5P__decode_uint8_t(const void **_pp, void *value);
+H5_DLL herr_t H5P__decode_hbool_t(const void **_pp, void *value);
+H5_DLL herr_t H5P__decode_double(const void **_pp, void *value);
+H5_DLL herr_t H5P__encode_coll_md_read_flag_t(const void *value, void **_pp, size_t *size);
+H5_DLL herr_t H5P__decode_coll_md_read_flag_t(const void **_pp, void *value);
+
+/* Private OCPL routines */
+H5_DLL herr_t H5P_get_filter(const struct H5Z_filter_info_t *filter,
+    unsigned int *flags, size_t *cd_nelmts, unsigned cd_values[],
+    size_t namelen, char name[], unsigned *filter_config);
+
+/* Testing functions */
+#ifdef H5P_TESTING
+H5_DLL char *H5P_get_class_path_test(hid_t pclass_id);
+H5_DLL hid_t H5P_open_class_path_test(const char *path);
+#endif /* H5P_TESTING */
+
+#endif /* _H5Ppkg_H */
+
diff --git a/install/include/H5Ppublic.h b/install/include/H5Ppublic.h
new file mode 100644
index 0000000000..55b3877c54
--- /dev/null
+++ b/install/include/H5Ppublic.h
@@ -0,0 +1,547 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains function prototypes for each exported function in the
+ * H5P module.
+ */
+#ifndef _H5Ppublic_H
+#define _H5Ppublic_H
+
+/* System headers needed by this file */
+
+/* Public headers needed by this file */
+#include "H5public.h"
+#include "H5ACpublic.h"
+#include "H5Dpublic.h"
+#include "H5Fpublic.h"
+#include "H5FDpublic.h"
+#include "H5Ipublic.h"
+#include "H5Lpublic.h"
+#include "H5Opublic.h"
+#include "H5MMpublic.h"
+#include "H5Tpublic.h"
+#include "H5Zpublic.h"
+
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* When this header is included from a private HDF5 header, don't make calls to H5open() */
+#undef H5OPEN
+#ifndef _H5private_H
+#define H5OPEN        H5open(),
+#else   /* _H5private_H */
+#define H5OPEN
+#endif  /* _H5private_H */
+
+/*
+ * The library's property list classes
+ */
+
+#define H5P_ROOT		   	(H5OPEN H5P_CLS_ROOT_ID_g)
+#define H5P_OBJECT_CREATE 		(H5OPEN H5P_CLS_OBJECT_CREATE_ID_g)
+#define H5P_FILE_CREATE 		(H5OPEN H5P_CLS_FILE_CREATE_ID_g)
+#define H5P_FILE_ACCESS 		(H5OPEN H5P_CLS_FILE_ACCESS_ID_g)
+#define H5P_DATASET_CREATE     		(H5OPEN H5P_CLS_DATASET_CREATE_ID_g)
+#define H5P_DATASET_ACCESS     		(H5OPEN H5P_CLS_DATASET_ACCESS_ID_g)
+#define H5P_DATASET_XFER       		(H5OPEN H5P_CLS_DATASET_XFER_ID_g)
+#define H5P_FILE_MOUNT       		(H5OPEN H5P_CLS_FILE_MOUNT_ID_g)
+#define H5P_GROUP_CREATE 		(H5OPEN H5P_CLS_GROUP_CREATE_ID_g)
+#define H5P_GROUP_ACCESS 		(H5OPEN H5P_CLS_GROUP_ACCESS_ID_g)
+#define H5P_DATATYPE_CREATE 		(H5OPEN H5P_CLS_DATATYPE_CREATE_ID_g)
+#define H5P_DATATYPE_ACCESS 		(H5OPEN H5P_CLS_DATATYPE_ACCESS_ID_g)
+#define H5P_STRING_CREATE 		(H5OPEN H5P_CLS_STRING_CREATE_ID_g)
+#define H5P_ATTRIBUTE_CREATE 		(H5OPEN H5P_CLS_ATTRIBUTE_CREATE_ID_g)
+#define H5P_ATTRIBUTE_ACCESS 		(H5OPEN H5P_CLS_ATTRIBUTE_ACCESS_ID_g)
+#define H5P_OBJECT_COPY	 		(H5OPEN H5P_CLS_OBJECT_COPY_ID_g)
+#define H5P_LINK_CREATE 		(H5OPEN H5P_CLS_LINK_CREATE_ID_g)
+#define H5P_LINK_ACCESS 		(H5OPEN H5P_CLS_LINK_ACCESS_ID_g)
+
+/*
+ * The library's default property lists
+ */
+#define H5P_FILE_CREATE_DEFAULT		(H5OPEN H5P_LST_FILE_CREATE_ID_g)
+#define H5P_FILE_ACCESS_DEFAULT 	(H5OPEN H5P_LST_FILE_ACCESS_ID_g)
+#define H5P_DATASET_CREATE_DEFAULT  	(H5OPEN H5P_LST_DATASET_CREATE_ID_g)
+#define H5P_DATASET_ACCESS_DEFAULT  	(H5OPEN H5P_LST_DATASET_ACCESS_ID_g)
+#define H5P_DATASET_XFER_DEFAULT   	(H5OPEN H5P_LST_DATASET_XFER_ID_g)
+#define H5P_FILE_MOUNT_DEFAULT       	(H5OPEN H5P_LST_FILE_MOUNT_ID_g)
+#define H5P_GROUP_CREATE_DEFAULT	(H5OPEN H5P_LST_GROUP_CREATE_ID_g)
+#define H5P_GROUP_ACCESS_DEFAULT 	(H5OPEN H5P_LST_GROUP_ACCESS_ID_g)
+#define H5P_DATATYPE_CREATE_DEFAULT	(H5OPEN H5P_LST_DATATYPE_CREATE_ID_g)
+#define H5P_DATATYPE_ACCESS_DEFAULT 	(H5OPEN H5P_LST_DATATYPE_ACCESS_ID_g)
+#define H5P_ATTRIBUTE_CREATE_DEFAULT	(H5OPEN H5P_LST_ATTRIBUTE_CREATE_ID_g)
+#define H5P_ATTRIBUTE_ACCESS_DEFAULT	(H5OPEN H5P_LST_ATTRIBUTE_ACCESS_ID_g)
+#define H5P_OBJECT_COPY_DEFAULT		(H5OPEN H5P_LST_OBJECT_COPY_ID_g)
+#define H5P_LINK_CREATE_DEFAULT		(H5OPEN H5P_LST_LINK_CREATE_ID_g)
+#define H5P_LINK_ACCESS_DEFAULT		(H5OPEN H5P_LST_LINK_ACCESS_ID_g)
+
+/* Common creation order flags (for links in groups and attributes on objects) */
+#define H5P_CRT_ORDER_TRACKED           0x0001
+#define H5P_CRT_ORDER_INDEXED           0x0002
+
+/* Default value for all property list classes */
+#define H5P_DEFAULT     (hid_t)0
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+
+/* Define property list class callback function pointer types */
+typedef herr_t (*H5P_cls_create_func_t)(hid_t prop_id, void *create_data);
+typedef herr_t (*H5P_cls_copy_func_t)(hid_t new_prop_id, hid_t old_prop_id,
+                                      void *copy_data);
+typedef herr_t (*H5P_cls_close_func_t)(hid_t prop_id, void *close_data);
+
+/* Define property list callback function pointer types */
+typedef herr_t (*H5P_prp_cb1_t)(const char *name, size_t size, void *value);
+typedef herr_t (*H5P_prp_cb2_t)(hid_t prop_id, const char *name, size_t size, void *value);
+typedef H5P_prp_cb1_t H5P_prp_create_func_t;
+typedef H5P_prp_cb2_t H5P_prp_set_func_t;
+typedef H5P_prp_cb2_t H5P_prp_get_func_t;
+typedef herr_t (*H5P_prp_encode_func_t)(const void *value, void **buf, size_t *size);
+typedef herr_t (*H5P_prp_decode_func_t)(const void **buf, void *value);
+typedef H5P_prp_cb2_t H5P_prp_delete_func_t;
+typedef H5P_prp_cb1_t H5P_prp_copy_func_t;
+typedef int (*H5P_prp_compare_func_t)(const void *value1, const void *value2, size_t size);
+typedef H5P_prp_cb1_t H5P_prp_close_func_t;
+
+/* Define property list iteration function type */
+typedef herr_t (*H5P_iterate_t)(hid_t id, const char *name, void *iter_data);
+
+/* Actual IO mode property */
+typedef enum H5D_mpio_actual_chunk_opt_mode_t {
+    /* The default value, H5D_MPIO_NO_CHUNK_OPTIMIZATION, is used for all I/O
+     * operations that do not use chunk optimizations, including non-collective
+     * I/O and contiguous collective I/O.
+     */
+    H5D_MPIO_NO_CHUNK_OPTIMIZATION = 0,
+    H5D_MPIO_LINK_CHUNK,
+    H5D_MPIO_MULTI_CHUNK
+}  H5D_mpio_actual_chunk_opt_mode_t;
+
+typedef enum H5D_mpio_actual_io_mode_t {
+    /* The following four values are conveniently defined as a bit field so that
+     * we can switch from the default to indpendent or collective and then to
+     * mixed without having to check the original value. 
+     * 
+     * NO_COLLECTIVE means that either collective I/O wasn't requested or that 
+     * no I/O took place.
+     *
+     * CHUNK_INDEPENDENT means that collective I/O was requested, but the
+     * chunk optimization scheme chose independent I/O for each chunk.
+     */
+    H5D_MPIO_NO_COLLECTIVE = 0x0,
+    H5D_MPIO_CHUNK_INDEPENDENT = 0x1,
+    H5D_MPIO_CHUNK_COLLECTIVE = 0x2,
+    H5D_MPIO_CHUNK_MIXED = 0x1 | 0x2,
+
+    /* The contiguous case is separate from the bit field. */
+    H5D_MPIO_CONTIGUOUS_COLLECTIVE = 0x4
+} H5D_mpio_actual_io_mode_t; 
+
+/* Broken collective IO property */
+typedef enum H5D_mpio_no_collective_cause_t {
+    H5D_MPIO_COLLECTIVE = 0x00,
+    H5D_MPIO_SET_INDEPENDENT = 0x01,
+    H5D_MPIO_DATATYPE_CONVERSION = 0x02,
+    H5D_MPIO_DATA_TRANSFORMS = 0x04,
+    H5D_MPIO_MPI_OPT_TYPES_ENV_VAR_DISABLED = 0x08,
+    H5D_MPIO_NOT_SIMPLE_OR_SCALAR_DATASPACES = 0x10,
+    H5D_MPIO_NOT_CONTIGUOUS_OR_CHUNKED_DATASET = 0x20,
+    H5D_MPIO_FILTERS = 0x40
+} H5D_mpio_no_collective_cause_t;
+
+/********************/
+/* Public Variables */
+/********************/
+
+/* Property list class IDs */
+/* (Internal to library, do not use!  Use macros above) */
+H5_DLLVAR hid_t H5P_CLS_ROOT_ID_g;
+H5_DLLVAR hid_t H5P_CLS_OBJECT_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_FILE_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_FILE_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_CLS_DATASET_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_DATASET_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_CLS_DATASET_XFER_ID_g;
+H5_DLLVAR hid_t H5P_CLS_FILE_MOUNT_ID_g;
+H5_DLLVAR hid_t H5P_CLS_GROUP_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_GROUP_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_CLS_DATATYPE_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_DATATYPE_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_CLS_STRING_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_ATTRIBUTE_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_ATTRIBUTE_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_CLS_OBJECT_COPY_ID_g;
+H5_DLLVAR hid_t H5P_CLS_LINK_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_LINK_ACCESS_ID_g;
+
+/* Default roperty list IDs */
+/* (Internal to library, do not use!  Use macros above) */
+H5_DLLVAR hid_t H5P_LST_FILE_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_LST_FILE_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_LST_DATASET_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_LST_DATASET_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_LST_DATASET_XFER_ID_g;
+H5_DLLVAR hid_t H5P_LST_FILE_MOUNT_ID_g;
+H5_DLLVAR hid_t H5P_LST_GROUP_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_LST_GROUP_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_LST_DATATYPE_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_LST_DATATYPE_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_LST_ATTRIBUTE_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_LST_ATTRIBUTE_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_LST_OBJECT_COPY_ID_g;
+H5_DLLVAR hid_t H5P_LST_LINK_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_LST_LINK_ACCESS_ID_g;
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+/* Generic property list routines */
+H5_DLL hid_t H5Pcreate_class(hid_t parent, const char *name,
+    H5P_cls_create_func_t cls_create, void *create_data,
+    H5P_cls_copy_func_t cls_copy, void *copy_data,
+    H5P_cls_close_func_t cls_close, void *close_data);
+H5_DLL char *H5Pget_class_name(hid_t pclass_id);
+H5_DLL hid_t H5Pcreate(hid_t cls_id);
+H5_DLL herr_t H5Pregister2(hid_t cls_id, const char *name, size_t size,
+    void *def_value, H5P_prp_create_func_t prp_create,
+    H5P_prp_set_func_t prp_set, H5P_prp_get_func_t prp_get,
+    H5P_prp_delete_func_t prp_del, H5P_prp_copy_func_t prp_copy,
+    H5P_prp_compare_func_t prp_cmp, H5P_prp_close_func_t prp_close);
+H5_DLL herr_t H5Pinsert2(hid_t plist_id, const char *name, size_t size,
+    void *value, H5P_prp_set_func_t prp_set, H5P_prp_get_func_t prp_get,
+    H5P_prp_delete_func_t prp_delete, H5P_prp_copy_func_t prp_copy,
+    H5P_prp_compare_func_t prp_cmp, H5P_prp_close_func_t prp_close);
+H5_DLL herr_t H5Pset(hid_t plist_id, const char *name, const void *value);
+H5_DLL htri_t H5Pexist(hid_t plist_id, const char *name);
+H5_DLL herr_t H5Pencode(hid_t plist_id, void *buf, size_t *nalloc);
+H5_DLL hid_t  H5Pdecode(const void *buf);
+H5_DLL herr_t H5Pget_size(hid_t id, const char *name, size_t *size);
+H5_DLL herr_t H5Pget_nprops(hid_t id, size_t *nprops);
+H5_DLL hid_t H5Pget_class(hid_t plist_id);
+H5_DLL hid_t H5Pget_class_parent(hid_t pclass_id);
+H5_DLL herr_t H5Pget(hid_t plist_id, const char *name, void * value);
+H5_DLL htri_t H5Pequal(hid_t id1, hid_t id2);
+H5_DLL htri_t H5Pisa_class(hid_t plist_id, hid_t pclass_id);
+H5_DLL int H5Piterate(hid_t id, int *idx, H5P_iterate_t iter_func,
+            void *iter_data);
+H5_DLL herr_t H5Pcopy_prop(hid_t dst_id, hid_t src_id, const char *name);
+H5_DLL herr_t H5Premove(hid_t plist_id, const char *name);
+H5_DLL herr_t H5Punregister(hid_t pclass_id, const char *name);
+H5_DLL herr_t H5Pclose_class(hid_t plist_id);
+H5_DLL herr_t H5Pclose(hid_t plist_id);
+H5_DLL hid_t H5Pcopy(hid_t plist_id);
+
+/* Object creation property list (OCPL) routines */
+H5_DLL herr_t H5Pset_attr_phase_change(hid_t plist_id, unsigned max_compact, unsigned min_dense);
+H5_DLL herr_t H5Pget_attr_phase_change(hid_t plist_id, unsigned *max_compact, unsigned *min_dense);
+H5_DLL herr_t H5Pset_attr_creation_order(hid_t plist_id, unsigned crt_order_flags);
+H5_DLL herr_t H5Pget_attr_creation_order(hid_t plist_id, unsigned *crt_order_flags);
+H5_DLL herr_t H5Pset_obj_track_times(hid_t plist_id, hbool_t track_times);
+H5_DLL herr_t H5Pget_obj_track_times(hid_t plist_id, hbool_t *track_times);
+H5_DLL herr_t H5Pmodify_filter(hid_t plist_id, H5Z_filter_t filter,
+        unsigned int flags, size_t cd_nelmts,
+        const unsigned int cd_values[/*cd_nelmts*/]);
+H5_DLL herr_t H5Pset_filter(hid_t plist_id, H5Z_filter_t filter,
+        unsigned int flags, size_t cd_nelmts,
+        const unsigned int c_values[]);
+H5_DLL int H5Pget_nfilters(hid_t plist_id);
+H5_DLL H5Z_filter_t H5Pget_filter2(hid_t plist_id, unsigned filter,
+       unsigned int *flags/*out*/,
+       size_t *cd_nelmts/*out*/,
+       unsigned cd_values[]/*out*/,
+       size_t namelen, char name[],
+       unsigned *filter_config /*out*/);
+H5_DLL herr_t H5Pget_filter_by_id2(hid_t plist_id, H5Z_filter_t id,
+       unsigned int *flags/*out*/, size_t *cd_nelmts/*out*/,
+       unsigned cd_values[]/*out*/, size_t namelen, char name[]/*out*/,
+       unsigned *filter_config/*out*/);
+H5_DLL htri_t H5Pall_filters_avail(hid_t plist_id);
+H5_DLL herr_t H5Premove_filter(hid_t plist_id, H5Z_filter_t filter);
+H5_DLL herr_t H5Pset_deflate(hid_t plist_id, unsigned aggression);
+H5_DLL herr_t H5Pset_fletcher32(hid_t plist_id);
+
+/* File creation property list (FCPL) routines */
+H5_DLL herr_t H5Pset_userblock(hid_t plist_id, hsize_t size);
+H5_DLL herr_t H5Pget_userblock(hid_t plist_id, hsize_t *size);
+H5_DLL herr_t H5Pset_sizes(hid_t plist_id, size_t sizeof_addr,
+       size_t sizeof_size);
+H5_DLL herr_t H5Pget_sizes(hid_t plist_id, size_t *sizeof_addr/*out*/,
+       size_t *sizeof_size/*out*/);
+H5_DLL herr_t H5Pset_sym_k(hid_t plist_id, unsigned ik, unsigned lk);
+H5_DLL herr_t H5Pget_sym_k(hid_t plist_id, unsigned *ik/*out*/, unsigned *lk/*out*/);
+H5_DLL herr_t H5Pset_istore_k(hid_t plist_id, unsigned ik);
+H5_DLL herr_t H5Pget_istore_k(hid_t plist_id, unsigned *ik/*out*/);
+H5_DLL herr_t H5Pset_shared_mesg_nindexes(hid_t plist_id, unsigned nindexes);
+H5_DLL herr_t H5Pget_shared_mesg_nindexes(hid_t plist_id, unsigned *nindexes);
+H5_DLL herr_t H5Pset_shared_mesg_index(hid_t plist_id, unsigned index_num, unsigned mesg_type_flags, unsigned min_mesg_size);
+H5_DLL herr_t H5Pget_shared_mesg_index(hid_t plist_id, unsigned index_num, unsigned *mesg_type_flags, unsigned *min_mesg_size);
+H5_DLL herr_t H5Pset_shared_mesg_phase_change(hid_t plist_id, unsigned max_list, unsigned min_btree);
+H5_DLL herr_t H5Pget_shared_mesg_phase_change(hid_t plist_id, unsigned *max_list, unsigned *min_btree);
+H5_DLL herr_t H5Pset_file_space_strategy(hid_t plist_id, H5F_fspace_strategy_t strategy, hbool_t persist, hsize_t threshold);
+H5_DLL herr_t H5Pget_file_space_strategy(hid_t plist_id, H5F_fspace_strategy_t *strategy, hbool_t *persist, hsize_t *threshold);
+H5_DLL herr_t H5Pset_file_space_page_size(hid_t plist_id, hsize_t fsp_size);
+H5_DLL herr_t H5Pget_file_space_page_size(hid_t plist_id, hsize_t *fsp_size);
+
+/* File access property list (FAPL) routines */
+H5_DLL herr_t H5Pset_alignment(hid_t fapl_id, hsize_t threshold,
+    hsize_t alignment);
+H5_DLL herr_t H5Pget_alignment(hid_t fapl_id, hsize_t *threshold/*out*/,
+    hsize_t *alignment/*out*/);
+H5_DLL herr_t H5Pset_driver(hid_t plist_id, hid_t driver_id,
+        const void *driver_info);
+H5_DLL hid_t H5Pget_driver(hid_t plist_id);
+H5_DLL const void *H5Pget_driver_info(hid_t plist_id);
+H5_DLL herr_t H5Pset_family_offset(hid_t fapl_id, hsize_t offset);
+H5_DLL herr_t H5Pget_family_offset(hid_t fapl_id, hsize_t *offset);
+H5_DLL herr_t H5Pset_multi_type(hid_t fapl_id, H5FD_mem_t type);
+H5_DLL herr_t H5Pget_multi_type(hid_t fapl_id, H5FD_mem_t *type);
+H5_DLL herr_t H5Pset_cache(hid_t plist_id, int mdc_nelmts,
+       size_t rdcc_nslots, size_t rdcc_nbytes,
+       double rdcc_w0);
+H5_DLL herr_t H5Pget_cache(hid_t plist_id,
+       int *mdc_nelmts, /* out */
+       size_t *rdcc_nslots/*out*/,
+       size_t *rdcc_nbytes/*out*/, double *rdcc_w0);
+H5_DLL herr_t H5Pset_mdc_config(hid_t    plist_id,
+       H5AC_cache_config_t * config_ptr);
+H5_DLL herr_t H5Pget_mdc_config(hid_t     plist_id,
+       H5AC_cache_config_t * config_ptr);	/* out */
+H5_DLL herr_t H5Pset_gc_references(hid_t fapl_id, unsigned gc_ref);
+H5_DLL herr_t H5Pget_gc_references(hid_t fapl_id, unsigned *gc_ref/*out*/);
+H5_DLL herr_t H5Pset_fclose_degree(hid_t fapl_id, H5F_close_degree_t degree);
+H5_DLL herr_t H5Pget_fclose_degree(hid_t fapl_id, H5F_close_degree_t *degree);
+H5_DLL herr_t H5Pset_meta_block_size(hid_t fapl_id, hsize_t size);
+H5_DLL herr_t H5Pget_meta_block_size(hid_t fapl_id, hsize_t *size/*out*/);
+H5_DLL herr_t H5Pset_sieve_buf_size(hid_t fapl_id, size_t size);
+H5_DLL herr_t H5Pget_sieve_buf_size(hid_t fapl_id, size_t *size/*out*/);
+H5_DLL herr_t H5Pset_small_data_block_size(hid_t fapl_id, hsize_t size);
+H5_DLL herr_t H5Pget_small_data_block_size(hid_t fapl_id, hsize_t *size/*out*/);
+H5_DLL herr_t H5Pset_libver_bounds(hid_t plist_id, H5F_libver_t low,
+    H5F_libver_t high);
+H5_DLL herr_t H5Pget_libver_bounds(hid_t plist_id, H5F_libver_t *low,
+    H5F_libver_t *high);
+H5_DLL herr_t H5Pset_elink_file_cache_size(hid_t plist_id, unsigned efc_size);
+H5_DLL herr_t H5Pget_elink_file_cache_size(hid_t plist_id, unsigned *efc_size);
+H5_DLL herr_t H5Pset_file_image(hid_t fapl_id, void *buf_ptr, size_t buf_len);
+H5_DLL herr_t H5Pget_file_image(hid_t fapl_id, void **buf_ptr_ptr, size_t *buf_len_ptr);
+H5_DLL herr_t H5Pset_file_image_callbacks(hid_t fapl_id,
+       H5FD_file_image_callbacks_t *callbacks_ptr);
+H5_DLL herr_t H5Pget_file_image_callbacks(hid_t fapl_id,
+       H5FD_file_image_callbacks_t *callbacks_ptr);
+H5_DLL herr_t H5Pset_core_write_tracking(hid_t fapl_id, hbool_t is_enabled, size_t page_size);
+H5_DLL herr_t H5Pget_core_write_tracking(hid_t fapl_id, hbool_t *is_enabled, size_t *page_size);
+H5_DLL herr_t H5Pset_metadata_read_attempts(hid_t plist_id, unsigned attempts);
+H5_DLL herr_t H5Pget_metadata_read_attempts(hid_t plist_id, unsigned *attempts);
+H5_DLL herr_t H5Pset_object_flush_cb(hid_t plist_id, H5F_flush_cb_t func, void *udata);
+H5_DLL herr_t H5Pget_object_flush_cb(hid_t plist_id, H5F_flush_cb_t *func, void **udata);
+H5_DLL herr_t H5Pset_mdc_log_options(hid_t plist_id, hbool_t is_enabled, const char *location, hbool_t start_on_access);
+H5_DLL herr_t H5Pget_mdc_log_options(hid_t plist_id, hbool_t *is_enabled, char *location, size_t *location_size, hbool_t *start_on_access);
+H5_DLL herr_t H5Pset_evict_on_close(hid_t fapl_id, hbool_t evict_on_close);
+H5_DLL herr_t H5Pget_evict_on_close(hid_t fapl_id, hbool_t *evict_on_close);
+#ifdef H5_HAVE_PARALLEL
+H5_DLL herr_t H5Pset_all_coll_metadata_ops(hid_t plist_id, hbool_t is_collective);
+H5_DLL herr_t H5Pget_all_coll_metadata_ops(hid_t plist_id, hbool_t *is_collective);
+H5_DLL herr_t H5Pset_coll_metadata_write(hid_t plist_id, hbool_t is_collective);
+H5_DLL herr_t H5Pget_coll_metadata_write(hid_t plist_id, hbool_t *is_collective);
+#endif /* H5_HAVE_PARALLEL */
+H5_DLL herr_t H5Pset_mdc_image_config(hid_t plist_id, H5AC_cache_image_config_t *config_ptr);
+H5_DLL herr_t H5Pget_mdc_image_config(hid_t plist_id, H5AC_cache_image_config_t *config_ptr /*out*/);
+H5_DLL herr_t H5Pset_page_buffer_size(hid_t plist_id, size_t buf_size, unsigned min_meta_per, unsigned min_raw_per);
+H5_DLL herr_t H5Pget_page_buffer_size(hid_t plist_id, size_t *buf_size, unsigned *min_meta_per, unsigned *min_raw_per);
+
+/* Dataset creation property list (DCPL) routines */
+H5_DLL herr_t H5Pset_layout(hid_t plist_id, H5D_layout_t layout);
+H5_DLL H5D_layout_t H5Pget_layout(hid_t plist_id);
+H5_DLL herr_t H5Pset_chunk(hid_t plist_id, int ndims, const hsize_t dim[/*ndims*/]);
+H5_DLL int H5Pget_chunk(hid_t plist_id, int max_ndims, hsize_t dim[]/*out*/);
+H5_DLL herr_t H5Pset_virtual(hid_t dcpl_id, hid_t vspace_id,
+    const char *src_file_name, const char *src_dset_name, hid_t src_space_id);
+H5_DLL herr_t H5Pget_virtual_count(hid_t dcpl_id, size_t *count/*out*/);
+H5_DLL hid_t H5Pget_virtual_vspace(hid_t dcpl_id, size_t index);
+H5_DLL hid_t H5Pget_virtual_srcspace(hid_t dcpl_id, size_t index);
+H5_DLL ssize_t H5Pget_virtual_filename(hid_t dcpl_id, size_t index,
+    char *name/*out*/, size_t size);
+H5_DLL ssize_t H5Pget_virtual_dsetname(hid_t dcpl_id, size_t index,
+    char *name/*out*/, size_t size);
+H5_DLL herr_t H5Pset_external(hid_t plist_id, const char *name, off_t offset,
+          hsize_t size);
+H5_DLL herr_t H5Pset_chunk_opts(hid_t plist_id, unsigned opts);
+H5_DLL herr_t H5Pget_chunk_opts(hid_t plist_id, unsigned *opts);
+H5_DLL int H5Pget_external_count(hid_t plist_id);
+H5_DLL herr_t H5Pget_external(hid_t plist_id, unsigned idx, size_t name_size,
+          char *name/*out*/, off_t *offset/*out*/,
+          hsize_t *size/*out*/);
+H5_DLL herr_t H5Pset_szip(hid_t plist_id, unsigned options_mask, unsigned pixels_per_block);
+H5_DLL herr_t H5Pset_shuffle(hid_t plist_id);
+H5_DLL herr_t H5Pset_nbit(hid_t plist_id);
+H5_DLL herr_t H5Pset_scaleoffset(hid_t plist_id, H5Z_SO_scale_type_t scale_type, int scale_factor);
+H5_DLL herr_t H5Pset_fill_value(hid_t plist_id, hid_t type_id,
+     const void *value);
+H5_DLL herr_t H5Pget_fill_value(hid_t plist_id, hid_t type_id,
+     void *value/*out*/);
+H5_DLL herr_t H5Pfill_value_defined(hid_t plist, H5D_fill_value_t *status);
+H5_DLL herr_t H5Pset_alloc_time(hid_t plist_id, H5D_alloc_time_t
+	alloc_time);
+H5_DLL herr_t H5Pget_alloc_time(hid_t plist_id, H5D_alloc_time_t
+	*alloc_time/*out*/);
+H5_DLL herr_t H5Pset_fill_time(hid_t plist_id, H5D_fill_time_t fill_time);
+H5_DLL herr_t H5Pget_fill_time(hid_t plist_id, H5D_fill_time_t
+	*fill_time/*out*/);
+
+/* Dataset access property list (DAPL) routines */
+H5_DLL herr_t H5Pset_chunk_cache(hid_t dapl_id, size_t rdcc_nslots,
+       size_t rdcc_nbytes, double rdcc_w0);
+H5_DLL herr_t H5Pget_chunk_cache(hid_t dapl_id,
+       size_t *rdcc_nslots/*out*/,
+       size_t *rdcc_nbytes/*out*/,
+       double *rdcc_w0/*out*/);
+H5_DLL herr_t H5Pset_virtual_view(hid_t plist_id, H5D_vds_view_t view);
+H5_DLL herr_t H5Pget_virtual_view(hid_t plist_id, H5D_vds_view_t *view);
+H5_DLL herr_t H5Pset_virtual_printf_gap(hid_t plist_id, hsize_t gap_size);
+H5_DLL herr_t H5Pget_virtual_printf_gap(hid_t plist_id, hsize_t *gap_size);
+H5_DLL herr_t H5Pset_append_flush(hid_t plist_id, unsigned ndims,
+    const hsize_t boundary[], H5D_append_cb_t func, void *udata);
+H5_DLL herr_t H5Pget_append_flush(hid_t plist_id, unsigned dims,
+    hsize_t boundary[], H5D_append_cb_t *func, void **udata);
+H5_DLL herr_t H5Pset_efile_prefix(hid_t dapl_id, const char* prefix);
+H5_DLL ssize_t H5Pget_efile_prefix(hid_t dapl_id, char* prefix /*out*/, size_t size);
+
+/* Dataset xfer property list (DXPL) routines */
+H5_DLL herr_t H5Pset_data_transform(hid_t plist_id, const char* expression);
+H5_DLL ssize_t H5Pget_data_transform(hid_t plist_id, char* expression /*out*/, size_t size);
+H5_DLL herr_t H5Pset_buffer(hid_t plist_id, size_t size, void *tconv,
+        void *bkg);
+H5_DLL size_t H5Pget_buffer(hid_t plist_id, void **tconv/*out*/,
+        void **bkg/*out*/);
+H5_DLL herr_t H5Pset_preserve(hid_t plist_id, hbool_t status);
+H5_DLL int H5Pget_preserve(hid_t plist_id);
+H5_DLL herr_t H5Pset_edc_check(hid_t plist_id, H5Z_EDC_t check);
+H5_DLL H5Z_EDC_t H5Pget_edc_check(hid_t plist_id);
+H5_DLL herr_t H5Pset_filter_callback(hid_t plist_id, H5Z_filter_func_t func,
+                                     void* op_data);
+H5_DLL herr_t H5Pset_btree_ratios(hid_t plist_id, double left, double middle,
+       double right);
+H5_DLL herr_t H5Pget_btree_ratios(hid_t plist_id, double *left/*out*/,
+       double *middle/*out*/,
+       double *right/*out*/);
+H5_DLL herr_t H5Pset_vlen_mem_manager(hid_t plist_id,
+                                       H5MM_allocate_t alloc_func,
+                                       void *alloc_info, H5MM_free_t free_func,
+                                       void *free_info);
+H5_DLL herr_t H5Pget_vlen_mem_manager(hid_t plist_id,
+                                       H5MM_allocate_t *alloc_func,
+                                       void **alloc_info,
+                                       H5MM_free_t *free_func,
+                                       void **free_info);
+H5_DLL herr_t H5Pset_hyper_vector_size(hid_t fapl_id, size_t size);
+H5_DLL herr_t H5Pget_hyper_vector_size(hid_t fapl_id, size_t *size/*out*/);
+H5_DLL herr_t H5Pset_type_conv_cb(hid_t dxpl_id, H5T_conv_except_func_t op, void* operate_data);
+H5_DLL herr_t H5Pget_type_conv_cb(hid_t dxpl_id, H5T_conv_except_func_t *op, void** operate_data);
+#ifdef H5_HAVE_PARALLEL
+H5_DLL herr_t H5Pget_mpio_actual_chunk_opt_mode(hid_t plist_id, H5D_mpio_actual_chunk_opt_mode_t *actual_chunk_opt_mode);
+H5_DLL herr_t H5Pget_mpio_actual_io_mode(hid_t plist_id, H5D_mpio_actual_io_mode_t *actual_io_mode);
+H5_DLL herr_t H5Pget_mpio_no_collective_cause(hid_t plist_id, uint32_t *local_no_collective_cause, uint32_t *global_no_collective_cause);
+#endif /* H5_HAVE_PARALLEL */
+
+/* Link creation property list (LCPL) routines */
+H5_DLL herr_t H5Pset_create_intermediate_group(hid_t plist_id, unsigned crt_intmd);
+H5_DLL herr_t H5Pget_create_intermediate_group(hid_t plist_id, unsigned *crt_intmd /*out*/);
+
+/* Group creation property list (GCPL) routines */
+H5_DLL herr_t H5Pset_local_heap_size_hint(hid_t plist_id, size_t size_hint);
+H5_DLL herr_t H5Pget_local_heap_size_hint(hid_t plist_id, size_t *size_hint /*out*/);
+H5_DLL herr_t H5Pset_link_phase_change(hid_t plist_id, unsigned max_compact, unsigned min_dense);
+H5_DLL herr_t H5Pget_link_phase_change(hid_t plist_id, unsigned *max_compact /*out*/, unsigned *min_dense /*out*/);
+H5_DLL herr_t H5Pset_est_link_info(hid_t plist_id, unsigned est_num_entries, unsigned est_name_len);
+H5_DLL herr_t H5Pget_est_link_info(hid_t plist_id, unsigned *est_num_entries /* out */, unsigned *est_name_len /* out */);
+H5_DLL herr_t H5Pset_link_creation_order(hid_t plist_id, unsigned crt_order_flags);
+H5_DLL herr_t H5Pget_link_creation_order(hid_t plist_id, unsigned *crt_order_flags /* out */);
+
+/* String creation property list (STRCPL) routines */
+H5_DLL herr_t H5Pset_char_encoding(hid_t plist_id, H5T_cset_t encoding);
+H5_DLL herr_t H5Pget_char_encoding(hid_t plist_id, H5T_cset_t *encoding /*out*/);
+
+/* Link access property list (LAPL) routines */
+H5_DLL herr_t H5Pset_nlinks(hid_t plist_id, size_t nlinks);
+H5_DLL herr_t H5Pget_nlinks(hid_t plist_id, size_t *nlinks);
+H5_DLL herr_t H5Pset_elink_prefix(hid_t plist_id, const char *prefix);
+H5_DLL ssize_t H5Pget_elink_prefix(hid_t plist_id, char *prefix, size_t size);
+H5_DLL hid_t H5Pget_elink_fapl(hid_t lapl_id);
+H5_DLL herr_t H5Pset_elink_fapl(hid_t lapl_id, hid_t fapl_id);
+H5_DLL herr_t H5Pset_elink_acc_flags(hid_t lapl_id, unsigned flags);
+H5_DLL herr_t H5Pget_elink_acc_flags(hid_t lapl_id, unsigned *flags);
+H5_DLL herr_t H5Pset_elink_cb(hid_t lapl_id, H5L_elink_traverse_t func, void *op_data);
+H5_DLL herr_t H5Pget_elink_cb(hid_t lapl_id, H5L_elink_traverse_t *func, void **op_data);
+
+/* Object copy property list (OCPYPL) routines */
+H5_DLL herr_t H5Pset_copy_object(hid_t plist_id, unsigned crt_intmd);
+H5_DLL herr_t H5Pget_copy_object(hid_t plist_id, unsigned *crt_intmd /*out*/);
+H5_DLL herr_t H5Padd_merge_committed_dtype_path(hid_t plist_id, const char *path);
+H5_DLL herr_t H5Pfree_merge_committed_dtype_paths(hid_t plist_id);
+H5_DLL herr_t H5Pset_mcdt_search_cb(hid_t plist_id, H5O_mcdt_search_cb_t func, void *op_data);
+H5_DLL herr_t H5Pget_mcdt_search_cb(hid_t plist_id, H5O_mcdt_search_cb_t *func, void **op_data);
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+
+/* We renamed the "root" of the property list class hierarchy */
+#define H5P_NO_CLASS            H5P_ROOT
+
+
+/* Typedefs */
+
+
+/* Function prototypes */
+H5_DLL herr_t H5Pregister1(hid_t cls_id, const char *name, size_t size,
+    void *def_value, H5P_prp_create_func_t prp_create,
+    H5P_prp_set_func_t prp_set, H5P_prp_get_func_t prp_get,
+    H5P_prp_delete_func_t prp_del, H5P_prp_copy_func_t prp_copy,
+    H5P_prp_close_func_t prp_close);
+H5_DLL herr_t H5Pinsert1(hid_t plist_id, const char *name, size_t size,
+    void *value, H5P_prp_set_func_t prp_set, H5P_prp_get_func_t prp_get,
+    H5P_prp_delete_func_t prp_delete, H5P_prp_copy_func_t prp_copy,
+    H5P_prp_close_func_t prp_close);
+H5_DLL H5Z_filter_t H5Pget_filter1(hid_t plist_id, unsigned filter,
+    unsigned int *flags/*out*/, size_t *cd_nelmts/*out*/,
+    unsigned cd_values[]/*out*/, size_t namelen, char name[]);
+H5_DLL herr_t H5Pget_filter_by_id1(hid_t plist_id, H5Z_filter_t id,
+    unsigned int *flags/*out*/, size_t *cd_nelmts/*out*/,
+    unsigned cd_values[]/*out*/, size_t namelen, char name[]/*out*/);
+H5_DLL herr_t H5Pget_version(hid_t plist_id, unsigned *boot/*out*/,
+         unsigned *freelist/*out*/, unsigned *stab/*out*/,
+         unsigned *shhdr/*out*/);
+H5_DLL herr_t H5Pset_file_space(hid_t plist_id, H5F_file_space_type_t strategy, hsize_t threshold);
+H5_DLL herr_t H5Pget_file_space(hid_t plist_id, H5F_file_space_type_t *strategy, hsize_t *threshold);
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _H5Ppublic_H */
+
diff --git a/install/include/H5PredType.h b/install/include/H5PredType.h
new file mode 100644
index 0000000000..2ffc87fd56
--- /dev/null
+++ b/install/include/H5PredType.h
@@ -0,0 +1,442 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5PredType_H
+#define __H5PredType_H
+
+namespace H5 {
+
+/*! \class PredType
+    \brief Class PredType holds the definition of all the HDF5 predefined
+    datatypes.
+
+    These types can only be made copy of, not created by H5Tcreate or
+    closed by H5Tclose.  They are treated as constants.
+
+    Inheritance: AtomType -> DataType -> H5Object -> H5Location -> IdComponent
+*/
+class H5_DLLCPP PredType : public AtomType {
+   public:
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("PredType"); }
+
+        // Makes a copy of the predefined type and stores the new
+        // id in the left hand side object.
+        PredType& operator=(const PredType& rhs);
+
+        // Copy constructor - makes copy of the original object
+        PredType(const PredType& original);
+
+        // Noop destructor
+        virtual ~PredType();
+
+        /*! \brief This dummy function do not inherit from DataType - it will
+            throw a DataTypeIException if invoked.
+        */
+        void commit(H5Location& loc, const H5std_string& name);
+        /*! \brief This dummy function do not inherit from DataType - it will
+            throw a DataTypeIException if invoked.
+        */
+        void commit(H5Location& loc, const char* name);
+        /*! \brief This dummy function do not inherit from DataType - it will
+            throw a DataTypeIException if invoked.
+        */
+        bool committed();
+
+        ///\brief PredType constants
+        static const PredType& STD_I8BE;
+        static const PredType& STD_I8LE;
+        static const PredType& STD_I16BE;
+        static const PredType& STD_I16LE;
+        static const PredType& STD_I32BE;
+        static const PredType& STD_I32LE;
+        static const PredType& STD_I64BE;
+        static const PredType& STD_I64LE;
+        static const PredType& STD_U8BE;
+        static const PredType& STD_U8LE;
+        static const PredType& STD_U16BE;
+        static const PredType& STD_U16LE;
+        static const PredType& STD_U32BE;
+        static const PredType& STD_U32LE;
+        static const PredType& STD_U64BE;
+        static const PredType& STD_U64LE;
+        static const PredType& STD_B8BE;
+        static const PredType& STD_B8LE;
+        static const PredType& STD_B16BE;
+        static const PredType& STD_B16LE;
+        static const PredType& STD_B32BE;
+        static const PredType& STD_B32LE;
+        static const PredType& STD_B64BE;
+        static const PredType& STD_B64LE;
+        static const PredType& STD_REF_OBJ;
+        static const PredType& STD_REF_DSETREG;
+
+        static const PredType& C_S1;
+        static const PredType& FORTRAN_S1;
+
+        static const PredType& IEEE_F32BE;
+        static const PredType& IEEE_F32LE;
+        static const PredType& IEEE_F64BE;
+        static const PredType& IEEE_F64LE;
+
+        static const PredType& UNIX_D32BE;
+        static const PredType& UNIX_D32LE;
+        static const PredType& UNIX_D64BE;
+        static const PredType& UNIX_D64LE;
+
+        static const PredType& INTEL_I8;
+        static const PredType& INTEL_I16;
+        static const PredType& INTEL_I32;
+        static const PredType& INTEL_I64;
+        static const PredType& INTEL_U8;
+        static const PredType& INTEL_U16;
+        static const PredType& INTEL_U32;
+        static const PredType& INTEL_U64;
+        static const PredType& INTEL_B8;
+        static const PredType& INTEL_B16;
+        static const PredType& INTEL_B32;
+        static const PredType& INTEL_B64;
+        static const PredType& INTEL_F32;
+        static const PredType& INTEL_F64;
+
+        static const PredType& ALPHA_I8;
+        static const PredType& ALPHA_I16;
+        static const PredType& ALPHA_I32;
+        static const PredType& ALPHA_I64;
+        static const PredType& ALPHA_U8;
+        static const PredType& ALPHA_U16;
+        static const PredType& ALPHA_U32;
+        static const PredType& ALPHA_U64;
+        static const PredType& ALPHA_B8;
+        static const PredType& ALPHA_B16;
+        static const PredType& ALPHA_B32;
+        static const PredType& ALPHA_B64;
+        static const PredType& ALPHA_F32;
+        static const PredType& ALPHA_F64;
+
+        static const PredType& MIPS_I8;
+        static const PredType& MIPS_I16;
+        static const PredType& MIPS_I32;
+        static const PredType& MIPS_I64;
+        static const PredType& MIPS_U8;
+        static const PredType& MIPS_U16;
+        static const PredType& MIPS_U32;
+        static const PredType& MIPS_U64;
+        static const PredType& MIPS_B8;
+        static const PredType& MIPS_B16;
+        static const PredType& MIPS_B32;
+        static const PredType& MIPS_B64;
+        static const PredType& MIPS_F32;
+        static const PredType& MIPS_F64;
+
+        static const PredType& NATIVE_CHAR;
+        static const PredType& NATIVE_SCHAR;
+        static const PredType& NATIVE_UCHAR;
+        static const PredType& NATIVE_SHORT;
+        static const PredType& NATIVE_USHORT;
+        static const PredType& NATIVE_INT;
+        static const PredType& NATIVE_UINT;
+        static const PredType& NATIVE_LONG;
+        static const PredType& NATIVE_ULONG;
+        static const PredType& NATIVE_LLONG;
+        static const PredType& NATIVE_ULLONG;
+        static const PredType& NATIVE_FLOAT;
+        static const PredType& NATIVE_DOUBLE;
+        static const PredType& NATIVE_LDOUBLE;
+        static const PredType& NATIVE_B8;
+        static const PredType& NATIVE_B16;
+        static const PredType& NATIVE_B32;
+        static const PredType& NATIVE_B64;
+        static const PredType& NATIVE_OPAQUE;
+        static const PredType& NATIVE_HSIZE;
+        static const PredType& NATIVE_HSSIZE;
+        static const PredType& NATIVE_HERR;
+        static const PredType& NATIVE_HBOOL;
+
+        static const PredType& NATIVE_INT8;
+        static const PredType& NATIVE_UINT8;
+        static const PredType& NATIVE_INT16;
+        static const PredType& NATIVE_UINT16;
+        static const PredType& NATIVE_INT32;
+        static const PredType& NATIVE_UINT32;
+        static const PredType& NATIVE_INT64;
+        static const PredType& NATIVE_UINT64;
+
+// LEAST types
+#if H5_SIZEOF_INT_LEAST8_T != 0
+        static const PredType& NATIVE_INT_LEAST8;
+#endif /* H5_SIZEOF_INT_LEAST8_T */
+#if H5_SIZEOF_UINT_LEAST8_T != 0
+        static const PredType& NATIVE_UINT_LEAST8;
+#endif /* H5_SIZEOF_UINT_LEAST8_T */
+
+#if H5_SIZEOF_INT_LEAST16_T != 0
+        static const PredType& NATIVE_INT_LEAST16;
+#endif /* H5_SIZEOF_INT_LEAST16_T */
+#if H5_SIZEOF_UINT_LEAST16_T != 0
+        static const PredType& NATIVE_UINT_LEAST16;
+#endif /* H5_SIZEOF_UINT_LEAST16_T */
+
+#if H5_SIZEOF_INT_LEAST32_T != 0
+        static const PredType& NATIVE_INT_LEAST32;
+#endif /* H5_SIZEOF_INT_LEAST32_T */
+#if H5_SIZEOF_UINT_LEAST32_T != 0
+        static const PredType& NATIVE_UINT_LEAST32;
+#endif /* H5_SIZEOF_UINT_LEAST32_T */
+
+#if H5_SIZEOF_INT_LEAST64_T != 0
+        static const PredType& NATIVE_INT_LEAST64;
+#endif /* H5_SIZEOF_INT_LEAST64_T */
+#if H5_SIZEOF_UINT_LEAST64_T != 0
+        static const PredType& NATIVE_UINT_LEAST64;
+#endif /* H5_SIZEOF_UINT_LEAST64_T */
+
+// FAST types
+#if H5_SIZEOF_INT_FAST8_T != 0
+        static const PredType& NATIVE_INT_FAST8;
+#endif /* H5_SIZEOF_INT_FAST8_T */
+#if H5_SIZEOF_UINT_FAST8_T != 0
+        static const PredType& NATIVE_UINT_FAST8;
+#endif /* H5_SIZEOF_UINT_FAST8_T */
+
+#if H5_SIZEOF_INT_FAST16_T != 0
+        static const PredType& NATIVE_INT_FAST16;
+#endif /* H5_SIZEOF_INT_FAST16_T */
+#if H5_SIZEOF_UINT_FAST16_T != 0
+        static const PredType& NATIVE_UINT_FAST16;
+#endif /* H5_SIZEOF_UINT_FAST16_T */
+
+#if H5_SIZEOF_INT_FAST32_T != 0
+        static const PredType& NATIVE_INT_FAST32;
+#endif /* H5_SIZEOF_INT_FAST32_T */
+#if H5_SIZEOF_UINT_FAST32_T != 0
+        static const PredType& NATIVE_UINT_FAST32;
+#endif /* H5_SIZEOF_UINT_FAST32_T */
+
+#if H5_SIZEOF_INT_FAST64_T != 0
+        static const PredType& NATIVE_INT_FAST64;
+#endif /* H5_SIZEOF_INT_FAST64_T */
+#if H5_SIZEOF_UINT_FAST64_T != 0
+        static const PredType& NATIVE_UINT_FAST64;
+#endif /* H5_SIZEOF_UINT_FAST64_T */
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+        // Deletes the PredType global constants
+        static void deleteConstants();
+
+        // Dummy constant
+        static const PredType& PREDTYPE_CONST; // dummy constant
+
+   protected:
+        // Default constructor
+        PredType();
+
+        // Creates a pre-defined type using an HDF5 pre-defined constant
+        PredType(const hid_t predtype_id);  // used by the library only
+
+   private:
+        // Activates the creation of the PredType global constants
+        static PredType* getPredTypes();
+
+        // Dynamically allocates PredType global constants
+        static void makePredTypes();
+
+        // Dummy constant
+        static PredType* PREDTYPE_CONST_;
+
+        // Declaration of pointers to constants
+        static PredType* STD_I8BE_;
+        static PredType* STD_I8LE_;
+        static PredType* STD_I16BE_;
+        static PredType* STD_I16LE_;
+        static PredType* STD_I32BE_;
+        static PredType* STD_I32LE_;
+        static PredType* STD_I64BE_;
+        static PredType* STD_I64LE_;
+        static PredType* STD_U8BE_;
+        static PredType* STD_U8LE_;
+        static PredType* STD_U16BE_;
+        static PredType* STD_U16LE_;
+        static PredType* STD_U32BE_;
+        static PredType* STD_U32LE_;
+        static PredType* STD_U64BE_;
+        static PredType* STD_U64LE_;
+        static PredType* STD_B8BE_;
+        static PredType* STD_B8LE_;
+        static PredType* STD_B16BE_;
+        static PredType* STD_B16LE_;
+        static PredType* STD_B32BE_;
+        static PredType* STD_B32LE_;
+        static PredType* STD_B64BE_;
+        static PredType* STD_B64LE_;
+        static PredType* STD_REF_OBJ_;
+        static PredType* STD_REF_DSETREG_;
+
+        static PredType* C_S1_;
+        static PredType* FORTRAN_S1_;
+
+        static PredType* IEEE_F32BE_;
+        static PredType* IEEE_F32LE_;
+        static PredType* IEEE_F64BE_;
+        static PredType* IEEE_F64LE_;
+
+        static PredType* UNIX_D32BE_;
+        static PredType* UNIX_D32LE_;
+        static PredType* UNIX_D64BE_;
+        static PredType* UNIX_D64LE_;
+
+        static PredType* INTEL_I8_;
+        static PredType* INTEL_I16_;
+        static PredType* INTEL_I32_;
+        static PredType* INTEL_I64_;
+        static PredType* INTEL_U8_;
+        static PredType* INTEL_U16_;
+        static PredType* INTEL_U32_;
+        static PredType* INTEL_U64_;
+        static PredType* INTEL_B8_;
+        static PredType* INTEL_B16_;
+        static PredType* INTEL_B32_;
+        static PredType* INTEL_B64_;
+        static PredType* INTEL_F32_;
+        static PredType* INTEL_F64_;
+
+        static PredType* ALPHA_I8_;
+        static PredType* ALPHA_I16_;
+        static PredType* ALPHA_I32_;
+        static PredType* ALPHA_I64_;
+        static PredType* ALPHA_U8_;
+        static PredType* ALPHA_U16_;
+        static PredType* ALPHA_U32_;
+        static PredType* ALPHA_U64_;
+        static PredType* ALPHA_B8_;
+        static PredType* ALPHA_B16_;
+        static PredType* ALPHA_B32_;
+        static PredType* ALPHA_B64_;
+        static PredType* ALPHA_F32_;
+        static PredType* ALPHA_F64_;
+
+        static PredType* MIPS_I8_;
+        static PredType* MIPS_I16_;
+        static PredType* MIPS_I32_;
+        static PredType* MIPS_I64_;
+        static PredType* MIPS_U8_;
+        static PredType* MIPS_U16_;
+        static PredType* MIPS_U32_;
+        static PredType* MIPS_U64_;
+        static PredType* MIPS_B8_;
+        static PredType* MIPS_B16_;
+        static PredType* MIPS_B32_;
+        static PredType* MIPS_B64_;
+        static PredType* MIPS_F32_;
+        static PredType* MIPS_F64_;
+
+        static PredType* NATIVE_CHAR_;
+        static PredType* NATIVE_SCHAR_;
+        static PredType* NATIVE_UCHAR_;
+        static PredType* NATIVE_SHORT_;
+        static PredType* NATIVE_USHORT_;
+        static PredType* NATIVE_INT_;
+        static PredType* NATIVE_UINT_;
+        static PredType* NATIVE_LONG_;
+        static PredType* NATIVE_ULONG_;
+        static PredType* NATIVE_LLONG_;
+        static PredType* NATIVE_ULLONG_;
+        static PredType* NATIVE_FLOAT_;
+        static PredType* NATIVE_DOUBLE_;
+        static PredType* NATIVE_LDOUBLE_;
+        static PredType* NATIVE_B8_;
+        static PredType* NATIVE_B16_;
+        static PredType* NATIVE_B32_;
+        static PredType* NATIVE_B64_;
+        static PredType* NATIVE_OPAQUE_;
+        static PredType* NATIVE_HSIZE_;
+        static PredType* NATIVE_HSSIZE_;
+        static PredType* NATIVE_HERR_;
+        static PredType* NATIVE_HBOOL_;
+
+        static PredType* NATIVE_INT8_;
+        static PredType* NATIVE_UINT8_;
+        static PredType* NATIVE_INT16_;
+        static PredType* NATIVE_UINT16_;
+        static PredType* NATIVE_INT32_;
+        static PredType* NATIVE_UINT32_;
+        static PredType* NATIVE_INT64_;
+        static PredType* NATIVE_UINT64_;
+
+// LEAST types
+#if H5_SIZEOF_INT_LEAST8_T != 0
+        static PredType* NATIVE_INT_LEAST8_;
+#endif /* H5_SIZEOF_INT_LEAST8_T */
+#if H5_SIZEOF_UINT_LEAST8_T != 0
+        static PredType* NATIVE_UINT_LEAST8_;
+#endif /* H5_SIZEOF_UINT_LEAST8_T */
+
+#if H5_SIZEOF_INT_LEAST16_T != 0
+        static PredType* NATIVE_INT_LEAST16_;
+#endif /* H5_SIZEOF_INT_LEAST16_T */
+#if H5_SIZEOF_UINT_LEAST16_T != 0
+        static PredType* NATIVE_UINT_LEAST16_;
+#endif /* H5_SIZEOF_UINT_LEAST16_T */
+
+#if H5_SIZEOF_INT_LEAST32_T != 0
+        static PredType* NATIVE_INT_LEAST32_;
+#endif /* H5_SIZEOF_INT_LEAST32_T */
+#if H5_SIZEOF_UINT_LEAST32_T != 0
+        static PredType* NATIVE_UINT_LEAST32_;
+#endif /* H5_SIZEOF_UINT_LEAST32_T */
+
+#if H5_SIZEOF_INT_LEAST64_T != 0
+        static PredType* NATIVE_INT_LEAST64_;
+#endif /* H5_SIZEOF_INT_LEAST64_T */
+#if H5_SIZEOF_UINT_LEAST64_T != 0
+        static PredType* NATIVE_UINT_LEAST64_;
+#endif /* H5_SIZEOF_UINT_LEAST64_T */
+
+// FAST types
+#if H5_SIZEOF_INT_FAST8_T != 0
+        static PredType* NATIVE_INT_FAST8_;
+#endif /* H5_SIZEOF_INT_FAST8_T */
+#if H5_SIZEOF_UINT_FAST8_T != 0
+        static PredType* NATIVE_UINT_FAST8_;
+#endif /* H5_SIZEOF_UINT_FAST8_T */
+
+#if H5_SIZEOF_INT_FAST16_T != 0
+        static PredType* NATIVE_INT_FAST16_;
+#endif /* H5_SIZEOF_INT_FAST16_T */
+#if H5_SIZEOF_UINT_FAST16_T != 0
+        static PredType* NATIVE_UINT_FAST16_;
+#endif /* H5_SIZEOF_UINT_FAST16_T */
+
+#if H5_SIZEOF_INT_FAST32_T != 0
+        static PredType* NATIVE_INT_FAST32_;
+#endif /* H5_SIZEOF_INT_FAST32_T */
+#if H5_SIZEOF_UINT_FAST32_T != 0
+        static PredType* NATIVE_UINT_FAST32_;
+#endif /* H5_SIZEOF_UINT_FAST32_T */
+
+#if H5_SIZEOF_INT_FAST64_T != 0
+        static PredType* NATIVE_INT_FAST64_;
+#endif /* H5_SIZEOF_INT_FAST64_T */
+#if H5_SIZEOF_UINT_FAST64_T != 0
+        static PredType* NATIVE_UINT_FAST64_;
+#endif /* H5_SIZEOF_UINT_FAST64_T */
+        // End of Declaration of pointers
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end of PredType
+} // namespace H5
+
+#endif // __H5PredType_H
diff --git a/install/include/H5PropList.h b/install/include/H5PropList.h
new file mode 100644
index 0000000000..154d7b2b9f
--- /dev/null
+++ b/install/include/H5PropList.h
@@ -0,0 +1,145 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5PropList_H
+#define __H5PropList_H
+
+namespace H5 {
+
+//! Class PropList provides operations for generic property lists.
+/*! \class PropList
+    \brief Class PropList inherits from IdComponent and provides wrappers for
+    the HDF5 generic property list.
+
+    Inheritance: IdComponent
+*/
+class H5_DLLCPP PropList : public IdComponent {
+   public:
+        ///\brief Default property list
+        static const PropList& DEFAULT;
+
+        // Creates a property list of a given type or creates a copy of an
+        // existing property list giving the property list id.
+        PropList(const hid_t plist_id);
+
+        // Make a copy of the given property list using assignment statement
+        PropList& operator=(const PropList& rhs);
+
+        // Compares this property list or class against the given list or class.
+        bool operator==(const PropList& rhs) const;
+
+        // Close this property list.
+        virtual void close();
+
+        // Close a property list class.
+        void closeClass() const;
+
+        // Makes a copy of the given property list.
+        void copy(const PropList& like_plist);
+
+        // Copies a property from this property list or class to another
+        void copyProp(PropList& dest, const char* name) const;
+        void copyProp(PropList& dest, const H5std_string& name) const;
+
+        // Copies a property from one property list or property class to another
+        void copyProp(PropList& dest, PropList& src, const char* name) const;
+        void copyProp(PropList& dest, PropList& src, const H5std_string& name) const;
+
+        // Gets the class of this property list, i.e. H5P_FILE_CREATE,
+        // H5P_FILE_ACCESS, ...
+        hid_t getClass() const;
+
+        // Return the name of a generic property list class.
+        H5std_string getClassName() const;
+
+        // Returns the parent class of a generic property class.
+        PropList getClassParent() const;
+
+        // Returns the number of properties in this property list or class.
+        size_t getNumProps() const;
+
+        // Query the value of a property in a property list.
+        void getProperty(const char* name, void* value) const;
+        void getProperty(const H5std_string& name, void* value) const;
+        H5std_string getProperty(const char* name) const;
+        H5std_string getProperty(const H5std_string& name) const;
+
+        // Set a property's value in a property list.
+        void setProperty(const char* name, const char* charptr) const;
+        void setProperty(const char* name, const void* value) const;
+        void setProperty(const char* name, const H5std_string& strg) const;
+        void setProperty(const H5std_string& name, const void* value) const;
+        void setProperty(const H5std_string& name, const H5std_string& strg) const;
+        // Deprecated after 1.10.1, missing const
+        void setProperty(const char* name, void* value) const;
+        void setProperty(const char* name, H5std_string& strg) const;
+        void setProperty(const H5std_string& name, void* value) const;
+        void setProperty(const H5std_string& name, H5std_string& strg) const;
+
+        // Query the size of a property in a property list or class.
+        size_t getPropSize(const char *name) const;
+        size_t getPropSize(const H5std_string& name) const;
+
+        // Determines whether a property list is a certain class.
+        bool isAClass(const PropList& prop_class) const;
+
+        /// Query the existance of a property in a property object.
+        bool propExist(const char* name) const;
+        bool propExist(const H5std_string& name) const;
+
+        // Removes a property from a property list.
+        void removeProp(const char *name) const;
+        void removeProp(const H5std_string& name) const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("PropList"); }
+
+        // Default constructor: creates a stub PropList object.
+        PropList();
+
+        // Copy constructor: creates a copy of a PropList object.
+        PropList(const PropList& original);
+
+        // Gets the property list id.
+        virtual hid_t getId() const;
+
+        // Destructor: properly terminates access to this property list.
+        virtual ~PropList();
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+
+        // Deletes the PropList global constant
+        static void deleteConstants();
+
+    protected:
+        hid_t id;    // HDF5 property list id
+
+        // Sets the property list id.
+        virtual void p_setId(const hid_t new_id);
+
+    private:
+        static PropList* DEFAULT_;
+
+        // Dynamically allocates the PropList global constant
+        static PropList* getConstant();
+
+        // Friend function to set PropList id.  For library use only.
+        friend void f_PropList_setId(PropList* plist, hid_t new_id);
+
+#endif // DOXYGEN_SHOULD_SKIP_THIS
+
+}; // end of PropList
+} // namespace H5
+
+#endif  // __H5PropList_H
diff --git a/install/include/H5Rpkg.h b/install/include/H5Rpkg.h
new file mode 100644
index 0000000000..6d5036bf56
--- /dev/null
+++ b/install/include/H5Rpkg.h
@@ -0,0 +1,62 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer: Quincey Koziol <koziol@hdfgroup.org>
+ *             Thursday, September 13, 2007
+ *
+ * Purpose:     This file contains declarations which are visible
+ *              only within the H5R package. Source files outside the
+ *              H5R package should include H5Rprivate.h instead.
+ */
+#if !(defined H5R_FRIEND || defined H5R_MODULE)
+#error "Do not include this file outside the H5R package!"
+#endif
+
+#ifndef _H5Rpkg_H
+#define _H5Rpkg_H
+
+/* Get package's private header */
+#include "H5Rprivate.h"
+
+/* Other private headers needed by this file */
+#include "H5Fprivate.h"         /* File access				*/
+
+/**************************/
+/* Package Private Macros */
+/**************************/
+
+
+/****************************/
+/* Package Private Typedefs */
+/****************************/
+
+
+/*****************************/
+/* Package Private Variables */
+/*****************************/
+
+
+/******************************/
+/* Package Private Prototypes */
+/******************************/
+
+/* General functions */
+H5_DLL herr_t H5R_get_obj_type(H5F_t *file, hid_t dxpl_id, H5R_type_t ref_type,
+    const void *_ref, H5O_type_t *obj_type);
+H5_DLL hid_t H5R_dereference(H5F_t *file, hid_t dapl_id, hid_t dxpl_id, H5R_type_t ref_type,
+    const void *_ref, hbool_t app_ref);
+
+
+#endif /* _H5Rpkg_H */
+
diff --git a/install/include/H5Rpublic.h b/install/include/H5Rpublic.h
new file mode 100644
index 0000000000..446b7cd362
--- /dev/null
+++ b/install/include/H5Rpublic.h
@@ -0,0 +1,91 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5R module.
+ */
+#ifndef _H5Rpublic_H
+#define _H5Rpublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+#include "H5Gpublic.h"
+#include "H5Ipublic.h"
+
+/*
+ * Reference types allowed.
+ */
+typedef enum {
+    H5R_BADTYPE     =   (-1),   /*invalid Reference Type                     */
+    H5R_OBJECT,                 /*Object reference                           */
+    H5R_DATASET_REGION,         /*Dataset Region Reference                   */
+    H5R_MAXTYPE                 /*highest type (Invalid as true type)	     */
+} H5R_type_t;
+
+/* Note! Be careful with the sizes of the references because they should really
+ * depend on the run-time values in the file.  Unfortunately, the arrays need
+ * to be defined at compile-time, so we have to go with the worst case sizes for
+ * them.  -QAK
+ */
+#define H5R_OBJ_REF_BUF_SIZE    sizeof(haddr_t)
+/* Object reference structure for user's code */
+typedef haddr_t hobj_ref_t; /* Needs to be large enough to store largest haddr_t in a worst case machine (ie. 8 bytes currently) */
+
+#define H5R_DSET_REG_REF_BUF_SIZE    (sizeof(haddr_t)+4)
+/* 4 is used instead of sizeof(int) to permit portability between
+   the Crays and other machines (the heap ID is always encoded as an int32 anyway)
+*/
+/* Dataset Region reference structure for user's code */
+typedef unsigned char hdset_reg_ref_t[H5R_DSET_REG_REF_BUF_SIZE];/* Buffer to store heap ID and index */
+/* Needs to be large enough to store largest haddr_t in a worst case machine (ie. 8 bytes currently) plus an int */
+
+/* Publicly visible data structures */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Functions in H5R.c */
+H5_DLL herr_t H5Rcreate(void *ref, hid_t loc_id, const char *name,
+			 H5R_type_t ref_type, hid_t space_id);
+H5_DLL hid_t H5Rdereference2(hid_t obj_id, hid_t oapl_id, H5R_type_t ref_type, const void *ref);
+H5_DLL hid_t H5Rget_region(hid_t dataset, H5R_type_t ref_type, const void *ref);
+H5_DLL herr_t H5Rget_obj_type2(hid_t id, H5R_type_t ref_type, const void *_ref,
+    H5O_type_t *obj_type);
+H5_DLL ssize_t H5Rget_name(hid_t loc_id, H5R_type_t ref_type, const void *ref,
+    char *name/*out*/, size_t size);
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+
+
+/* Typedefs */
+
+
+/* Function prototypes */
+H5_DLL H5G_obj_t H5Rget_obj_type1(hid_t id, H5R_type_t ref_type, const void *_ref);
+H5_DLL hid_t H5Rdereference1(hid_t obj_id, H5R_type_t ref_type, const void *ref);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _H5Rpublic_H */
+
diff --git a/install/include/H5SMpkg.h b/install/include/H5SMpkg.h
new file mode 100644
index 0000000000..6dea7ae6f3
--- /dev/null
+++ b/install/include/H5SMpkg.h
@@ -0,0 +1,288 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  James Laird <jlaird@ncsa.uiuc.edu>
+ *              Thursday, March 30, 2006
+ *
+ * Purpose:     This file contains declarations which are visible only within
+ *              the H5SM shared object header messages package.  Source files
+ *              outside the H5SM package should	include H5SMprivate.h instead.
+ */
+#if !(defined H5SM_FRIEND || defined H5SM_MODULE)
+#error "Do not include this file outside the H5SM package!"
+#endif
+
+#ifndef _H5SMpkg_H
+#define _H5SMpkg_H
+
+/* Get package's private header */
+#include "H5SMprivate.h"	/* Shared Object Header Messages	*/
+
+/* Other private headers needed by this file */
+#include "H5ACprivate.h"        /* Metadata Cache		  	*/
+#include "H5B2private.h"        /* B-trees                              */
+#include "H5HFprivate.h"        /* Fractal heaps		  	*/
+
+
+/****************************/
+/* Package Macros           */
+/****************************/
+
+/* Size of checksum information (on disk) */
+#define H5SM_SIZEOF_CHECKSUM 4
+
+#define H5SM_HEAP_LOC_SIZE (                                                  \
+        (unsigned)4                     /* Reference count */                 \
+        + sizeof(H5O_fheap_id_t)        /* size of heap ID on disk */         \
+    )
+
+#define H5SM_OH_LOC_SIZE(f) (                                                 \
+        (unsigned)1             /* reserved (possible flags?) */              \
+        + (unsigned)1           /* message type ID */			      \
+        + (unsigned)2           /* creation index of message in OH */         \
+        + H5F_SIZEOF_ADDR(f)    /* address of OH */                           \
+    )
+
+#define H5SM_SOHM_ENTRY_SIZE(f) (                                             \
+        (unsigned)1             /* Message location */                        \
+        + (unsigned)4           /* Hash value */                              \
+        + MAX(H5SM_HEAP_LOC_SIZE, H5SM_OH_LOC_SIZE(f))  /* Entry */           \
+    )
+
+#define H5SM_INDEX_HEADER_SIZE(f) (                                           \
+        (unsigned)1             /* Whether index is a list or B-tree */       \
+        + (unsigned)1           /* Version of index format */                 \
+        + (unsigned)2           /* Type of messages stored in the index */    \
+        + (unsigned)4           /* Minimum size of messages to share */       \
+        + (unsigned)(3 * 2)     /* B-tree cutoff, list cutoff, # of shared messages */ \
+        + H5F_SIZEOF_ADDR(f)    /* Location of list or B-tree */              \
+        + H5F_SIZEOF_ADDR(f)    /* Address of heap */                         \
+    )
+
+/* Format overhead for all SOHM tree metadata in the file */
+#define H5SM_METADATA_PREFIX_SIZE (                                           \
+    H5_SIZEOF_MAGIC             /* Signature */                               \
+    + H5SM_SIZEOF_CHECKSUM      /* Checksum */                                \
+    )
+
+#define H5SM_TABLE_SIZE(f) (                                                  \
+    /* General metadata fields */                                             \
+    H5SM_METADATA_PREFIX_SIZE                                                 \
+                                                                              \
+    /* Indices */                                                             \
+    + (H5F_SOHM_NINDEXES(f) * H5SM_INDEX_HEADER_SIZE(f))                      \
+    )
+
+#define H5SM_LIST_SIZE(f, num_mesg) (                                         \
+    /* General metadata fields */                                             \
+    H5SM_METADATA_PREFIX_SIZE                                                 \
+                                                                              \
+    /* Message entries */                                                     \
+    + (H5SM_SOHM_ENTRY_SIZE(f) * num_mesg)                                    \
+    )
+
+#define H5SM_B2_NODE_SIZE 512
+#define H5SM_B2_SPLIT_PERCENT 100
+#define H5SM_B2_MERGE_PERCENT 40
+
+#define H5SM_LIST_VERSION	0	/* Verion of Shared Object Header Message List Indexes */
+
+/****************************/
+/* Package Typedefs         */
+/****************************/
+
+/* There are a number of Shared Object Header Message-specific structs here.
+ *
+ * The H5SM_master_table_t is pointed to by the file superblock.  Since a file
+ * can have more than one SOHM index, this table collects all the indexes into
+ * one place.  It holds an array of H5SM_index_header_t structs.
+ *
+ * An H5SM_index_header_t is actually the for a given index.  It holds
+ * the number of messages in the index, the types of messages in the index,
+ * etc.  It also records whether the index is a list or a b-tree, and has
+ * the address of the list or b-tree.
+ *
+ * If the index is a list, the address in the index header should be given
+ * to the cache, which can load it into a H5SM_list_t struct.  This is mostly
+ * just a header for the cache information; it contains a pointer back to
+ * the index header and an unsorted array of messages.
+ *
+ * These messages are H5SM_sohm_t structs.  They hold the actual SOHM's
+ * address, hash value, and refcount.
+ *
+ * If the index is a b-tree, the H5SM_index_header_t struct holds the address
+ * of the b-tree instead of the address of a H5SM_list_t.  The B-tree's nodes
+ * are still 'H5SM_sohm_t's.
+ *
+ * H5SM_mesg_key_t structs are used to search lists and B-trees for a certain
+ * message.  They correspond to a message that hasn't yet been written to
+ * disk.
+ */
+
+/* Where a message is stored */
+typedef enum {
+    H5SM_NO_LOC = -1,
+    H5SM_IN_HEAP = 0,    	/* Message is stored in the heap */
+    H5SM_IN_OH    		/* Message is stored in an object header */
+} H5SM_storage_loc_t;
+
+/* Typedef for a record's location if it's stored in the heap */
+typedef struct {
+    hsize_t ref_count;		/* Number of times this message is used in the file */
+    H5O_fheap_id_t fheap_id;    /* ID of the OHM in the fractal heap */
+} H5SM_heap_loc_t;
+
+/* Typedef for a SOHM index node */
+typedef struct {
+    H5SM_storage_loc_t location;        /* Type of message location */
+    uint32_t hash;		        /* Hash value for encoded OHM */
+    unsigned msg_type_id;               /* Message's type ID */
+    union {
+        H5O_mesg_loc_t mesg_loc;        /* Location of message in object header */
+        H5SM_heap_loc_t heap_loc;       /* Heap ID for message in SOHM heap */
+    } u;
+} H5SM_sohm_t;
+
+/* Types of message indices */
+typedef enum {
+    H5SM_BADTYPE = -1,
+    H5SM_LIST,    		/* Index is an unsorted list */
+    H5SM_BTREE    		/* Index is a sorted B-tree */
+} H5SM_index_type_t;
+
+/* Typedef for a SOHM index header */
+typedef struct {
+/* Stored */
+    unsigned mesg_types;	/* Bit flag vector of message types */
+    size_t min_mesg_size;	/* number of messages being tracked */
+    size_t list_max;		/* >= this many messages, index with a B-tree */
+    size_t btree_min;		/* <= this many messages, index with a list again */
+    size_t num_messages;	/* number of messages being tracked */
+    H5SM_index_type_t index_type; /* Is the index a list or a B-tree? */
+    haddr_t index_addr;		/* Address of the actual index (list or B-tree) */
+    haddr_t heap_addr;		/* Address of the fheap used to store shared messages */
+
+/* Not stored */
+    size_t list_size;           /* Size of list index on disk */
+} H5SM_index_header_t;
+
+/* Typedef for a SOHM list */
+typedef struct {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    H5SM_index_header_t *header;    /* Pointer to the corresponding index header */
+    H5SM_sohm_t *messages;          /* Actual list, stored as an array */
+} H5SM_list_t;
+
+/* Typedef for shared object header message master table */
+struct H5SM_master_table_t {
+    /* Information for H5AC cache functions, _must_ be first field in structure */
+    H5AC_info_t cache_info;
+
+    size_t table_size;              /* Size of table on disk */
+    unsigned num_indexes;           /* Number of indexes */
+    H5SM_index_header_t *indexes;   /* Array of num_indexes indexes */
+};
+
+/* Typedef for searching an index (list or B-tree) */
+typedef struct {
+    H5F_t *file;                        /* File in which sharing is happening */
+    hid_t dxpl_id;                      /* DXPL for sharing messages in heap */
+    H5HF_t *fheap;    			/* The heap for this message type, open. */
+    void *encoding; 		        /* The message encoded, or NULL */
+    size_t encoding_size; 		/* Size of the encoding, or 0 */
+    H5SM_sohm_t message;                /* The message to find/insert.
+                                         * If the message doesn't yet have a
+                                         * heap ID, the heap ID will be 0. */
+} H5SM_mesg_key_t;
+
+/*
+ * Data exchange structure to pass through the fractal heap layer for the
+ * H5HF_op function when computing a hash value for a message.
+ */
+typedef struct {
+    /* downward (internal) */
+    unsigned    type_id;                /* Message type */
+
+    /* upward */
+    uint32_t    hash;                   /* Hash value */
+} H5SM_fh_ud_gh_t;
+
+/* Typedef to increment a reference count in the B-tree */
+typedef struct {
+    H5SM_mesg_key_t *key;       /* IN: key for message being incremented */
+    H5O_fheap_id_t fheap_id;    /* OUT: fheap ID of record */
+    hid_t dxpl_id;
+} H5SM_incr_ref_opdata;
+
+/* v2 B-tree client callback context */
+typedef struct H5SM_bt2_ctx_t {
+    uint8_t     sizeof_addr;    /* Size of file addresses */
+} H5SM_bt2_ctx_t;
+
+/* Callback info for loading a shared message table index into the cache */
+typedef struct H5SM_table_cache_ud_t {
+    H5F_t *f;                   /* File that shared message index stored as a table is in */
+} H5SM_table_cache_ud_t;
+
+/* Callback info for loading a shared message list index into the cache */
+typedef struct H5SM_list_cache_ud_t {
+    H5F_t *f;                   /* File that shared message index stored as a table is in */
+    H5SM_index_header_t *header; /* Index header for this list */
+} H5SM_list_cache_ud_t;
+
+
+/****************************/
+/* Package Variables        */
+/****************************/
+
+/* Declare free lists to manage H5SM structs */
+H5FL_EXTERN(H5SM_master_table_t);
+H5FL_ARR_EXTERN(H5SM_index_header_t);
+H5FL_EXTERN(H5SM_list_t);
+H5FL_ARR_EXTERN(H5SM_sohm_t);
+
+H5_DLLVAR const H5B2_class_t H5SM_INDEX[1];
+
+/****************************/
+/* Package Prototypes       */
+/****************************/
+
+/* General routines */
+H5_DLL ssize_t H5SM_get_index(const H5SM_master_table_t *table, unsigned type_id);
+
+/* Encode and decode routines, used for B-tree and cache encoding/decoding */
+H5_DLL herr_t H5SM__message_compare(const void *rec1, const void *rec2, int *result);
+H5_DLL herr_t H5SM__message_encode(uint8_t *raw, const void *native, void *ctx);
+H5_DLL herr_t H5SM__message_decode(const uint8_t *raw, void *native, void *ctx);
+
+/* H5B2_remove_t callback to add messages to a list index */
+H5_DLL herr_t H5SM_bt2_convert_to_list_op(const void * record, void *op_data);
+
+/* Fractal heap 'op' callback to compute hash value for message "in place" */
+H5_DLL herr_t H5SM_get_hash_fh_cb(const void *obj, size_t obj_len, void *_udata);
+
+/* Routines to release data structures */
+herr_t H5SM_table_free(H5SM_master_table_t *table);
+herr_t H5SM_list_free(H5SM_list_t *list);
+
+/* Testing functions */
+#ifdef H5SM_TESTING
+H5_DLL herr_t H5SM_get_mesg_count_test(H5F_t *f, hid_t dxpl_id, unsigned type_id,
+    size_t *mesg_count);
+#endif /* H5SM_TESTING */
+
+#endif /* _H5SMpkg_H */
+
diff --git a/install/include/H5Spkg.h b/install/include/H5Spkg.h
new file mode 100644
index 0000000000..315af29cc1
--- /dev/null
+++ b/install/include/H5Spkg.h
@@ -0,0 +1,283 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:	Quincey Koziol <koziol@ncsa.uiuc.edu>
+ *		Thursday, September 28, 2000
+ *
+ * Purpose:	This file contains declarations which are visible only within
+ *		the H5S package.  Source files outside the H5S package should
+ *		include H5Sprivate.h instead.
+ */
+#if !(defined H5S_FRIEND || defined H5S_MODULE)
+#error "Do not include this file outside the H5S package!"
+#endif
+
+#ifndef _H5Spkg_H
+#define _H5Spkg_H
+
+#include "H5Sprivate.h"
+
+/* Flags to indicate special dataspace features are active */
+#define H5S_VALID_MAX	0x01
+#define H5S_VALID_PERM	0x02
+
+/* Flags for serialization of selections */
+#define H5S_SELECT_FLAG_UNLIM   0x01
+#define H5S_SELECT_FLAG_BITS    (H5S_SELECT_FLAG_UNLIM)
+
+/* Length of stack-allocated sequences for "project intersect" routines */
+#define H5S_PROJECT_INTERSECT_NSEQS 256
+
+
+/* Initial version of the dataspace information */
+#define H5O_SDSPACE_VERSION_1	1
+
+/* This version adds support for "null" dataspaces, encodes the type of the
+ *      dataspace in the message and eliminated the rest of the "reserved"
+ *      bytes.
+ */
+#define H5O_SDSPACE_VERSION_2	2
+
+/* The latest version of the format.  Look through the 'encode'
+ *      and 'size' callbacks for places to change when updating this. */
+#define H5O_SDSPACE_VERSION_LATEST H5O_SDSPACE_VERSION_2
+
+/* Maximum dimension size (highest value that is not a special value e.g.
+ * H5S_UNLIMITED) */
+#define H5S_MAX_SIZE            ((hsize_t)(hssize_t)(-2))
+
+
+/*
+ * Dataspace extent information
+ */
+/* Extent container */
+struct H5S_extent_t {
+    H5O_shared_t sh_loc;        /* Shared message info (must be first) */
+
+    H5S_class_t	type;           /* Type of extent */
+    unsigned version;           /* Version of object header message to encode this object with */
+    hsize_t nelem;              /* Number of elements in extent */
+
+    unsigned rank;              /* Number of dimensions */
+    hsize_t *size;              /* Current size of the dimensions */
+    hsize_t *max;               /* Maximum size of the dimensions */
+};
+
+/*
+ * Dataspace selection information
+ */
+/* Node in point selection list (typedef'd in H5Sprivate.h) */
+struct H5S_pnt_node_t {
+    hsize_t *pnt;          /* Pointer to a selected point */
+    struct H5S_pnt_node_t *next;  /* pointer to next point in list */
+};
+
+/* Information about point selection list */
+typedef struct {
+    H5S_pnt_node_t *head;   /* Pointer to head of point list */
+} H5S_pnt_list_t;
+
+/* Information about new-style hyperslab spans */
+
+/* Information a particular hyperslab span */
+struct H5S_hyper_span_t {
+    hsize_t low, high;          /* Low & high bounds of span */
+    hsize_t nelem;              /* Number of elements in span (only needed during I/O) */
+    hsize_t pstride;            /* Pseudo-stride from start of previous span (only used during I/O) */
+    struct H5S_hyper_span_info_t *down;     /* Pointer to list of spans in next dimension down */
+    struct H5S_hyper_span_t *next;     /* Pointer to next span in list */
+};
+
+/* Information about a list of hyperslab spans */
+struct H5S_hyper_span_info_t {
+    unsigned count;                    /* Ref. count of number of spans which share this span */
+    struct H5S_hyper_span_info_t *scratch;  /* Scratch pointer
+                                             * (used during copies, as mark
+                                             * during precomputes for I/O &
+                                             * to point to the last span in a
+                                             * list during single element adds)
+                                             */
+    struct H5S_hyper_span_t *head;  /* Pointer to list of spans in next dimension down */
+};
+
+/* Information about new-style hyperslab selection */
+typedef struct {
+    hbool_t diminfo_valid;                      /* Whether the dataset has valid diminfo */
+    H5S_hyper_dim_t opt_diminfo[H5S_MAX_RANK];  /* per-dim selection info */
+    H5S_hyper_dim_t app_diminfo[H5S_MAX_RANK];  /* per-dim selection info */
+	/* 'opt_diminfo' points to a [potentially] optimized version of the user's
+         * hyperslab information.  'app_diminfo' points to the actual parameters
+         * that the application used for setting the hyperslab selection.  These
+         * are only used for re-gurgitating the original values used to set the
+         * hyperslab to the application when it queries the hyperslab selection
+         * information. */
+    int unlim_dim;                              /* Dimension where selection is unlimited, or -1 if none */
+    hsize_t num_elem_non_unlim;                 /* # of elements in a "slice" excluding the unlimited dimension */
+    H5S_hyper_span_info_t *span_lst; /* List of hyperslab span information */
+} H5S_hyper_sel_t;
+
+/* Selection information methods */
+/* Method to copy a selection */
+typedef herr_t (*H5S_sel_copy_func_t)(H5S_t *dst, const H5S_t *src, hbool_t share_selection);
+/* Method to retrieve a list of offset/length sequences for selection */
+typedef herr_t (*H5S_sel_get_seq_list_func_t)(const H5S_t *space, unsigned flags,
+    H5S_sel_iter_t *iter, size_t maxseq, size_t maxbytes,
+    size_t *nseq, size_t *nbytes, hsize_t *off, size_t *len);
+/* Method to release current selection */
+typedef herr_t (*H5S_sel_release_func_t)(H5S_t *space);
+/* Method to determine if current selection is valid for dataspace */
+typedef htri_t (*H5S_sel_is_valid_func_t)(const H5S_t *space);
+/* Method to determine number of bytes required to store current selection */
+typedef hssize_t (*H5S_sel_serial_size_func_t)(const H5S_t *space);
+/* Method to store current selection in "serialized" form (a byte sequence suitable for storing on disk) */
+typedef herr_t (*H5S_sel_serialize_func_t)(const H5S_t *space, uint8_t **p);
+/* Method to create selection from "serialized" form (a byte sequence suitable for storing on disk) */
+typedef herr_t (*H5S_sel_deserialize_func_t)(H5S_t *space, uint32_t version, uint8_t flags,
+    const uint8_t **p);
+/* Method to determine smallest n-D bounding box containing the current selection */
+typedef herr_t (*H5S_sel_bounds_func_t)(const H5S_t *space, hsize_t *start, hsize_t *end);
+/* Method to determine linear offset of initial element in selection within dataspace */
+typedef herr_t (*H5S_sel_offset_func_t)(const H5S_t *space, hsize_t *offset);
+/* Method to get unlimited dimension of selection (or -1 for none) */
+typedef int (*H5S_sel_unlim_dim_func_t)(const H5S_t *space);
+/* Method to get the number of elements in a slice through the unlimited dimension */
+typedef herr_t (*H5S_sel_num_elem_non_unlim_func_t)(const H5S_t *space,
+    hsize_t *num_elem_non_unlim);
+/* Method to determine if current selection is contiguous */
+typedef htri_t (*H5S_sel_is_contiguous_func_t)(const H5S_t *space);
+/* Method to determine if current selection is a single block */
+typedef htri_t (*H5S_sel_is_single_func_t)(const H5S_t *space);
+/* Method to determine if current selection is "regular" */
+typedef htri_t (*H5S_sel_is_regular_func_t)(const H5S_t *space);
+/* Method to adjust a selection by an offset */
+typedef herr_t (*H5S_sel_adjust_u_func_t)(H5S_t *space, const hsize_t *offset);
+/* Method to construct single element projection onto scalar dataspace */
+typedef herr_t (*H5S_sel_project_scalar)(const H5S_t *space, hsize_t *offset);
+/* Method to construct selection projection onto/into simple dataspace */
+typedef herr_t (*H5S_sel_project_simple)(const H5S_t *space, H5S_t *new_space, hsize_t *offset);
+/* Method to initialize iterator for current selection */
+typedef herr_t (*H5S_sel_iter_init_func_t)(H5S_sel_iter_t *sel_iter, const H5S_t *space);
+
+/* Selection class information */
+typedef struct {
+    H5S_sel_type type;                          /* Type of selection (all, none, points or hyperslab) */
+
+    /* Methods */
+    H5S_sel_copy_func_t copy;                   /* Method to make a copy of a selection */
+    H5S_sel_get_seq_list_func_t get_seq_list;   /* Method to retrieve a list of offset/length sequences for selection */
+    H5S_sel_release_func_t release;             /* Method to release current selection */
+    H5S_sel_is_valid_func_t is_valid;           /* Method to determine if current selection is valid for dataspace */
+    H5S_sel_serial_size_func_t serial_size;     /* Method to determine number of bytes required to store current selection */
+    H5S_sel_serialize_func_t serialize;         /* Method to store current selection in "serialized" form (a byte sequence suitable for storing on disk) */
+    H5S_sel_deserialize_func_t deserialize;     /* Method to store create selection from "serialized" form (a byte sequence suitable for storing on disk) */
+    H5S_sel_bounds_func_t bounds;               /* Method to determine to smallest n-D bounding box containing the current selection */
+    H5S_sel_offset_func_t offset;               /* Method to determine linear offset of initial element in selection within dataspace */
+    H5S_sel_unlim_dim_func_t unlim_dim;              /* Method to get unlimited dimension of selection (or -1 for none) */
+    H5S_sel_num_elem_non_unlim_func_t num_elem_non_unlim; /* Method to get the number of elements in a slice through the unlimited dimension */
+    H5S_sel_is_contiguous_func_t is_contiguous; /* Method to determine if current selection is contiguous */
+    H5S_sel_is_single_func_t is_single;         /* Method to determine if current selection is a single block */
+    H5S_sel_is_regular_func_t is_regular;       /* Method to determine if current selection is "regular" */
+    H5S_sel_adjust_u_func_t adjust_u;           /* Method to adjust a selection by an offset */
+    H5S_sel_project_scalar project_scalar;      /* Method to construct scalar dataspace projection */
+    H5S_sel_project_simple project_simple;      /* Method to construct simple dataspace projection */
+    H5S_sel_iter_init_func_t iter_init;         /* Method to initialize iterator for current selection */
+} H5S_select_class_t;
+
+/* Selection information object */
+typedef struct {
+    const H5S_select_class_t *type;     /* Pointer to selection's class info */
+    hbool_t offset_changed;             /* Indicate that the offset for the selection has been changed */
+    hssize_t offset[H5S_MAX_RANK];      /* Offset within the extent */
+    hsize_t num_elem;   /* Number of elements in selection */
+    union {
+        H5S_pnt_list_t *pnt_lst; /* List of selected points (order is important) */
+        H5S_hyper_sel_t *hslab;  /* Info about hyperslab selections */
+    } sel_info;
+} H5S_select_t;
+
+/* Main dataspace structure (typedef'd in H5Sprivate.h) */
+struct H5S_t {
+    H5S_extent_t extent;                /* Dataspace extent (must stay first) */
+    H5S_select_t select;		/* Dataspace selection */
+};
+
+/* Selection iteration methods */
+/* Method to retrieve the current coordinates of iterator for current selection */
+typedef herr_t (*H5S_sel_iter_coords_func_t)(const H5S_sel_iter_t *iter, hsize_t *coords);
+/* Method to retrieve the current block of iterator for current selection */
+typedef herr_t (*H5S_sel_iter_block_func_t)(const H5S_sel_iter_t *iter, hsize_t *start, hsize_t *end);
+/* Method to determine number of elements left in iterator for current selection */
+typedef hsize_t (*H5S_sel_iter_nelmts_func_t)(const H5S_sel_iter_t *iter);
+/* Method to determine if there are more blocks left in the current selection */
+typedef htri_t (*H5S_sel_iter_has_next_block_func_t)(const H5S_sel_iter_t *iter);
+/* Method to move selection iterator to the next element in the selection */
+typedef herr_t (*H5S_sel_iter_next_func_t)(H5S_sel_iter_t *iter, size_t nelem);
+/* Method to move selection iterator to the next block in the selection */
+typedef herr_t (*H5S_sel_iter_next_block_func_t)(H5S_sel_iter_t *iter);
+/* Method to release iterator for current selection */
+typedef herr_t (*H5S_sel_iter_release_func_t)(H5S_sel_iter_t *iter);
+
+/* Selection iteration class */
+typedef struct H5S_sel_iter_class_t {
+    H5S_sel_type type;                          /* Type of selection (all, none, points or hyperslab) */
+
+    /* Methods on selections */
+    H5S_sel_iter_coords_func_t iter_coords;     /* Method to retrieve the current coordinates of iterator for current selection */
+    H5S_sel_iter_block_func_t iter_block;       /* Method to retrieve the current block of iterator for current selection */
+    H5S_sel_iter_nelmts_func_t iter_nelmts;     /* Method to determine number of elements left in iterator for current selection */
+    H5S_sel_iter_has_next_block_func_t iter_has_next_block;         /* Method to query if there is another block left in the selection */
+    H5S_sel_iter_next_func_t iter_next;         /* Method to move selection iterator to the next element in the selection */
+    H5S_sel_iter_next_block_func_t iter_next_block;     /* Method to move selection iterator to the next block in the selection */
+    H5S_sel_iter_release_func_t iter_release;   /* Method to release iterator for current selection */
+} H5S_sel_iter_class_t;
+
+/*
+ * All selection class methods.
+ */
+H5_DLLVAR const H5S_select_class_t H5S_sel_all[1];
+
+/*
+ * Hyperslab selection class methods.
+ */
+H5_DLLVAR const H5S_select_class_t H5S_sel_hyper[1];
+
+/*
+ * None selection class methods.
+ */
+H5_DLLVAR const H5S_select_class_t H5S_sel_none[1];
+
+/*
+ * Pointer selection class methods.
+ */
+H5_DLLVAR const H5S_select_class_t H5S_sel_point[1];
+
+/* Extent functions */
+H5_DLL herr_t H5S_extent_release(H5S_extent_t *extent);
+H5_DLL herr_t H5S_extent_copy_real(H5S_extent_t *dst, const H5S_extent_t *src,
+    hbool_t copy_max);
+
+/* Operations on selections */
+H5_DLL herr_t H5S__hyper_project_intersection(const H5S_t *src_space,
+    const H5S_t *dst_space, const H5S_t *src_intersect_space,
+    H5S_t *proj_space);
+H5_DLL herr_t H5S__hyper_subtract(H5S_t *space, H5S_t *subtract_space);
+
+/* Testing functions */
+#ifdef H5S_TESTING
+H5_DLL htri_t H5S_select_shape_same_test(hid_t sid1, hid_t sid2);
+H5_DLL htri_t H5S_get_rebuild_status_test(hid_t space_id);
+#endif /* H5S_TESTING */
+
+#endif /*_H5Spkg_H*/
+
diff --git a/install/include/H5Spublic.h b/install/include/H5Spublic.h
new file mode 100644
index 0000000000..5ed6249fb6
--- /dev/null
+++ b/install/include/H5Spublic.h
@@ -0,0 +1,155 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5S module.
+ */
+#ifndef _H5Spublic_H
+#define _H5Spublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+#include "H5Ipublic.h"
+
+/* Define atomic datatypes */
+#define H5S_ALL         (hid_t)0
+#define H5S_UNLIMITED   HSIZE_UNDEF
+
+/* Define user-level maximum number of dimensions */
+#define H5S_MAX_RANK    32
+
+/* Different types of dataspaces */
+typedef enum H5S_class_t {
+    H5S_NO_CLASS         = -1,  /*error                                      */
+    H5S_SCALAR           = 0,   /*scalar variable                            */
+    H5S_SIMPLE           = 1,   /*simple data space                          */
+    H5S_NULL             = 2    /*null data space                            */
+} H5S_class_t;
+
+/* Different ways of combining selections */
+typedef enum H5S_seloper_t {
+    H5S_SELECT_NOOP      = -1,  /* error                                     */
+    H5S_SELECT_SET       = 0,   /* Select "set" operation 		     */
+    H5S_SELECT_OR,              /* Binary "or" operation for hyperslabs
+                                 * (add new selection to existing selection)
+                                 * Original region:  AAAAAAAAAA
+                                 * New region:             BBBBBBBBBB
+                                 * A or B:           CCCCCCCCCCCCCCCC
+                                 */
+    H5S_SELECT_AND,             /* Binary "and" operation for hyperslabs
+                                 * (only leave overlapped regions in selection)
+                                 * Original region:  AAAAAAAAAA
+                                 * New region:             BBBBBBBBBB
+                                 * A and B:                CCCC
+                                 */
+    H5S_SELECT_XOR,             /* Binary "xor" operation for hyperslabs
+                                 * (only leave non-overlapped regions in selection)
+                                 * Original region:  AAAAAAAAAA
+                                 * New region:             BBBBBBBBBB
+                                 * A xor B:          CCCCCC    CCCCCC
+                                 */
+    H5S_SELECT_NOTB,            /* Binary "not" operation for hyperslabs
+                                 * (only leave non-overlapped regions in original selection)
+                                 * Original region:  AAAAAAAAAA
+                                 * New region:             BBBBBBBBBB
+                                 * A not B:          CCCCCC
+                                 */
+    H5S_SELECT_NOTA,            /* Binary "not" operation for hyperslabs
+                                 * (only leave non-overlapped regions in new selection)
+                                 * Original region:  AAAAAAAAAA
+                                 * New region:             BBBBBBBBBB
+                                 * B not A:                    CCCCCC
+                                 */
+    H5S_SELECT_APPEND,          /* Append elements to end of point selection */
+    H5S_SELECT_PREPEND,         /* Prepend elements to beginning of point selection */
+    H5S_SELECT_INVALID          /* Invalid upper bound on selection operations */
+} H5S_seloper_t;
+
+/* Enumerated type for the type of selection */
+typedef enum {
+    H5S_SEL_ERROR	= -1, 	/* Error			*/
+    H5S_SEL_NONE	= 0,    /* Nothing selected 		*/
+    H5S_SEL_POINTS	= 1,    /* Sequence of points selected	*/
+    H5S_SEL_HYPERSLABS  = 2,    /* "New-style" hyperslab selection defined	*/
+    H5S_SEL_ALL		= 3,    /* Entire extent selected	*/
+    H5S_SEL_N			/*THIS MUST BE LAST		*/
+}H5S_sel_type;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Functions in H5S.c */
+H5_DLL hid_t H5Screate(H5S_class_t type);
+H5_DLL hid_t H5Screate_simple(int rank, const hsize_t dims[],
+			       const hsize_t maxdims[]);
+H5_DLL herr_t H5Sset_extent_simple(hid_t space_id, int rank,
+				    const hsize_t dims[],
+				    const hsize_t max[]);
+H5_DLL hid_t H5Scopy(hid_t space_id);
+H5_DLL herr_t H5Sclose(hid_t space_id);
+H5_DLL herr_t H5Sencode(hid_t obj_id, void *buf, size_t *nalloc);
+H5_DLL hid_t H5Sdecode(const void *buf);
+H5_DLL hssize_t H5Sget_simple_extent_npoints(hid_t space_id);
+H5_DLL int H5Sget_simple_extent_ndims(hid_t space_id);
+H5_DLL int H5Sget_simple_extent_dims(hid_t space_id, hsize_t dims[],
+				      hsize_t maxdims[]);
+H5_DLL htri_t H5Sis_simple(hid_t space_id);
+H5_DLL hssize_t H5Sget_select_npoints(hid_t spaceid);
+H5_DLL herr_t H5Sselect_hyperslab(hid_t space_id, H5S_seloper_t op,
+				   const hsize_t start[],
+				   const hsize_t _stride[],
+				   const hsize_t count[],
+				   const hsize_t _block[]);
+/* #define NEW_HYPERSLAB_API */
+/* Note that these haven't been working for a while and were never
+ *      publicly released - QAK */
+#ifdef NEW_HYPERSLAB_API
+H5_DLL hid_t H5Scombine_hyperslab(hid_t space_id, H5S_seloper_t op,
+				   const hsize_t start[],
+				   const hsize_t _stride[],
+				   const hsize_t count[],
+				   const hsize_t _block[]);
+H5_DLL herr_t H5Sselect_select(hid_t space1_id, H5S_seloper_t op,
+                                  hid_t space2_id);
+H5_DLL hid_t H5Scombine_select(hid_t space1_id, H5S_seloper_t op,
+                                  hid_t space2_id);
+#endif /* NEW_HYPERSLAB_API */
+H5_DLL herr_t H5Sselect_elements(hid_t space_id, H5S_seloper_t op,
+    size_t num_elem, const hsize_t *coord);
+H5_DLL H5S_class_t H5Sget_simple_extent_type(hid_t space_id);
+H5_DLL herr_t H5Sset_extent_none(hid_t space_id);
+H5_DLL herr_t H5Sextent_copy(hid_t dst_id,hid_t src_id);
+H5_DLL htri_t H5Sextent_equal(hid_t sid1, hid_t sid2);
+H5_DLL herr_t H5Sselect_all(hid_t spaceid);
+H5_DLL herr_t H5Sselect_none(hid_t spaceid);
+H5_DLL herr_t H5Soffset_simple(hid_t space_id, const hssize_t *offset);
+H5_DLL htri_t H5Sselect_valid(hid_t spaceid);
+H5_DLL htri_t H5Sis_regular_hyperslab(hid_t spaceid);
+H5_DLL htri_t H5Sget_regular_hyperslab(hid_t spaceid, hsize_t start[],
+    hsize_t stride[], hsize_t count[], hsize_t block[]);
+H5_DLL hssize_t H5Sget_select_hyper_nblocks(hid_t spaceid);
+H5_DLL hssize_t H5Sget_select_elem_npoints(hid_t spaceid);
+H5_DLL herr_t H5Sget_select_hyper_blocklist(hid_t spaceid, hsize_t startblock,
+    hsize_t numblocks, hsize_t buf[/*numblocks*/]);
+H5_DLL herr_t H5Sget_select_elem_pointlist(hid_t spaceid, hsize_t startpoint,
+    hsize_t numpoints, hsize_t buf[/*numpoints*/]);
+H5_DLL herr_t H5Sget_select_bounds(hid_t spaceid, hsize_t start[],
+    hsize_t end[]);
+H5_DLL H5S_sel_type H5Sget_select_type(hid_t spaceid);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _H5Spublic_H */
+
diff --git a/install/include/H5StrType.h b/install/include/H5StrType.h
new file mode 100644
index 0000000000..abac8de748
--- /dev/null
+++ b/install/include/H5StrType.h
@@ -0,0 +1,74 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5StrType_H
+#define __H5StrType_H
+
+namespace H5 {
+
+/*! \class StrType
+    \brief StrType is a derivative of a DataType and operates on HDF5
+    string datatype.
+
+    Inheritance: AtomType -> DataType -> H5Object -> H5Location -> IdComponent
+*/
+class H5_DLLCPP StrType : public AtomType {
+   public:
+        // Creates a string type using a predefined type
+        StrType(const PredType& pred_type);
+
+        // Creates a string type with specified length - may be obsolete
+        StrType(const PredType& pred_type, const size_t& size);
+
+        // Creates a string type with specified length
+        StrType(const int dummy, const size_t& size);
+
+        // Gets the string datatype of the specified dataset
+        StrType(const DataSet& dataset);
+
+        // Constructors that open an HDF5 string datatype, given a location.
+        StrType(const H5Location& loc, const char* name);
+        StrType(const H5Location& loc, const H5std_string& name);
+
+        // Retrieves the character set type of this string datatype.
+        H5T_cset_t getCset() const;
+
+        // Sets character set to be used.
+        void setCset(H5T_cset_t cset) const;
+
+        // Retrieves the string padding method for this string datatype.
+        H5T_str_t getStrpad() const;
+
+        // Defines the storage mechanism for character strings.
+        void setStrpad(H5T_str_t strpad) const;
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("StrType"); }
+
+        // default constructor
+        StrType();
+
+        // Creates a string datatype using an existing id
+        StrType(const hid_t existing_id);
+
+        // Copy constructor - makes a copy of the original object
+        StrType(const StrType& original);
+
+        // Noop destructor.
+        virtual ~StrType();
+
+}; // end of StrType
+} // namespace H5
+
+#endif // __H5StrType_H
diff --git a/install/include/H5TBpublic.h b/install/include/H5TBpublic.h
new file mode 100644
index 0000000000..56aa915cfb
--- /dev/null
+++ b/install/include/H5TBpublic.h
@@ -0,0 +1,231 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef _H5TBpublic_H
+#define _H5TBpublic_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*-------------------------------------------------------------------------
+ *
+ * Create functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+H5_HLDLL herr_t  H5TBmake_table( const char *table_title,
+                       hid_t loc_id,
+                       const char *dset_name,
+                       hsize_t nfields,
+                       hsize_t nrecords,
+                       size_t type_size,
+                       const char *field_names[],
+                       const size_t *field_offset,
+                       const hid_t *field_types,
+                       hsize_t chunk_size,
+                       void *fill_data,
+                       int compress,
+                       const void *buf );
+
+
+/*-------------------------------------------------------------------------
+ *
+ * Write functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+H5_HLDLL herr_t  H5TBappend_records( hid_t loc_id,
+                           const char *dset_name,
+                           hsize_t nrecords,
+                           size_t type_size,
+                           const size_t *field_offset,
+                           const size_t *dst_sizes,
+                           const void *buf );
+
+H5_HLDLL herr_t  H5TBwrite_records( hid_t loc_id,
+                          const char *dset_name,
+                          hsize_t start,
+                          hsize_t nrecords,
+                          size_t type_size,
+                          const size_t *field_offset,
+                          const size_t *dst_sizes,
+                          const void *buf );
+
+
+H5_HLDLL herr_t  H5TBwrite_fields_name( hid_t loc_id,
+                              const char *dset_name,
+                              const char *field_names,
+                              hsize_t start,
+                              hsize_t nrecords,
+                              size_t type_size,
+                              const size_t *field_offset,
+                              const size_t *dst_sizes,
+                              const void *buf );
+
+H5_HLDLL herr_t  H5TBwrite_fields_index( hid_t loc_id,
+                               const char *dset_name,
+                               hsize_t nfields,
+                               const int *field_index,
+                               hsize_t start,
+                               hsize_t nrecords,
+                               size_t type_size,
+                               const size_t *field_offset,
+                               const size_t *dst_sizes,
+                               const void *buf );
+
+
+/*-------------------------------------------------------------------------
+ *
+ * Read functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+
+
+H5_HLDLL herr_t  H5TBread_table( hid_t loc_id,
+                       const char *dset_name,
+                       size_t dst_size,
+                       const size_t *dst_offset,
+                       const size_t *dst_sizes,
+                       void *dst_buf );
+
+
+H5_HLDLL herr_t  H5TBread_fields_name( hid_t loc_id,
+                             const char *dset_name,
+                             const char *field_names,
+                             hsize_t start,
+                             hsize_t nrecords,
+                             size_t type_size,
+                             const size_t *field_offset,
+                             const size_t *dst_sizes,
+                             void *buf );
+
+H5_HLDLL herr_t  H5TBread_fields_index( hid_t loc_id,
+                              const char *dset_name,
+                              hsize_t nfields,
+                              const int *field_index,
+                              hsize_t start,
+                              hsize_t nrecords,
+                              size_t type_size,
+                              const size_t *field_offset,
+                              const size_t *dst_sizes,
+                              void *buf );
+
+
+H5_HLDLL herr_t  H5TBread_records( hid_t loc_id,
+                         const char *dset_name,
+                         hsize_t start,
+                         hsize_t nrecords,
+                         size_t type_size,
+                         const size_t *dst_offset,
+                         const size_t *dst_sizes,
+                         void *buf );
+
+/*-------------------------------------------------------------------------
+ *
+ * Inquiry functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+
+H5_HLDLL herr_t  H5TBget_table_info ( hid_t loc_id,
+                            const char *dset_name,
+                            hsize_t *nfields,
+                            hsize_t *nrecords );
+
+H5_HLDLL herr_t  H5TBget_field_info( hid_t loc_id,
+                           const char *dset_name,
+                           char *field_names[],
+                           size_t *field_sizes,
+                           size_t *field_offsets,
+                           size_t *type_size );
+
+
+/*-------------------------------------------------------------------------
+ *
+ * Manipulation functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+
+H5_HLDLL herr_t  H5TBdelete_record( hid_t loc_id,
+                          const char *dset_name,
+                          hsize_t start,
+                          hsize_t nrecords );
+
+
+H5_HLDLL herr_t  H5TBinsert_record( hid_t loc_id,
+                          const char *dset_name,
+                          hsize_t start,
+                          hsize_t nrecords,
+                          size_t dst_size,
+                          const size_t *dst_offset,
+                          const size_t *dst_sizes,
+                          void *buf );
+
+H5_HLDLL herr_t  H5TBadd_records_from( hid_t loc_id,
+                             const char *dset_name1,
+                             hsize_t start1,
+                             hsize_t nrecords,
+                             const char *dset_name2,
+                             hsize_t start2 );
+
+H5_HLDLL herr_t  H5TBcombine_tables( hid_t loc_id1,
+                           const char *dset_name1,
+                           hid_t loc_id2,
+                           const char *dset_name2,
+                           const char *dset_name3 );
+
+H5_HLDLL herr_t  H5TBinsert_field( hid_t loc_id,
+                         const char *dset_name,
+                         const char *field_name,
+                         hid_t field_type,
+                         hsize_t position,
+                         const void *fill_data,
+                         const void *buf );
+
+H5_HLDLL herr_t  H5TBdelete_field( hid_t loc_id,
+                         const char *dset_name,
+                         const char *field_name );
+
+
+/*-------------------------------------------------------------------------
+ *
+ * Table attribute functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+H5_HLDLL herr_t  H5TBAget_title( hid_t loc_id,
+                       char *table_title );
+
+H5_HLDLL htri_t  H5TBAget_fill(hid_t loc_id,
+                      const char *dset_name,
+                      hid_t dset_id,
+                      unsigned char *dst_buf);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
diff --git a/install/include/H5Tpkg.h b/install/include/H5Tpkg.h
new file mode 100644
index 0000000000..d075127eed
--- /dev/null
+++ b/install/include/H5Tpkg.h
@@ -0,0 +1,1323 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:	Robb Matzke <matzke@llnl.gov>
+ *		Monday, December  8, 1997
+ *
+ * Purpose:	This file contains declarations which are visible only within
+ *		the H5T package.  Source files outside the H5T package should
+ *		include H5Tprivate.h instead.
+ */
+#if !(defined H5T_FRIEND || defined H5T_MODULE)
+#error "Do not include this file outside the H5T package!"
+#endif
+
+#ifndef _H5Tpkg_H
+#define _H5Tpkg_H
+
+/*
+ * Define this to enable debugging.
+ */
+#ifdef NDEBUG
+#  undef H5T_DEBUG
+#endif
+
+/* Get package's private header */
+#include "H5Tprivate.h"
+
+/* Other private headers needed by this file */
+#include "H5Fprivate.h"		/* Files				*/
+#include "H5FLprivate.h"	/* Free Lists				*/
+#include "H5Oprivate.h"		/* Object headers		  	*/
+
+/* Other public headers needed by this file */
+#include "H5Spublic.h"		/* Dataspace functions			*/
+
+/* Length of debugging name buffer */
+#define H5T_NAMELEN		32
+
+/* Macro to ease detecting "complex" datatypes (i.e. those with base types or fields) */
+#define H5T_IS_COMPLEX(t)       ((t) == H5T_COMPOUND || (t) == H5T_ENUM || (t) == H5T_VLEN || (t) == H5T_ARRAY)
+
+/* Macro to ease detecting fixed "string" datatypes */
+#define H5T_IS_FIXED_STRING(dt) (H5T_STRING == (dt)->type)
+
+/* Macro to ease detecting variable-length "string" datatypes */
+#define H5T_IS_VL_STRING(dt)    (H5T_VLEN == (dt)->type && H5T_VLEN_STRING == (dt)->u.vlen.type)
+
+/* Macro to ease detecting fixed or variable-length "string" datatypes */
+#define H5T_IS_STRING(dt)       (H5T_IS_FIXED_STRING(dt) || H5T_IS_VL_STRING(dt))
+
+/* Macro to ease detecting atomic datatypes */
+#define H5T_IS_ATOMIC(dt)       (!(H5T_IS_COMPLEX((dt)->type) || (dt)->type == H5T_OPAQUE))
+
+/* Macro to ease retrieving class of shared datatype */
+/* (Externally, a VL string is a string; internally, a VL string is a VL.  Lie
+ *      to the user if they have a VL string and tell them it's in the string
+ *      class)
+ */
+#define H5T_GET_CLASS(shared, internal) ((internal) ? (shared)->type : (H5T_IS_VL_STRING(shared) ?  H5T_STRING : (shared)->type))
+
+
+/*
+ * Datatype encoding versions
+ */
+
+/* This is the version to create all datatypes which don't contain
+ * array datatypes (atomic types, compound datatypes without array fields,
+ * vlen sequences of objects which aren't arrays, etc.) or VAX byte-ordered
+ * objects.
+ */
+#define H5O_DTYPE_VERSION_1	1
+
+/* This is the version to create all datatypes which contain H5T_ARRAY
+ * class objects (array definitely, potentially compound & vlen sequences also),
+ * but not VAX byte-ordered objects.
+ */
+#define H5O_DTYPE_VERSION_2	2
+
+/* This is the version to create all datatypes which contain VAX byte-ordered
+ * objects (floating-point types, currently).
+ */
+/* This version also packs compound & enum field names without padding */
+/* This version also encodes the member offset of compound fields more efficiently */
+/* This version also encodes array types more efficiently */
+#define H5O_DTYPE_VERSION_3	3
+
+/* The latest version of the format.  Look through the 'encode helper' routine
+ *      and 'size' callback for places to change when updating this. */
+#define H5O_DTYPE_VERSION_LATEST H5O_DTYPE_VERSION_3
+
+
+/* Flags for visiting datatype */
+#define H5T_VISIT_COMPLEX_FIRST 0x01            /* Visit complex datatype before visiting member/parent datatypes */
+#define H5T_VISIT_COMPLEX_LAST  0x02            /* Visit complex datatype after visiting member/parent datatypes */
+                                                /* (setting both flags will mean visiting complex type twice) */
+#define H5T_VISIT_SIMPLE        0x04            /* Visit simple datatypes (at all) */
+                                                /* (setting H5T_VISIT_SIMPLE and _not_ setting either H5T_VISIT_COMPLEX_FIRST or H5T_VISIT_COMPLEX_LAST will mean visiting _only_ "simple" "leafs" in the "tree" */
+                                                /* (_not_ setting H5T_VISIT_SIMPLE and setting either H5T_VISIT_COMPLEX_FIRST or H5T_VISIT_COMPLEX_LAST will mean visiting all nodes _except_ "simple" "leafs" in the "tree" */
+
+
+/* Define an internal macro for converting long long to long double.  Mac OS 10.4 gives some
+ * incorrect conversions. */
+#if (H5_WANT_DATA_ACCURACY && defined(H5_LLONG_TO_LDOUBLE_CORRECT)) || (!H5_WANT_DATA_ACCURACY)
+#define H5T_CONV_INTERNAL_LLONG_LDOUBLE       1
+#endif
+
+/* Define an internal macro for converting unsigned long long to long double.  SGI compilers give
+ * some incorect conversion.  64-bit Solaris does different rounding.   Windows Visual Studio 6 does
+ * not support unsigned long long.  For FreeBSD(sleipnir), the last 2 bytes of mantissa are lost when
+ * compiler tries to do the conversion.  For Cygwin, compiler doesn't do rounding correctly.
+ * Mac OS 10.4 gives some incorrect result. */
+#if (H5_WANT_DATA_ACCURACY && defined(H5_LLONG_TO_LDOUBLE_CORRECT)) || (!H5_WANT_DATA_ACCURACY)
+#define H5T_CONV_INTERNAL_ULLONG_LDOUBLE         1
+#endif
+
+/* Define an internal macro for converting long double to long long.  SGI compilers give some incorrect
+ * conversions. Mac OS 10.4 gives incorrect conversions. HP-UX 11.00 compiler generates floating exception.
+ * The hard conversion on Windows .NET 2003 has a bug and gives wrong exception value. */
+#if (H5_WANT_DATA_ACCURACY && defined(H5_LDOUBLE_TO_LLONG_ACCURATE)) || \
+    (!H5_WANT_DATA_ACCURACY)
+#define H5T_CONV_INTERNAL_LDOUBLE_LLONG         1
+#endif
+
+/* Define an internal macro for converting long double to unsigned long long.  SGI compilers give some
+ * incorrect conversions.  Mac OS 10.4 gives incorrect conversions. HP-UX 11.00 compiler generates
+ * floating exception. */
+#if (H5_WANT_DATA_ACCURACY && defined(H5_LDOUBLE_TO_LLONG_ACCURATE)) || \
+    (!H5_WANT_DATA_ACCURACY)
+#define H5T_CONV_INTERNAL_LDOUBLE_ULLONG         1
+#else
+#define H5T_CONV_INTERNAL_LDOUBLE_ULLONG         0
+#endif
+
+/* Statistics about a conversion function */
+struct H5T_stats_t {
+    unsigned	ncalls;			/*num calls to conversion function   */
+    hsize_t	nelmts;			/*total data points converted	     */
+    H5_timer_t	timer;			/*total time for conversion	     */
+};
+
+/* The datatype conversion database */
+struct H5T_path_t {
+    char	name[H5T_NAMELEN];	/*name for debugging only	     */
+    H5T_t	*src;			/*source datatype 		     */
+    H5T_t	*dst;			/*destination datatype		     */
+    H5T_conv_t	func;			/*data conversion function	     */
+    hbool_t	is_hard;		/*is it a hard function?	     */
+    hbool_t	is_noop;		/*is it the noop conversion?	     */
+    hbool_t	are_compounds;		/*are source and dest both compounds?*/
+    H5T_stats_t	stats;			/*statistics for the conversion	     */
+    H5T_cdata_t	cdata;			/*data for this function	     */
+};
+
+typedef struct H5T_atomic_t {
+    H5T_order_t		order;	/*byte order				     */
+    size_t		prec;	/*precision in bits			     */
+    size_t		offset; /*bit position of lsb of value		     */
+    H5T_pad_t	        lsb_pad;/*type of lsb padding			     */
+    H5T_pad_t		msb_pad;/*type of msb padding			     */
+    union {
+	struct {
+	    H5T_sign_t	sign;	/*type of integer sign			     */
+	} i;			/*integer; integer types		     */
+
+	struct {
+	    size_t	sign;	/*bit position of sign bit		     */
+	    size_t	epos;	/*position of lsb of exponent		     */
+	    size_t	esize;	/*size of exponent in bits		     */
+	    uint64_t	ebias;	/*exponent bias				     */
+	    size_t	mpos;	/*position of lsb of mantissa		     */
+	    size_t	msize;	/*size of mantissa			     */
+	    H5T_norm_t	norm;	/*normalization				     */
+	    H5T_pad_t	pad;	/*type of padding for internal bits	     */
+	} f;			/*floating-point types			     */
+
+	struct {
+	    H5T_cset_t	cset;	/*character set				     */
+	    H5T_str_t	pad;	/*space or null padding of extra bytes	     */
+	} s;			/*string types				     */
+
+	struct {
+	    H5R_type_t	rtype;	/*type of reference stored		     */
+            H5T_loc_t   loc;    /* Location of data in buffer		     */
+	} r;			/*reference types			     */
+    } u;
+} H5T_atomic_t;
+
+/* How members are sorted for compound or enum datatypes */
+typedef enum H5T_sort_t {
+    H5T_SORT_NONE	= 0,		/*not sorted			     */
+    H5T_SORT_NAME	= 1,		/*sorted by member name		     */
+    H5T_SORT_VALUE	= 2 		/*sorted by memb offset or enum value*/
+} H5T_sort_t;
+
+/* A compound datatype member */
+typedef struct H5T_cmemb_t {
+    char		*name;		/*name of this member		     */
+    size_t		offset;		/*offset from beginning of struct    */
+    size_t		size;		/*size of this member		     */
+    struct H5T_t	*type;		/*type of this member		     */
+} H5T_cmemb_t;
+
+/* A compound datatype */
+typedef struct H5T_compnd_t {
+    unsigned	nalloc;		/*num entries allocated in MEMB array*/
+    unsigned	nmembs;		/*number of members defined in struct*/
+    H5T_sort_t	sorted;		/*how are members sorted?	     */
+    hbool_t     packed;		/*are members packed together?       */
+    H5T_cmemb_t	*memb;		/*array of struct members	     */
+    size_t      memb_size;	/*total of all member sizes          */
+} H5T_compnd_t;
+
+/* An enumeration datatype */
+typedef struct H5T_enum_t {
+    unsigned	nalloc;		/*num entries allocated		     */
+    unsigned	nmembs;		/*number of members defined in enum  */
+    H5T_sort_t	sorted;		/*how are members sorted?	     */
+    uint8_t	*value;		/*array of values		     */
+    char	**name;		/*array of symbol names		     */
+} H5T_enum_t;
+
+/* VL function pointers */
+typedef ssize_t (*H5T_vlen_getlenfunc_t)(const void *vl_addr);
+typedef void * (*H5T_vlen_getptrfunc_t)(void *vl_addr);
+typedef htri_t (*H5T_vlen_isnullfunc_t)(const H5F_t *f, void *vl_addr);
+typedef herr_t (*H5T_vlen_readfunc_t)(H5F_t *f, hid_t dxpl_id, void *_vl, void *buf, size_t len);
+typedef herr_t (*H5T_vlen_writefunc_t)(H5F_t *f, hid_t dxpl_id, const H5T_vlen_alloc_info_t *vl_alloc_info, void *_vl, void *buf, void *_bg, size_t seq_len, size_t base_size);
+typedef herr_t (*H5T_vlen_setnullfunc_t)(H5F_t *f, hid_t dxpl_id, void *_vl, void *_bg);
+
+/* VL types */
+typedef enum {
+    H5T_VLEN_BADTYPE =  -1, /* invalid VL Type */
+    H5T_VLEN_SEQUENCE = 0,  /* VL sequence */
+    H5T_VLEN_STRING,        /* VL string */
+    H5T_VLEN_MAXTYPE        /* highest type (Invalid as true type) */
+} H5T_vlen_type_t;
+
+/* A VL datatype */
+typedef struct H5T_vlen_t {
+    H5T_vlen_type_t     type;   /* Type of VL data in buffer */
+    H5T_loc_t		loc;    /* Location of VL data in buffer */
+    H5T_cset_t          cset;   /* For VL string. character set */
+    H5T_str_t           pad;    /* For VL string.  space or null padding of
+                                 * extra bytes */
+    H5F_t *f;                   /* File ID (if VL data is on disk) */
+    H5T_vlen_getptrfunc_t getptr;   /* Function to get VL sequence pointer */
+    H5T_vlen_getlenfunc_t getlen;   /* Function to get VL sequence size (in element units, not bytes) */
+    H5T_vlen_isnullfunc_t isnull;   /* Function to check if VL value is NIL */
+    H5T_vlen_readfunc_t read;   /* Function to read VL sequence into buffer */
+    H5T_vlen_writefunc_t write; /* Function to write VL sequence from buffer */
+    H5T_vlen_setnullfunc_t setnull; /* Function to set a VL value to NIL */
+} H5T_vlen_t;
+
+/* An opaque datatype */
+typedef struct H5T_opaque_t {
+    char		*tag;		/*short type description string	     */
+} H5T_opaque_t;
+
+/* An array datatype */
+typedef struct H5T_array_t {
+    size_t	nelem;		/* total number of elements in array */
+    unsigned	ndims;		/* member dimensionality        */
+    size_t	dim[H5S_MAX_RANK];  /* size in each dimension       */
+} H5T_array_t;
+
+typedef enum H5T_state_t {
+    H5T_STATE_TRANSIENT, 		/*type is a modifiable, closable transient */
+    H5T_STATE_RDONLY,			/*transient, not modifiable, closable */
+    H5T_STATE_IMMUTABLE,		/*transient, not modifiable, not closable */
+    H5T_STATE_NAMED,			/*named constant, not open	     */
+    H5T_STATE_OPEN			/*named constant, open object header */
+} H5T_state_t;
+
+    /* This struct is shared between all occurances of an open named type */
+typedef struct H5T_shared_t {
+    hsize_t		fo_count; /* number of references to this file object */
+    H5T_state_t		state;	/*current state of the type		     */
+    H5T_class_t		type;	/*which class of type is this?		     */
+    size_t		size;	/*total size of an instance of this type     */
+    unsigned            version;        /* Version of object header message to encode this object with */
+    hbool_t		force_conv;/* Set if this type always needs to be converted and H5T__conv_noop cannot be called */
+    struct H5T_t	*parent;/*parent type for derived datatypes	     */
+    union {
+        H5T_atomic_t	atomic; /* an atomic datatype              */
+        H5T_compnd_t	compnd; /* a compound datatype (struct)    */
+        H5T_enum_t	enumer; /* an enumeration type (enum)       */
+        H5T_vlen_t	vlen;   /* a variable-length datatype       */
+        H5T_opaque_t	opaque; /* an opaque datatype              */
+        H5T_array_t	array;  /* an array datatype                */
+    } u;
+} H5T_shared_t;
+
+struct H5T_t {
+    H5O_shared_t    sh_loc;     /* Shared message info (must be first) */
+
+    H5T_shared_t   *shared;     /* all other information */
+    H5O_loc_t       oloc;       /* Object location, if the type is a named type */
+    H5G_name_t      path;       /* group hier. path if the type is a named type */
+};
+
+/* The master list of soft conversion functions */
+typedef struct H5T_soft_t {
+    char	name[H5T_NAMELEN];	/*name for debugging only	     */
+    H5T_class_t src;			/*source datatype class	     */
+    H5T_class_t dst;			/*destination datatype class	     */
+    H5T_conv_t	func;			/*the conversion function	     */
+} H5T_soft_t;
+
+/* Bit search direction */
+typedef enum H5T_sdir_t {
+    H5T_BIT_LSB,			/*search lsb toward msb		     */
+    H5T_BIT_MSB				/*search msb toward lsb		     */
+} H5T_sdir_t;
+
+/* Typedef for named datatype creation operation */
+typedef struct {
+    H5T_t *dt;                  /* Datatype to commit */
+    hid_t tcpl_id;              /* Named datatype creation property list */
+} H5T_obj_create_t;
+
+/* Typedef for datatype iteration operations */
+typedef herr_t (*H5T_operator_t)(H5T_t *dt, void *op_data/*in,out*/);
+
+/*
+ * Alignment information for native types. A value of N indicates that the
+ * data must be aligned on an address ADDR such that 0 == ADDR mod N. When
+ * N=1 no alignment is required; N=0 implies that alignment constraints were
+ * not calculated.  These alignment info is only for H5Tget_native_type.
+ * These values are used for structure alignment.
+ */
+H5_DLLVAR size_t	H5T_NATIVE_SCHAR_COMP_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_SHORT_COMP_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_INT_COMP_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_LONG_COMP_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_LLONG_COMP_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_FLOAT_COMP_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_DOUBLE_COMP_ALIGN_g;
+#if H5_SIZEOF_LONG_DOUBLE !=0
+H5_DLLVAR size_t	H5T_NATIVE_LDOUBLE_COMP_ALIGN_g;
+#endif
+
+H5_DLLVAR size_t H5T_POINTER_COMP_ALIGN_g;
+H5_DLLVAR size_t H5T_HVL_COMP_ALIGN_g;
+H5_DLLVAR size_t H5T_HOBJREF_COMP_ALIGN_g;
+H5_DLLVAR size_t H5T_HDSETREGREF_COMP_ALIGN_g;
+
+/*
+ * Alignment information for native types. A value of N indicates that the
+ * data must be aligned on an address ADDR such that 0 == ADDR mod N. When
+ * N=1 no alignment is required; N=0 implies that alignment constraints were
+ * not calculated.
+ */
+H5_DLLVAR size_t	H5T_NATIVE_SCHAR_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UCHAR_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_SHORT_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_USHORT_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_INT_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UINT_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_LONG_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_ULONG_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_LLONG_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_ULLONG_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_FLOAT_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_DOUBLE_ALIGN_g;
+#if H5_SIZEOF_LONG_DOUBLE !=0
+H5_DLLVAR size_t	H5T_NATIVE_LDOUBLE_ALIGN_g;
+#endif
+
+/* C9x alignment constraints */
+H5_DLLVAR size_t	H5T_NATIVE_INT8_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UINT8_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_INT_LEAST8_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UINT_LEAST8_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_INT_FAST8_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UINT_FAST8_ALIGN_g;
+
+H5_DLLVAR size_t	H5T_NATIVE_INT16_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UINT16_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_INT_LEAST16_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UINT_LEAST16_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_INT_FAST16_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UINT_FAST16_ALIGN_g;
+
+H5_DLLVAR size_t	H5T_NATIVE_INT32_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UINT32_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_INT_LEAST32_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UINT_LEAST32_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_INT_FAST32_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UINT_FAST32_ALIGN_g;
+
+H5_DLLVAR size_t	H5T_NATIVE_INT64_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UINT64_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_INT_LEAST64_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UINT_LEAST64_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_INT_FAST64_ALIGN_g;
+H5_DLLVAR size_t	H5T_NATIVE_UINT_FAST64_ALIGN_g;
+
+/* Useful floating-point values for conversion routines */
+/* (+/- Inf for all floating-point types) */
+H5_DLLVAR float H5T_NATIVE_FLOAT_POS_INF_g;
+H5_DLLVAR float H5T_NATIVE_FLOAT_NEG_INF_g;
+H5_DLLVAR double H5T_NATIVE_DOUBLE_POS_INF_g;
+H5_DLLVAR double H5T_NATIVE_DOUBLE_NEG_INF_g;
+#if H5_SIZEOF_LONG_DOUBLE !=0
+H5_DLLVAR double H5T_NATIVE_LDOUBLE_POS_INF_g;
+H5_DLLVAR double H5T_NATIVE_LDOUBLE_NEG_INF_g;
+#endif
+
+/* Declare extern the free lists for H5T_t's and H5T_shared_t's */
+H5FL_EXTERN(H5T_t);
+H5FL_EXTERN(H5T_shared_t);
+
+/* Common functions */
+H5_DLL herr_t H5T__init_native(void);
+H5_DLL H5T_t *H5T__create(H5T_class_t type, size_t size);
+H5_DLL herr_t H5T__commit(H5F_t *file, H5T_t *type, hid_t tcpl_id, hid_t dxpl_id);
+H5_DLL herr_t H5T__commit_named(const H5G_loc_t *loc, const char *name,
+    H5T_t *dt, hid_t lcpl_id, hid_t tcpl_id, hid_t tapl_id, hid_t dxpl_id);
+H5_DLL H5T_t *H5T__alloc(void);
+H5_DLL herr_t H5T__free(H5T_t *dt);
+H5_DLL herr_t H5T__visit(H5T_t *dt, unsigned visit_flags, H5T_operator_t op,
+    void *op_value);
+H5_DLL herr_t H5T__upgrade_version(H5T_t *dt, unsigned new_version);
+
+/* Conversion functions */
+H5_DLL herr_t H5T__conv_noop(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+			    size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *buf, void *bkg,
+                            hid_t dset_xfer_plist);
+
+H5_DLL herr_t H5T__conv_order(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+			    size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *_buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_order_opt(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+                            size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *_buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_struct(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+			    size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *_buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_struct_opt(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+                            size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *_buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_enum(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+			    size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_enum_numeric(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+			    size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_vlen(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+			    size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_array(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+			    size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_i_i(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+                            size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *_buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_f_f(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+			    size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *_buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_f_i(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+			    size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *_buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_i_f(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+			    size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *_buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_s_s(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+			    size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *_buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_b_b(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+			    size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *_buf, void *bkg,
+                            hid_t dset_xfer_plist);
+
+H5_DLL herr_t H5T__conv_schar_uchar(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+                            size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uchar_schar(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+                            size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_schar_short(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+                            size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_schar_ushort(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+                            size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uchar_short(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+                            size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uchar_ushort(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+                            size_t nelmts, size_t buf_stride,
+                            size_t bkg_stride, void *buf, void *bkg,
+                            hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_schar_int(hid_t src_id, hid_t dst_id,
+				  H5T_cdata_t *cdata, size_t nelmts,
+				  size_t buf_stride, size_t bkg_stride,
+                                  void *buf, void *bkg,
+                                  hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_schar_uint(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uchar_int(hid_t src_id, hid_t dst_id,
+				  H5T_cdata_t *cdata, size_t nelmts,
+				  size_t buf_stride, size_t bkg_stride,
+                                  void *buf, void *bkg,
+                                  hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uchar_uint(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_schar_long(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_schar_ulong(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uchar_long(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uchar_ulong(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_schar_llong(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_schar_ullong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uchar_llong(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uchar_ullong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+
+H5_DLL herr_t H5T__conv_short_schar(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_short_uchar(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ushort_schar(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ushort_uchar(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_short_ushort(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ushort_short(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_short_int(hid_t src_id, hid_t dst_id,
+				  H5T_cdata_t *cdata, size_t nelmts,
+				  size_t buf_stride, size_t bkg_stride,
+                                  void *buf, void *bkg,
+                                  hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_short_uint(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ushort_int(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ushort_uint(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_short_long(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_short_ulong(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ushort_long(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ushort_ulong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_short_llong(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_short_ullong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ushort_llong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ushort_ullong(hid_t src_id, hid_t dst_id,
+				      H5T_cdata_t *cdata, size_t nelmts,
+				      size_t buf_stride, size_t bkg_stride,
+                                      void *buf, void *bkg,
+                                      hid_t dset_xfer_plist);
+
+H5_DLL herr_t H5T__conv_int_schar(hid_t src_id, hid_t dst_id,
+				  H5T_cdata_t *cdata, size_t nelmts,
+				  size_t buf_stride, size_t bkg_stride,
+                                  void *buf, void *bkg,
+                                  hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_int_uchar(hid_t src_id, hid_t dst_id,
+				  H5T_cdata_t *cdata, size_t nelmts,
+				  size_t buf_stride, size_t bkg_stride,
+                                  void *buf, void *bkg,
+                                  hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uint_schar(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uint_uchar(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_int_short(hid_t src_id, hid_t dst_id,
+				  H5T_cdata_t *cdata, size_t nelmts,
+				  size_t buf_stride, size_t bkg_stride,
+                                  void *buf, void *bkg,
+                                  hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_int_ushort(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uint_short(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uint_ushort(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_int_uint(hid_t src_id, hid_t dst_id,
+				 H5T_cdata_t *cdata, size_t nelmts,
+				 size_t buf_stride, size_t bkg_stride,
+                                 void *buf, void *bkg,
+                                 hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uint_int(hid_t src_id, hid_t dst_id,
+				 H5T_cdata_t *cdata, size_t nelmts,
+				 size_t buf_stride, size_t bkg_stride,
+                                 void *buf, void *bkg,
+                                 hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_int_long(hid_t src_id, hid_t dst_id,
+				 H5T_cdata_t *cdata, size_t nelmts,
+				 size_t buf_stride, size_t bkg_stride,
+                                 void *buf, void *bkg,
+                                 hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_int_ulong(hid_t src_id, hid_t dst_id,
+				  H5T_cdata_t *cdata, size_t nelmts,
+				  size_t buf_stride, size_t bkg_stride,
+                                  void *buf, void *bkg,
+                                  hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uint_long(hid_t src_id, hid_t dst_id,
+				  H5T_cdata_t *cdata, size_t nelmts,
+				  size_t buf_stride, size_t bkg_stride,
+                                  void *buf, void *bkg,
+                                  hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uint_ulong(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_int_llong(hid_t src_id, hid_t dst_id,
+				  H5T_cdata_t *cdata, size_t nelmts,
+				  size_t buf_stride, size_t bkg_stride,
+                                  void *buf, void *bkg,
+                                  hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_int_ullong(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uint_llong(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uint_ullong(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+
+H5_DLL herr_t H5T__conv_long_schar(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_long_uchar(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ulong_schar(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ulong_uchar(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_long_short(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_long_ushort(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ulong_short(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ulong_ushort(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_long_int(hid_t src_id, hid_t dst_id,
+				 H5T_cdata_t *cdata, size_t nelmts,
+				 size_t buf_stride, size_t bkg_stride,
+                                 void *buf, void *bkg,
+                                 hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_long_uint(hid_t src_id, hid_t dst_id,
+				  H5T_cdata_t *cdata, size_t nelmts,
+				  size_t buf_stride, size_t bkg_stride,
+                                  void *buf, void *bkg,
+                                  hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ulong_int(hid_t src_id, hid_t dst_id,
+				  H5T_cdata_t *cdata, size_t nelmts,
+				  size_t buf_stride, size_t bkg_stride,
+                                  void *buf, void *bkg,
+                                  hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ulong_uint(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_long_ulong(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ulong_long(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_long_llong(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_long_ullong(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ulong_llong(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ulong_ullong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+
+H5_DLL herr_t H5T__conv_llong_schar(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_llong_uchar(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ullong_schar(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ullong_uchar(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_llong_short(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_llong_ushort(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ullong_short(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ullong_ushort(hid_t src_id, hid_t dst_id,
+				      H5T_cdata_t *cdata, size_t nelmts,
+				      size_t buf_stride, size_t bkg_stride,
+                                      void *buf, void *bkg,
+                                      hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_llong_int(hid_t src_id, hid_t dst_id,
+				  H5T_cdata_t *cdata, size_t nelmts,
+				  size_t buf_stride, size_t bkg_stride,
+                                  void *buf, void *bkg,
+                                  hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_llong_uint(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ullong_int(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ullong_uint(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_llong_long(hid_t src_id, hid_t dst_id,
+				   H5T_cdata_t *cdata, size_t nelmts,
+				   size_t buf_stride, size_t bkg_stride,
+                                   void *buf, void *bkg,
+                                   hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_llong_ulong(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ullong_long(hid_t src_id, hid_t dst_id,
+				    H5T_cdata_t *cdata, size_t nelmts,
+				    size_t buf_stride, size_t bkg_stride,
+                                    void *buf, void *bkg,
+                                    hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ullong_ulong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_llong_ullong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ullong_llong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_float_double(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_float_ldouble(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_double_float(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_double_ldouble(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ldouble_float(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ldouble_double(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_schar_float(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_schar_double(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_schar_ldouble(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uchar_float(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uchar_double(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uchar_ldouble(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_short_float(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_short_double(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_short_ldouble(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ushort_float(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ushort_double(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ushort_ldouble(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_int_float(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_int_double(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_int_ldouble(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uint_float(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uint_double(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_uint_ldouble(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_long_float(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_long_double(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_long_ldouble(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ulong_float(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ulong_double(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ulong_ldouble(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_llong_float(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_llong_double(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_llong_ldouble(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ullong_float(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ullong_double(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ullong_ldouble(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_float_schar(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_float_uchar(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_float_short(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_float_ushort(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_float_int(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_float_uint(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_float_long(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_float_ulong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_float_llong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_float_ullong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_double_schar(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_double_uchar(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_double_short(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_double_ushort(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_double_int(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_double_uint(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_double_long(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_double_ulong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_double_llong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_double_ullong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ldouble_schar(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ldouble_uchar(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ldouble_short(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ldouble_ushort(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ldouble_int(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ldouble_uint(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ldouble_long(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ldouble_ulong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ldouble_llong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+H5_DLL herr_t H5T__conv_ldouble_ullong(hid_t src_id, hid_t dst_id,
+				     H5T_cdata_t *cdata, size_t nelmts,
+				     size_t buf_stride, size_t bkg_stride,
+                                     void *buf, void *bkg,
+                                     hid_t dset_xfer_plist);
+
+/* Bit twiddling functions */
+H5_DLL void H5T__bit_copy(uint8_t *dst, size_t dst_offset, const uint8_t *src,
+			  size_t src_offset, size_t size);
+H5_DLL herr_t H5T__bit_shift(uint8_t *buf, ssize_t shift_dist, size_t offset, size_t size);
+H5_DLL void H5T__bit_set(uint8_t *buf, size_t offset, size_t size,
+			 hbool_t value);
+H5_DLL uint64_t H5T__bit_get_d(uint8_t *buf, size_t offset, size_t size);
+H5_DLL void H5T__bit_set_d(uint8_t *buf, size_t offset, size_t size,
+			   uint64_t val);
+H5_DLL ssize_t H5T__bit_find(uint8_t *buf, size_t offset, size_t size,
+			     H5T_sdir_t direction, hbool_t value);
+H5_DLL hbool_t H5T__bit_inc(uint8_t *buf, size_t start, size_t size);
+H5_DLL hbool_t H5T__bit_dec(uint8_t *buf, size_t start, size_t size);
+H5_DLL void H5T__bit_neg(uint8_t *buf, size_t start, size_t size);
+
+/* VL functions */
+H5_DLL H5T_t * H5T__vlen_create(const H5T_t *base);
+H5_DLL htri_t H5T__vlen_set_loc(const H5T_t *dt, H5F_t *f, H5T_loc_t loc);
+
+/* Array functions */
+H5_DLL H5T_t *H5T__array_create(H5T_t *base, unsigned ndims, const hsize_t dim[/* ndims */]);
+H5_DLL int    H5T__get_array_ndims(const H5T_t *dt);
+H5_DLL int    H5T__get_array_dims(const H5T_t *dt, hsize_t dims[]);
+
+/* Compound functions */
+H5_DLL herr_t H5T__insert(H5T_t *parent, const char *name, size_t offset,
+        const H5T_t *member);
+H5_DLL size_t H5T__get_member_size(const H5T_t *dt, unsigned membno);
+H5_DLL void H5T__update_packed(const H5T_t *dt);
+H5_DLL H5T_subset_info_t *H5T__conv_struct_subset(const H5T_cdata_t *cdata);
+
+/* Enumerated type functions */
+H5_DLL H5T_t *H5T__enum_create(const H5T_t *parent);
+H5_DLL herr_t H5T__enum_insert(const H5T_t *dt, const char *name, const void *value);
+H5_DLL herr_t H5T__get_member_value(const H5T_t *dt, unsigned membno, void *value);
+
+/* Field functions (for both compound & enumerated types) */
+H5_DLL char  *H5T__get_member_name(H5T_t const *dt, unsigned membno);
+H5_DLL herr_t H5T__sort_value(const H5T_t *dt, int *map);
+H5_DLL herr_t H5T__sort_name(const H5T_t *dt, int *map);
+
+/* Debugging functions */
+H5_DLL herr_t H5T__print_stats(H5T_path_t *path, int *nprint/*in,out*/);
+
+#endif /* _H5Tpkg_H */
+
diff --git a/install/include/H5Tpublic.h b/install/include/H5Tpublic.h
new file mode 100644
index 0000000000..fc3e4ee340
--- /dev/null
+++ b/install/include/H5Tpublic.h
@@ -0,0 +1,621 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5T module.
+ */
+#ifndef _H5Tpublic_H
+#define _H5Tpublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+#include "H5Ipublic.h"
+
+#define HOFFSET(S,M)    (offsetof(S,M))
+
+/* These are the various classes of datatypes */
+/* If this goes over 16 types (0-15), the file format will need to change) */
+typedef enum H5T_class_t {
+    H5T_NO_CLASS         = -1,  /*error                                      */
+    H5T_INTEGER          = 0,   /*integer types                              */
+    H5T_FLOAT            = 1,   /*floating-point types                       */
+    H5T_TIME             = 2,   /*date and time types                        */
+    H5T_STRING           = 3,   /*character string types                     */
+    H5T_BITFIELD         = 4,   /*bit field types                            */
+    H5T_OPAQUE           = 5,   /*opaque types                               */
+    H5T_COMPOUND         = 6,   /*compound types                             */
+    H5T_REFERENCE        = 7,   /*reference types                            */
+    H5T_ENUM		 = 8,	/*enumeration types                          */
+    H5T_VLEN		 = 9,	/*Variable-Length types                      */
+    H5T_ARRAY	         = 10,	/*Array types                                */
+
+    H5T_NCLASSES                /*this must be last                          */
+} H5T_class_t;
+
+/* Byte orders */
+typedef enum H5T_order_t {
+    H5T_ORDER_ERROR      = -1,  /*error                                      */
+    H5T_ORDER_LE         = 0,   /*little endian                              */
+    H5T_ORDER_BE         = 1,   /*bit endian                                 */
+    H5T_ORDER_VAX        = 2,   /*VAX mixed endian                           */
+    H5T_ORDER_MIXED      = 3,   /*Compound type with mixed member orders     */
+    H5T_ORDER_NONE       = 4    /*no particular order (strings, bits,..)     */
+    /*H5T_ORDER_NONE must be last */
+} H5T_order_t;
+
+/* Types of integer sign schemes */
+typedef enum H5T_sign_t {
+    H5T_SGN_ERROR        = -1,  /*error                                      */
+    H5T_SGN_NONE         = 0,   /*this is an unsigned type                   */
+    H5T_SGN_2            = 1,   /*two's complement                           */
+
+    H5T_NSGN             = 2    /*this must be last!                         */
+} H5T_sign_t;
+
+/* Floating-point normalization schemes */
+typedef enum H5T_norm_t {
+    H5T_NORM_ERROR       = -1,  /*error                                      */
+    H5T_NORM_IMPLIED     = 0,   /*msb of mantissa isn't stored, always 1     */
+    H5T_NORM_MSBSET      = 1,   /*msb of mantissa is always 1                */
+    H5T_NORM_NONE        = 2    /*not normalized                             */
+    /*H5T_NORM_NONE must be last */
+} H5T_norm_t;
+
+/*
+ * Character set to use for text strings.  Do not change these values since
+ * they appear in HDF5 files!
+ */
+typedef enum H5T_cset_t {
+    H5T_CSET_ERROR       = -1,  /*error                                      */
+    H5T_CSET_ASCII       = 0,   /*US ASCII                                   */
+    H5T_CSET_UTF8        = 1,   /*UTF-8 Unicode encoding		     */
+    H5T_CSET_RESERVED_2  = 2,   /*reserved for later use		     */
+    H5T_CSET_RESERVED_3  = 3,   /*reserved for later use		     */
+    H5T_CSET_RESERVED_4  = 4,   /*reserved for later use		     */
+    H5T_CSET_RESERVED_5  = 5,   /*reserved for later use		     */
+    H5T_CSET_RESERVED_6  = 6,   /*reserved for later use		     */
+    H5T_CSET_RESERVED_7  = 7,   /*reserved for later use		     */
+    H5T_CSET_RESERVED_8  = 8,   /*reserved for later use		     */
+    H5T_CSET_RESERVED_9  = 9,   /*reserved for later use		     */
+    H5T_CSET_RESERVED_10 = 10,  /*reserved for later use		     */
+    H5T_CSET_RESERVED_11 = 11,  /*reserved for later use		     */
+    H5T_CSET_RESERVED_12 = 12,  /*reserved for later use		     */
+    H5T_CSET_RESERVED_13 = 13,  /*reserved for later use		     */
+    H5T_CSET_RESERVED_14 = 14,  /*reserved for later use		     */
+    H5T_CSET_RESERVED_15 = 15   /*reserved for later use		     */
+} H5T_cset_t;
+#define H5T_NCSET H5T_CSET_RESERVED_2    		/*Number of character sets actually defined  */
+
+/*
+ * Type of padding to use in character strings.  Do not change these values
+ * since they appear in HDF5 files!
+ */
+typedef enum H5T_str_t {
+    H5T_STR_ERROR        = -1,  /*error                                      */
+    H5T_STR_NULLTERM     = 0,   /*null terminate like in C                   */
+    H5T_STR_NULLPAD      = 1,   /*pad with nulls                             */
+    H5T_STR_SPACEPAD     = 2,   /*pad with spaces like in Fortran            */
+    H5T_STR_RESERVED_3   = 3,   /*reserved for later use		     */
+    H5T_STR_RESERVED_4   = 4,   /*reserved for later use		     */
+    H5T_STR_RESERVED_5   = 5,   /*reserved for later use		     */
+    H5T_STR_RESERVED_6   = 6,   /*reserved for later use		     */
+    H5T_STR_RESERVED_7   = 7,   /*reserved for later use		     */
+    H5T_STR_RESERVED_8   = 8,   /*reserved for later use		     */
+    H5T_STR_RESERVED_9   = 9,   /*reserved for later use		     */
+    H5T_STR_RESERVED_10  = 10,  /*reserved for later use		     */
+    H5T_STR_RESERVED_11  = 11,  /*reserved for later use		     */
+    H5T_STR_RESERVED_12  = 12,  /*reserved for later use		     */
+    H5T_STR_RESERVED_13  = 13,  /*reserved for later use		     */
+    H5T_STR_RESERVED_14  = 14,  /*reserved for later use		     */
+    H5T_STR_RESERVED_15  = 15   /*reserved for later use		     */
+} H5T_str_t;
+#define H5T_NSTR H5T_STR_RESERVED_3		/*num H5T_str_t types actually defined	     */
+
+/* Type of padding to use in other atomic types */
+typedef enum H5T_pad_t {
+    H5T_PAD_ERROR        = -1,  /*error                                      */
+    H5T_PAD_ZERO         = 0,   /*always set to zero                         */
+    H5T_PAD_ONE          = 1,   /*always set to one                          */
+    H5T_PAD_BACKGROUND   = 2,   /*set to background value                    */
+
+    H5T_NPAD             = 3    /*THIS MUST BE LAST                          */
+} H5T_pad_t;
+
+/* Commands sent to conversion functions */
+typedef enum H5T_cmd_t {
+    H5T_CONV_INIT	= 0,	/*query and/or initialize private data	     */
+    H5T_CONV_CONV	= 1, 	/*convert data from source to dest datatype */
+    H5T_CONV_FREE	= 2	/*function is being removed from path	     */
+} H5T_cmd_t;
+
+/* How is the `bkg' buffer used by the conversion function? */
+typedef enum H5T_bkg_t {
+    H5T_BKG_NO		= 0, 	/*background buffer is not needed, send NULL */
+    H5T_BKG_TEMP	= 1,	/*bkg buffer used as temp storage only       */
+    H5T_BKG_YES		= 2	/*init bkg buf with data before conversion   */
+} H5T_bkg_t;
+
+/* Type conversion client data */
+typedef struct H5T_cdata_t {
+    H5T_cmd_t		command;/*what should the conversion function do?    */
+    H5T_bkg_t		need_bkg;/*is the background buffer needed?	     */
+    hbool_t		recalc;	/*recalculate private data		     */
+    void		*priv;	/*private data				     */
+} H5T_cdata_t;
+
+/* Conversion function persistence */
+typedef enum H5T_pers_t {
+    H5T_PERS_DONTCARE	= -1, 	/*wild card				     */
+    H5T_PERS_HARD	= 0,	/*hard conversion function		     */
+    H5T_PERS_SOFT	= 1 	/*soft conversion function		     */
+} H5T_pers_t;
+
+/* The order to retrieve atomic native datatype */
+typedef enum H5T_direction_t {
+    H5T_DIR_DEFAULT     = 0,    /*default direction is inscendent            */
+    H5T_DIR_ASCEND      = 1,    /*in inscendent order                        */
+    H5T_DIR_DESCEND     = 2     /*in descendent order                        */
+} H5T_direction_t;
+
+/* The exception type passed into the conversion callback function */
+typedef enum H5T_conv_except_t {
+    H5T_CONV_EXCEPT_RANGE_HI       = 0,   /*source value is greater than destination's range */
+    H5T_CONV_EXCEPT_RANGE_LOW      = 1,   /*source value is less than destination's range    */
+    H5T_CONV_EXCEPT_PRECISION      = 2,   /*source value loses precision in destination      */
+    H5T_CONV_EXCEPT_TRUNCATE       = 3,   /*source value is truncated in destination         */
+    H5T_CONV_EXCEPT_PINF           = 4,   /*source value is positive infinity(floating number) */
+    H5T_CONV_EXCEPT_NINF           = 5,   /*source value is negative infinity(floating number) */
+    H5T_CONV_EXCEPT_NAN            = 6    /*source value is NaN(floating number)             */
+} H5T_conv_except_t;
+
+/* The return value from conversion callback function H5T_conv_except_func_t */
+typedef enum H5T_conv_ret_t {
+    H5T_CONV_ABORT      = -1,   /*abort conversion                           */
+    H5T_CONV_UNHANDLED  = 0,    /*callback function failed to handle the exception      */
+    H5T_CONV_HANDLED    = 1     /*callback function handled the exception successfully  */
+} H5T_conv_ret_t;
+
+/* Variable Length Datatype struct in memory */
+/* (This is only used for VL sequences, not VL strings, which are stored in char *'s) */
+typedef struct {
+    size_t len; /* Length of VL data (in base type units) */
+    void *p;    /* Pointer to VL data */
+} hvl_t;
+
+/* Variable Length String information */
+#define H5T_VARIABLE    ((size_t)(-1))  /* Indicate that a string is variable length (null-terminated in C, instead of fixed length) */
+
+/* Opaque information */
+#define H5T_OPAQUE_TAG_MAX      256     /* Maximum length of an opaque tag */
+                                        /* This could be raised without too much difficulty */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* All datatype conversion functions are... */
+typedef herr_t (*H5T_conv_t) (hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+      size_t nelmts, size_t buf_stride, size_t bkg_stride, void *buf,
+      void *bkg, hid_t dset_xfer_plist);
+
+/* Exception handler.  If an exception like overflow happenes during conversion,
+ * this function is called if it's registered through H5Pset_type_conv_cb.
+ */
+typedef H5T_conv_ret_t (*H5T_conv_except_func_t)(H5T_conv_except_t except_type,
+    hid_t src_id, hid_t dst_id, void *src_buf, void *dst_buf, void *user_data);
+
+/* When this header is included from a private header, don't make calls to H5open() */
+#undef H5OPEN
+#ifndef _H5private_H
+#define H5OPEN          H5open(),
+#else   /* _H5private_H */
+#define H5OPEN
+#endif  /* _H5private_H */
+
+/*
+ * The IEEE floating point types in various byte orders.
+ */
+#define H5T_IEEE_F32BE		(H5OPEN H5T_IEEE_F32BE_g)
+#define H5T_IEEE_F32LE		(H5OPEN H5T_IEEE_F32LE_g)
+#define H5T_IEEE_F64BE		(H5OPEN H5T_IEEE_F64BE_g)
+#define H5T_IEEE_F64LE		(H5OPEN H5T_IEEE_F64LE_g)
+H5_DLLVAR hid_t H5T_IEEE_F32BE_g;
+H5_DLLVAR hid_t H5T_IEEE_F32LE_g;
+H5_DLLVAR hid_t H5T_IEEE_F64BE_g;
+H5_DLLVAR hid_t H5T_IEEE_F64LE_g;
+
+/*
+ * These are "standard" types.  For instance, signed (2's complement) and
+ * unsigned integers of various sizes and byte orders.
+ */
+#define H5T_STD_I8BE		(H5OPEN H5T_STD_I8BE_g)
+#define H5T_STD_I8LE		(H5OPEN H5T_STD_I8LE_g)
+#define H5T_STD_I16BE		(H5OPEN H5T_STD_I16BE_g)
+#define H5T_STD_I16LE		(H5OPEN H5T_STD_I16LE_g)
+#define H5T_STD_I32BE		(H5OPEN H5T_STD_I32BE_g)
+#define H5T_STD_I32LE		(H5OPEN H5T_STD_I32LE_g)
+#define H5T_STD_I64BE		(H5OPEN H5T_STD_I64BE_g)
+#define H5T_STD_I64LE		(H5OPEN H5T_STD_I64LE_g)
+#define H5T_STD_U8BE		(H5OPEN H5T_STD_U8BE_g)
+#define H5T_STD_U8LE		(H5OPEN H5T_STD_U8LE_g)
+#define H5T_STD_U16BE		(H5OPEN H5T_STD_U16BE_g)
+#define H5T_STD_U16LE		(H5OPEN H5T_STD_U16LE_g)
+#define H5T_STD_U32BE		(H5OPEN H5T_STD_U32BE_g)
+#define H5T_STD_U32LE		(H5OPEN H5T_STD_U32LE_g)
+#define H5T_STD_U64BE		(H5OPEN H5T_STD_U64BE_g)
+#define H5T_STD_U64LE		(H5OPEN H5T_STD_U64LE_g)
+#define H5T_STD_B8BE		(H5OPEN H5T_STD_B8BE_g)
+#define H5T_STD_B8LE		(H5OPEN H5T_STD_B8LE_g)
+#define H5T_STD_B16BE		(H5OPEN H5T_STD_B16BE_g)
+#define H5T_STD_B16LE		(H5OPEN H5T_STD_B16LE_g)
+#define H5T_STD_B32BE		(H5OPEN H5T_STD_B32BE_g)
+#define H5T_STD_B32LE		(H5OPEN H5T_STD_B32LE_g)
+#define H5T_STD_B64BE		(H5OPEN H5T_STD_B64BE_g)
+#define H5T_STD_B64LE		(H5OPEN H5T_STD_B64LE_g)
+#define H5T_STD_REF_OBJ	        (H5OPEN H5T_STD_REF_OBJ_g)
+#define H5T_STD_REF_DSETREG     (H5OPEN H5T_STD_REF_DSETREG_g)
+H5_DLLVAR hid_t H5T_STD_I8BE_g;
+H5_DLLVAR hid_t H5T_STD_I8LE_g;
+H5_DLLVAR hid_t H5T_STD_I16BE_g;
+H5_DLLVAR hid_t H5T_STD_I16LE_g;
+H5_DLLVAR hid_t H5T_STD_I32BE_g;
+H5_DLLVAR hid_t H5T_STD_I32LE_g;
+H5_DLLVAR hid_t H5T_STD_I64BE_g;
+H5_DLLVAR hid_t H5T_STD_I64LE_g;
+H5_DLLVAR hid_t H5T_STD_U8BE_g;
+H5_DLLVAR hid_t H5T_STD_U8LE_g;
+H5_DLLVAR hid_t H5T_STD_U16BE_g;
+H5_DLLVAR hid_t H5T_STD_U16LE_g;
+H5_DLLVAR hid_t H5T_STD_U32BE_g;
+H5_DLLVAR hid_t H5T_STD_U32LE_g;
+H5_DLLVAR hid_t H5T_STD_U64BE_g;
+H5_DLLVAR hid_t H5T_STD_U64LE_g;
+H5_DLLVAR hid_t H5T_STD_B8BE_g;
+H5_DLLVAR hid_t H5T_STD_B8LE_g;
+H5_DLLVAR hid_t H5T_STD_B16BE_g;
+H5_DLLVAR hid_t H5T_STD_B16LE_g;
+H5_DLLVAR hid_t H5T_STD_B32BE_g;
+H5_DLLVAR hid_t H5T_STD_B32LE_g;
+H5_DLLVAR hid_t H5T_STD_B64BE_g;
+H5_DLLVAR hid_t H5T_STD_B64LE_g;
+H5_DLLVAR hid_t H5T_STD_REF_OBJ_g;
+H5_DLLVAR hid_t H5T_STD_REF_DSETREG_g;
+
+/*
+ * Types which are particular to Unix.
+ */
+#define H5T_UNIX_D32BE		(H5OPEN H5T_UNIX_D32BE_g)
+#define H5T_UNIX_D32LE		(H5OPEN H5T_UNIX_D32LE_g)
+#define H5T_UNIX_D64BE		(H5OPEN H5T_UNIX_D64BE_g)
+#define H5T_UNIX_D64LE		(H5OPEN H5T_UNIX_D64LE_g)
+H5_DLLVAR hid_t H5T_UNIX_D32BE_g;
+H5_DLLVAR hid_t H5T_UNIX_D32LE_g;
+H5_DLLVAR hid_t H5T_UNIX_D64BE_g;
+H5_DLLVAR hid_t H5T_UNIX_D64LE_g;
+
+/*
+ * Types particular to the C language.  String types use `bytes' instead
+ * of `bits' as their size.
+ */
+#define H5T_C_S1		(H5OPEN H5T_C_S1_g)
+H5_DLLVAR hid_t H5T_C_S1_g;
+
+/*
+ * Types particular to Fortran.
+ */
+#define H5T_FORTRAN_S1		(H5OPEN H5T_FORTRAN_S1_g)
+H5_DLLVAR hid_t H5T_FORTRAN_S1_g;
+
+/*
+ * These types are for Intel CPU's.  They are little endian with IEEE
+ * floating point.
+ */
+#define H5T_INTEL_I8		H5T_STD_I8LE
+#define H5T_INTEL_I16		H5T_STD_I16LE
+#define H5T_INTEL_I32		H5T_STD_I32LE
+#define H5T_INTEL_I64		H5T_STD_I64LE
+#define H5T_INTEL_U8		H5T_STD_U8LE
+#define H5T_INTEL_U16		H5T_STD_U16LE
+#define H5T_INTEL_U32		H5T_STD_U32LE
+#define H5T_INTEL_U64		H5T_STD_U64LE
+#define H5T_INTEL_B8		H5T_STD_B8LE
+#define H5T_INTEL_B16		H5T_STD_B16LE
+#define H5T_INTEL_B32		H5T_STD_B32LE
+#define H5T_INTEL_B64		H5T_STD_B64LE
+#define H5T_INTEL_F32		H5T_IEEE_F32LE
+#define H5T_INTEL_F64		H5T_IEEE_F64LE
+
+/*
+ * These types are for DEC Alpha CPU's.  They are little endian with IEEE
+ * floating point.
+ */
+#define H5T_ALPHA_I8		H5T_STD_I8LE
+#define H5T_ALPHA_I16		H5T_STD_I16LE
+#define H5T_ALPHA_I32		H5T_STD_I32LE
+#define H5T_ALPHA_I64		H5T_STD_I64LE
+#define H5T_ALPHA_U8		H5T_STD_U8LE
+#define H5T_ALPHA_U16		H5T_STD_U16LE
+#define H5T_ALPHA_U32		H5T_STD_U32LE
+#define H5T_ALPHA_U64		H5T_STD_U64LE
+#define H5T_ALPHA_B8		H5T_STD_B8LE
+#define H5T_ALPHA_B16		H5T_STD_B16LE
+#define H5T_ALPHA_B32		H5T_STD_B32LE
+#define H5T_ALPHA_B64		H5T_STD_B64LE
+#define H5T_ALPHA_F32		H5T_IEEE_F32LE
+#define H5T_ALPHA_F64		H5T_IEEE_F64LE
+
+/*
+ * These types are for MIPS cpu's commonly used in SGI systems. They are big
+ * endian with IEEE floating point.
+ */
+#define H5T_MIPS_I8		H5T_STD_I8BE
+#define H5T_MIPS_I16		H5T_STD_I16BE
+#define H5T_MIPS_I32		H5T_STD_I32BE
+#define H5T_MIPS_I64		H5T_STD_I64BE
+#define H5T_MIPS_U8		H5T_STD_U8BE
+#define H5T_MIPS_U16		H5T_STD_U16BE
+#define H5T_MIPS_U32		H5T_STD_U32BE
+#define H5T_MIPS_U64		H5T_STD_U64BE
+#define H5T_MIPS_B8		H5T_STD_B8BE
+#define H5T_MIPS_B16		H5T_STD_B16BE
+#define H5T_MIPS_B32		H5T_STD_B32BE
+#define H5T_MIPS_B64		H5T_STD_B64BE
+#define H5T_MIPS_F32		H5T_IEEE_F32BE
+#define H5T_MIPS_F64		H5T_IEEE_F64BE
+
+/*
+ * The VAX floating point types (i.e. in VAX byte order)
+ */
+#define H5T_VAX_F32		(H5OPEN H5T_VAX_F32_g)
+#define H5T_VAX_F64		(H5OPEN H5T_VAX_F64_g)
+H5_DLLVAR hid_t H5T_VAX_F32_g;
+H5_DLLVAR hid_t H5T_VAX_F64_g;
+
+/*
+ * The predefined native types. These are the types detected by H5detect and
+ * they violate the naming scheme a little.  Instead of a class name,
+ * precision and byte order as the last component, they have a C-like type
+ * name.  If the type begins with `U' then it is the unsigned version of the
+ * integer type; other integer types are signed.  The type LLONG corresponds
+ * to C's `long long' and LDOUBLE is `long double' (these types might be the
+ * same as `LONG' and `DOUBLE' respectively).
+ */
+#define H5T_NATIVE_CHAR		(CHAR_MIN?H5T_NATIVE_SCHAR:H5T_NATIVE_UCHAR)
+#define H5T_NATIVE_SCHAR        (H5OPEN H5T_NATIVE_SCHAR_g)
+#define H5T_NATIVE_UCHAR        (H5OPEN H5T_NATIVE_UCHAR_g)
+#define H5T_NATIVE_SHORT        (H5OPEN H5T_NATIVE_SHORT_g)
+#define H5T_NATIVE_USHORT       (H5OPEN H5T_NATIVE_USHORT_g)
+#define H5T_NATIVE_INT          (H5OPEN H5T_NATIVE_INT_g)
+#define H5T_NATIVE_UINT         (H5OPEN H5T_NATIVE_UINT_g)
+#define H5T_NATIVE_LONG         (H5OPEN H5T_NATIVE_LONG_g)
+#define H5T_NATIVE_ULONG        (H5OPEN H5T_NATIVE_ULONG_g)
+#define H5T_NATIVE_LLONG        (H5OPEN H5T_NATIVE_LLONG_g)
+#define H5T_NATIVE_ULLONG       (H5OPEN H5T_NATIVE_ULLONG_g)
+#define H5T_NATIVE_FLOAT        (H5OPEN H5T_NATIVE_FLOAT_g)
+#define H5T_NATIVE_DOUBLE       (H5OPEN H5T_NATIVE_DOUBLE_g)
+#if H5_SIZEOF_LONG_DOUBLE !=0
+#define H5T_NATIVE_LDOUBLE	(H5OPEN H5T_NATIVE_LDOUBLE_g)
+#endif
+#define H5T_NATIVE_B8		(H5OPEN H5T_NATIVE_B8_g)
+#define H5T_NATIVE_B16		(H5OPEN H5T_NATIVE_B16_g)
+#define H5T_NATIVE_B32		(H5OPEN H5T_NATIVE_B32_g)
+#define H5T_NATIVE_B64		(H5OPEN H5T_NATIVE_B64_g)
+#define H5T_NATIVE_OPAQUE       (H5OPEN H5T_NATIVE_OPAQUE_g)
+#define H5T_NATIVE_HADDR	(H5OPEN H5T_NATIVE_HADDR_g)
+#define H5T_NATIVE_HSIZE	(H5OPEN H5T_NATIVE_HSIZE_g)
+#define H5T_NATIVE_HSSIZE	(H5OPEN H5T_NATIVE_HSSIZE_g)
+#define H5T_NATIVE_HERR		(H5OPEN H5T_NATIVE_HERR_g)
+#define H5T_NATIVE_HBOOL	(H5OPEN H5T_NATIVE_HBOOL_g)
+H5_DLLVAR hid_t H5T_NATIVE_SCHAR_g;
+H5_DLLVAR hid_t H5T_NATIVE_UCHAR_g;
+H5_DLLVAR hid_t H5T_NATIVE_SHORT_g;
+H5_DLLVAR hid_t H5T_NATIVE_USHORT_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_g;
+H5_DLLVAR hid_t H5T_NATIVE_LONG_g;
+H5_DLLVAR hid_t H5T_NATIVE_ULONG_g;
+H5_DLLVAR hid_t H5T_NATIVE_LLONG_g;
+H5_DLLVAR hid_t H5T_NATIVE_ULLONG_g;
+H5_DLLVAR hid_t H5T_NATIVE_FLOAT_g;
+H5_DLLVAR hid_t H5T_NATIVE_DOUBLE_g;
+#if H5_SIZEOF_LONG_DOUBLE !=0
+H5_DLLVAR hid_t H5T_NATIVE_LDOUBLE_g;
+#endif
+H5_DLLVAR hid_t H5T_NATIVE_B8_g;
+H5_DLLVAR hid_t H5T_NATIVE_B16_g;
+H5_DLLVAR hid_t H5T_NATIVE_B32_g;
+H5_DLLVAR hid_t H5T_NATIVE_B64_g;
+H5_DLLVAR hid_t H5T_NATIVE_OPAQUE_g;
+H5_DLLVAR hid_t H5T_NATIVE_HADDR_g;
+H5_DLLVAR hid_t H5T_NATIVE_HSIZE_g;
+H5_DLLVAR hid_t H5T_NATIVE_HSSIZE_g;
+H5_DLLVAR hid_t H5T_NATIVE_HERR_g;
+H5_DLLVAR hid_t H5T_NATIVE_HBOOL_g;
+
+/* C9x integer types */
+#define H5T_NATIVE_INT8			(H5OPEN H5T_NATIVE_INT8_g)
+#define H5T_NATIVE_UINT8		(H5OPEN H5T_NATIVE_UINT8_g)
+#define H5T_NATIVE_INT_LEAST8		(H5OPEN H5T_NATIVE_INT_LEAST8_g)
+#define H5T_NATIVE_UINT_LEAST8		(H5OPEN H5T_NATIVE_UINT_LEAST8_g)
+#define H5T_NATIVE_INT_FAST8 		(H5OPEN H5T_NATIVE_INT_FAST8_g)
+#define H5T_NATIVE_UINT_FAST8		(H5OPEN H5T_NATIVE_UINT_FAST8_g)
+H5_DLLVAR hid_t H5T_NATIVE_INT8_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT8_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_LEAST8_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_LEAST8_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_FAST8_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_FAST8_g;
+
+#define H5T_NATIVE_INT16		(H5OPEN H5T_NATIVE_INT16_g)
+#define H5T_NATIVE_UINT16		(H5OPEN H5T_NATIVE_UINT16_g)
+#define H5T_NATIVE_INT_LEAST16		(H5OPEN H5T_NATIVE_INT_LEAST16_g)
+#define H5T_NATIVE_UINT_LEAST16		(H5OPEN H5T_NATIVE_UINT_LEAST16_g)
+#define H5T_NATIVE_INT_FAST16		(H5OPEN H5T_NATIVE_INT_FAST16_g)
+#define H5T_NATIVE_UINT_FAST16		(H5OPEN H5T_NATIVE_UINT_FAST16_g)
+H5_DLLVAR hid_t H5T_NATIVE_INT16_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT16_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_LEAST16_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_LEAST16_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_FAST16_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_FAST16_g;
+
+#define H5T_NATIVE_INT32		(H5OPEN H5T_NATIVE_INT32_g)
+#define H5T_NATIVE_UINT32		(H5OPEN H5T_NATIVE_UINT32_g)
+#define H5T_NATIVE_INT_LEAST32		(H5OPEN H5T_NATIVE_INT_LEAST32_g)
+#define H5T_NATIVE_UINT_LEAST32		(H5OPEN H5T_NATIVE_UINT_LEAST32_g)
+#define H5T_NATIVE_INT_FAST32		(H5OPEN H5T_NATIVE_INT_FAST32_g)
+#define H5T_NATIVE_UINT_FAST32		(H5OPEN H5T_NATIVE_UINT_FAST32_g)
+H5_DLLVAR hid_t H5T_NATIVE_INT32_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT32_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_LEAST32_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_LEAST32_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_FAST32_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_FAST32_g;
+
+#define H5T_NATIVE_INT64		(H5OPEN H5T_NATIVE_INT64_g)
+#define H5T_NATIVE_UINT64		(H5OPEN H5T_NATIVE_UINT64_g)
+#define H5T_NATIVE_INT_LEAST64		(H5OPEN H5T_NATIVE_INT_LEAST64_g)
+#define H5T_NATIVE_UINT_LEAST64 	(H5OPEN H5T_NATIVE_UINT_LEAST64_g)
+#define H5T_NATIVE_INT_FAST64		(H5OPEN H5T_NATIVE_INT_FAST64_g)
+#define H5T_NATIVE_UINT_FAST64		(H5OPEN H5T_NATIVE_UINT_FAST64_g)
+H5_DLLVAR hid_t H5T_NATIVE_INT64_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT64_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_LEAST64_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_LEAST64_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_FAST64_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_FAST64_g;
+
+/* Operations defined on all datatypes */
+H5_DLL hid_t H5Tcreate(H5T_class_t type, size_t size);
+H5_DLL hid_t H5Tcopy(hid_t type_id);
+H5_DLL herr_t H5Tclose(hid_t type_id);
+H5_DLL htri_t H5Tequal(hid_t type1_id, hid_t type2_id);
+H5_DLL herr_t H5Tlock(hid_t type_id);
+H5_DLL herr_t H5Tcommit2(hid_t loc_id, const char *name, hid_t type_id,
+    hid_t lcpl_id, hid_t tcpl_id, hid_t tapl_id);
+H5_DLL hid_t H5Topen2(hid_t loc_id, const char *name, hid_t tapl_id);
+H5_DLL herr_t H5Tcommit_anon(hid_t loc_id, hid_t type_id, hid_t tcpl_id, hid_t tapl_id);
+H5_DLL hid_t H5Tget_create_plist(hid_t type_id);
+H5_DLL htri_t H5Tcommitted(hid_t type_id);
+H5_DLL herr_t H5Tencode(hid_t obj_id, void *buf, size_t *nalloc);
+H5_DLL hid_t H5Tdecode(const void *buf);
+H5_DLL herr_t H5Tflush(hid_t type_id);
+H5_DLL herr_t H5Trefresh(hid_t type_id);
+
+/* Operations defined on compound datatypes */
+H5_DLL herr_t H5Tinsert(hid_t parent_id, const char *name, size_t offset,
+			 hid_t member_id);
+H5_DLL herr_t H5Tpack(hid_t type_id);
+
+/* Operations defined on enumeration datatypes */
+H5_DLL hid_t H5Tenum_create(hid_t base_id);
+H5_DLL herr_t H5Tenum_insert(hid_t type, const char *name, const void *value);
+H5_DLL herr_t H5Tenum_nameof(hid_t type, const void *value, char *name/*out*/,
+			     size_t size);
+H5_DLL herr_t H5Tenum_valueof(hid_t type, const char *name,
+			      void *value/*out*/);
+
+/* Operations defined on variable-length datatypes */
+H5_DLL hid_t H5Tvlen_create(hid_t base_id);
+
+/* Operations defined on array datatypes */
+H5_DLL hid_t H5Tarray_create2(hid_t base_id, unsigned ndims,
+            const hsize_t dim[/* ndims */]);
+H5_DLL int H5Tget_array_ndims(hid_t type_id);
+H5_DLL int H5Tget_array_dims2(hid_t type_id, hsize_t dims[]);
+
+/* Operations defined on opaque datatypes */
+H5_DLL herr_t H5Tset_tag(hid_t type, const char *tag);
+H5_DLL char *H5Tget_tag(hid_t type);
+
+/* Querying property values */
+H5_DLL hid_t H5Tget_super(hid_t type);
+H5_DLL H5T_class_t H5Tget_class(hid_t type_id);
+H5_DLL htri_t H5Tdetect_class(hid_t type_id, H5T_class_t cls);
+H5_DLL size_t H5Tget_size(hid_t type_id);
+H5_DLL H5T_order_t H5Tget_order(hid_t type_id);
+H5_DLL size_t H5Tget_precision(hid_t type_id);
+H5_DLL int H5Tget_offset(hid_t type_id);
+H5_DLL herr_t H5Tget_pad(hid_t type_id, H5T_pad_t *lsb/*out*/,
+			  H5T_pad_t *msb/*out*/);
+H5_DLL H5T_sign_t H5Tget_sign(hid_t type_id);
+H5_DLL herr_t H5Tget_fields(hid_t type_id, size_t *spos/*out*/,
+			     size_t *epos/*out*/, size_t *esize/*out*/,
+			     size_t *mpos/*out*/, size_t *msize/*out*/);
+H5_DLL size_t H5Tget_ebias(hid_t type_id);
+H5_DLL H5T_norm_t H5Tget_norm(hid_t type_id);
+H5_DLL H5T_pad_t H5Tget_inpad(hid_t type_id);
+H5_DLL H5T_str_t H5Tget_strpad(hid_t type_id);
+H5_DLL int H5Tget_nmembers(hid_t type_id);
+H5_DLL char *H5Tget_member_name(hid_t type_id, unsigned membno);
+H5_DLL int H5Tget_member_index(hid_t type_id, const char *name);
+H5_DLL size_t H5Tget_member_offset(hid_t type_id, unsigned membno);
+H5_DLL H5T_class_t H5Tget_member_class(hid_t type_id, unsigned membno);
+H5_DLL hid_t H5Tget_member_type(hid_t type_id, unsigned membno);
+H5_DLL herr_t H5Tget_member_value(hid_t type_id, unsigned membno, void *value/*out*/);
+H5_DLL H5T_cset_t H5Tget_cset(hid_t type_id);
+H5_DLL htri_t H5Tis_variable_str(hid_t type_id);
+H5_DLL hid_t H5Tget_native_type(hid_t type_id, H5T_direction_t direction);
+
+/* Setting property values */
+H5_DLL herr_t H5Tset_size(hid_t type_id, size_t size);
+H5_DLL herr_t H5Tset_order(hid_t type_id, H5T_order_t order);
+H5_DLL herr_t H5Tset_precision(hid_t type_id, size_t prec);
+H5_DLL herr_t H5Tset_offset(hid_t type_id, size_t offset);
+H5_DLL herr_t H5Tset_pad(hid_t type_id, H5T_pad_t lsb, H5T_pad_t msb);
+H5_DLL herr_t H5Tset_sign(hid_t type_id, H5T_sign_t sign);
+H5_DLL herr_t H5Tset_fields(hid_t type_id, size_t spos, size_t epos,
+			     size_t esize, size_t mpos, size_t msize);
+H5_DLL herr_t H5Tset_ebias(hid_t type_id, size_t ebias);
+H5_DLL herr_t H5Tset_norm(hid_t type_id, H5T_norm_t norm);
+H5_DLL herr_t H5Tset_inpad(hid_t type_id, H5T_pad_t pad);
+H5_DLL herr_t H5Tset_cset(hid_t type_id, H5T_cset_t cset);
+H5_DLL herr_t H5Tset_strpad(hid_t type_id, H5T_str_t strpad);
+
+/* Type conversion database */
+H5_DLL herr_t H5Tregister(H5T_pers_t pers, const char *name, hid_t src_id,
+			   hid_t dst_id, H5T_conv_t func);
+H5_DLL herr_t H5Tunregister(H5T_pers_t pers, const char *name, hid_t src_id,
+			     hid_t dst_id, H5T_conv_t func);
+H5_DLL H5T_conv_t H5Tfind(hid_t src_id, hid_t dst_id, H5T_cdata_t **pcdata);
+H5_DLL htri_t H5Tcompiler_conv(hid_t src_id, hid_t dst_id);
+H5_DLL herr_t H5Tconvert(hid_t src_id, hid_t dst_id, size_t nelmts,
+			  void *buf, void *background, hid_t plist_id);
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+
+
+/* Typedefs */
+
+
+/* Function prototypes */
+H5_DLL herr_t H5Tcommit1(hid_t loc_id, const char *name, hid_t type_id);
+H5_DLL hid_t H5Topen1(hid_t loc_id, const char *name);
+H5_DLL hid_t H5Tarray_create1(hid_t base_id, int ndims,
+            const hsize_t dim[/* ndims */],
+            const int perm[/* ndims */]);
+H5_DLL int H5Tget_array_dims1(hid_t type_id, hsize_t dims[], int perm[]);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _H5Tpublic_H */
+
diff --git a/install/include/H5VarLenType.h b/install/include/H5VarLenType.h
new file mode 100644
index 0000000000..4048a4ebfe
--- /dev/null
+++ b/install/include/H5VarLenType.h
@@ -0,0 +1,54 @@
+// C++ informative line for the emacs editor: -*- C++ -*-
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef __H5VarLenType_H
+#define __H5VarLenType_H
+
+namespace H5 {
+
+/*! \class VarLenType
+    \brief VarLenType is a derivative of a DataType and operates on HDF5
+    C's Variable-length Datatypes.
+
+    Inheritance: DataType -> H5Object -> H5Location -> IdComponent
+*/
+class H5_DLLCPP VarLenType : public DataType {
+   public:
+        // Constructor that creates a variable-length datatype based
+        // on the specified base type.
+        VarLenType(const DataType* base_type);
+
+        ///\brief Returns this class name.
+        virtual H5std_string fromClass () const { return("VarLenType"); }
+
+        // Copy constructor: makes copy of the original object.
+        VarLenType(const VarLenType& original);
+
+        // Constructor that takes an existing id
+        VarLenType(const hid_t existing_id);
+
+        // Constructors that open a variable-length datatype, given a location.
+        VarLenType(const H5Location& loc, const char* name);
+        VarLenType(const H5Location& loc, const H5std_string& name);
+
+        // Noop destructor
+        virtual ~VarLenType();
+
+        // Default constructor
+        VarLenType();
+
+}; // end of VarLenType
+} // namespace H5
+
+#endif // __H5VarLenType_H
diff --git a/install/include/H5Zpkg.h b/install/include/H5Zpkg.h
new file mode 100644
index 0000000000..2aa17f2440
--- /dev/null
+++ b/install/include/H5Zpkg.h
@@ -0,0 +1,55 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#if !(defined H5Z_FRIEND || defined H5Z_MODULE)
+#error "Do not include this file outside the H5Z package!"
+#endif
+
+#ifndef _H5Zpkg_H
+#define _H5Zpkg_H
+
+/* Include private header file */
+#include "H5Zprivate.h"          /* Filter functions                */
+
+/********************/
+/* Internal filters */
+/********************/
+
+/* Shuffle filter */
+H5_DLLVAR const H5Z_class2_t H5Z_SHUFFLE[1];
+
+/* Fletcher32 filter */
+H5_DLLVAR const H5Z_class2_t H5Z_FLETCHER32[1];
+
+/* n-bit filter */
+H5_DLLVAR H5Z_class2_t H5Z_NBIT[1];
+
+/* Scale/offset filter */
+H5_DLLVAR H5Z_class2_t H5Z_SCALEOFFSET[1];
+
+/********************/
+/* External filters */
+/********************/
+
+/* Deflate filter */
+#ifdef H5_HAVE_FILTER_DEFLATE
+H5_DLLVAR const H5Z_class2_t H5Z_DEFLATE[1];
+#endif /* H5_HAVE_FILTER_DEFLATE */
+
+/* szip filter */
+#ifdef H5_HAVE_FILTER_SZIP
+H5_DLLVAR H5Z_class2_t H5Z_SZIP[1];
+#endif /* H5_HAVE_FILTER_SZIP */
+
+#endif /* _H5Zpkg_H */
+
diff --git a/install/include/H5Zpublic.h b/install/include/H5Zpublic.h
new file mode 100644
index 0000000000..f6b313e529
--- /dev/null
+++ b/install/include/H5Zpublic.h
@@ -0,0 +1,248 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Programmer:  Robb Matzke <matzke@llnl.gov>
+ *              Thursday, April 16, 1998
+ */
+
+#ifndef _H5Zpublic_H
+#define _H5Zpublic_H
+
+/* Public headers needed by this file */
+#include "H5public.h"
+
+/*
+ * Filter identifiers.  Values 0 through 255 are for filters defined by the
+ * HDF5 library.  Values 256 through 511 are available for testing new
+ * filters. Subsequent values should be obtained from the HDF5 development
+ * team at hdf5dev@ncsa.uiuc.edu.  These values will never change because they
+ * appear in the HDF5 files.
+ */
+typedef int H5Z_filter_t;
+
+/* Filter IDs */
+#define H5Z_FILTER_ERROR	(-1)	/*no filter			*/
+#define H5Z_FILTER_NONE		0	/*reserved indefinitely		*/
+#define H5Z_FILTER_DEFLATE	1 	/*deflation like gzip	     	*/
+#define H5Z_FILTER_SHUFFLE      2       /*shuffle the data              */
+#define H5Z_FILTER_FLETCHER32   3       /*fletcher32 checksum of EDC    */
+#define H5Z_FILTER_SZIP         4       /*szip compression              */
+#define H5Z_FILTER_NBIT         5       /*nbit compression              */
+#define H5Z_FILTER_SCALEOFFSET  6       /*scale+offset compression      */
+#define H5Z_FILTER_RESERVED     256	/*filter ids below this value are reserved for library use */
+
+#define H5Z_FILTER_MAX		65535	/*maximum filter id		*/
+
+/* General macros */
+#define H5Z_FILTER_ALL	 	0	/* Symbol to remove all filters in H5Premove_filter */
+#define H5Z_MAX_NFILTERS        32      /* Maximum number of filters allowed in a pipeline */
+                                        /* (should probably be allowed to be an
+                                         * unlimited amount, but currently each
+                                         * filter uses a bit in a 32-bit field,
+                                         * so the format would have to be
+                                         * changed to accomodate that)
+                                         */
+
+/* Flags for filter definition (stored) */
+#define H5Z_FLAG_DEFMASK	0x00ff	/*definition flag mask		*/
+#define H5Z_FLAG_MANDATORY      0x0000  /*filter is mandatory		*/
+#define H5Z_FLAG_OPTIONAL	0x0001	/*filter is optional		*/
+
+/* Additional flags for filter invocation (not stored) */
+#define H5Z_FLAG_INVMASK	0xff00	/*invocation flag mask		*/
+#define H5Z_FLAG_REVERSE	0x0100	/*reverse direction; read	*/
+#define H5Z_FLAG_SKIP_EDC	0x0200	/*skip EDC filters for read	*/
+
+/* Special parameters for szip compression */
+/* [These are aliases for the similar definitions in szlib.h, which we can't
+ * include directly due to the duplication of various symbols with the zlib.h
+ * header file] */
+#define H5_SZIP_ALLOW_K13_OPTION_MASK   1
+#define H5_SZIP_CHIP_OPTION_MASK        2
+#define H5_SZIP_EC_OPTION_MASK          4
+#define H5_SZIP_NN_OPTION_MASK          32
+#define H5_SZIP_MAX_PIXELS_PER_BLOCK    32
+
+/* Macros for the shuffle filter */
+#define H5Z_SHUFFLE_USER_NPARMS    0    /* Number of parameters that users can set */
+#define H5Z_SHUFFLE_TOTAL_NPARMS   1    /* Total number of parameters for filter */
+
+/* Macros for the szip filter */
+#define H5Z_SZIP_USER_NPARMS    2       /* Number of parameters that users can set */
+#define H5Z_SZIP_TOTAL_NPARMS   4       /* Total number of parameters for filter */
+#define H5Z_SZIP_PARM_MASK      0       /* "User" parameter for option mask */
+#define H5Z_SZIP_PARM_PPB       1       /* "User" parameter for pixels-per-block */
+#define H5Z_SZIP_PARM_BPP       2       /* "Local" parameter for bits-per-pixel */
+#define H5Z_SZIP_PARM_PPS       3       /* "Local" parameter for pixels-per-scanline */
+
+/* Macros for the nbit filter */
+#define H5Z_NBIT_USER_NPARMS     0     /* Number of parameters that users can set */
+
+/* Macros for the scale offset filter */
+#define H5Z_SCALEOFFSET_USER_NPARMS      2    /* Number of parameters that users can set */
+
+
+/* Special parameters for ScaleOffset filter*/
+#define H5Z_SO_INT_MINBITS_DEFAULT 0
+typedef enum H5Z_SO_scale_type_t {
+    H5Z_SO_FLOAT_DSCALE = 0,
+    H5Z_SO_FLOAT_ESCALE = 1,
+    H5Z_SO_INT          = 2
+} H5Z_SO_scale_type_t;
+
+/* Current version of the H5Z_class_t struct */
+#define H5Z_CLASS_T_VERS (1)
+
+/* Values to decide if EDC is enabled for reading data */
+typedef enum H5Z_EDC_t {
+    H5Z_ERROR_EDC       = -1,   /* error value */
+    H5Z_DISABLE_EDC     = 0,
+    H5Z_ENABLE_EDC      = 1,
+    H5Z_NO_EDC          = 2     /* must be the last */
+} H5Z_EDC_t;
+
+/* Bit flags for H5Zget_filter_info */
+#define H5Z_FILTER_CONFIG_ENCODE_ENABLED (0x0001)
+#define H5Z_FILTER_CONFIG_DECODE_ENABLED (0x0002)
+
+/* Return values for filter callback function */
+typedef enum H5Z_cb_return_t {
+    H5Z_CB_ERROR  = -1,
+    H5Z_CB_FAIL   = 0,    /* I/O should fail if filter fails. */
+    H5Z_CB_CONT   = 1,    /* I/O continues if filter fails.   */
+    H5Z_CB_NO     = 2
+} H5Z_cb_return_t;
+
+/* Filter callback function definition */
+typedef H5Z_cb_return_t (*H5Z_filter_func_t)(H5Z_filter_t filter, void* buf,
+                                size_t buf_size, void* op_data);
+
+/* Structure for filter callback property */
+typedef struct H5Z_cb_t {
+    H5Z_filter_func_t func;
+    void*              op_data;
+} H5Z_cb_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Before a dataset gets created, the "can_apply" callbacks for any filters used
+ * in the dataset creation property list are called
+ * with the dataset's dataset creation property list, the dataset's datatype and
+ * a dataspace describing a chunk (for chunked dataset storage).
+ *
+ * The "can_apply" callback must determine if the combination of the dataset
+ * creation property list setting, the datatype and the dataspace represent a
+ * valid combination to apply this filter to.  For example, some cases of
+ * invalid combinations may involve the filter not operating correctly on
+ * certain datatypes (or certain datatype sizes), or certain sizes of the chunk
+ * dataspace.
+ *
+ * The "can_apply" callback can be the NULL pointer, in which case, the library
+ * will assume that it can apply to any combination of dataset creation
+ * property list values, datatypes and dataspaces.
+ *
+ * The "can_apply" callback returns positive a valid combination, zero for an
+ * invalid combination and negative for an error.
+ */
+typedef htri_t (*H5Z_can_apply_func_t)(hid_t dcpl_id, hid_t type_id, hid_t space_id);
+
+/*
+ * After the "can_apply" callbacks are checked for new datasets, the "set_local"
+ * callbacks for any filters used in the dataset creation property list are
+ * called.  These callbacks receive the dataset's private copy of the dataset
+ * creation property list passed in to H5Dcreate (i.e. not the actual property
+ * list passed in to H5Dcreate) and the datatype ID passed in to H5Dcreate
+ * (which is not copied and should not be modified) and a dataspace describing
+ * the chunk (for chunked dataset storage) (which should also not be modified).
+ *
+ * The "set_local" callback must set any parameters that are specific to this
+ * dataset, based on the combination of the dataset creation property list
+ * values, the datatype and the dataspace.  For example, some filters perform
+ * different actions based on different datatypes (or datatype sizes) or
+ * different number of dimensions or dataspace sizes.
+ *
+ * The "set_local" callback can be the NULL pointer, in which case, the library
+ * will assume that there are no dataset-specific settings for this filter.
+ *
+ * The "set_local" callback must return non-negative on success and negative
+ * for an error.
+ */
+typedef herr_t (*H5Z_set_local_func_t)(hid_t dcpl_id, hid_t type_id, hid_t space_id);
+
+/*
+ * A filter gets definition flags and invocation flags (defined above), the
+ * client data array and size defined when the filter was added to the
+ * pipeline, the size in bytes of the data on which to operate, and pointers
+ * to a buffer and its allocated size.
+ *
+ * The filter should store the result in the supplied buffer if possible,
+ * otherwise it can allocate a new buffer, freeing the original.  The
+ * allocated size of the new buffer should be returned through the BUF_SIZE
+ * pointer and the new buffer through the BUF pointer.
+ *
+ * The return value from the filter is the number of bytes in the output
+ * buffer. If an error occurs then the function should return zero and leave
+ * all pointer arguments unchanged.
+ */
+typedef size_t (*H5Z_func_t)(unsigned int flags, size_t cd_nelmts,
+			     const unsigned int cd_values[], size_t nbytes,
+			     size_t *buf_size, void **buf);
+
+/*
+ * The filter table maps filter identification numbers to structs that
+ * contain a pointers to the filter function and timing statistics.
+ */
+typedef struct H5Z_class2_t {
+    int version;                /* Version number of the H5Z_class_t struct */
+    H5Z_filter_t id;		/* Filter ID number			     */
+    unsigned encoder_present;   /* Does this filter have an encoder? */
+    unsigned decoder_present;   /* Does this filter have a decoder? */
+    const char	*name;		/* Comment for debugging		     */
+    H5Z_can_apply_func_t can_apply; /* The "can apply" callback for a filter */
+    H5Z_set_local_func_t set_local; /* The "set local" callback for a filter */
+    H5Z_func_t filter;		/* The actual filter function		     */
+} H5Z_class2_t;
+
+H5_DLL herr_t H5Zregister(const void *cls);
+H5_DLL herr_t H5Zunregister(H5Z_filter_t id);
+H5_DLL htri_t H5Zfilter_avail(H5Z_filter_t id);
+H5_DLL herr_t H5Zget_filter_info(H5Z_filter_t filter, unsigned int *filter_config_flags);
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/*
+ * The filter table maps filter identification numbers to structs that
+ * contain a pointers to the filter function and timing statistics.
+ */
+typedef struct H5Z_class1_t {
+    H5Z_filter_t id;		/* Filter ID number			     */
+    const char	*name;		/* Comment for debugging		     */
+    H5Z_can_apply_func_t can_apply; /* The "can apply" callback for a filter */
+    H5Z_set_local_func_t set_local; /* The "set local" callback for a filter */
+    H5Z_func_t filter;		/* The actual filter function		     */
+} H5Z_class1_t;
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/install/include/H5api_adpt.h b/install/include/H5api_adpt.h
new file mode 100644
index 0000000000..0ff0f7481f
--- /dev/null
+++ b/install/include/H5api_adpt.h
@@ -0,0 +1,254 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * H5api_adpt.h
+ * Used for the HDF5 dll project
+ * Created by Patrick Lu on 1/12/99
+ */
+#ifndef H5API_ADPT_H
+#define H5API_ADPT_H
+
+
+/* This will only be defined if HDF5 was built with CMake */
+#ifdef H5_BUILT_AS_DYNAMIC_LIB
+
+#if defined(hdf5_shared_EXPORTS)
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5_DLL __declspec(dllexport)
+    #define H5_DLLVAR extern __declspec(dllexport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5_DLL __attribute__ ((visibility("default")))
+    #define H5_DLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#else
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5_DLL __declspec(dllimport)
+    #define H5_DLLVAR __declspec(dllimport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5_DLL __attribute__ ((visibility("default")))
+    #define H5_DLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#endif
+
+#ifndef H5_DLL
+  #define H5_DLL
+  #define H5_DLLVAR extern
+#endif /* _HDF5DLL_ */
+
+#if defined(hdf5_test_shared_EXPORTS)
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5TEST_DLL __declspec(dllexport)
+    #define H5TEST_DLLVAR extern __declspec(dllexport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5TEST_DLL __attribute__ ((visibility("default")))
+    #define H5TEST_DLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#else
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5TEST_DLL __declspec(dllimport)
+    #define H5TEST_DLLVAR __declspec(dllimport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5TEST_DLL __attribute__ ((visibility("default")))
+    #define H5TEST_DLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#endif
+
+#ifndef H5TEST_DLL
+  #define H5TEST_DLL
+  #define H5TEST_DLLVAR extern
+#endif /* H5TEST_DLL */
+
+#if defined(hdf5_tools_shared_EXPORTS)
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5TOOLS_DLL __declspec(dllexport)
+    #define H5TOOLS_DLLVAR extern __declspec(dllexport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5TOOLS_DLL __attribute__ ((visibility("default")))
+    #define H5TOOLS_DLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#else
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5TOOLS_DLL __declspec(dllimport)
+    #define H5TOOLS_DLLVAR __declspec(dllimport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5TOOLS_DLL __attribute__ ((visibility("default")))
+    #define H5TOOLS_DLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#endif
+
+#ifndef H5TOOLS_DLL
+  #define H5TOOLS_DLL
+  #define H5TOOLS_DLLVAR extern
+#endif /* H5TOOLS_DLL */
+
+#if defined(hdf5_cpp_shared_EXPORTS)
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5_DLLCPP __declspec(dllexport)
+    #define H5_DLLCPPVAR extern __declspec(dllexport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5_DLLCPP __attribute__ ((visibility("default")))
+    #define H5_DLLCPPVAR extern __attribute__ ((visibility("default")))
+  #endif
+#else
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5_DLLCPP __declspec(dllimport)
+    #define H5_DLLCPPVAR __declspec(dllimport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5_DLLCPP __attribute__ ((visibility("default")))
+    #define H5_DLLCPPVAR extern __attribute__ ((visibility("default")))
+  #endif
+#endif
+
+#ifndef H5_DLLCPP
+  #define H5_DLLCPP
+  #define H5_DLLCPPVAR extern
+#endif /* H5_DLLCPP */
+
+#if defined(hdf5_hl_shared_EXPORTS)
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5_HLDLL __declspec(dllexport)
+    #define H5_HLDLLVAR extern __declspec(dllexport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5_HLDLL __attribute__ ((visibility("default")))
+    #define H5_HLDLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#else
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5_HLDLL __declspec(dllimport)
+    #define H5_HLDLLVAR __declspec(dllimport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5_HLDLL __attribute__ ((visibility("default")))
+    #define H5_HLDLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#endif
+
+#ifndef H5_HLDLL
+  #define H5_HLDLL
+  #define H5_HLDLLVAR extern
+#endif /* H5_HLDLL */
+
+#if defined(hdf5_hl_cpp_shared_EXPORTS)
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5_HLCPPDLL __declspec(dllexport)
+    #define H5_HLCPPDLLVAR extern __declspec(dllexport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5_HLCPPDLL __attribute__ ((visibility("default")))
+    #define H5_HLCPPDLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#else
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5_HLCPPDLL __declspec(dllimport)
+    #define H5_HLCPPDLLVAR __declspec(dllimport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5_HLCPPDLL __attribute__ ((visibility("default")))
+    #define H5_HLCPPDLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#endif
+
+#ifndef H5_HLCPPDLL
+  #define H5_HLCPPDLL
+  #define H5_HLCPPDLLVAR extern
+#endif /* H5_HLCPPDLL */
+
+#if defined(hdf5_f90cstub_shared_EXPORTS)
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5_FCDLL __declspec(dllexport)
+    #define H5_FCDLLVAR extern __declspec(dllexport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5_FCDLL __attribute__ ((visibility("default")))
+    #define H5_FCDLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#else
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5_FCDLL __declspec(dllimport)
+    #define H5_FCDLLVAR __declspec(dllimport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5_FCDLL __attribute__ ((visibility("default")))
+    #define H5_FCDLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#endif
+
+#ifndef H5_FCDLL
+  #define H5_FCDLL
+  #define H5_FCDLLVAR extern
+#endif /* H5_FCDLL */
+
+#if defined(hdf5_test_f90cstub_shared_EXPORTS)
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5_FCTESTDLL __declspec(dllexport)
+    #define H5_FCTESTDLLVAR extern __declspec(dllexport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5_FCTESTDLL __attribute__ ((visibility("default")))
+    #define H5_FCTESTDLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#else
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define H5_FCTESTDLL __declspec(dllimport)
+    #define H5_FCTESTDLLVAR __declspec(dllimport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define H5_FCTESTDLL __attribute__ ((visibility("default")))
+    #define H5_FCTESTDLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#endif
+
+#ifndef H5_FCTESTDLL
+  #define H5_FCTESTDLL
+  #define H5_FCTESTDLLVAR extern
+#endif /* H5_FCTESTDLL */
+
+#if defined(hdf5_hl_f90cstub_shared_EXPORTS)
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define HDF5_HL_F90CSTUBDLL __declspec(dllexport)
+    #define HDF5_HL_F90CSTUBDLLVAR extern __declspec(dllexport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define HDF5_HL_F90CSTUBDLL __attribute__ ((visibility("default")))
+    #define HDF5_HL_F90CSTUBDLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#else
+  #if defined (_MSC_VER)  /* MSVC Compiler Case */
+    #define HDF5_HL_F90CSTUBDLL __declspec(dllimport)
+    #define HDF5_HL_F90CSTUBDLLVAR __declspec(dllimport)
+  #elif (__GNUC__ >= 4)  /* GCC 4.x has support for visibility options */
+    #define HDF5_HL_F90CSTUBDLL __attribute__ ((visibility("default")))
+    #define HDF5_HL_F90CSTUBDLLVAR extern __attribute__ ((visibility("default")))
+  #endif
+#endif
+
+#ifndef HDF5_HL_F90CSTUBDLL
+  #define HDF5_HL_F90CSTUBDLL
+  #define HDF5_HL_F90CSTUBDLLVAR extern
+#endif /* HDF5_HL_F90CSTUBDLL */
+
+#else
+  #define H5_DLL
+  #define H5_DLLVAR extern
+  #define H5TEST_DLL
+  #define H5TEST_DLLVAR extern
+  #define H5TOOLS_DLL
+  #define H5TOOLS_DLLVAR extern
+  #define H5_DLLCPP
+  #define H5_DLLCPPVAR extern
+  #define H5_HLDLL
+  #define H5_HLDLLVAR extern
+  #define H5_HLCPPDLL
+  #define H5_HLCPPDLLVAR extern
+  #define H5_FCDLL
+  #define H5_FCDLLVAR extern
+  #define H5_FCTESTDLL
+  #define H5_FCTESTDLLVAR extern
+  #define HDF5_HL_F90CSTUBDLL
+  #define HDF5_HL_F90CSTUBDLLVAR extern
+#endif /* H5_BUILT_AS_DYNAMIC_LIB */
+
+#endif /* H5API_ADPT_H */
diff --git a/install/include/H5overflow.h b/install/include/H5overflow.h
new file mode 100644
index 0000000000..8532af61b0
--- /dev/null
+++ b/install/include/H5overflow.h
@@ -0,0 +1,2252 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Generated automatically by bin/make_overflow -- do not edit */
+/* Add new types to H5overflow.txt file */
+
+
+#ifndef _H5overflow_H
+#define _H5overflow_H
+
+
+/* Each type in this file is tested for assignment to the other types,
+ *      and range checks are defined for bad assignments at run-time.
+ */
+
+/* Assignment checks for unsigned */
+
+/* src: unsigned, dst: int */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_INT
+    #define ASSIGN_unsigned_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_INT
+    #define ASSIGN_unsigned_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_INT */
+    #define ASSIGN_unsigned_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: int */
+
+/* src: unsigned, dst: int64_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_INT64_T
+    #define ASSIGN_unsigned_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_INT64_T
+    #define ASSIGN_unsigned_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_INT64_T */
+    #define ASSIGN_unsigned_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: int64_t */
+
+/* src: unsigned, dst: uint8_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_UINT8_T
+    #define ASSIGN_unsigned_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_UINT8_T
+    #define ASSIGN_unsigned_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_unsigned_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: uint8_t */
+
+/* src: unsigned, dst: uint16_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_UINT16_T
+    #define ASSIGN_unsigned_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_UINT16_T
+    #define ASSIGN_unsigned_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_unsigned_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: uint16_t */
+
+/* src: unsigned, dst: uint32_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_UINT32_T
+    #define ASSIGN_unsigned_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_UINT32_T
+    #define ASSIGN_unsigned_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_unsigned_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: uint32_t */
+
+/* src: unsigned, dst: uint64_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_UINT64_T
+    #define ASSIGN_unsigned_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_UINT64_T
+    #define ASSIGN_unsigned_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_unsigned_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: uint64_t */
+
+/* src: unsigned, dst: ptrdiff_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_unsigned_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_unsigned_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_unsigned_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: ptrdiff_t */
+
+/* src: unsigned, dst: size_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_SIZE_T
+    #define ASSIGN_unsigned_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_SIZE_T
+    #define ASSIGN_unsigned_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_unsigned_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: size_t */
+
+/* src: unsigned, dst: ssize_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_unsigned_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_unsigned_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_unsigned_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: ssize_t */
+
+/* src: unsigned, dst: haddr_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_HADDR_T
+    #define ASSIGN_unsigned_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_HADDR_T
+    #define ASSIGN_unsigned_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_unsigned_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: haddr_t */
+
+/* src: unsigned, dst: hsize_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_unsigned_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_unsigned_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_unsigned_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: hsize_t */
+
+/* src: unsigned, dst: hssize_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_unsigned_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_unsigned_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_unsigned_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: hssize_t */
+
+/* src: unsigned, dst: h5_stat_size_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_unsigned_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_unsigned_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_unsigned_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: h5_stat_size_t */
+
+
+/* Assignment checks for int */
+
+/* src: int, dst: unsigned */
+#if H5_SIZEOF_INT < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_int_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_int_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_int_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: unsigned */
+
+/* src: int, dst: int64_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_INT64_T
+    #define ASSIGN_int_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_INT64_T
+    #define ASSIGN_int_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_INT64_T */
+    #define ASSIGN_int_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: int64_t */
+
+/* src: int, dst: uint8_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_UINT8_T
+    #define ASSIGN_int_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_UINT8_T
+    #define ASSIGN_int_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_int_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: uint8_t */
+
+/* src: int, dst: uint16_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_UINT16_T
+    #define ASSIGN_int_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_UINT16_T
+    #define ASSIGN_int_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_int_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: uint16_t */
+
+/* src: int, dst: uint32_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_UINT32_T
+    #define ASSIGN_int_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_UINT32_T
+    #define ASSIGN_int_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_int_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: uint32_t */
+
+/* src: int, dst: uint64_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_UINT64_T
+    #define ASSIGN_int_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_UINT64_T
+    #define ASSIGN_int_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_int_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: uint64_t */
+
+/* src: int, dst: ptrdiff_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_int_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_int_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_int_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: ptrdiff_t */
+
+/* src: int, dst: size_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_SIZE_T
+    #define ASSIGN_int_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_SIZE_T
+    #define ASSIGN_int_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_int_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: size_t */
+
+/* src: int, dst: ssize_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_int_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_int_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_int_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: ssize_t */
+
+/* src: int, dst: haddr_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_HADDR_T
+    #define ASSIGN_int_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_HADDR_T
+    #define ASSIGN_int_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_int_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: haddr_t */
+
+/* src: int, dst: hsize_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_int_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_int_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_int_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: hsize_t */
+
+/* src: int, dst: hssize_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_int_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_int_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_int_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: hssize_t */
+
+/* src: int, dst: h5_stat_size_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_int_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_int_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_int_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: h5_stat_size_t */
+
+
+/* Assignment checks for int64_t */
+
+/* src: int64_t, dst: unsigned */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_int64_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_int64_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_int64_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: unsigned */
+
+/* src: int64_t, dst: int */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_INT
+    #define ASSIGN_int64_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_INT
+    #define ASSIGN_int64_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_INT */
+    #define ASSIGN_int64_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: int */
+
+/* src: int64_t, dst: uint8_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_int64_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_int64_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_int64_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: uint8_t */
+
+/* src: int64_t, dst: uint16_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_int64_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_int64_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_int64_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: uint16_t */
+
+/* src: int64_t, dst: uint32_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_int64_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_int64_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_int64_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: uint32_t */
+
+/* src: int64_t, dst: uint64_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_int64_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_int64_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_int64_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: uint64_t */
+
+/* src: int64_t, dst: ptrdiff_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_int64_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_int64_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_int64_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: ptrdiff_t */
+
+/* src: int64_t, dst: size_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_int64_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_int64_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_int64_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: size_t */
+
+/* src: int64_t, dst: ssize_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_int64_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_int64_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_int64_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: ssize_t */
+
+/* src: int64_t, dst: haddr_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_int64_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_int64_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_int64_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: haddr_t */
+
+/* src: int64_t, dst: hsize_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_int64_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_int64_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_int64_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: hsize_t */
+
+/* src: int64_t, dst: hssize_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_int64_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_int64_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_int64_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: hssize_t */
+
+/* src: int64_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_int64_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_int64_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_int64_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for uint8_t */
+
+/* src: uint8_t, dst: unsigned */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint8_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint8_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_uint8_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: unsigned */
+
+/* src: uint8_t, dst: int */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_INT
+    #define ASSIGN_uint8_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_INT
+    #define ASSIGN_uint8_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_INT */
+    #define ASSIGN_uint8_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: int */
+
+/* src: uint8_t, dst: int64_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_uint8_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_uint8_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_uint8_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: int64_t */
+
+/* src: uint8_t, dst: uint16_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_uint8_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_uint8_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_uint8_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: uint16_t */
+
+/* src: uint8_t, dst: uint32_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_uint8_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_uint8_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_uint8_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: uint32_t */
+
+/* src: uint8_t, dst: uint64_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_uint8_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_uint8_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_uint8_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: uint64_t */
+
+/* src: uint8_t, dst: ptrdiff_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint8_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint8_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_uint8_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: ptrdiff_t */
+
+/* src: uint8_t, dst: size_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint8_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint8_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_uint8_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: size_t */
+
+/* src: uint8_t, dst: ssize_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint8_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint8_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_uint8_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: ssize_t */
+
+/* src: uint8_t, dst: haddr_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint8_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint8_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_uint8_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: haddr_t */
+
+/* src: uint8_t, dst: hsize_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint8_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint8_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_uint8_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: hsize_t */
+
+/* src: uint8_t, dst: hssize_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint8_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint8_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_uint8_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: hssize_t */
+
+/* src: uint8_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint8_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint8_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_uint8_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for uint16_t */
+
+/* src: uint16_t, dst: unsigned */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint16_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint16_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_uint16_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: unsigned */
+
+/* src: uint16_t, dst: int */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_INT
+    #define ASSIGN_uint16_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_INT
+    #define ASSIGN_uint16_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_INT */
+    #define ASSIGN_uint16_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: int */
+
+/* src: uint16_t, dst: int64_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_uint16_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_uint16_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_uint16_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: int64_t */
+
+/* src: uint16_t, dst: uint8_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_uint16_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_uint16_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_uint16_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: uint8_t */
+
+/* src: uint16_t, dst: uint32_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_uint16_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_uint16_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_uint16_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: uint32_t */
+
+/* src: uint16_t, dst: uint64_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_uint16_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_uint16_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_uint16_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: uint64_t */
+
+/* src: uint16_t, dst: ptrdiff_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint16_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint16_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_uint16_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: ptrdiff_t */
+
+/* src: uint16_t, dst: size_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint16_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint16_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_uint16_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: size_t */
+
+/* src: uint16_t, dst: ssize_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint16_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint16_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_uint16_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: ssize_t */
+
+/* src: uint16_t, dst: haddr_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint16_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint16_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_uint16_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: haddr_t */
+
+/* src: uint16_t, dst: hsize_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint16_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint16_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_uint16_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: hsize_t */
+
+/* src: uint16_t, dst: hssize_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint16_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint16_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_uint16_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: hssize_t */
+
+/* src: uint16_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint16_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint16_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_uint16_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for uint32_t */
+
+/* src: uint32_t, dst: unsigned */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint32_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint32_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_uint32_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: unsigned */
+
+/* src: uint32_t, dst: int */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_INT
+    #define ASSIGN_uint32_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_INT
+    #define ASSIGN_uint32_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_INT */
+    #define ASSIGN_uint32_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: int */
+
+/* src: uint32_t, dst: int64_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_uint32_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_uint32_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_uint32_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: int64_t */
+
+/* src: uint32_t, dst: uint8_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_uint32_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_uint32_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_uint32_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: uint8_t */
+
+/* src: uint32_t, dst: uint16_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_uint32_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_uint32_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_uint32_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: uint16_t */
+
+/* src: uint32_t, dst: uint64_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_uint32_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_uint32_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_uint32_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: uint64_t */
+
+/* src: uint32_t, dst: ptrdiff_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint32_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint32_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_uint32_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: ptrdiff_t */
+
+/* src: uint32_t, dst: size_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint32_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint32_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_uint32_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: size_t */
+
+/* src: uint32_t, dst: ssize_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint32_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint32_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_uint32_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: ssize_t */
+
+/* src: uint32_t, dst: haddr_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint32_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint32_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_uint32_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: haddr_t */
+
+/* src: uint32_t, dst: hsize_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint32_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint32_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_uint32_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: hsize_t */
+
+/* src: uint32_t, dst: hssize_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint32_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint32_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_uint32_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: hssize_t */
+
+/* src: uint32_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint32_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint32_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_uint32_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for uint64_t */
+
+/* src: uint64_t, dst: unsigned */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint64_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint64_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_uint64_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: unsigned */
+
+/* src: uint64_t, dst: int */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_INT
+    #define ASSIGN_uint64_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_INT
+    #define ASSIGN_uint64_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_INT */
+    #define ASSIGN_uint64_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: int */
+
+/* src: uint64_t, dst: int64_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_uint64_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_uint64_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_uint64_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: int64_t */
+
+/* src: uint64_t, dst: uint8_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_uint64_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_uint64_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_uint64_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: uint8_t */
+
+/* src: uint64_t, dst: uint16_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_uint64_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_uint64_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_uint64_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: uint16_t */
+
+/* src: uint64_t, dst: uint32_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_uint64_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_uint64_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_uint64_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: uint32_t */
+
+/* src: uint64_t, dst: ptrdiff_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint64_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint64_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_uint64_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: ptrdiff_t */
+
+/* src: uint64_t, dst: size_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint64_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint64_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_uint64_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: size_t */
+
+/* src: uint64_t, dst: ssize_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint64_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint64_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_uint64_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: ssize_t */
+
+/* src: uint64_t, dst: haddr_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint64_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint64_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_uint64_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: haddr_t */
+
+/* src: uint64_t, dst: hsize_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint64_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint64_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_uint64_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: hsize_t */
+
+/* src: uint64_t, dst: hssize_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint64_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint64_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_uint64_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: hssize_t */
+
+/* src: uint64_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint64_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint64_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_uint64_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for ptrdiff_t */
+
+/* src: ptrdiff_t, dst: unsigned */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_ptrdiff_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_ptrdiff_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_ptrdiff_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: unsigned */
+
+/* src: ptrdiff_t, dst: int */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_INT
+    #define ASSIGN_ptrdiff_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_INT
+    #define ASSIGN_ptrdiff_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_INT */
+    #define ASSIGN_ptrdiff_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: int */
+
+/* src: ptrdiff_t, dst: int64_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_ptrdiff_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_ptrdiff_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_ptrdiff_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: int64_t */
+
+/* src: ptrdiff_t, dst: uint8_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_ptrdiff_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_ptrdiff_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_ptrdiff_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: uint8_t */
+
+/* src: ptrdiff_t, dst: uint16_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_ptrdiff_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_ptrdiff_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_ptrdiff_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: uint16_t */
+
+/* src: ptrdiff_t, dst: uint32_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_ptrdiff_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_ptrdiff_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_ptrdiff_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: uint32_t */
+
+/* src: ptrdiff_t, dst: uint64_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_ptrdiff_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_ptrdiff_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_ptrdiff_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: uint64_t */
+
+/* src: ptrdiff_t, dst: size_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_ptrdiff_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_ptrdiff_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_ptrdiff_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: size_t */
+
+/* src: ptrdiff_t, dst: ssize_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_ptrdiff_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_ptrdiff_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_ptrdiff_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: ssize_t */
+
+/* src: ptrdiff_t, dst: haddr_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_ptrdiff_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_ptrdiff_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_ptrdiff_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: haddr_t */
+
+/* src: ptrdiff_t, dst: hsize_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_ptrdiff_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_ptrdiff_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_ptrdiff_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: hsize_t */
+
+/* src: ptrdiff_t, dst: hssize_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_ptrdiff_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_ptrdiff_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_ptrdiff_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: hssize_t */
+
+/* src: ptrdiff_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_ptrdiff_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_ptrdiff_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_ptrdiff_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for size_t */
+
+/* src: size_t, dst: unsigned */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_size_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_size_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_size_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: unsigned */
+
+/* src: size_t, dst: int */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_INT
+    #define ASSIGN_size_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_INT
+    #define ASSIGN_size_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_INT */
+    #define ASSIGN_size_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: int */
+
+/* src: size_t, dst: int64_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_size_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_size_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_size_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: int64_t */
+
+/* src: size_t, dst: uint8_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_size_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_size_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_size_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: uint8_t */
+
+/* src: size_t, dst: uint16_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_size_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_size_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_size_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: uint16_t */
+
+/* src: size_t, dst: uint32_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_size_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_size_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_size_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: uint32_t */
+
+/* src: size_t, dst: uint64_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_size_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_size_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_size_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: uint64_t */
+
+/* src: size_t, dst: ptrdiff_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_size_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_size_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_size_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: ptrdiff_t */
+
+/* src: size_t, dst: ssize_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_size_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_size_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_size_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: ssize_t */
+
+/* src: size_t, dst: haddr_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_size_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_size_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_size_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: haddr_t */
+
+/* src: size_t, dst: hsize_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_size_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_size_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_size_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: hsize_t */
+
+/* src: size_t, dst: hssize_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_size_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_size_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_size_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: hssize_t */
+
+/* src: size_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_size_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_size_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_size_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for ssize_t */
+
+/* src: ssize_t, dst: unsigned */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_ssize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_ssize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_ssize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: unsigned */
+
+/* src: ssize_t, dst: int */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_INT
+    #define ASSIGN_ssize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_INT
+    #define ASSIGN_ssize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_INT */
+    #define ASSIGN_ssize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: int */
+
+/* src: ssize_t, dst: int64_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_ssize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_ssize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_ssize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: int64_t */
+
+/* src: ssize_t, dst: uint8_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_ssize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_ssize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_ssize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: uint8_t */
+
+/* src: ssize_t, dst: uint16_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_ssize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_ssize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_ssize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: uint16_t */
+
+/* src: ssize_t, dst: uint32_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_ssize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_ssize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_ssize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: uint32_t */
+
+/* src: ssize_t, dst: uint64_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_ssize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_ssize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_ssize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: uint64_t */
+
+/* src: ssize_t, dst: ptrdiff_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_ssize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_ssize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_ssize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: ptrdiff_t */
+
+/* src: ssize_t, dst: size_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_ssize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_ssize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_ssize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: size_t */
+
+/* src: ssize_t, dst: haddr_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_ssize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_ssize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_ssize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: haddr_t */
+
+/* src: ssize_t, dst: hsize_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_ssize_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_ssize_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_ssize_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: hsize_t */
+
+/* src: ssize_t, dst: hssize_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_ssize_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_ssize_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_ssize_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: hssize_t */
+
+/* src: ssize_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_ssize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_ssize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_ssize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for haddr_t */
+
+/* src: haddr_t, dst: unsigned */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_haddr_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_haddr_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_haddr_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: unsigned */
+
+/* src: haddr_t, dst: int */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_INT
+    #define ASSIGN_haddr_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_INT
+    #define ASSIGN_haddr_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_INT */
+    #define ASSIGN_haddr_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: int */
+
+/* src: haddr_t, dst: int64_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_haddr_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_haddr_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_haddr_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: int64_t */
+
+/* src: haddr_t, dst: uint8_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_haddr_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_haddr_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_haddr_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: uint8_t */
+
+/* src: haddr_t, dst: uint16_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_haddr_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_haddr_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_haddr_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: uint16_t */
+
+/* src: haddr_t, dst: uint32_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_haddr_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_haddr_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_haddr_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: uint32_t */
+
+/* src: haddr_t, dst: uint64_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_haddr_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_haddr_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_haddr_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: uint64_t */
+
+/* src: haddr_t, dst: ptrdiff_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_haddr_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_haddr_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_haddr_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: ptrdiff_t */
+
+/* src: haddr_t, dst: size_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_haddr_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_haddr_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_haddr_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: size_t */
+
+/* src: haddr_t, dst: ssize_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_haddr_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_haddr_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_haddr_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: ssize_t */
+
+/* src: haddr_t, dst: hsize_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_haddr_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_haddr_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_haddr_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: hsize_t */
+
+/* src: haddr_t, dst: hssize_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_haddr_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_haddr_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_haddr_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: hssize_t */
+
+/* src: haddr_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_haddr_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_haddr_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_haddr_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for hsize_t */
+
+/* src: hsize_t, dst: unsigned */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_hsize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_hsize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_hsize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: unsigned */
+
+/* src: hsize_t, dst: int */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_INT
+    #define ASSIGN_hsize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_INT
+    #define ASSIGN_hsize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_INT */
+    #define ASSIGN_hsize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: int */
+
+/* src: hsize_t, dst: int64_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_hsize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_hsize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_hsize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: int64_t */
+
+/* src: hsize_t, dst: uint8_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_hsize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_hsize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_hsize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: uint8_t */
+
+/* src: hsize_t, dst: uint16_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_hsize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_hsize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_hsize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: uint16_t */
+
+/* src: hsize_t, dst: uint32_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_hsize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_hsize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_hsize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: uint32_t */
+
+/* src: hsize_t, dst: uint64_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_hsize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_hsize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_hsize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: uint64_t */
+
+/* src: hsize_t, dst: ptrdiff_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_hsize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_hsize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_hsize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: ptrdiff_t */
+
+/* src: hsize_t, dst: size_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_hsize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_hsize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_hsize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: size_t */
+
+/* src: hsize_t, dst: ssize_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_hsize_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_hsize_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_hsize_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: ssize_t */
+
+/* src: hsize_t, dst: haddr_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_hsize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_hsize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_hsize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: haddr_t */
+
+/* src: hsize_t, dst: hssize_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_hsize_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_hsize_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_hsize_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: hssize_t */
+
+/* src: hsize_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_hsize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_hsize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_hsize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for hssize_t */
+
+/* src: hssize_t, dst: unsigned */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_hssize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_hssize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_hssize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: unsigned */
+
+/* src: hssize_t, dst: int */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_INT
+    #define ASSIGN_hssize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_INT
+    #define ASSIGN_hssize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_INT */
+    #define ASSIGN_hssize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: int */
+
+/* src: hssize_t, dst: int64_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_hssize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_hssize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_hssize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: int64_t */
+
+/* src: hssize_t, dst: uint8_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_hssize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_hssize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_hssize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: uint8_t */
+
+/* src: hssize_t, dst: uint16_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_hssize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_hssize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_hssize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: uint16_t */
+
+/* src: hssize_t, dst: uint32_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_hssize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_hssize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_hssize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: uint32_t */
+
+/* src: hssize_t, dst: uint64_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_hssize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_hssize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_hssize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: uint64_t */
+
+/* src: hssize_t, dst: ptrdiff_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_hssize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_hssize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_hssize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: ptrdiff_t */
+
+/* src: hssize_t, dst: size_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_hssize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_hssize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_hssize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: size_t */
+
+/* src: hssize_t, dst: ssize_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_hssize_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_hssize_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_hssize_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: ssize_t */
+
+/* src: hssize_t, dst: haddr_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_hssize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_hssize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_hssize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: haddr_t */
+
+/* src: hssize_t, dst: hsize_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_hssize_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_hssize_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_hssize_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: hsize_t */
+
+/* src: hssize_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_hssize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_hssize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_hssize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for h5_stat_size_t */
+
+/* src: h5_stat_size_t, dst: unsigned */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_h5_stat_size_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_h5_stat_size_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_h5_stat_size_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: unsigned */
+
+/* src: h5_stat_size_t, dst: int */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_INT
+    #define ASSIGN_h5_stat_size_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_INT
+    #define ASSIGN_h5_stat_size_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_INT */
+    #define ASSIGN_h5_stat_size_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: int */
+
+/* src: h5_stat_size_t, dst: int64_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_h5_stat_size_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_h5_stat_size_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_h5_stat_size_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: int64_t */
+
+/* src: h5_stat_size_t, dst: uint8_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_h5_stat_size_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_h5_stat_size_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_h5_stat_size_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: uint8_t */
+
+/* src: h5_stat_size_t, dst: uint16_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_h5_stat_size_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_h5_stat_size_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_h5_stat_size_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: uint16_t */
+
+/* src: h5_stat_size_t, dst: uint32_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_h5_stat_size_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_h5_stat_size_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_h5_stat_size_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: uint32_t */
+
+/* src: h5_stat_size_t, dst: uint64_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_h5_stat_size_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_h5_stat_size_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_h5_stat_size_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: uint64_t */
+
+/* src: h5_stat_size_t, dst: ptrdiff_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_h5_stat_size_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_h5_stat_size_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_h5_stat_size_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: ptrdiff_t */
+
+/* src: h5_stat_size_t, dst: size_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_h5_stat_size_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: size_t */
+
+/* src: h5_stat_size_t, dst: ssize_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_h5_stat_size_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: ssize_t */
+
+/* src: h5_stat_size_t, dst: haddr_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_h5_stat_size_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_h5_stat_size_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_h5_stat_size_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: haddr_t */
+
+/* src: h5_stat_size_t, dst: hsize_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_h5_stat_size_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: hsize_t */
+
+/* src: h5_stat_size_t, dst: hssize_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_h5_stat_size_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: hssize_t */
+
+#endif /* H5overflow_H */
+
diff --git a/install/include/H5pubconf.h b/install/include/H5pubconf.h
new file mode 100644
index 0000000000..0e33216df7
--- /dev/null
+++ b/install/include/H5pubconf.h
@@ -0,0 +1,733 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* H5pubconf.h  Generated By CMake during the configuration */
+
+#ifndef H5_CONFIG_H_
+#define H5_CONFIG_H_
+
+/* Define if the Windows virtual file driver should be compiled */
+/* #undef H5_HAVE_WINDOWS */
+
+/* Define if using MinGW */
+/* #undef H5_HAVE_MINGW */
+
+/* Define if on the Windows platform and default WIN32 API */
+/* #undef H5_HAVE_WIN32_API */
+
+/* Define if using a Windows compiler (i.e. Visual Studio) */
+/* #undef H5_HAVE_VISUAL_STUDIO */
+
+/* Define if building universal (internal helper macro) */
+/* #undef H5_AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define if C++ compiler recognizes offsetof */
+/* #undef H5_CXX_HAVE_OFFSETOF */
+
+/* Define the default plugins path to compile */
+#define H5_DEFAULT_PLUGINDIR "/usr/local/hdf5/lib/plugin"
+
+/* Define if `dev_t' is a scalar */
+#define H5_DEV_T_IS_SCALAR 1
+
+/* Define to dummy `main' function (if any) required to link to the Fortran
+   libraries. */
+/* #undef H5_FC_DUMMY_MAIN */
+
+/* Define if F77 and FC dummy `main' functions are identical. */
+/* #undef H5_FC_DUMMY_MAIN_EQ_F77 */
+
+/* Define to a macro mangling the given C identifier (in lower and upper
+   case), which must not contain underscores, for linking with Fortran. */
+#define H5_FC_FUNC(name,NAME) name ## _
+
+/* As FC_FUNC, but for C identifiers containing underscores. */
+#define H5_FC_FUNC_(name,NAME) name ## _
+
+/* Define if Fortran C_LONG_DOUBLE is different from C_DOUBLE */
+/* #undef H5_FORTRAN_C_LONG_DOUBLE_IS_UNIQUE */
+
+/* Define if we have Fortran C_LONG_DOUBLE */
+/* #undef H5_FORTRAN_HAVE_C_LONG_DOUBLE */
+
+/* Define if we have Fortran intrinsic C_SIZEOF */
+/* #undef H5_FORTRAN_HAVE_C_SIZEOF */
+
+/* Define if we have Fortran intrinsic SIZEOF */
+/* #undef H5_FORTRAN_HAVE_SIZEOF */
+
+/* Define if we have Fortran intrinsic STORAGE_SIZE */
+/* #undef H5_FORTRAN_HAVE_STORAGE_SIZE */
+
+/* Determine the size of C long double */
+/* #undef H5_FORTRAN_SIZEOF_LONG_DOUBLE */
+
+/* Define Fortran compiler ID */
+/* #undef H5_Fortran_COMPILER_ID */
+
+/* Define valid Fortran INTEGER KINDs */
+/* #undef H5_H5CONFIG_F_IKIND */
+
+/* Define number of valid Fortran INTEGER KINDs */
+/* #undef H5_H5CONFIG_F_NUM_IKIND */
+
+/* Define number of valid Fortran REAL KINDs */
+/* #undef H5_H5CONFIG_F_NUM_RKIND */
+
+/* Define valid Fortran REAL KINDs */
+/* #undef H5_H5CONFIG_F_RKIND */
+
+/* Define valid Fortran REAL KINDs Sizeof */
+/* #undef H5_H5CONFIG_F_RKIND_SIZEOF */
+
+/* Define to 1 if you have the `alarm' function. */
+#define H5_HAVE_ALARM 1
+
+/* Define to 1 if you have the `asprintf' function. */
+#define H5_HAVE_ASPRINTF 1
+
+/* Define if the __attribute__(()) extension is present */
+#define H5_HAVE_ATTRIBUTE 1
+
+/* Define if the compiler understands C99 designated initialization of structs
+   and unions */
+#define H5_HAVE_C99_DESIGNATED_INITIALIZER 1
+
+/* Define if the compiler understands the __func__ keyword */
+#define H5_HAVE_C99_FUNC 1
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#define H5_HAVE_CLOCK_GETTIME 1
+
+/* Define if the function stack tracing code is to be compiled in */
+/* #undef H5_HAVE_CODESTACK */
+
+/* Define if Darwin or Mac OS X */
+/* #undef H5_HAVE_DARWIN */
+
+/* Define to 1 if you have the `difftime' function. */
+#define H5_HAVE_DIFFTIME 1
+
+/* Define if the direct I/O virtual file driver (VFD) should be compiled */
+/* #undef H5_HAVE_DIRECT */
+
+/* Define to 1 if you have the <dirent.h> header file. */
+#define H5_HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define H5_HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <dmalloc.h> header file. */
+/* #undef H5_HAVE_DMALLOC_H */
+
+/* Define if library information should be embedded in the executables */
+#define H5_HAVE_EMBEDDED_LIBINFO 1
+
+/* Define to 1 if you have the `fcntl' function. */
+#define H5_HAVE_FCNTL 1
+
+/* Define to 1 if you have the <features.h> header file. */
+#define H5_HAVE_FEATURES_H 1
+
+/* Define if support for deflate (zlib) filter is enabled */
+/* #undef H5_HAVE_FILTER_DEFLATE */
+
+/* Define if support for szip filter is enabled */
+/* #undef H5_HAVE_FILTER_SZIP */
+
+/* Determine if __float128 is available */
+#define H5_HAVE_FLOAT128 1
+
+/* Define to 1 if you have the `flock' function. */
+#define H5_HAVE_FLOCK 1
+
+/* Define to 1 if you have the `fork' function. */
+#define H5_HAVE_FORK 1
+
+/* Define to 1 if you have the `frexpf' function. */
+#define H5_HAVE_FREXPF 1
+
+/* Define to 1 if you have the `frexpl' function. */
+#define H5_HAVE_FREXPL 1
+
+/* Define to 1 if you have the `fseeko' function. */
+#define H5_HAVE_FSEEKO 1
+
+/* Define to 1 if you have the `fseeko64' function. */
+#define H5_HAVE_FSEEKO64 1
+
+/* Define to 1 if you have the `fstat64' function. */
+#define H5_HAVE_FSTAT64 1
+
+/* Define to 1 if you have the `ftello' function. */
+#define H5_HAVE_FTELLO 1
+
+/* Define to 1 if you have the `ftello64' function. */
+#define H5_HAVE_FTELLO64 1
+
+/* Define to 1 if you have the `ftruncate64' function. */
+#define H5_HAVE_FTRUNCATE64 1
+
+/* Define if the compiler understands the __FUNCTION__ keyword */
+#define H5_HAVE_FUNCTION 1
+
+/* Define to 1 if you have the `GetConsoleScreenBufferInfo' function. */
+/* #undef H5_HAVE_GETCONSOLESCREENBUFFERINFO */
+
+/* Define to 1 if you have the `gethostname' function. */
+#define H5_HAVE_GETHOSTNAME 1
+
+/* Define to 1 if you have the `getpwuid' function. */
+#define H5_HAVE_GETPWUID 1
+
+/* Define to 1 if you have the `getrusage' function. */
+#define H5_HAVE_GETRUSAGE 1
+
+/* Define to 1 if you have the `gettextinfo' function. */
+/* #undef H5_HAVE_GETTEXTINFO */
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define H5_HAVE_GETTIMEOFDAY 1
+
+/* Define if the compiler understands inline */
+#define H5_HAVE_INLINE 1
+
+/* Define if parallel library will contain instrumentation to detect correct
+   optimization operation */
+/* #undef H5_HAVE_INSTRUMENTED_LIBRARY */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define H5_HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `ioctl' function. */
+#define H5_HAVE_IOCTL 1
+
+/* Define to 1 if you have the <io.h> header file. */
+/* #undef H5_HAVE_IO_H */
+
+/* Define to 1 if you have the `dl' library (-ldl). */
+#define H5_HAVE_LIBDL 1
+
+/* Define to 1 if you have the `dmalloc' library (-ldmalloc). */
+/* #undef H5_HAVE_LIBDMALLOC */
+
+/* Define to 1 if you have the `m' library (-lm). */
+#define H5_HAVE_LIBM 1
+
+/* Define to 1 if you have the `mpe' library (-lmpe). */
+/* #undef H5_HAVE_LIBMPE */
+
+/* Define to 1 if you have the `pthread' library (-lpthread). */
+/* #undef H5_HAVE_LIBPTHREAD */
+
+/* Define to 1 if you have the `sz' library (-lsz). */
+/* #undef H5_HAVE_LIBSZ */
+
+/* Define to 1 if you have the `ws2_32' library (-lws2_32). */
+/* #undef H5_HAVE_LIBWS2_32 */
+
+/* Define to 1 if you have the `z' library (-lz). */
+/* #undef H5_HAVE_LIBZ */
+
+/* Define to 1 if you have the `llround' function. */
+#define H5_HAVE_LLROUND 1
+
+/* Define to 1 if you have the `llroundf' function. */
+#define H5_HAVE_LLROUNDF 1
+
+/* Define to 1 if you have the `longjmp' function. */
+#define H5_HAVE_LONGJMP 1
+
+/* Define to 1 if you have the `lround' function. */
+#define H5_HAVE_LROUND 1
+
+/* Define to 1 if you have the `lroundf' function. */
+#define H5_HAVE_LROUNDF 1
+
+/* Define to 1 if you have the `lseek64' function. */
+#define H5_HAVE_LSEEK64 1
+
+/* Define to 1 if you have the `lstat' function. */
+#define H5_HAVE_LSTAT 1
+
+/* Define to 1 if you have the <mach/mach_time.h> header file. */
+/* #undef H5_HAVE_MACH_MACH_TIME_H */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define H5_HAVE_MEMORY_H 1
+
+/* Define if we have MPE support */
+/* #undef H5_HAVE_MPE */
+
+/* Define to 1 if you have the <mpe.h> header file. */
+/* #undef H5_HAVE_MPE_H */
+
+/* Define if `MPI_Comm_c2f' and `MPI_Comm_f2c' exists */
+/* #undef H5_HAVE_MPI_MULTI_LANG_Comm */
+
+/* Define if `MPI_Info_c2f' and `MPI_Info_f2c' exists */
+/* #undef H5_HAVE_MPI_MULTI_LANG_Info */
+
+/* Define if we have parallel support */
+/* #undef H5_HAVE_PARALLEL */
+
+/* Define to 1 if you have the <pthread.h> header file. */
+#define H5_HAVE_PTHREAD_H 1
+
+/* Define to 1 if you have the <quadmath.h> header file. */
+/* #undef H5_HAVE_QUADMATH_H */
+
+/* Define to 1 if you have the `random' function. */
+#define H5_HAVE_RANDOM 1
+
+/* Define to 1 if you have the `rand_r' function. */
+#define H5_HAVE_RAND_R 1
+
+/* Define to 1 if you have the `round' function. */
+#define H5_HAVE_ROUND 1
+
+/* Define to 1 if you have the `roundf' function. */
+#define H5_HAVE_ROUNDF 1
+
+/* Define to 1 if you have the `setjmp' function. */
+#define H5_HAVE_SETJMP 1
+
+/* Define to 1 if you have the <setjmp.h> header file. */
+#define H5_HAVE_SETJMP_H 1
+
+/* Define to 1 if you have the `setsysinfo' function. */
+/* #undef H5_HAVE_SETSYSINFO */
+
+/* Define to 1 if you have the `siglongjmp' function. */
+#define H5_HAVE_SIGLONGJMP 1
+
+/* Define to 1 if you have the `signal' function. */
+#define H5_HAVE_SIGNAL 1
+
+/* Define to 1 if you have the `sigprocmask' function. */
+#define H5_HAVE_SIGPROCMASK 1
+
+/* Define to 1 if you have the `sigsetjmp' function. */
+#define H5_HAVE_SIGSETJMP 1
+
+/* Define to 1 if you have the `snprintf' function. */
+#define H5_HAVE_SNPRINTF 1
+
+/* Define to 1 if you have the `srandom' function. */
+#define H5_HAVE_SRANDOM 1
+
+/* Define to 1 if you have the `stat64' function. */
+#define H5_HAVE_STAT64 1
+
+/* Define if `struct stat' has the `st_blocks' field */
+#define H5_HAVE_STAT_ST_BLOCKS 1
+
+/* Define to 1 if you have the <stdbool.h> header file. */
+#define H5_HAVE_STDBOOL_H 1
+
+/* Define to 1 if you have the <stddef.h> header file. */
+#define H5_HAVE_STDDEF_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define H5_HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdint.h> header file for Cplusplus. */
+#define H5_HAVE_STDINT_H_CXX 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define H5_HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define H5_HAVE_STRDUP 1
+
+/* Define to 1 if you have the `strtoll' function. */
+#define H5_HAVE_STRTOLL 1
+
+/* Define to 1 if you have the `strtoull' function. */
+#define H5_HAVE_STRTOULL 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define H5_HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define H5_HAVE_STRING_H 1
+
+/* Define if `struct text_info' is defined */
+/* #undef H5_HAVE_STRUCT_TEXT_INFO */
+
+/* Define if `struct videoconfig' is defined */
+/* #undef H5_HAVE_STRUCT_VIDEOCONFIG */
+
+/* Define to 1 if you have the `symlink' function. */
+#define H5_HAVE_SYMLINK 1
+
+/* Define to 1 if you have the `system' function. */
+#define H5_HAVE_SYSTEM 1
+
+/* Define to 1 if you have the <sys/file.h> header file. */
+#define H5_HAVE_SYS_FILE_H 1
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define H5_HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#define H5_HAVE_SYS_RESOURCE_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define H5_HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define H5_HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/timeb.h> header file. */
+#define H5_HAVE_SYS_TIMEB_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define H5_HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define H5_HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <szlib.h> header file. */
+/* #undef H5_HAVE_SZLIB_H */
+
+/* Define if we have thread safe support */
+/* #undef H5_HAVE_THREADSAFE */
+
+/* Define if `timezone' is a global variable */
+#define H5_HAVE_TIMEZONE 1
+
+/* Define if the ioctl TIOCGETD is defined */
+#define H5_HAVE_TIOCGETD 1
+
+/* Define if the ioctl TIOGWINSZ is defined */
+#define H5_HAVE_TIOCGWINSZ 1
+
+/* Define to 1 if you have the `tmpfile' function. */
+#define H5_HAVE_TMPFILE 1
+
+/* Define if `tm_gmtoff' is a member of `struct tm' */
+#define H5_HAVE_TM_GMTOFF 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define H5_HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define H5_HAVE_VASPRINTF 1
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define H5_HAVE_VSNPRINTF 1
+
+/* Define to 1 if you have the `waitpid' function. */
+#define H5_HAVE_WAITPID 1
+
+/* Define to 1 if you have the 'InitOnceExecuteOnce' function. */
+/* #undef H5_HAVE_WIN_THREADS */
+
+/* Define if your system has window style path name. */
+/* #undef H5_HAVE_WINDOW_PATH */
+
+/* Define to 1 if you have the <winsock.h> header file. */
+/* #undef H5_HAVE_WINSOCK2_H */
+
+/* Define to 1 if you have the <zlib.h> header file. */
+/* #undef H5_HAVE_ZLIB_H */
+
+/* Define to 1 if you have the `_getvideoconfig' function. */
+/* #undef H5_HAVE__GETVIDEOCONFIG */
+
+/* Define to 1 if you have the `_scrsize' function. */
+/* #undef H5_HAVE__SCRSIZE */
+
+/* Define if the compiler understands __inline */
+#define H5_HAVE___INLINE 1
+
+/* Define if the compiler understands __inline__ */
+#define H5_HAVE___INLINE__ 1
+
+/* Define if HDF5's high-level library headers should be included in hdf5.h */
+#define H5_INCLUDE_HL 1
+
+/* Define if your system can convert long double to (unsigned) long long
+   values correctly. */
+#define H5_LDOUBLE_TO_LLONG_ACCURATE 1
+
+/* Define if your system converts long double to (unsigned) long values with
+   special algorithm. */
+/* #undef H5_LDOUBLE_TO_LONG_SPECIAL */
+
+/* Define if your system can convert (unsigned) long long to long double
+   values correctly. */
+#define H5_LLONG_TO_LDOUBLE_CORRECT 1
+
+/* Define if your system can convert (unsigned) long to long double values
+   with special algorithm. */
+/* #undef H5_LONG_TO_LDOUBLE_SPECIAL */
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+/* #undef H5_LT_OBJDIR */
+
+/* Define to enable internal memory allocation sanity checking. */
+/* #undef H5_MEMORY_ALLOC_SANITY_CHECK */
+
+/* Define if the metadata trace file code is to be compiled in */
+/* #undef H5_METADATA_TRACE_FILE */
+
+/* Define if we can violate pointer alignment restrictions */
+#define H5_NO_ALIGNMENT_RESTRICTIONS 1
+
+/* Define if deprecated public API symbols are disabled */
+/* #undef H5_NO_DEPRECATED_SYMBOLS */
+
+/* Name of package */
+#define H5_PACKAGE "hdf5"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define H5_PACKAGE_BUGREPORT "help@hdfgroup.org"
+
+/* Define to the full name of this package. */
+#define H5_PACKAGE_NAME "HDF5"
+
+/* Define to the full name and version of this package. */
+#define H5_PACKAGE_STRING "HDF5 1.11.0"
+
+/* Define to the one symbol short name of this package. */
+#define H5_PACKAGE_TARNAME "hdf5"
+
+/* Define to the home page for this package. */
+#define H5_PACKAGE_URL "http://www.hdfgroup.org"
+
+/* Define to the version of this package. */
+#define H5_PACKAGE_VERSION "1.11.0"
+
+/* Determine the maximum decimal precision in C */
+#define H5_PAC_C_MAX_REAL_PRECISION 
+
+/* Define Fortran Maximum Real Decimal Precision */
+/* #undef H5_PAC_FC_MAX_REAL_PRECISION */
+
+/* Width for printf() for type `long long' or `__int64', use `ll' */
+#define H5_PRINTF_LL_WIDTH "l"
+
+/* The size of `bool', as computed by sizeof. */
+#define H5_SIZEOF_BOOL 1
+
+/* The size of `char', as computed by sizeof. */
+#define H5_SIZEOF_CHAR 1
+
+/* The size of `double', as computed by sizeof. */
+#define H5_SIZEOF_DOUBLE 8
+
+/* The size of `float', as computed by sizeof. */
+#define H5_SIZEOF_FLOAT 4
+
+/* The size of `int', as computed by sizeof. */
+#define H5_SIZEOF_INT 4
+
+/* The size of `int16_t', as computed by sizeof. */
+#define H5_SIZEOF_INT16_T 2
+
+/* The size of `int32_t', as computed by sizeof. */
+#define H5_SIZEOF_INT32_T 4
+
+/* The size of `int64_t', as computed by sizeof. */
+#define H5_SIZEOF_INT64_T 8
+
+/* The size of `int8_t', as computed by sizeof. */
+#define H5_SIZEOF_INT8_T 1
+
+/* The size of `int_fast16_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_FAST16_T 8
+
+/* The size of `int_fast32_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_FAST32_T 8
+
+/* The size of `int_fast64_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_FAST64_T 8
+
+/* The size of `int_fast8_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_FAST8_T 1
+
+/* The size of `int_least16_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_LEAST16_T 2
+
+/* The size of `int_least32_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_LEAST32_T 4
+
+/* The size of `int_least64_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_LEAST64_T 8
+
+/* The size of `int_least8_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_LEAST8_T 1
+
+#if !defined(__APPLE__)
+/* The size of `size_t', as computed by sizeof. */
+#define H5_SIZEOF_SIZE_T 8
+
+/* The size of `ssize_t', as computed by sizeof. */
+#define H5_SIZEOF_SSIZE_T 8
+
+/* The size of `long', as computed by sizeof. */
+#define H5_SIZEOF_LONG 8
+
+#else
+   # if defined(__LP64__) && __LP64__
+  #define H5_SIZEOF_LONG 8
+  #define H5_SIZEOF_SIZE_T 8
+  #define H5_SIZEOF_SSIZE_T 8
+  # else
+  #define H5_SIZEOF_LONG 4
+  #define H5_SIZEOF_SIZE_T 4
+  #define H5_SIZEOF_SSIZE_T 4
+  # endif
+
+#endif
+
+/* The size of `long double', as computed by sizeof. */
+#define H5_SIZEOF_LONG_DOUBLE 16
+
+/* Define size of long long and/or __int64 bit integer type only if the type
+   exists.  */
+#if !defined(__APPLE__)
+ #define H5_SIZEOF_LONG_LONG 8
+#else
+ #define H5_SIZEOF_LONG_LONG 8
+#endif
+
+/* The size of `off64_t', as computed by sizeof. */
+#define H5_SIZEOF_OFF64_T 8
+
+/* The size of `off_t', as computed by sizeof. */
+#define H5_SIZEOF_OFF_T 8
+
+/* The size of `ptrdiff_t', as computed by sizeof. */
+#define H5_SIZEOF_PTRDIFF_T 8
+
+/* The size of `short', as computed by sizeof. */
+#define H5_SIZEOF_SHORT 2
+
+/* The size of `uint16_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT16_T 2
+
+/* The size of `uint32_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT32_T 4
+
+/* The size of `uint64_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT64_T 8
+
+/* The size of `uint8_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT8_T 1
+
+/* The size of `uint_fast16_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_FAST16_T 8
+
+/* The size of `uint_fast32_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_FAST32_T 8
+
+/* The size of `uint_fast64_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_FAST64_T 8
+
+/* The size of `uint_fast8_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_FAST8_T 1
+
+/* The size of `uint_least16_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_LEAST16_T 2
+
+/* The size of `uint_least32_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_LEAST32_T 4
+
+/* The size of `uint_least64_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_LEAST64_T 8
+
+/* The size of `uint_least8_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_LEAST8_T 1
+
+/* The size of `unsigned', as computed by sizeof. */
+#define H5_SIZEOF_UNSIGNED 4
+
+/* The size of `_Quad', as computed by sizeof. */
+#define H5_SIZEOF__QUAD 
+
+/* The size of `__float128', as computed by sizeof. */
+#define H5_SIZEOF___FLOAT128 
+
+/* The size of `__int64', as computed by sizeof. */
+#define H5_SIZEOF___INT64 0
+
+/* Define to 1 if you have the ANSI C header files. */
+#define H5_STDC_HEADERS 1
+
+/* Define if strict file format checks are enabled */
+/* #undef H5_STRICT_FORMAT_CHECKS */
+
+/* Define if your system supports pthread_attr_setscope(&attribute,
+   PTHREAD_SCOPE_SYSTEM) call. */
+#define H5_SYSTEM_SCOPE_THREADS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define H5_TIME_WITH_SYS_TIME 1
+
+/* Define using v1.6 public API symbols by default */
+/* #undef H5_USE_16_API_DEFAULT */
+
+/* Define using v1.8 public API symbols by default */
+/* #undef H5_USE_18_API_DEFAULT */
+
+/* Define if a memory checking tool will be used on the library, to cause
+   library to be very picky about memory operations and also disable the
+   internal free list manager code. */
+/* #undef H5_USING_MEMCHECKER */
+
+/* Version number of package */
+#define H5_VERSION "1.11.0"
+
+/* Data accuracy is prefered to speed during data conversions */
+#define H5_WANT_DATA_ACCURACY 1
+
+/* Check exception handling functions during data conversions */
+#define H5_WANT_DCONV_EXCEPTION 1
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if !defined(__APPLE__)
+# ifndef WORDS_BIGENDIAN
+#  undef WORDS_BIGENDIAN
+# endif
+#else
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#endif
+
+/* #undef WORDS_BIGENDIAN */
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef H5__FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef H5__LARGE_FILES */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef H5_const */
+
+/* Define to `long int' if <sys/types.h> does not define. */
+/* #undef H5_off_t */
+
+/* Define to `long' if <sys/types.h> does not define. */
+/* #undef H5_ptrdiff_t */
+
+/* Define to `unsigned long' if <sys/types.h> does not define. */
+/* #undef H5_size_t */
+
+/* Define to `long' if <sys/types.h> does not define. */
+/* #undef H5_ssize_t */
+
+#endif
diff --git a/install/include/H5public.h b/install/include/H5public.h
new file mode 100644
index 0000000000..40e6e6eaf8
--- /dev/null
+++ b/install/include/H5public.h
@@ -0,0 +1,349 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the HDF5 module.
+ */
+#ifndef _H5public_H
+#define _H5public_H
+
+/* Include files for public use... */
+/*
+ * Since H5pubconf.h is a generated header file, it is messy to try
+ * to put a #ifndef _H5pubconf_H ... #endif guard in it.
+ * HDF5 has set an internal rule that it is being included here.
+ * Source files should NOT include H5pubconf.h directly but include
+ * it via H5public.h.  The #ifndef _H5public_H guard above would
+ * prevent repeated include.
+ */
+#include "H5pubconf.h"		/*from configure                             */
+
+/* API Version macro wrapper definitions */
+#include "H5version.h"
+
+#ifdef H5_HAVE_FEATURES_H
+#include <features.h>           /*for setting POSIX, BSD, etc. compatibility */
+#endif
+#ifdef H5_HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef H5_STDC_HEADERS
+#   include <limits.h>		/*for H5T_NATIVE_CHAR defn in H5Tpublic.h    */
+#endif
+#ifndef __cplusplus
+# ifdef H5_HAVE_STDINT_H
+#   include <stdint.h>		/*for C9x types				     */
+# endif
+#else
+# ifdef H5_HAVE_STDINT_H_CXX
+#   include <stdint.h>		/*for C9x types	when include from C++	     */
+# endif
+#endif
+#ifdef H5_HAVE_INTTYPES_H
+#   include <inttypes.h>        /* For uint64_t on some platforms            */
+#endif
+#ifdef H5_HAVE_STDDEF_H
+#   include <stddef.h>
+#endif
+#ifdef H5_HAVE_PARALLEL
+#   include <mpi.h>
+#ifndef MPI_FILE_NULL		/*MPIO may be defined in mpi.h already       */
+#   include <mpio.h>
+#endif
+#endif
+
+
+/* Include the Windows API adapter header early */
+#include "H5api_adpt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Macros for enabling/disabling particular GCC warnings */
+/* (see the following web-sites for more info:
+ *      http://www.dbp-consulting.com/tutorials/SuppressingGCCWarnings.html
+ *      http://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html#Diagnostic-Pragmas
+ */
+/* These pragmas are only implemented usefully in gcc 4.6+ */
+#if ((__GNUC__ * 100) + __GNUC_MINOR__) >= 406
+    #define H5_GCC_DIAG_STR(s) #s
+    #define H5_GCC_DIAG_JOINSTR(x,y) H5_GCC_DIAG_STR(x ## y)
+    #define H5_GCC_DIAG_DO_PRAGMA(x) _Pragma (#x)
+    #define H5_GCC_DIAG_PRAGMA(x) H5_GCC_DIAG_DO_PRAGMA(GCC diagnostic x)
+
+    #define H5_GCC_DIAG_OFF(x) H5_GCC_DIAG_PRAGMA(push) H5_GCC_DIAG_PRAGMA(ignored H5_GCC_DIAG_JOINSTR(-W,x))
+    #define H5_GCC_DIAG_ON(x) H5_GCC_DIAG_PRAGMA(pop)
+#else
+    #define H5_GCC_DIAG_OFF(x)
+    #define H5_GCC_DIAG_ON(x)
+#endif
+
+/* Version numbers */
+#define H5_VERS_MAJOR	1	/* For major interface/format changes  	     */
+#define H5_VERS_MINOR	11	/* For minor interface/format changes  	     */
+#define H5_VERS_RELEASE	0	/* For tweaks, bug-fixes, or development     */
+#define H5_VERS_SUBRELEASE ""	/* For pre-releases like snap0       */
+				/* Empty string for real releases.           */
+#define H5_VERS_INFO    "HDF5 library version: 1.11.0"      /* Full version string */
+
+#define H5check()	H5check_version(H5_VERS_MAJOR,H5_VERS_MINOR,	      \
+				        H5_VERS_RELEASE)
+
+/* macros for comparing the version */
+#define H5_VERSION_GE(Maj,Min,Rel) \
+       (((H5_VERS_MAJOR==Maj) && (H5_VERS_MINOR==Min) && (H5_VERS_RELEASE>=Rel)) || \
+        ((H5_VERS_MAJOR==Maj) && (H5_VERS_MINOR>Min)) || \
+        (H5_VERS_MAJOR>Maj))
+
+#define H5_VERSION_LE(Maj,Min,Rel) \
+       (((H5_VERS_MAJOR==Maj) && (H5_VERS_MINOR==Min) && (H5_VERS_RELEASE<=Rel)) || \
+        ((H5_VERS_MAJOR==Maj) && (H5_VERS_MINOR<Min)) || \
+        (H5_VERS_MAJOR<Maj))
+
+/*
+ * Status return values.  Failed integer functions in HDF5 result almost
+ * always in a negative value (unsigned failing functions sometimes return
+ * zero for failure) while successfull return is non-negative (often zero).
+ * The negative failure value is most commonly -1, but don't bet on it.  The
+ * proper way to detect failure is something like:
+ *
+ * 	if((dset = H5Dopen2(file, name)) < 0)
+ *	    fprintf(stderr, "unable to open the requested dataset\n");
+ */
+typedef int herr_t;
+
+
+/*
+ * Boolean type.  Successful return values are zero (false) or positive
+ * (true). The typical true value is 1 but don't bet on it.  Boolean
+ * functions cannot fail.  Functions that return `htri_t' however return zero
+ * (false), positive (true), or negative (failure). The proper way to test
+ * for truth from a htri_t function is:
+ *
+ * 	if ((retval = H5Tcommitted(type))>0) {
+ *	    printf("data type is committed\n");
+ *	} else if (!retval) {
+ * 	    printf("data type is not committed\n");
+ *	} else {
+ * 	    printf("error determining whether data type is committed\n");
+ *	}
+ */
+#ifdef H5_HAVE_STDBOOL_H
+  #include <stdbool.h>
+#else /* H5_HAVE_STDBOOL_H */
+  #ifndef __cplusplus
+    #if defined(H5_SIZEOF_BOOL) && (H5_SIZEOF_BOOL != 0)
+      #define bool    _Bool
+    #else
+      #define bool    unsigned int
+    #endif
+    #define true    1
+    #define false   0
+  #endif /* __cplusplus */
+#endif /* H5_HAVE_STDBOOL_H */
+typedef bool hbool_t;
+typedef int htri_t;
+
+/* Define the ssize_t type if it not is defined */
+#if H5_SIZEOF_SSIZE_T==0
+/* Undefine this size, we will re-define it in one of the sections below */
+#undef H5_SIZEOF_SSIZE_T
+#if H5_SIZEOF_SIZE_T==H5_SIZEOF_INT
+typedef int ssize_t;
+#       define H5_SIZEOF_SSIZE_T H5_SIZEOF_INT
+#elif H5_SIZEOF_SIZE_T==H5_SIZEOF_LONG
+typedef long ssize_t;
+#       define H5_SIZEOF_SSIZE_T H5_SIZEOF_LONG
+#elif H5_SIZEOF_SIZE_T==H5_SIZEOF_LONG_LONG
+typedef long long ssize_t;
+#       define H5_SIZEOF_SSIZE_T H5_SIZEOF_LONG_LONG
+#else /* Can't find matching type for ssize_t */
+#   error "nothing appropriate for ssize_t"
+#endif
+#endif
+
+/*
+ * The sizes of file objects have their own types defined here, use a 64-bit
+ * type.
+ */
+#if H5_SIZEOF_LONG_LONG >= 8
+H5_GCC_DIAG_OFF(long-long)
+typedef unsigned long long 	hsize_t;
+typedef signed long long	hssize_t;
+H5_GCC_DIAG_ON(long-long)
+#       define H5_SIZEOF_HSIZE_T H5_SIZEOF_LONG_LONG
+#       define H5_SIZEOF_HSSIZE_T H5_SIZEOF_LONG_LONG
+#else
+#   error "nothing appropriate for hsize_t"
+#endif
+#define HSIZE_UNDEF             ((hsize_t)(hssize_t)(-1))
+
+/*
+ * File addresses have their own types.
+ */
+#if H5_SIZEOF_INT >= 8
+    typedef unsigned                haddr_t;
+#   define HADDR_UNDEF              ((haddr_t)(-1))
+#   define H5_SIZEOF_HADDR_T        H5_SIZEOF_INT
+#   ifdef H5_HAVE_PARALLEL
+#       define HADDR_AS_MPI_TYPE    MPI_UNSIGNED
+#   endif  /* H5_HAVE_PARALLEL */
+#elif H5_SIZEOF_LONG >= 8
+    typedef unsigned long           haddr_t;
+#   define HADDR_UNDEF              ((haddr_t)(long)(-1))
+#   define H5_SIZEOF_HADDR_T        H5_SIZEOF_LONG
+#   ifdef H5_HAVE_PARALLEL
+#       define HADDR_AS_MPI_TYPE    MPI_UNSIGNED_LONG
+#   endif  /* H5_HAVE_PARALLEL */
+#elif H5_SIZEOF_LONG_LONG >= 8
+    typedef unsigned long long      haddr_t;
+#   define HADDR_UNDEF              ((haddr_t)(long long)(-1))
+#   define H5_SIZEOF_HADDR_T        H5_SIZEOF_LONG_LONG
+#   ifdef H5_HAVE_PARALLEL
+#       define HADDR_AS_MPI_TYPE    MPI_LONG_LONG_INT
+#   endif  /* H5_HAVE_PARALLEL */
+#else
+#   error "nothing appropriate for haddr_t"
+#endif
+#if H5_SIZEOF_HADDR_T == H5_SIZEOF_INT
+#   define H5_PRINTF_HADDR_FMT  "%u"
+#elif H5_SIZEOF_HADDR_T == H5_SIZEOF_LONG
+#   define H5_PRINTF_HADDR_FMT  "%lu"
+#elif H5_SIZEOF_HADDR_T == H5_SIZEOF_LONG_LONG
+#   define H5_PRINTF_HADDR_FMT  "%" H5_PRINTF_LL_WIDTH "u"
+#else
+#   error "nothing appropriate for H5_PRINTF_HADDR_FMT"
+#endif
+#define HADDR_MAX		(HADDR_UNDEF-1)
+
+/* uint32_t type is used for creation order field for messages.  It may be
+ * defined in Posix.1g, otherwise it is defined here.
+ */
+#if H5_SIZEOF_UINT32_T>=4
+#elif H5_SIZEOF_SHORT>=4
+    typedef short uint32_t;
+#   undef H5_SIZEOF_UINT32_T
+#   define H5_SIZEOF_UINT32_T H5_SIZEOF_SHORT
+#elif H5_SIZEOF_INT>=4
+    typedef unsigned int uint32_t;
+#   undef H5_SIZEOF_UINT32_T
+#   define H5_SIZEOF_UINT32_T H5_SIZEOF_INT
+#elif H5_SIZEOF_LONG>=4
+    typedef unsigned long uint32_t;
+#   undef H5_SIZEOF_UINT32_T
+#   define H5_SIZEOF_UINT32_T H5_SIZEOF_LONG
+#else
+#   error "nothing appropriate for uint32_t"
+#endif
+
+/* int64_t type is used for creation order field for links.  It may be
+ * defined in Posix.1g, otherwise it is defined here.
+ */
+#if H5_SIZEOF_INT64_T>=8
+#elif H5_SIZEOF_INT>=8
+    typedef int int64_t;
+#   undef H5_SIZEOF_INT64_T
+#   define H5_SIZEOF_INT64_T H5_SIZEOF_INT
+#elif H5_SIZEOF_LONG>=8
+    typedef long int64_t;
+#   undef H5_SIZEOF_INT64_T
+#   define H5_SIZEOF_INT64_T H5_SIZEOF_LONG
+#elif H5_SIZEOF_LONG_LONG>=8
+    typedef long long int64_t;
+#   undef H5_SIZEOF_INT64_T
+#   define H5_SIZEOF_INT64_T H5_SIZEOF_LONG_LONG
+#else
+#   error "nothing appropriate for int64_t"
+#endif
+
+/* uint64_t type is used for fields for H5O_info_t.  It may be
+ * defined in Posix.1g, otherwise it is defined here.
+ */
+#if H5_SIZEOF_UINT64_T>=8
+#elif H5_SIZEOF_INT>=8
+    typedef unsigned uint64_t;
+#   undef H5_SIZEOF_UINT64_T
+#   define H5_SIZEOF_UINT64_T H5_SIZEOF_INT
+#elif H5_SIZEOF_LONG>=8
+    typedef unsigned long uint64_t;
+#   undef H5_SIZEOF_UINT64_T
+#   define H5_SIZEOF_UINT64_T H5_SIZEOF_LONG
+#elif H5_SIZEOF_LONG_LONG>=8
+    typedef unsigned long long uint64_t;
+#   undef H5_SIZEOF_UINT64_T
+#   define H5_SIZEOF_UINT64_T H5_SIZEOF_LONG_LONG
+#else
+#   error "nothing appropriate for uint64_t"
+#endif
+
+/* Common iteration orders */
+typedef enum {
+    H5_ITER_UNKNOWN = -1,       /* Unknown order */
+    H5_ITER_INC,                /* Increasing order */
+    H5_ITER_DEC,                /* Decreasing order */
+    H5_ITER_NATIVE,             /* No particular order, whatever is fastest */
+    H5_ITER_N		        /* Number of iteration orders */
+} H5_iter_order_t;
+
+/* Iteration callback values */
+/* (Actually, any postive value will cause the iterator to stop and pass back
+ *      that positive value to the function that called the iterator)
+ */
+#define H5_ITER_ERROR   (-1)
+#define H5_ITER_CONT    (0)
+#define H5_ITER_STOP    (1)
+
+/*
+ * The types of indices on links in groups/attributes on objects.
+ * Primarily used for "<do> <foo> by index" routines and for iterating over
+ * links in groups/attributes on objects.
+ */
+typedef enum H5_index_t {
+    H5_INDEX_UNKNOWN = -1,	/* Unknown index type			*/
+    H5_INDEX_NAME,		/* Index on names 			*/
+    H5_INDEX_CRT_ORDER,		/* Index on creation order 		*/
+    H5_INDEX_N			/* Number of indices defined 		*/
+} H5_index_t;
+
+/*
+ * Storage info struct used by H5O_info_t and H5F_info_t
+ */
+typedef struct H5_ih_info_t {
+    hsize_t     index_size;     /* btree and/or list */
+    hsize_t     heap_size;
+} H5_ih_info_t;
+
+/* Functions in H5.c */
+H5_DLL herr_t H5open(void);
+H5_DLL herr_t H5close(void);
+H5_DLL herr_t H5dont_atexit(void);
+H5_DLL herr_t H5garbage_collect(void);
+H5_DLL herr_t H5set_free_list_limits (int reg_global_lim, int reg_list_lim,
+                int arr_global_lim, int arr_list_lim, int blk_global_lim,
+                int blk_list_lim);
+H5_DLL herr_t H5get_libversion(unsigned *majnum, unsigned *minnum,
+				unsigned *relnum);
+H5_DLL herr_t H5check_version(unsigned majnum, unsigned minnum,
+			       unsigned relnum);
+H5_DLL herr_t H5is_library_threadsafe(hbool_t *is_ts);
+H5_DLL herr_t H5free_memory(void *mem);
+H5_DLL void *H5allocate_memory(size_t size, hbool_t clear);
+H5_DLL void *H5resize_memory(void *mem, size_t size);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _H5public_H */
+ 
+
diff --git a/install/include/H5version.h b/install/include/H5version.h
new file mode 100644
index 0000000000..075274e8a1
--- /dev/null
+++ b/install/include/H5version.h
@@ -0,0 +1,562 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Generated automatically by bin/make_vers -- do not edit */
+/* Add new versioned symbols to H5vers.txt file */
+
+
+#ifndef _H5version_H
+#define _H5version_H
+
+/* Issue error if contradicting macros have been defined. */
+#if (defined(H5_USE_16_API) || defined(H5_USE_18_API)) && defined(H5_NO_DEPRECATED_SYMBOLS)
+  #error "Can't choose old API versions when deprecated APIs are disabled"
+#endif /* (defined(H5_USE_16_API) || defined(H5_USE_18_API)) && defined(H5_NO_DEPRECATED_SYMBOLS) */
+
+
+/* If a particular "global" version of the library's interfaces is chosen,
+ *      set the versions for the API symbols affected.
+ *
+ * Note: If an application has already chosen a particular version for an
+ *      API symbol, the individual API version macro takes priority.
+ */
+#if defined(H5_USE_16_API_DEFAULT) && !defined(H5_USE_16_API)
+  #define H5_USE_16_API 1
+#endif /* H5_USE_16_API_DEFAULT && !H5_USE_16_API */
+
+#if defined(H5_USE_18_API_DEFAULT) && !defined(H5_USE_18_API)
+  #define H5_USE_18_API 1
+#endif /* H5_USE_18_API_DEFAULT && !H5_USE_18_API */
+
+
+#ifdef H5_USE_16_API
+
+/*************/
+/* Functions */
+/*************/
+
+#if !defined(H5Acreate_vers)
+  #define H5Acreate_vers 1
+#endif /* !defined(H5Acreate_vers) */
+
+#if !defined(H5Aiterate_vers)
+  #define H5Aiterate_vers 1
+#endif /* !defined(H5Aiterate_vers) */
+
+#if !defined(H5Dcreate_vers)
+  #define H5Dcreate_vers 1
+#endif /* !defined(H5Dcreate_vers) */
+
+#if !defined(H5Dopen_vers)
+  #define H5Dopen_vers 1
+#endif /* !defined(H5Dopen_vers) */
+
+#if !defined(H5Eclear_vers)
+  #define H5Eclear_vers 1
+#endif /* !defined(H5Eclear_vers) */
+
+#if !defined(H5Eget_auto_vers)
+  #define H5Eget_auto_vers 1
+#endif /* !defined(H5Eget_auto_vers) */
+
+#if !defined(H5Eprint_vers)
+  #define H5Eprint_vers 1
+#endif /* !defined(H5Eprint_vers) */
+
+#if !defined(H5Epush_vers)
+  #define H5Epush_vers 1
+#endif /* !defined(H5Epush_vers) */
+
+#if !defined(H5Eset_auto_vers)
+  #define H5Eset_auto_vers 1
+#endif /* !defined(H5Eset_auto_vers) */
+
+#if !defined(H5Ewalk_vers)
+  #define H5Ewalk_vers 1
+#endif /* !defined(H5Ewalk_vers) */
+
+#if !defined(H5Gcreate_vers)
+  #define H5Gcreate_vers 1
+#endif /* !defined(H5Gcreate_vers) */
+
+#if !defined(H5Gopen_vers)
+  #define H5Gopen_vers 1
+#endif /* !defined(H5Gopen_vers) */
+
+#if !defined(H5Pget_filter_vers)
+  #define H5Pget_filter_vers 1
+#endif /* !defined(H5Pget_filter_vers) */
+
+#if !defined(H5Pget_filter_by_id_vers)
+  #define H5Pget_filter_by_id_vers 1
+#endif /* !defined(H5Pget_filter_by_id_vers) */
+
+#if !defined(H5Pinsert_vers)
+  #define H5Pinsert_vers 1
+#endif /* !defined(H5Pinsert_vers) */
+
+#if !defined(H5Pregister_vers)
+  #define H5Pregister_vers 1
+#endif /* !defined(H5Pregister_vers) */
+
+#if !defined(H5Rdereference_vers)
+  #define H5Rdereference_vers 1
+#endif /* !defined(H5Rdereference_vers) */
+
+#if !defined(H5Rget_obj_type_vers)
+  #define H5Rget_obj_type_vers 1
+#endif /* !defined(H5Rget_obj_type_vers) */
+
+#if !defined(H5Tarray_create_vers)
+  #define H5Tarray_create_vers 1
+#endif /* !defined(H5Tarray_create_vers) */
+
+#if !defined(H5Tcommit_vers)
+  #define H5Tcommit_vers 1
+#endif /* !defined(H5Tcommit_vers) */
+
+#if !defined(H5Tget_array_dims_vers)
+  #define H5Tget_array_dims_vers 1
+#endif /* !defined(H5Tget_array_dims_vers) */
+
+#if !defined(H5Topen_vers)
+  #define H5Topen_vers 1
+#endif /* !defined(H5Topen_vers) */
+
+/************/
+/* Typedefs */
+/************/
+
+#if !defined(H5E_auto_t_vers)
+  #define H5E_auto_t_vers 1
+#endif /* !defined(H5E_auto_t_vers) */
+
+#if !defined(H5Z_class_t_vers)
+  #define H5Z_class_t_vers 1
+#endif /* !defined(H5Z_class_t_vers) */
+
+#endif /* H5_USE_16_API */
+
+#ifdef H5_USE_18_API
+
+/*************/
+/* Functions */
+/*************/
+
+#if !defined(H5Acreate_vers)
+  #define H5Acreate_vers 2
+#endif /* !defined(H5Acreate_vers) */
+
+#if !defined(H5Aiterate_vers)
+  #define H5Aiterate_vers 2
+#endif /* !defined(H5Aiterate_vers) */
+
+#if !defined(H5Dcreate_vers)
+  #define H5Dcreate_vers 2
+#endif /* !defined(H5Dcreate_vers) */
+
+#if !defined(H5Dopen_vers)
+  #define H5Dopen_vers 2
+#endif /* !defined(H5Dopen_vers) */
+
+#if !defined(H5Eclear_vers)
+  #define H5Eclear_vers 2
+#endif /* !defined(H5Eclear_vers) */
+
+#if !defined(H5Eget_auto_vers)
+  #define H5Eget_auto_vers 2
+#endif /* !defined(H5Eget_auto_vers) */
+
+#if !defined(H5Eprint_vers)
+  #define H5Eprint_vers 2
+#endif /* !defined(H5Eprint_vers) */
+
+#if !defined(H5Epush_vers)
+  #define H5Epush_vers 2
+#endif /* !defined(H5Epush_vers) */
+
+#if !defined(H5Eset_auto_vers)
+  #define H5Eset_auto_vers 2
+#endif /* !defined(H5Eset_auto_vers) */
+
+#if !defined(H5Ewalk_vers)
+  #define H5Ewalk_vers 2
+#endif /* !defined(H5Ewalk_vers) */
+
+#if !defined(H5Fget_info_vers)
+  #define H5Fget_info_vers 1
+#endif /* !defined(H5Fget_info_vers) */
+
+#if !defined(H5Gcreate_vers)
+  #define H5Gcreate_vers 2
+#endif /* !defined(H5Gcreate_vers) */
+
+#if !defined(H5Gopen_vers)
+  #define H5Gopen_vers 2
+#endif /* !defined(H5Gopen_vers) */
+
+#if !defined(H5Pget_filter_vers)
+  #define H5Pget_filter_vers 2
+#endif /* !defined(H5Pget_filter_vers) */
+
+#if !defined(H5Pget_filter_by_id_vers)
+  #define H5Pget_filter_by_id_vers 2
+#endif /* !defined(H5Pget_filter_by_id_vers) */
+
+#if !defined(H5Pinsert_vers)
+  #define H5Pinsert_vers 2
+#endif /* !defined(H5Pinsert_vers) */
+
+#if !defined(H5Pregister_vers)
+  #define H5Pregister_vers 2
+#endif /* !defined(H5Pregister_vers) */
+
+#if !defined(H5Rdereference_vers)
+  #define H5Rdereference_vers 1
+#endif /* !defined(H5Rdereference_vers) */
+
+#if !defined(H5Rget_obj_type_vers)
+  #define H5Rget_obj_type_vers 2
+#endif /* !defined(H5Rget_obj_type_vers) */
+
+#if !defined(H5Tarray_create_vers)
+  #define H5Tarray_create_vers 2
+#endif /* !defined(H5Tarray_create_vers) */
+
+#if !defined(H5Tcommit_vers)
+  #define H5Tcommit_vers 2
+#endif /* !defined(H5Tcommit_vers) */
+
+#if !defined(H5Tget_array_dims_vers)
+  #define H5Tget_array_dims_vers 2
+#endif /* !defined(H5Tget_array_dims_vers) */
+
+#if !defined(H5Topen_vers)
+  #define H5Topen_vers 2
+#endif /* !defined(H5Topen_vers) */
+
+/************/
+/* Typedefs */
+/************/
+
+#if !defined(H5E_auto_t_vers)
+  #define H5E_auto_t_vers 2
+#endif /* !defined(H5E_auto_t_vers) */
+
+#if !defined(H5Z_class_t_vers)
+  #define H5Z_class_t_vers 2
+#endif /* !defined(H5Z_class_t_vers) */
+
+#endif /* H5_USE_18_API */
+
+
+/* Choose the correct version of each API symbol, defaulting to the latest
+ *      version of each.  The "best" name for API parameters/data structures
+ *      that have changed definitions is also set.  An error is issued for
+ *      specifying an invalid API version.
+ */
+
+/*************/
+/* Functions */
+/*************/
+
+#if !defined(H5Acreate_vers) || H5Acreate_vers == 2
+  #ifndef H5Acreate_vers
+    #define H5Acreate_vers 2
+  #endif /* H5Acreate_vers */
+  #define H5Acreate H5Acreate2
+#elif H5Acreate_vers == 1
+  #define H5Acreate H5Acreate1
+#else /* H5Acreate_vers */
+  #error "H5Acreate_vers set to invalid value"
+#endif /* H5Acreate_vers */
+
+#if !defined(H5Aiterate_vers) || H5Aiterate_vers == 2
+  #ifndef H5Aiterate_vers
+    #define H5Aiterate_vers 2
+  #endif /* H5Aiterate_vers */
+  #define H5Aiterate H5Aiterate2
+  #define H5A_operator_t H5A_operator2_t
+#elif H5Aiterate_vers == 1
+  #define H5Aiterate H5Aiterate1
+  #define H5A_operator_t H5A_operator1_t
+#else /* H5Aiterate_vers */
+  #error "H5Aiterate_vers set to invalid value"
+#endif /* H5Aiterate_vers */
+
+#if !defined(H5Dcreate_vers) || H5Dcreate_vers == 2
+  #ifndef H5Dcreate_vers
+    #define H5Dcreate_vers 2
+  #endif /* H5Dcreate_vers */
+  #define H5Dcreate H5Dcreate2
+#elif H5Dcreate_vers == 1
+  #define H5Dcreate H5Dcreate1
+#else /* H5Dcreate_vers */
+  #error "H5Dcreate_vers set to invalid value"
+#endif /* H5Dcreate_vers */
+
+#if !defined(H5Dopen_vers) || H5Dopen_vers == 2
+  #ifndef H5Dopen_vers
+    #define H5Dopen_vers 2
+  #endif /* H5Dopen_vers */
+  #define H5Dopen H5Dopen2
+#elif H5Dopen_vers == 1
+  #define H5Dopen H5Dopen1
+#else /* H5Dopen_vers */
+  #error "H5Dopen_vers set to invalid value"
+#endif /* H5Dopen_vers */
+
+#if !defined(H5Eclear_vers) || H5Eclear_vers == 2
+  #ifndef H5Eclear_vers
+    #define H5Eclear_vers 2
+  #endif /* H5Eclear_vers */
+  #define H5Eclear H5Eclear2
+#elif H5Eclear_vers == 1
+  #define H5Eclear H5Eclear1
+#else /* H5Eclear_vers */
+  #error "H5Eclear_vers set to invalid value"
+#endif /* H5Eclear_vers */
+
+#if !defined(H5Eget_auto_vers) || H5Eget_auto_vers == 2
+  #ifndef H5Eget_auto_vers
+    #define H5Eget_auto_vers 2
+  #endif /* H5Eget_auto_vers */
+  #define H5Eget_auto H5Eget_auto2
+#elif H5Eget_auto_vers == 1
+  #define H5Eget_auto H5Eget_auto1
+#else /* H5Eget_auto_vers */
+  #error "H5Eget_auto_vers set to invalid value"
+#endif /* H5Eget_auto_vers */
+
+#if !defined(H5Eprint_vers) || H5Eprint_vers == 2
+  #ifndef H5Eprint_vers
+    #define H5Eprint_vers 2
+  #endif /* H5Eprint_vers */
+  #define H5Eprint H5Eprint2
+#elif H5Eprint_vers == 1
+  #define H5Eprint H5Eprint1
+#else /* H5Eprint_vers */
+  #error "H5Eprint_vers set to invalid value"
+#endif /* H5Eprint_vers */
+
+#if !defined(H5Epush_vers) || H5Epush_vers == 2
+  #ifndef H5Epush_vers
+    #define H5Epush_vers 2
+  #endif /* H5Epush_vers */
+  #define H5Epush H5Epush2
+#elif H5Epush_vers == 1
+  #define H5Epush H5Epush1
+#else /* H5Epush_vers */
+  #error "H5Epush_vers set to invalid value"
+#endif /* H5Epush_vers */
+
+#if !defined(H5Eset_auto_vers) || H5Eset_auto_vers == 2
+  #ifndef H5Eset_auto_vers
+    #define H5Eset_auto_vers 2
+  #endif /* H5Eset_auto_vers */
+  #define H5Eset_auto H5Eset_auto2
+#elif H5Eset_auto_vers == 1
+  #define H5Eset_auto H5Eset_auto1
+#else /* H5Eset_auto_vers */
+  #error "H5Eset_auto_vers set to invalid value"
+#endif /* H5Eset_auto_vers */
+
+#if !defined(H5Ewalk_vers) || H5Ewalk_vers == 2
+  #ifndef H5Ewalk_vers
+    #define H5Ewalk_vers 2
+  #endif /* H5Ewalk_vers */
+  #define H5Ewalk H5Ewalk2
+  #define H5E_error_t H5E_error2_t
+  #define H5E_walk_t H5E_walk2_t
+#elif H5Ewalk_vers == 1
+  #define H5Ewalk H5Ewalk1
+  #define H5E_error_t H5E_error1_t
+  #define H5E_walk_t H5E_walk1_t
+#else /* H5Ewalk_vers */
+  #error "H5Ewalk_vers set to invalid value"
+#endif /* H5Ewalk_vers */
+
+#if !defined(H5Fget_info_vers) || H5Fget_info_vers == 2
+  #ifndef H5Fget_info_vers
+    #define H5Fget_info_vers 2
+  #endif /* H5Fget_info_vers */
+  #define H5Fget_info H5Fget_info2
+  #define H5F_info_t H5F_info2_t
+#elif H5Fget_info_vers == 1
+  #define H5Fget_info H5Fget_info1
+  #define H5F_info_t H5F_info1_t
+#else /* H5Fget_info_vers */
+  #error "H5Fget_info_vers set to invalid value"
+#endif /* H5Fget_info_vers */
+
+#if !defined(H5Gcreate_vers) || H5Gcreate_vers == 2
+  #ifndef H5Gcreate_vers
+    #define H5Gcreate_vers 2
+  #endif /* H5Gcreate_vers */
+  #define H5Gcreate H5Gcreate2
+#elif H5Gcreate_vers == 1
+  #define H5Gcreate H5Gcreate1
+#else /* H5Gcreate_vers */
+  #error "H5Gcreate_vers set to invalid value"
+#endif /* H5Gcreate_vers */
+
+#if !defined(H5Gopen_vers) || H5Gopen_vers == 2
+  #ifndef H5Gopen_vers
+    #define H5Gopen_vers 2
+  #endif /* H5Gopen_vers */
+  #define H5Gopen H5Gopen2
+#elif H5Gopen_vers == 1
+  #define H5Gopen H5Gopen1
+#else /* H5Gopen_vers */
+  #error "H5Gopen_vers set to invalid value"
+#endif /* H5Gopen_vers */
+
+#if !defined(H5Pget_filter_vers) || H5Pget_filter_vers == 2
+  #ifndef H5Pget_filter_vers
+    #define H5Pget_filter_vers 2
+  #endif /* H5Pget_filter_vers */
+  #define H5Pget_filter H5Pget_filter2
+#elif H5Pget_filter_vers == 1
+  #define H5Pget_filter H5Pget_filter1
+#else /* H5Pget_filter_vers */
+  #error "H5Pget_filter_vers set to invalid value"
+#endif /* H5Pget_filter_vers */
+
+#if !defined(H5Pget_filter_by_id_vers) || H5Pget_filter_by_id_vers == 2
+  #ifndef H5Pget_filter_by_id_vers
+    #define H5Pget_filter_by_id_vers 2
+  #endif /* H5Pget_filter_by_id_vers */
+  #define H5Pget_filter_by_id H5Pget_filter_by_id2
+#elif H5Pget_filter_by_id_vers == 1
+  #define H5Pget_filter_by_id H5Pget_filter_by_id1
+#else /* H5Pget_filter_by_id_vers */
+  #error "H5Pget_filter_by_id_vers set to invalid value"
+#endif /* H5Pget_filter_by_id_vers */
+
+#if !defined(H5Pinsert_vers) || H5Pinsert_vers == 2
+  #ifndef H5Pinsert_vers
+    #define H5Pinsert_vers 2
+  #endif /* H5Pinsert_vers */
+  #define H5Pinsert H5Pinsert2
+#elif H5Pinsert_vers == 1
+  #define H5Pinsert H5Pinsert1
+#else /* H5Pinsert_vers */
+  #error "H5Pinsert_vers set to invalid value"
+#endif /* H5Pinsert_vers */
+
+#if !defined(H5Pregister_vers) || H5Pregister_vers == 2
+  #ifndef H5Pregister_vers
+    #define H5Pregister_vers 2
+  #endif /* H5Pregister_vers */
+  #define H5Pregister H5Pregister2
+#elif H5Pregister_vers == 1
+  #define H5Pregister H5Pregister1
+#else /* H5Pregister_vers */
+  #error "H5Pregister_vers set to invalid value"
+#endif /* H5Pregister_vers */
+
+#if !defined(H5Rdereference_vers) || H5Rdereference_vers == 2
+  #ifndef H5Rdereference_vers
+    #define H5Rdereference_vers 2
+  #endif /* H5Rdereference_vers */
+  #define H5Rdereference H5Rdereference2
+#elif H5Rdereference_vers == 1
+  #define H5Rdereference H5Rdereference1
+#else /* H5Rdereference_vers */
+  #error "H5Rdereference_vers set to invalid value"
+#endif /* H5Rdereference_vers */
+
+#if !defined(H5Rget_obj_type_vers) || H5Rget_obj_type_vers == 2
+  #ifndef H5Rget_obj_type_vers
+    #define H5Rget_obj_type_vers 2
+  #endif /* H5Rget_obj_type_vers */
+  #define H5Rget_obj_type H5Rget_obj_type2
+#elif H5Rget_obj_type_vers == 1
+  #define H5Rget_obj_type H5Rget_obj_type1
+#else /* H5Rget_obj_type_vers */
+  #error "H5Rget_obj_type_vers set to invalid value"
+#endif /* H5Rget_obj_type_vers */
+
+#if !defined(H5Tarray_create_vers) || H5Tarray_create_vers == 2
+  #ifndef H5Tarray_create_vers
+    #define H5Tarray_create_vers 2
+  #endif /* H5Tarray_create_vers */
+  #define H5Tarray_create H5Tarray_create2
+#elif H5Tarray_create_vers == 1
+  #define H5Tarray_create H5Tarray_create1
+#else /* H5Tarray_create_vers */
+  #error "H5Tarray_create_vers set to invalid value"
+#endif /* H5Tarray_create_vers */
+
+#if !defined(H5Tcommit_vers) || H5Tcommit_vers == 2
+  #ifndef H5Tcommit_vers
+    #define H5Tcommit_vers 2
+  #endif /* H5Tcommit_vers */
+  #define H5Tcommit H5Tcommit2
+#elif H5Tcommit_vers == 1
+  #define H5Tcommit H5Tcommit1
+#else /* H5Tcommit_vers */
+  #error "H5Tcommit_vers set to invalid value"
+#endif /* H5Tcommit_vers */
+
+#if !defined(H5Tget_array_dims_vers) || H5Tget_array_dims_vers == 2
+  #ifndef H5Tget_array_dims_vers
+    #define H5Tget_array_dims_vers 2
+  #endif /* H5Tget_array_dims_vers */
+  #define H5Tget_array_dims H5Tget_array_dims2
+#elif H5Tget_array_dims_vers == 1
+  #define H5Tget_array_dims H5Tget_array_dims1
+#else /* H5Tget_array_dims_vers */
+  #error "H5Tget_array_dims_vers set to invalid value"
+#endif /* H5Tget_array_dims_vers */
+
+#if !defined(H5Topen_vers) || H5Topen_vers == 2
+  #ifndef H5Topen_vers
+    #define H5Topen_vers 2
+  #endif /* H5Topen_vers */
+  #define H5Topen H5Topen2
+#elif H5Topen_vers == 1
+  #define H5Topen H5Topen1
+#else /* H5Topen_vers */
+  #error "H5Topen_vers set to invalid value"
+#endif /* H5Topen_vers */
+
+/************/
+/* Typedefs */
+/************/
+
+#if !defined(H5E_auto_t_vers) || H5E_auto_t_vers == 2
+  #ifndef H5E_auto_t_vers
+    #define H5E_auto_t_vers 2
+  #endif /* H5E_auto_t_vers */
+  #define H5E_auto_t H5E_auto2_t
+#elif H5E_auto_t_vers == 1
+  #define H5E_auto_t H5E_auto1_t
+#else /* H5E_auto_t_vers */
+  #error "H5E_auto_t_vers set to invalid value"
+#endif /* H5E_auto_t_vers */
+
+
+#if !defined(H5Z_class_t_vers) || H5Z_class_t_vers == 2
+  #ifndef H5Z_class_t_vers
+    #define H5Z_class_t_vers 2
+  #endif /* H5Z_class_t_vers */
+  #define H5Z_class_t H5Z_class2_t
+#elif H5Z_class_t_vers == 1
+  #define H5Z_class_t H5Z_class1_t
+#else /* H5Z_class_t_vers */
+  #error "H5Z_class_t_vers set to invalid value"
+#endif /* H5Z_class_t_vers */
+
+#endif /* H5version_H */
+
diff --git a/install/include/h5diff.h b/install/include/h5diff.h
new file mode 100644
index 0000000000..0226e8380d
--- /dev/null
+++ b/install/include/h5diff.h
@@ -0,0 +1,198 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef H5DIFF_H__
+#define H5DIFF_H__
+
+#include "hdf5.h"
+#include "h5trav.h"
+
+/*
+ * Debug printf macros. The prefix allows output filtering by test scripts.
+ */
+#ifdef H5DIFF_DEBUG
+#define h5difftrace(x) HDfprintf(stderr, "h5diff debug: " x)
+#define h5diffdebug2(x1, x2) HDfprintf(stderr, "h5diff debug: " x1, x2)
+#define h5diffdebug3(x1, x2, x3) HDfprintf(stderr, "h5diff debug: " x1, x2, x3)
+#define h5diffdebug4(x1, x2, x3, x4) HDfprintf(stderr, "h5diff debug: " x1, x2, x3, x4)
+#define h5diffdebug5(x1, x2, x3, x4, x5) HDfprintf(stderr, "h5diff debug: " x1, x2, x3, x4, x5)
+#else
+#define h5difftrace(x)
+#define h5diffdebug2(x1, x2)
+#define h5diffdebug3(x1, x2, x3)
+#define h5diffdebug4(x1, x2, x3, x4)
+#define h5diffdebug5(x1, x2, x3, x4, x5)
+#endif
+
+#define MAX_FILENAME 1024
+
+/*-------------------------------------------------------------------------
+ * This is used to pass multiple args into diff().
+ * Passing this instead of several each arg provides smoother extensibility 
+ * through its members along with MPI code for ph5diff
+ * as it doesn't require interface change.
+ *------------------------------------------------------------------------*/
+typedef struct {
+    h5trav_type_t   type[2];
+    hbool_t is_same_trgobj;
+} diff_args_t;
+/*-------------------------------------------------------------------------
+ * command line options
+ *-------------------------------------------------------------------------
+ */
+/* linked list to keep exclude path list */
+struct exclude_path_list {
+    char  *obj_path;
+    h5trav_type_t obj_type;
+    struct exclude_path_list * next;
+};
+
+typedef struct {
+    int      m_quiet;               /* quiet mide: no output at all */
+    int      m_report;              /* report mode: print the data */
+    int      m_verbose;             /* verbose mode: print the data, list of objcets, warnings */
+    int      m_verbose_level;       /* control verbose details */
+    int      d;                     /* delta, absolute value to compare */
+    double   delta;                 /* delta value */
+    int      p;                     /* relative error to compare*/
+    int      use_system_epsilon;    /* flag to use system epsilon (1 or 0) */
+    double   percent;               /* relative error value */
+    int      n;                     /* count, compare up to count */
+    hsize_t  count;                 /* count value */
+    hbool_t  follow_links;          /* follow symbolic links */
+    int      no_dangle_links;       /* return error when find dangling link */
+    int      err_stat;              /* an error ocurred (1, error, 0, no error) */
+    int      cmn_objs;              /* do we have common objects */
+    int      not_cmp;               /* are the objects comparable */
+    int      contents;              /* equal contents */
+    int      do_nans;               /* consider Nans while diffing floats */
+    int      m_list_not_cmp;        /* list not comparable messages */
+    int      exclude_path;          /* exclude path to an object */
+    struct   exclude_path_list * exclude; /* keep exclude path list */
+} diff_opt_t;
+
+
+/*-------------------------------------------------------------------------
+ * public functions
+ *-------------------------------------------------------------------------
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5TOOLS_DLL hsize_t  h5diff(const char *fname1,
+                const char *fname2,
+                const char *objname1,
+                const char *objname2,
+                diff_opt_t *options);
+
+H5TOOLS_DLL hsize_t diff( hid_t      file1_id,
+              const char *path1,
+              hid_t      file2_id,
+              const char *path2,
+              diff_opt_t *options,
+              diff_args_t *argdata);
+
+#ifdef H5_HAVE_PARALLEL
+H5TOOLS_DLL void phdiff_dismiss_workers(void);
+H5TOOLS_DLL void print_manager_output(void);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+
+
+/*-------------------------------------------------------------------------
+ * private functions
+ *-------------------------------------------------------------------------
+ */
+
+
+hsize_t diff_dataset( hid_t file1_id,
+                      hid_t file2_id,
+                      const char *obj1_name,
+                      const char *obj2_name,
+                      diff_opt_t *options);
+
+hsize_t diff_datasetid( hid_t dset1_id,
+                        hid_t dset2_id,
+                        const char *obj1_name,
+                        const char *obj2_name,
+                        diff_opt_t *options);
+
+
+hsize_t diff_match( hid_t file1_id, const char *grp1, trav_info_t *info1,
+                    hid_t file2_id, const char *grp2, trav_info_t *info2,
+                    trav_table_t *table, diff_opt_t *options );
+
+hsize_t diff_array( void *_mem1,
+                    void *_mem2,
+                    hsize_t nelmts,
+                    hsize_t hyper_start,
+                    int rank,
+                    hsize_t *dims,
+                    diff_opt_t *options,
+                    const char *name1,
+                    const char *name2,
+                    hid_t m_type,
+                    hid_t container1_id,
+                    hid_t container2_id); /* dataset where the reference came from*/
+
+
+int diff_can_type( hid_t       f_type1, /* file data type */
+                   hid_t       f_type2, /* file data type */
+                   int         rank1,
+                   int         rank2,
+                   hsize_t     *dims1,
+                   hsize_t     *dims2,
+                   hsize_t     *maxdim1,
+                   hsize_t     *maxdim2,
+                   const char  *obj1_name,
+                   const char  *obj2_name,
+                   diff_opt_t  *options,
+                   int         is_compound);
+
+
+hsize_t diff_attr(hid_t loc1_id,
+                  hid_t loc2_id,
+                  const char *path1,
+                  const char *path2,
+                  diff_opt_t *options);
+
+
+/*-------------------------------------------------------------------------
+ * utility functions
+ *-------------------------------------------------------------------------
+ */
+
+/* in h5diff_util.c */
+void        print_found(hsize_t nfound);
+void        print_type(hid_t type);
+const char* diff_basename(const char *name);
+const char* get_type(h5trav_type_t type);
+const char* get_class(H5T_class_t tclass);
+const char* get_sign(H5T_sign_t sign);
+void        print_dimensions (int rank, hsize_t *dims);
+herr_t      match_up_memsize (hid_t f_tid1_id, hid_t f_tid2_id,
+                              hid_t *m_tid1, hid_t *m_tid2, 
+                              size_t *m_size1, size_t  *m_size2);
+/* in h5diff.c */
+int         print_objname(diff_opt_t *options, hsize_t nfound);
+void        do_print_objname (const char *OBJ, const char *path1, const char *path2, diff_opt_t * opts);
+void        do_print_attrname (const char *attr, const char *path1, const char *path2);
+
+#endif  /* H5DIFF_H__ */
+
diff --git a/install/include/h5tools.h b/install/include/h5tools.h
new file mode 100644
index 0000000000..6383df524a
--- /dev/null
+++ b/install/include/h5tools.h
@@ -0,0 +1,634 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Robb Matzke <matzke@llnl.gov>
+ *              Thursday, July 23, 1998
+ *
+ * Purpose:     Support functions for the various tools.
+ */
+#ifndef H5TOOLS_H__
+#define H5TOOLS_H__
+
+#include "hdf5.h"
+#include "h5tools_error.h"
+
+#define ESCAPE_HTML             1
+#define OPT(X,S)                ((X) ? (X) : (S))
+#define OPTIONAL_LINE_BREAK     "\001"  /* Special strings embedded in the output */
+#define START_OF_DATA       0x0001
+#define END_OF_DATA     0x0002
+
+/* format for hsize_t */
+#define HSIZE_T_FORMAT   "%" H5_PRINTF_LL_WIDTH "u"
+
+#define H5TOOLS_DUMP_MAX_RANK     H5S_MAX_RANK
+
+/* Stream macros */
+#define FLUSHSTREAM(S)           if(S != NULL) HDfflush(S)
+#define PRINTSTREAM(S, F, ...)   if(S != NULL) HDfprintf(S, F, __VA_ARGS__)
+#define PRINTVALSTREAM(S, V)   if(S != NULL) HDfprintf(S, V)
+#define PUTSTREAM(X,S)          do { if(S != NULL) HDfputs(X, S); } while(0)
+
+/*
+ * Strings for output - these were duplicated from the h5dump.h
+ * file in order to support region reference data display
+ */
+#define ATTRIBUTE       "ATTRIBUTE"
+#define BLOCK           "BLOCK"
+#define SUPER_BLOCK     "SUPER_BLOCK"
+#define COMPRESSION     "COMPRESSION"
+#define CONCATENATOR    "//"
+#define COMPLEX         "COMPLEX"
+#define COUNT           "COUNT"
+#define CSET            "CSET"
+#define CTYPE           "CTYPE"
+#define DATA            "DATA"
+#define DATASPACE       "DATASPACE"
+#define EXTERNAL        "EXTERNAL"
+#define FILENO          "FILENO"
+#define HARDLINK        "HARDLINK"
+#define NLINK           "NLINK"
+#define OBJID           "OBJECTID"
+#define OBJNO           "OBJNO"
+#define S_SCALAR        "SCALAR"
+#define S_SIMPLE        "SIMPLE"
+#define S_NULL          "NULL"
+#define SOFTLINK        "SOFTLINK"
+#define EXTLINK         "EXTERNAL_LINK"
+#define UDLINK          "USERDEFINED_LINK"
+#define START           "START"
+#define STRIDE          "STRIDE"
+#define STRSIZE         "STRSIZE"
+#define STRPAD          "STRPAD"
+#define SUBSET          "SUBSET"
+#define FILTERS         "FILTERS"
+#define DEFLATE         "COMPRESSION DEFLATE"
+#define DEFLATE_LEVEL   "LEVEL"
+#define SHUFFLE         "PREPROCESSING SHUFFLE"
+#define FLETCHER32      "CHECKSUM FLETCHER32"
+#define SZIP            "COMPRESSION SZIP"
+#define NBIT            "COMPRESSION NBIT"
+#define SCALEOFFSET     "COMPRESSION SCALEOFFSET"
+#define SCALEOFFSET_MINBIT            "MIN BITS"
+#define STORAGE_LAYOUT  "STORAGE_LAYOUT"
+#define CONTIGUOUS      "CONTIGUOUS"
+#define COMPACT         "COMPACT"
+#define CHUNKED         "CHUNKED"
+#define EXTERNAL_FILE   "EXTERNAL_FILE"
+#define FILLVALUE       "FILLVALUE"
+#define FILE_CONTENTS   "FILE_CONTENTS"
+#define PACKED_BITS     "PACKED_BITS"
+#define PACKED_OFFSET   "OFFSET"
+#define PACKED_LENGTH   "LENGTH"
+#define VDS_VIRTUAL     "VIRTUAL"
+#define VDS_MAPPING     "MAPPING"
+#define VDS_SOURCE      "SOURCE"
+#define VDS_REG_HYPERSLAB   "SELECTION REGULAR_HYPERSLAB"
+#define VDS_IRR_HYPERSLAB   "SELECTION IRREGULAR_HYPERSLAB"
+#define VDS_POINT       "POINT"
+#define VDS_SRC_FILE    "FILE"
+#define VDS_SRC_DATASET "DATASET"
+#define VDS_NONE        "SELECTION NONE"
+#define VDS_ALL         "SELECTION ALL"
+
+#define BEGIN           "{"
+#define END             "}"
+
+/*
+ * dump structure for output - this was duplicated from the h5dump.h
+ * file in order to support region reference data display
+ */
+typedef struct h5tools_dump_header_t {
+    const char *name;
+    const char *filebegin;
+    const char *fileend;
+    const char *bootblockbegin;
+    const char *bootblockend;
+    const char *groupbegin;
+    const char *groupend;
+    const char *datasetbegin;
+    const char *datasetend;
+    const char *attributebegin;
+    const char *attributeend;
+    const char *datatypebegin;
+    const char *datatypeend;
+    const char *dataspacebegin;
+    const char *dataspaceend;
+    const char *databegin;
+    const char *dataend;
+    const char *softlinkbegin;
+    const char *softlinkend;
+    const char *extlinkbegin;
+    const char *extlinkend;
+    const char *udlinkbegin;
+    const char *udlinkend;
+    const char *subsettingbegin;
+    const char *subsettingend;
+    const char *startbegin;
+    const char *startend;
+    const char *stridebegin;
+    const char *strideend;
+    const char *countbegin;
+    const char *countend;
+    const char *blockbegin;
+    const char *blockend;
+
+    const char *fileblockbegin;
+    const char *fileblockend;
+    const char *bootblockblockbegin;
+    const char *bootblockblockend;
+    const char *groupblockbegin;
+    const char *groupblockend;
+    const char *datasetblockbegin;
+    const char *datasetblockend;
+    const char *attributeblockbegin;
+    const char *attributeblockend;
+    const char *datatypeblockbegin;
+    const char *datatypeblockend;
+    const char *dataspaceblockbegin;
+    const char *dataspaceblockend;
+    const char *datablockbegin;
+    const char *datablockend;
+    const char *softlinkblockbegin;
+    const char *softlinkblockend;
+    const char *extlinkblockbegin;
+    const char *extlinkblockend;
+    const char *udlinkblockbegin;
+    const char *udlinkblockend;
+    const char *strblockbegin;
+    const char *strblockend;
+    const char *enumblockbegin;
+    const char *enumblockend;
+    const char *structblockbegin;
+    const char *structblockend;
+    const char *vlenblockbegin;
+    const char *vlenblockend;
+    const char *subsettingblockbegin;
+    const char *subsettingblockend;
+    const char *startblockbegin;
+    const char *startblockend;
+    const char *strideblockbegin;
+    const char *strideblockend;
+    const char *countblockbegin;
+    const char *countblockend;
+    const char *blockblockbegin;
+    const char *blockblockend;
+
+    const char *dataspacedescriptionbegin;
+    const char *dataspacedescriptionend;
+    const char *dataspacedimbegin;
+    const char *dataspacedimend;
+
+    const char *virtualselectionbegin;
+    const char *virtualselectionend;
+    const char *virtualselectionblockbegin;
+    const char *virtualselectionblockend;
+    const char *virtualfilenamebegin;
+    const char *virtualfilenameend;
+    const char *virtualdatasetnamebegin;
+    const char *virtualdatasetnameend;
+
+} h5tools_dump_header_t;
+
+/* Forward declaration (see declaration in h5tools_str.c) */
+struct H5LD_memb_t;
+
+
+/*
+ * Information about how to format output.
+ */
+typedef struct h5tool_format_t {
+    /*
+     * Fields associated with formatting numeric data.  If a datatype matches
+     * multiple formats based on its size, then the first applicable format
+     * from this list is used. However, if `raw' is non-zero then dump all
+     * data in hexadecimal format without translating from what appears on
+     * disk.
+     *
+     *   raw:        If set then print all data as hexadecimal without
+     *               performing any conversion from disk.
+     *
+     *   fmt_raw:    The printf() format for each byte of raw data. The
+     *               default is `%02x'.
+     *
+     *   fmt_int:    The printf() format to use when rendering data which is
+     *               typed `int'. The default is `%d'.
+     *
+     *   fmt_uint:   The printf() format to use when rendering data which is
+     *               typed `unsigned'. The default is `%u'.
+     *
+     *   fmt_schar:  The printf() format to use when rendering data which is
+     *               typed `signed char'. The default is `%d'. This format is
+     *               used ony if the `ascii' field is zero.
+     *
+     *   fmt_uchar:  The printf() format to use when rendering data which is
+     *               typed `unsigned char'. The default is `%u'. This format
+     *               is used only if the `ascii' field is zero.
+     *
+     *   fmt_short:  The printf() format to use when rendering data which is
+     *               typed `short'. The default is `%d'.
+     *
+     *   fmt_ushort: The printf() format to use when rendering data which is
+     *               typed `unsigned short'. The default is `%u'.
+     *
+     *   fmt_long:   The printf() format to use when rendering data which is
+     *               typed `long'. The default is `%ld'.
+     *
+     *   fmt_ulong:  The printf() format to use when rendering data which is
+     *               typed `unsigned long'. The default is `%lu'.
+     *
+     *   fmt_llong:  The printf() format to use when rendering data which is
+     *               typed `long long'. The default depends on what printf()
+     *               format is available to print this datatype.
+     *
+     *   fmt_ullong: The printf() format to use when rendering data which is
+     *               typed `unsigned long long'. The default depends on what
+     *               printf() format is available to print this datatype.
+     *
+     *   fmt_double: The printf() format to use when rendering data which is
+     *               typed `double'. The default is `%g'.
+     *
+     *   fmt_float:  The printf() format to use when rendering data which is
+     *               typed `float'. The default is `%g'.
+     *
+     *   ascii:      If set then print 1-byte integer values as an ASCII
+     *               character (no quotes).  If the character is one of the
+     *               standard C escapes then print the escaped version.  If
+     *               the character is unprintable then print a 3-digit octal
+     *               escape.  If `ascii' is zero then then 1-byte integers are
+     *               printed as numeric values.  The default is zero.
+     *
+     *   str_locale: Determines how strings are printed. If zero then strings
+     *               are printed like in C except. If set to ESCAPE_HTML then
+     *               strings are printed using HTML encoding where each
+     *               character not in the class [a-zA-Z0-9] is substituted
+     *               with `%XX' where `X' is a hexadecimal digit.
+     *
+     *   str_repeat: If set to non-zero then any character value repeated N
+     *               or more times is printed as 'C'*N
+     *
+     * Numeric data is also subject to the formats for individual elements.
+     */
+    hbool_t     raw;
+    const char  *fmt_raw;
+    const char  *fmt_int;
+    const char  *fmt_uint;
+    const char  *fmt_schar;
+    const char  *fmt_uchar;
+    const char  *fmt_short;
+    const char  *fmt_ushort;
+    const char  *fmt_long;
+    const char  *fmt_ulong;
+    const char  *fmt_llong;
+    const char  *fmt_ullong;
+    const char  *fmt_double;
+    const char  *fmt_float;
+    int         ascii;
+    int         str_locale;
+    unsigned    str_repeat;
+
+    /*
+     * Fields associated with compound array members.
+     *
+     *   pre:       A string to print at the beginning of each array. The
+     *              default value is the left square bracket `['.
+     *
+     *   sep:       A string to print between array values.  The default
+     *              value is a ",\001" ("\001" indicates an optional line
+     *              break).
+     *
+     *   suf:       A string to print at the end of each array.  The default
+     *              value is a right square bracket `]'.
+     *
+     *   linebreaks: a boolean value to determine if we want to break the line
+     *               after each row of an array.
+     */
+    const char  *arr_pre;
+    const char  *arr_sep;
+    const char  *arr_suf;
+    int         arr_linebreak;
+
+    /*
+     * Fields associated with compound data types.
+     *
+     *   name:      How the name of the struct member is printed in the
+     *              values. By default the name is not printed, but a
+     *              reasonable setting might be "%s=" which prints the name
+     *              followed by an equal sign and then the value.
+     *
+     *   sep:       A string that separates one member from another.  The
+     *              default is ", \001" (the \001 indicates an optional
+     *              line break to allow structs to span multiple lines of
+     *              output).
+     *
+     *   pre:       A string to print at the beginning of a compound type.
+     *              The default is a left curly brace.
+     *
+     *   suf:       A string to print at the end of each compound type.  The
+     *              default is  right curly brace.
+     *
+     *   end:       a string to print after we reach the last element of
+     *              each compound type. prints out before the suf.
+     *
+     *   listv:    h5watch: vector containing info about the list of compound fields to be printed.
+     */
+    const char  *cmpd_name;
+    const char  *cmpd_sep;
+    const char  *cmpd_pre;
+    const char  *cmpd_suf;
+    const char  *cmpd_end;
+    const struct H5LD_memb_t * const *cmpd_listv;
+
+
+    /*
+     * Fields associated with vlen data types.
+     *
+     *   sep:       A string that separates one member from another.  The
+     *              default is ", \001" (the \001 indicates an optional
+     *              line break to allow structs to span multiple lines of
+     *              output).
+     *
+     *   pre:       A string to print at the beginning of a vlen type.
+     *              The default is a left parentheses.
+     *
+     *   suf:       A string to print at the end of each vlen type.  The
+     *              default is a right parentheses.
+     *
+     *   end:       a string to print after we reach the last element of
+     *              each compound type. prints out before the suf.
+     */
+    const char  *vlen_sep;
+    const char  *vlen_pre;
+    const char  *vlen_suf;
+    const char  *vlen_end;
+
+    /*
+     * Fields associated with the individual elements.
+     *
+     *   fmt:       A printf(3c) format to use to print the value string
+     *              after it has been rendered.  The default is "%s".
+     *
+     *   suf1:      This string is appended to elements which are followed by
+     *              another element whether the following element is on the
+     *              same line or the next line.  The default is a comma.
+     *
+     *   suf2:      This string is appended (after `suf1') to elements which
+     *              are followed on the same line by another element.  The
+     *              default is a single space.
+     */
+    const char  *elmt_fmt;
+    const char  *elmt_suf1;
+    const char  *elmt_suf2;
+
+    /*
+     * Fields associated with the index values printed at the left edge of
+     * each line of output.
+     *
+     *   n_fmt:     Each index value is printed according to this printf(3c)
+     *              format string which should include a format for a long
+     *              integer.  The default is "%lu".
+     *
+     *   sep:       Each integer in the index list will be separated from the
+     *              others by this string, which defaults to a comma.
+     *
+     *   fmt:       After the index values are formated individually and
+     *              separated from one another by some string, the entire
+     *              resulting string will be formated according to this
+     *              printf(3c) format which should include a format for a
+     *              character string.  The default is "%s".
+     */
+    const char  *idx_n_fmt;             /*index number format           */
+    const char  *idx_sep;               /*separator between numbers     */
+    const char  *idx_fmt;               /*entire index format           */
+
+    /*
+     * Fields associated with entire lines.
+     *
+     *   ncols:     Number of columns per line defaults to 80.
+     *
+     *   per_line:  If this field has a positive value then every Nth element
+     *              will be printed at the beginning of a line.
+     *
+     *   pre:       Each line of output contains an optional prefix area
+     *              before the data. This area can contain the index for the
+     *              first datum (represented by `%s') as well as other
+     *              constant text.  The default value is `%s'.
+     *
+     *   1st:       This is the format to print at the beginning of the first
+     *              line of output. The default value is the current value of
+     *              `pre' described above.
+     *
+     *   cont:      This is the format to print at the beginning of each line
+     *              which was continued because the line was split onto
+     *              multiple lines. This often happens with compound
+     *              data which is longer than one line of output. The default
+     *              value is the current value of the `pre' field
+     *              described above.
+     *
+     *   suf:       This character string will be appended to each line of
+     *              output.  It should not contain line feeds.  The default
+     *              is the empty string.
+     *
+     *   sep:       A character string to be printed after every line feed
+     *              defaulting to the empty string.  It should end with a
+     *              line feed.
+     *
+     *   multi_new: Indicates the algorithm to use when data elements tend to
+     *              occupy more than one line of output. The possible values
+     *              are (zero is the default):
+     *
+     *              0:  No consideration. Each new element is printed
+     *                  beginning where the previous element ended.
+     *
+     *              1:  Print the current element beginning where the
+     *                  previous element left off. But if that would result
+     *                  in the element occupying more than one line and it
+     *                  would only occupy one line if it started at the
+     *                  beginning of a line, then it is printed at the
+     *                  beginning of the next line.
+     *
+     *   multi_new: If an element is continued onto additional lines then
+     *              should the following element begin on the next line? The
+     *              default is to start the next element on the same line
+     *              unless it wouldn't fit.
+     *
+     * indentlevel: a string that shows how far to indent if extra spacing
+     *              is needed. dumper uses it.
+     */
+    unsigned    line_ncols;             /*columns of output             */
+    size_t      line_per_line;          /*max elements per line         */
+    const char  *line_pre;              /*prefix at front of each line  */
+    const char  *line_1st;              /*alternate pre. on first line  */
+    const char  *line_cont;             /*alternate pre. on continuation*/
+    const char  *line_suf;              /*string to append to each line */
+    const char  *line_sep;              /*separates lines               */
+    int         line_multi_new;         /*split multi-line outputs?     */
+    const char  *line_indent;           /*for extra identation if we need it*/
+
+    /*used to skip the first set of checks for line length*/
+    int skip_first;
+
+    /*flag used to hide or show the file number for obj refs*/
+    int obj_hidefileno;
+
+    /*string used to format the output for the obje refs*/
+    const char *obj_format;
+
+    /*flag used to hide or show the file number for dataset regions*/
+    int dset_hidefileno;
+
+    /*string used to format the output for the dataset regions*/
+    const char *dset_format;
+
+    const char *dset_blockformat_pre;
+    const char *dset_ptformat_pre;
+    const char *dset_ptformat;
+
+    /*print array indices in output matrix */
+    int pindex;
+
+    /*escape non printable characters */
+    int do_escape;
+
+} h5tool_format_t;
+
+typedef struct h5tools_context_t {
+    size_t cur_column;                       /*current column for output */
+    size_t cur_elmt;                         /*current element/output line */
+    int  need_prefix;                        /*is line prefix needed? */
+    unsigned ndims;                          /*dimensionality  */
+    hsize_t p_min_idx[H5S_MAX_RANK];         /*min selected index */
+    hsize_t p_max_idx[H5S_MAX_RANK];         /*max selected index */
+    int  prev_multiline;                     /*was prev datum multiline? */
+    size_t prev_prefix_len;                  /*length of previous prefix */
+    int  continuation;                       /*continuation of previous data?*/
+    hsize_t size_last_dim;                   /*the size of the last dimension,
+                                              *needed so we can break after each
+                                              *row */
+    unsigned  indent_level;                /*the number of times we need some
+                                       *extra indentation */
+    unsigned  default_indent_level;        /*this is used when the indent level gets changed */
+    hsize_t acc[H5S_MAX_RANK];        /* accumulator position */
+    hsize_t pos[H5S_MAX_RANK];        /* matrix position */
+    hsize_t sm_pos;                   /* current stripmine element position */
+    const struct H5LD_memb_t * const *cmpd_listv;  /* h5watch: vector containing info about the list of compound fields to be printed */
+} h5tools_context_t;
+
+typedef struct subset_d {
+    hsize_t     *data;
+    unsigned int len;
+} subset_d;
+
+/* a structure to hold the subsetting particulars for a dataset */
+struct subset_t {
+    subset_d start;
+    subset_d stride;
+    subset_d count;
+    subset_d block;
+};
+
+/* The following include, h5tools_str.h, must be after the
+ * above stucts are defined. There is a dependency in the following
+ * include that hasn't been identified yet. */
+
+#include "h5tools_str.h"
+
+H5TOOLS_DLLVAR h5tool_format_t h5tools_dataformat;
+H5TOOLS_DLLVAR const h5tools_dump_header_t h5tools_standardformat;
+H5TOOLS_DLLVAR const h5tools_dump_header_t* h5tools_dump_header_format;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5TOOLS_DLLVAR unsigned packed_bits_num;    /* number of packed bits to display */
+H5TOOLS_DLLVAR unsigned packed_data_offset; /* offset of packed bits to display */
+H5TOOLS_DLLVAR unsigned packed_data_length; /* length of packed bits to display */
+H5TOOLS_DLLVAR unsigned long long packed_data_mask;  /* mask in which packed bits to display */
+H5TOOLS_DLLVAR FILE   *rawattrstream;       /* output stream for raw attribute data */
+H5TOOLS_DLLVAR FILE   *rawdatastream;       /* output stream for raw data */
+H5TOOLS_DLLVAR FILE   *rawinstream;         /* input stream for raw input */
+H5TOOLS_DLLVAR FILE   *rawoutstream;        /* output stream for raw output */
+H5TOOLS_DLLVAR FILE   *rawerrorstream;      /* output stream for raw error */
+H5TOOLS_DLLVAR int     bin_output;          /* binary output */
+H5TOOLS_DLLVAR int     bin_form;            /* binary form */
+H5TOOLS_DLLVAR int     region_output;       /* region output */
+H5TOOLS_DLLVAR int     oid_output;          /* oid output */
+H5TOOLS_DLLVAR int     data_output;         /* data output */
+H5TOOLS_DLLVAR int     attr_data_output;    /* attribute data output */
+
+/* sort parameters */
+H5TOOLS_DLLVAR H5_index_t   sort_by;        /*sort_by [creation_order | name]  */
+H5TOOLS_DLLVAR H5_iter_order_t sort_order;  /*sort_order [ascending | descending]   */
+
+/* things to display or which are set via command line parameters */
+H5TOOLS_DLLVAR int     enable_error_stack; /* re-enable error stack */
+
+/* Strings for output */
+#define H5_TOOLS_GROUP           "GROUP"
+#define H5_TOOLS_DATASET         "DATASET"
+#define H5_TOOLS_DATATYPE        "DATATYPE"
+
+/* Definitions of useful routines */
+H5TOOLS_DLL void    h5tools_init(void);
+H5TOOLS_DLL void    h5tools_close(void);
+H5TOOLS_DLL int     h5tools_set_data_output_file(const char *fname, int is_bin);
+H5TOOLS_DLL int     h5tools_set_attr_output_file(const char *fname, int is_bin);
+H5TOOLS_DLL int     h5tools_set_input_file(const char *fname, int is_bin);
+H5TOOLS_DLL int     h5tools_set_output_file(const char *fname, int is_bin);
+H5TOOLS_DLL int     h5tools_set_error_file(const char *fname, int is_bin);
+H5TOOLS_DLL hid_t   h5tools_fopen(const char *fname, unsigned flags, hid_t fapl,
+                            const char *driver, char *drivername, size_t drivername_len);
+H5TOOLS_DLL hid_t   h5tools_get_little_endian_type(hid_t type);
+H5TOOLS_DLL hid_t   h5tools_get_big_endian_type(hid_t type);
+H5TOOLS_DLL htri_t  h5tools_detect_vlen(hid_t tid);
+H5TOOLS_DLL htri_t  h5tools_detect_vlen_str(hid_t tid);
+H5TOOLS_DLL hbool_t h5tools_is_obj_same(hid_t loc_id1, const char *name1, hid_t loc_id2, const char *name2);
+H5TOOLS_DLL void    init_acc_pos(h5tools_context_t *ctx, hsize_t *dims);
+H5TOOLS_DLL hbool_t h5tools_is_zero(const void *_mem, size_t size);
+H5TOOLS_DLL int     h5tools_canreadf(const char* name,  hid_t dcpl_id);
+H5TOOLS_DLL int     h5tools_can_encode(H5Z_filter_t filtn);
+
+H5TOOLS_DLL void    h5tools_simple_prefix(FILE *stream, const h5tool_format_t *info,
+                            h5tools_context_t *ctx, hsize_t elmtno, int secnum);
+H5TOOLS_DLL void    h5tools_region_simple_prefix(FILE *stream, const h5tool_format_t *info,
+                            h5tools_context_t *ctx, hsize_t elmtno, hsize_t *ptdata, int secnum);
+
+H5TOOLS_DLL int     render_bin_output(FILE *stream, hid_t container, hid_t tid, void *_mem, hsize_t nelmts);
+H5TOOLS_DLL int     render_bin_output_region_data_blocks(hid_t region_id, FILE *stream,
+                            hid_t container, unsigned ndims, hid_t type_id, hsize_t nblocks, hsize_t *ptdata);
+H5TOOLS_DLL hbool_t render_bin_output_region_blocks(hid_t region_space, hid_t region_id,
+                             FILE *stream, hid_t container);
+H5TOOLS_DLL int     render_bin_output_region_data_points(hid_t region_space, hid_t region_id,
+                            FILE* stream, hid_t container, unsigned ndims, hid_t type_id, hsize_t npoints);
+H5TOOLS_DLL hbool_t render_bin_output_region_points(hid_t region_space, hid_t region_id,
+                             FILE *stream, hid_t container);
+
+H5TOOLS_DLL hbool_t h5tools_render_element(FILE *stream, const h5tool_format_t *info,
+                            h5tools_context_t *ctx, h5tools_str_t *buffer, hsize_t *curr_pos,
+                            size_t ncols, hsize_t local_elmt_counter, hsize_t elmt_counter);
+H5TOOLS_DLL hbool_t h5tools_render_region_element(FILE *stream, const h5tool_format_t *info,
+                h5tools_context_t *ctx/*in,out*/,
+                h5tools_str_t *buffer/*string into which to render */,
+                hsize_t *curr_pos/*total data element position*/,
+                size_t ncols, hsize_t *ptdata,
+                hsize_t local_elmt_counter/*element counter*/,
+                hsize_t elmt_counter);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5TOOLS_H__ */
+
diff --git a/install/include/h5tools_dump.h b/install/include/h5tools_dump.h
new file mode 100644
index 0000000000..dc79f43124
--- /dev/null
+++ b/install/include/h5tools_dump.h
@@ -0,0 +1,82 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:     Support h5dump functions for the various tools.
+ */
+#ifndef H5TOOLS_DUMP_H__
+#define H5TOOLS_DUMP_H__
+
+#include "h5tools_utils.h"
+
+/* 3 private values: can't be set, but can be read.
+   Note: these are defined in H5Zprivate, they are
+   duplicated here.
+ */
+#define H5_SZIP_LSB_OPTION_MASK         8
+#define H5_SZIP_MSB_OPTION_MASK         16
+#define H5_SZIP_RAW_OPTION_MASK         128
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5TOOLS_DLLVAR table_t *h5dump_type_table;  /*type table reference for datatype dump  */
+
+/* Definitions of useful routines */
+H5TOOLS_DLL void    h5tools_dump_init(void);
+
+H5TOOLS_DLL int     h5tools_dump_dset(FILE *stream, const h5tool_format_t *info,
+                            h5tools_context_t *ctx/*in,out*/, hid_t dset,
+                            struct subset_t *sset);
+H5TOOLS_DLL int     h5tools_dump_mem(FILE *stream, const h5tool_format_t *info,
+                            h5tools_context_t *ctx/*in,out*/, hid_t obj_id,
+                            hid_t type, hid_t space, void *mem);
+H5TOOLS_DLL int     h5tools_dump_simple_data(FILE *stream, const h5tool_format_t *info, hid_t container,
+                            h5tools_context_t *ctx/*in,out*/, unsigned flags,
+                            hsize_t nelmts, hid_t type, void *_mem);
+H5TOOLS_DLL void    h5tools_dump_datatype(FILE *stream, const h5tool_format_t *info,
+                            h5tools_context_t *ctx/*in,out*/, hid_t type);
+H5TOOLS_DLL void    h5tools_dump_dataspace(FILE *stream, const h5tool_format_t *info,
+                            h5tools_context_t *ctx/*in,out*/, hid_t space);
+H5TOOLS_DLL void    h5tools_dump_attribute(FILE *stream, const h5tool_format_t *info,
+                            h5tools_context_t *ctx/*in,out*/, const char *attr_name, 
+                            hid_t attr_id, int display_index, int display_char);
+H5TOOLS_DLL void    h5tools_dump_oid(FILE *stream, const h5tool_format_t *info,
+                            h5tools_context_t *ctx/*in,out*/, hid_t oid);
+H5TOOLS_DLL void    h5tools_dump_dcpl(FILE *stream, const h5tool_format_t *info,
+                            h5tools_context_t *ctx/*in,out*/, hid_t dcpl, hid_t type_id, hid_t obj_id);
+H5TOOLS_DLL void    h5tools_dump_comment(FILE *stream, const h5tool_format_t *info,
+                            h5tools_context_t *ctx/*in,out*/, hid_t obj_id);
+H5TOOLS_DLL void    h5tools_dump_data(FILE *stream, const h5tool_format_t *info,
+                            h5tools_context_t *ctx, hid_t obj_id,
+                            int obj_data, struct subset_t *sset, int display_index, int display_char);
+
+H5TOOLS_DLL int     h5tools_print_datatype(FILE *stream, h5tools_str_t *buffer/*in,out*/,
+                            const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            hid_t type, int object_search);
+H5TOOLS_DLL int     h5tools_print_dataspace(h5tools_str_t *buffer/*in,out*/,
+                            hid_t space);
+H5TOOLS_DLL int     h5tools_print_enum(FILE *stream, h5tools_str_t *buffer/*in,out*/,
+                            const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/,
+                            hid_t type);
+H5TOOLS_DLL void    h5tools_print_fill_value(h5tools_str_t *buffer/*in,out*/,
+                            const h5tool_format_t *info, h5tools_context_t *ctx/*in,out*/, 
+                            hid_t dcpl, hid_t type_id, hid_t obj_id);
+H5TOOLS_DLL void    h5tools_print_packed_bits(h5tools_str_t *buffer/*in,out*/, hid_t type);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5TOOLS_DUMP_H__ */
+
diff --git a/install/include/h5tools_ref.h b/install/include/h5tools_ref.h
new file mode 100644
index 0000000000..b7bd9a3da5
--- /dev/null
+++ b/install/include/h5tools_ref.h
@@ -0,0 +1,36 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef H5TOOLS_REF_H__
+#define H5TOOLS_REF_H__
+
+#include "hdf5.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5TOOLS_DLL herr_t      fill_ref_path_table(hid_t fid);
+H5TOOLS_DLL const char *lookup_ref_path(haddr_t ref);
+H5TOOLS_DLL int         get_next_xid(void);
+H5TOOLS_DLL haddr_t     get_fake_xid(void);
+H5TOOLS_DLL haddr_t     ref_path_table_lookup(const char *);
+H5TOOLS_DLL haddr_t     ref_path_table_gen_fake(const char *);
+H5TOOLS_DLL int         term_ref_path_table(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/install/include/h5tools_str.h b/install/include/h5tools_str.h
new file mode 100644
index 0000000000..a5045ac220
--- /dev/null
+++ b/install/include/h5tools_str.h
@@ -0,0 +1,52 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Bill Wendling <wendling@ncsa.uiuc.edu>
+ *              Monday, 19. February 2001
+ */
+#ifndef H5TOOLS_STR_H__
+#define H5TOOLS_STR_H__
+
+typedef struct h5tools_str_t {
+    char    *s;     /*allocate string       */
+    size_t  len;        /*length of actual value    */
+    size_t  nalloc;     /*allocated size of string  */
+} h5tools_str_t;
+
+H5TOOLS_DLL void     h5tools_str_close(h5tools_str_t *str);
+H5TOOLS_DLL size_t   h5tools_str_len(h5tools_str_t *str);
+H5TOOLS_DLL char    *h5tools_str_append(h5tools_str_t *str, const char *fmt, ...);
+H5TOOLS_DLL char    *h5tools_str_reset(h5tools_str_t *str);
+H5TOOLS_DLL char    *h5tools_str_trunc(h5tools_str_t *str, size_t size);
+H5TOOLS_DLL char    *h5tools_str_fmt(h5tools_str_t *str, size_t start, const char *fmt);
+H5TOOLS_DLL char    *h5tools_str_prefix(h5tools_str_t *str, const h5tool_format_t *info,
+                        hsize_t elmtno, unsigned ndims, h5tools_context_t *ctx);
+/*
+ * new functions needed to display region reference data
+ */
+H5TOOLS_DLL char    *h5tools_str_region_prefix(h5tools_str_t *str, const h5tool_format_t *info,
+                                   hsize_t elmtno, hsize_t *ptdata, unsigned ndims, 
+                                   hsize_t max_idx[], h5tools_context_t *ctx);
+H5TOOLS_DLL void     h5tools_str_dump_space_slabs(h5tools_str_t *, hid_t, const h5tool_format_t *, h5tools_context_t *ctx);
+H5TOOLS_DLL void     h5tools_str_dump_space_blocks(h5tools_str_t *, hid_t, const h5tool_format_t *);
+H5TOOLS_DLL void     h5tools_str_dump_space_points(h5tools_str_t *, hid_t, const h5tool_format_t *);
+H5TOOLS_DLL void     h5tools_str_sprint_region(h5tools_str_t *str, const h5tool_format_t *info, hid_t container,
+                                   void *vp);
+H5TOOLS_DLL char    *h5tools_str_sprint(h5tools_str_t *str, const h5tool_format_t *info,
+                                   hid_t container, hid_t type, void *vp,
+                                   h5tools_context_t *ctx);
+H5TOOLS_DLL char    *h5tools_str_replace ( const char *string, const char *substr, 
+									const char *replacement );
+
+#endif  /* H5TOOLS_STR_H__ */
diff --git a/install/include/h5tools_utils.h b/install/include/h5tools_utils.h
new file mode 100644
index 0000000000..a31ba3aa26
--- /dev/null
+++ b/install/include/h5tools_utils.h
@@ -0,0 +1,181 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Programmer:  Bill Wendling <wendling@ncsa.uiuc.edu>
+ *              Tuesday, 6. March 2001
+ *
+ * Purpose:     Support functions for the various tools.
+ */
+#ifndef H5TOOLS_UTILS_H__
+#define H5TOOLS_UTILS_H__
+
+#include "hdf5.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ``parallel_print'' information */
+#define PRINT_DATA_MAX_SIZE     512
+#define OUTBUFF_SIZE        (PRINT_DATA_MAX_SIZE*4)
+
+H5TOOLS_DLLVAR int  g_nTasks;
+H5TOOLS_DLLVAR unsigned char g_Parallel;
+H5TOOLS_DLLVAR char    outBuff[];
+H5TOOLS_DLLVAR unsigned outBuffOffset;
+H5TOOLS_DLLVAR FILE *   overflow_file;
+
+/* Maximum size used in a call to malloc for a dataset */
+H5TOOLS_DLLVAR hsize_t H5TOOLS_MALLOCSIZE;
+/* size of hyperslab buffer when a dataset is bigger than H5TOOLS_MALLOCSIZE */
+H5TOOLS_DLLVAR hsize_t H5TOOLS_BUFSIZE;
+/*
+ * begin get_option section
+ */
+H5TOOLS_DLLVAR int         opt_err;     /* getoption prints errors if this is on    */
+H5TOOLS_DLLVAR int         opt_ind;     /* token pointer                            */
+H5TOOLS_DLLVAR const char *opt_arg;     /* flag argument (or value)                 */
+
+enum {
+    no_arg = 0,         /* doesn't take an argument     */
+    require_arg,        /* requires an argument          */
+    optional_arg        /* argument is optional         */
+};
+
+/*
+ * get_option determines which options are specified on the command line and
+ * returns a pointer to any arguments possibly associated with the option in
+ * the ``opt_arg'' variable. get_option returns the shortname equivalent of
+ * the option. The long options are specified in the following way:
+ *
+ * struct long_options foo[] = {
+ *   { "filename", require_arg, 'f' },
+ *   { "append", no_arg, 'a' },
+ *   { "width", require_arg, 'w' },
+ *   { NULL, 0, 0 }
+ * };
+ *
+ * Long named options can have arguments specified as either:
+ *
+ *   ``--param=arg'' or ``--param arg''
+ *
+ * Short named options can have arguments specified as either:
+ *
+ *   ``-w80'' or ``-w 80''
+ *
+ * and can have more than one short named option specified at one time:
+ *
+ *   -aw80
+ *
+ * in which case those options which expect an argument need to come at the
+ * end.
+ */
+typedef struct long_options {
+    const char  *name;          /* name of the long option              */
+    int          has_arg;       /* whether we should look for an arg    */
+    char         shortval;      /* the shortname equivalent of long arg
+                                 * this gets returned from get_option   */
+} long_options;
+
+H5TOOLS_DLL int    get_option(int argc, const char **argv, const char *opt,
+                         const struct long_options *l_opt);
+/*
+ * end get_option section
+ */
+
+/*struct taken from the dumper. needed in table struct*/
+typedef struct obj_t {
+    haddr_t objno;
+    char *objname;
+    hbool_t displayed;          /* Flag to indicate that the object has been displayed */
+    hbool_t recorded;           /* Flag for named datatypes to indicate they were found in the group hierarchy */
+} obj_t;
+
+/*struct for the tables that the find_objs function uses*/
+typedef struct table_t {
+    size_t size;
+    size_t nobjs;
+    obj_t *objs;
+} table_t;
+
+/*this struct stores the information that is passed to the find_objs function*/
+typedef struct find_objs_t {
+    hid_t fid;
+    table_t *group_table;
+    table_t *type_table;
+    table_t *dset_table;
+} find_objs_t;
+
+H5TOOLS_DLLVAR unsigned h5tools_nCols;               /*max number of columns for outputting  */
+
+/* Definitions of useful routines */
+H5TOOLS_DLL void     indentation(unsigned);
+H5TOOLS_DLL void     print_version(const char *progname);
+H5TOOLS_DLL void     parallel_print(const char* format, ... );
+H5TOOLS_DLL void     error_msg(const char *fmt, ...);
+H5TOOLS_DLL void     warn_msg(const char *fmt, ...);
+H5TOOLS_DLL void     help_ref_msg(FILE *output);
+H5TOOLS_DLL void     free_table(table_t *table);
+#ifdef H5DUMP_DEBUG
+H5TOOLS_DLL void     dump_tables(find_objs_t *info)
+#endif  /* H5DUMP_DEBUG */
+H5TOOLS_DLL herr_t init_objs(hid_t fid, find_objs_t *info, table_t **group_table,
+    table_t **dset_table, table_t **type_table);
+H5TOOLS_DLL obj_t   *search_obj(table_t *temp, haddr_t objno);
+#ifndef H5_HAVE_TMPFILE
+H5TOOLS_DLL FILE *  tmpfile(void);
+#endif
+
+/*************************************************************
+ *
+ * candidate functions to be public
+ *
+ *************************************************************/
+
+/* This code is layout for common code among tools */
+typedef enum toolname_t {
+    TOOL_H5DIFF, TOOL_H5LS, TOOL__H5DUMP /* add as necessary */
+} h5tool_toolname_t;
+
+/* this struct can be used to differntiate among tools */
+typedef struct {
+    h5tool_toolname_t toolname;
+    int msg_mode;
+} h5tool_opt_t;
+
+/* obtain link info from H5tools_get_symlink_info() */
+typedef struct {
+    H5O_type_t  trg_type;  /* OUT: target type */
+    char *trg_path;        /* OUT: target obj path. This must be freed 
+                            *      when used with H5tools_get_symlink_info() */
+    haddr_t     objno;     /* OUT: target object address */
+    unsigned long  fileno; /* OUT: File number that target object is located in */
+    H5L_info_t linfo;      /* OUT: link info */
+    h5tool_opt_t opt;      /* IN: options */
+} h5tool_link_info_t;
+
+
+/* Definitions of routines */
+H5TOOLS_DLL int H5tools_get_symlink_info(hid_t file_id, const char * linkpath,
+    h5tool_link_info_t *link_info, hbool_t get_obj_type);
+H5TOOLS_DLL const char *h5tools_getprogname(void);
+H5TOOLS_DLL void     h5tools_setprogname(const char*progname);
+H5TOOLS_DLL int      h5tools_getstatus(void);
+H5TOOLS_DLL void     h5tools_setstatus(int d_status);
+H5TOOLS_DLL int h5tools_getenv_update_hyperslab_bufsize(void);
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* H5TOOLS_UTILS_H__ */
diff --git a/install/include/h5trav.h b/install/include/h5trav.h
new file mode 100644
index 0000000000..c2ad9b7c0c
--- /dev/null
+++ b/install/include/h5trav.h
@@ -0,0 +1,197 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef H5TRAV_H__
+#define H5TRAV_H__
+
+#include "hdf5.h"
+
+/* Typedefs for visiting objects */
+typedef herr_t (*h5trav_obj_func_t)(const char *path_name, const H5O_info_t *oinfo,
+        const char *first_seen, void *udata);
+typedef herr_t (*h5trav_lnk_func_t)(const char *path_name, const H5L_info_t *linfo,
+        void *udata);
+
+/*-------------------------------------------------------------------------
+ * public enum to specify type of an object
+ * the TYPE can be:
+ *    H5TRAV_TYPE_UNKNOWN = -1,
+ *    H5TRAV_TYPE_GROUP,            Object is a group
+ *    H5TRAV_TYPE_DATASET,          Object is a dataset
+ *    H5TRAV_TYPE_TYPE,             Object is a named datatype
+ *    H5TRAV_TYPE_LINK,             Object is a symbolic link
+ *    H5TRAV_TYPE_UDLINK,           Object is a user-defined link
+ *-------------------------------------------------------------------------
+ */
+typedef enum {
+    H5TRAV_TYPE_UNKNOWN = -1,        /* Unknown object type */
+    H5TRAV_TYPE_GROUP,          /* Object is a group */
+    H5TRAV_TYPE_DATASET,        /* Object is a dataset */
+    H5TRAV_TYPE_NAMED_DATATYPE, /* Object is a named datatype */
+    H5TRAV_TYPE_LINK,           /* Object is a symbolic link */
+    H5TRAV_TYPE_UDLINK          /* Object is a user-defined link */
+} h5trav_type_t;
+
+/*-------------------------------------------------------------------------
+ * public struct to store name and type of an object
+ *-------------------------------------------------------------------------
+ */
+/* Struct to keep track of symbolic link targets visited.
+ * Functions: symlink_visit_add() and symlink_is_visited()
+ */
+typedef struct symlink_trav_path_t {
+    H5L_type_t  type;
+    char *file;
+    char *path;
+} symlink_trav_path_t;
+
+typedef struct symlink_trav_t {
+    size_t      nalloc;
+    size_t      nused;
+    symlink_trav_path_t *objs;
+    hbool_t dangle_link;
+} symlink_trav_t;
+
+typedef struct trav_path_t {
+    char      *path;
+    h5trav_type_t type;
+    haddr_t     objno;     /* object address */
+    unsigned long 	fileno; /* File number that object is located in */
+} trav_path_t;
+
+typedef struct trav_info_t {
+    size_t      nalloc;
+    size_t      nused;
+    const char *fname;
+    hid_t fid;                          /* File ID */
+    trav_path_t *paths;
+    symlink_trav_t symlink_visited;     /* already visited symbolic links */
+    void * opts;                        /* optional data passing */
+} trav_info_t;
+
+
+/*-------------------------------------------------------------------------
+ * keep record of hard link information
+ *-------------------------------------------------------------------------
+ */
+typedef struct trav_link_t {
+    char      *new_name;
+} trav_link_t;
+
+
+/*-------------------------------------------------------------------------
+ * struct to store basic info needed for the h5trav table traversal algorythm
+ *-------------------------------------------------------------------------
+ */
+
+typedef struct trav_obj_t {
+    haddr_t     objno;     /* object address */
+    unsigned    flags[2];  /* h5diff.object is present or not in both files*/
+    hbool_t     is_same_trgobj; /* same target object? no need to compare */
+    char        *name;     /* name */
+    h5trav_type_t type;    /* type of object */
+    trav_link_t *links;    /* array of possible link names */
+    size_t      sizelinks; /* size of links array */
+    size_t      nlinks;    /* number of links */
+} trav_obj_t;
+
+
+/*-------------------------------------------------------------------------
+ * private struct that stores all objects
+ *-------------------------------------------------------------------------
+ */
+
+typedef struct trav_table_t {
+    size_t      size;
+    size_t      nobjs;
+    trav_obj_t *objs;
+} trav_table_t;
+
+
+/*-------------------------------------------------------------------------
+ * public functions
+ *-------------------------------------------------------------------------
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*-------------------------------------------------------------------------
+ * "h5trav general" public functions
+ *-------------------------------------------------------------------------
+ */
+H5TOOLS_DLL void h5trav_set_index(H5_index_t print_index_by, H5_iter_order_t print_index_order);
+H5TOOLS_DLL int h5trav_visit(hid_t file_id, const char *grp_name, 
+    hbool_t visit_start, hbool_t recurse, h5trav_obj_func_t visit_obj, 
+    h5trav_lnk_func_t visit_lnk, void *udata);
+H5TOOLS_DLL herr_t symlink_visit_add(symlink_trav_t *visited, H5L_type_t type, const char *file, const char *path);
+H5TOOLS_DLL hbool_t symlink_is_visited(symlink_trav_t *visited, H5L_type_t type, const char *file, const char *path);
+
+/*-------------------------------------------------------------------------
+ * "h5trav info" public functions
+ *-------------------------------------------------------------------------
+ */
+H5TOOLS_DLL int h5trav_getinfo(hid_t file_id, trav_info_t *info);
+H5TOOLS_DLL ssize_t h5trav_getindex(const trav_info_t *info, const char *obj);
+H5TOOLS_DLL int trav_info_visit_obj (const char *path, const H5O_info_t *oinfo, const char *already_visited, void *udata);
+H5TOOLS_DLL int trav_info_visit_lnk (const char *path, const H5L_info_t *linfo, void *udata);
+
+/*-------------------------------------------------------------------------
+ * "h5trav table" public functions
+ *-------------------------------------------------------------------------
+ */
+
+H5TOOLS_DLL int  h5trav_gettable(hid_t fid, trav_table_t *travt);
+H5TOOLS_DLL int  h5trav_getindext(const char *obj, const trav_table_t *travt);
+
+/*-------------------------------------------------------------------------
+ * "h5trav print" public functions
+ *-------------------------------------------------------------------------
+ */
+H5TOOLS_DLL int h5trav_print(hid_t fid);
+H5TOOLS_DLL void h5trav_set_verbose(int print_verbose);
+
+#ifdef __cplusplus
+}
+#endif
+
+/*-------------------------------------------------------------------------
+ * info private functions
+ *-------------------------------------------------------------------------
+ */
+
+H5TOOLS_DLL void trav_info_init(const char *filename, hid_t fileid, trav_info_t **info);
+
+H5TOOLS_DLL void trav_info_free(trav_info_t *info);
+
+H5TOOLS_DLL void trav_info_add(trav_info_t *info, const char *path, h5trav_type_t obj_type);
+
+H5TOOLS_DLL void trav_fileinfo_add(trav_info_t *info, hid_t loc_id);
+
+/*-------------------------------------------------------------------------
+ * table private functions
+ *-------------------------------------------------------------------------
+ */
+
+H5TOOLS_DLL void trav_table_init(trav_table_t **table);
+
+H5TOOLS_DLL void trav_table_free(trav_table_t *table);
+
+H5TOOLS_DLL void trav_table_addflags(unsigned *flags,
+                         char *objname,
+                         h5trav_type_t type,
+                         trav_table_t *table);
+
+#endif  /* H5TRAV_H__ */
+
diff --git a/install/include/hdf5.h b/install/include/hdf5.h
new file mode 100644
index 0000000000..fc4541a27d
--- /dev/null
+++ b/install/include/hdf5.h
@@ -0,0 +1,54 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This is the main public HDF5 include file.  Put further information in
+ * a particular header file and include that here, don't fill this file with
+ * lots of gunk...
+ */
+#ifndef _HDF5_H
+#define _HDF5_H
+
+#include "H5public.h"
+#include "H5Apublic.h"		/* Attributes				*/
+#include "H5ACpublic.h"		/* Metadata cache			*/
+#include "H5Dpublic.h"		/* Datasets				*/
+#include "H5Epublic.h"		/* Errors				*/
+#include "H5Fpublic.h"		/* Files				*/
+#include "H5FDpublic.h"		/* File drivers				*/
+#include "H5Gpublic.h"		/* Groups				*/
+#include "H5Ipublic.h"		/* ID management			*/
+#include "H5Lpublic.h"		/* Links				*/
+#include "H5MMpublic.h"		/* Memory management			*/
+#include "H5Opublic.h"		/* Object headers			*/
+#include "H5Ppublic.h"      /* Property lists           */
+#include "H5PLpublic.h"     /* Plugins           */
+#include "H5Rpublic.h"		/* References				*/
+#include "H5Spublic.h"		/* Dataspaces				*/
+#include "H5Tpublic.h"		/* Datatypes				*/
+#include "H5Zpublic.h"		/* Data filters				*/
+
+/* Predefined file drivers */
+#include "H5FDcore.h"		/* Files stored entirely in memory	*/
+#include "H5FDdirect.h"     	/* Linux direct I/O			*/
+#include "H5FDfamily.h"		/* File families 			*/
+#include "H5FDlog.h"        	/* sec2 driver with I/O logging (for debugging) */
+#include "H5FDmpi.h"            /* MPI-based file drivers		*/
+#include "H5FDmulti.h"		/* Usage-partitioned file family	*/
+#include "H5FDsec2.h"		/* POSIX unbuffered file I/O		*/
+#include "H5FDstdio.h"		/* Standard C buffered I/O		*/
+#ifdef H5_HAVE_WINDOWS
+#include "H5FDwindows.h"        /* Windows buffered I/O     */
+#endif
+
+#endif
diff --git a/install/include/hdf5_hl.h b/install/include/hdf5_hl.h
new file mode 100644
index 0000000000..3a7b8ee60f
--- /dev/null
+++ b/install/include/hdf5_hl.h
@@ -0,0 +1,32 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * Copyright by the Board of Trustees of the University of Illinois.         *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.  *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This is the main public HDF5 High Level include file.  Put further
+ * information in a particular header file and include that here, don't
+ * fill this file with lots of gunk...
+ */
+
+#ifndef _HDF5_HL_H
+#define _HDF5_HL_H
+#include "hdf5.h"       /* hdf5 main library */
+#include "H5DOpublic.h" /* dataset optimization */
+#include "H5DSpublic.h" /* dimension scales */
+#include "H5LTpublic.h" /* lite */
+#include "H5IMpublic.h" /* image */
+#include "H5TBpublic.h" /* table */
+#include "H5PTpublic.h" /* packet table */
+#include "H5LDpublic.h" /* lite dataset */
+
+#endif /*H5_INCLUDE_HL*/
+
diff --git a/install/share/COPYING b/install/share/COPYING
new file mode 100644
index 0000000000..51cb4e6fde
--- /dev/null
+++ b/install/share/COPYING
@@ -0,0 +1,105 @@
+Copyright Notice and License Terms for 
+HDF5 (Hierarchical Data Format 5) Software Library and Utilities
+-----------------------------------------------------------------------------
+
+HDF5 (Hierarchical Data Format 5) Software Library and Utilities
+Copyright (c) 2006, The HDF Group. 
+
+NCSA HDF5 (Hierarchical Data Format 5) Software Library and Utilities
+Copyright (c) 1998-2006, The Board of Trustees of the University of Illinois. 
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without 
+modification, are permitted for any purpose (including commercial purposes) 
+provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, 
+   this list of conditions, and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice, 
+   this list of conditions, and the following disclaimer in the documentation 
+   and/or materials provided with the distribution.
+
+3. In addition, redistributions of modified forms of the source or binary 
+   code must carry prominent notices stating that the original code was 
+   changed and the date of the change.
+
+4. All publications or advertising materials mentioning features or use of 
+   this software are asked, but not required, to acknowledge that it was 
+   developed by The HDF Group and by the National Center for Supercomputing 
+   Applications at the University of Illinois at Urbana-Champaign and 
+   credit the contributors.
+
+5. Neither the name of The HDF Group, the name of the University, nor the 
+   name of any Contributor may be used to endorse or promote products derived 
+   from this software without specific prior written permission from 
+   The HDF Group, the University, or the Contributor, respectively.
+
+DISCLAIMER: 
+THIS SOFTWARE IS PROVIDED BY THE HDF GROUP AND THE CONTRIBUTORS 
+"AS IS" WITH NO WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED.  In no 
+event shall The HDF Group or the Contributors be liable for any damages 
+suffered by the users arising out of the use of this software, even if 
+advised of the possibility of such damage. 
+
+-----------------------------------------------------------------------------
+-----------------------------------------------------------------------------
+
+Limited portions of HDF5 were developed by Lawrence Berkeley National 
+Laboratory (LBNL). LBNL's Copyright Notice and Licensing Terms can be
+found here: COPYING_LBNL_HDF5 file in this directory or at 
+http://support.hdfgroup.org/ftp/HDF5/releases/COPYING_LBNL_HDF5. 
+
+-----------------------------------------------------------------------------
+-----------------------------------------------------------------------------
+
+Contributors:   National Center for Supercomputing Applications (NCSA) at 
+the University of Illinois, Fortner Software, Unidata Program Center (netCDF), 
+The Independent JPEG Group (JPEG), Jean-loup Gailly and Mark Adler (gzip), 
+and Digital Equipment Corporation (DEC).
+
+-----------------------------------------------------------------------------
+ 
+Portions of HDF5 were developed with support from the Lawrence Berkeley 
+National Laboratory (LBNL) and the United States Department of Energy 
+under Prime Contract No. DE-AC02-05CH11231.
+
+-----------------------------------------------------------------------------
+
+Portions of HDF5 were developed with support from the University of 
+California, Lawrence Livermore National Laboratory (UC LLNL).  
+The following statement applies to those portions of the product and must 
+be retained in any redistribution of source code, binaries, documentation, 
+and/or accompanying materials:
+
+   This work was partially produced at the University of California, 
+   Lawrence Livermore National Laboratory (UC LLNL) under contract 
+   no. W-7405-ENG-48 (Contract 48) between the U.S. Department of Energy 
+   (DOE) and The Regents of the University of California (University) 
+   for the operation of UC LLNL.
+
+   DISCLAIMER: 
+   This work was prepared as an account of work sponsored by an agency of 
+   the United States Government. Neither the United States Government nor 
+   the University of California nor any of their employees, makes any 
+   warranty, express or implied, or assumes any liability or responsibility 
+   for the accuracy, completeness, or usefulness of any information, 
+   apparatus, product, or process disclosed, or represents that its use 
+   would not infringe privately- owned rights. Reference herein to any 
+   specific commercial products, process, or service by trade name, 
+   trademark, manufacturer, or otherwise, does not necessarily constitute 
+   or imply its endorsement, recommendation, or favoring by the United 
+   States Government or the University of California. The views and 
+   opinions of authors expressed herein do not necessarily state or reflect 
+   those of the United States Government or the University of California, 
+   and shall not be used for advertising or product endorsement purposes.
+
+-----------------------------------------------------------------------------
+
+HDF5 is available with the SZIP compression library but SZIP is not part 
+of HDF5 and has separate copyright and license terms. See Szip Compression 
+in HDF Products (www.hdfgroup.org/doc_resource/SZIP/) for further details.
+
+-----------------------------------------------------------------------------
+
diff --git a/install/share/RELEASE.txt b/install/share/RELEASE.txt
new file mode 100644
index 0000000000..2dbe7e9ffa
--- /dev/null
+++ b/install/share/RELEASE.txt
@@ -0,0 +1,413 @@
+HDF5 version 1.11.0 currently under development
+================================================================================
+
+
+INTRODUCTION
+
+This document describes the differences between HDF5-1.10.1 and HDF5 1.10.2, and
+contains information on the platforms tested and known problems in HDF5-1.10.1.
+For more details check the HISTORY*.txt files in the HDF5 source.
+
+
+Links to HDF5 1.10.1 source code, documentation, and additional materials can be found on The HDF5 web page at:
+
+     https://support.hdfgroup.org/HDF5/
+
+The HDF5 1.10.1 release can be obtained from:
+
+     https://support.hdfgroup.org/HDF5/release/obtain5.html
+
+User documentation for the snapshot can be accessed directly at this location:
+
+     https://support.hdfgroup.org/HDF5/doc/
+
+New features in the HDF5-1.10.x release series, including brief general
+descriptions of some new and modified APIs, are described in the "New Features
+in HDF5 1.10" document:
+
+https://support.hdfgroup.org/HDF5/docNewFeatures/index.html
+
+All new and modified APIs are listed in detail in the "HDF5 Software Changes
+from Release to Release" document, in the section "Release 1.10.1 (current
+release) versus Release 1.10.0
+
+     https://support.hdfgroup.org/HDF5/doc/ADGuide/Changes.html
+
+If you have any questions or comments, please send them to the HDF Help Desk:
+
+    help@hdfgroup.org
+
+
+CONTENTS
+
+- New Features
+- Support for new platforms and languages
+- Bug Fixes since HDF5-1.10.1
+- Supported Platforms
+- Tested Configuration Features Summary
+- More Tested Platforms
+- Known Problems
+
+
+New Features
+============
+
+    Configuration:
+    -------------
+    -
+
+    Library:
+    --------
+    -
+
+    Parallel Library:
+    -----------------
+    - Large MPI-IO transfers
+
+      Previous releases of PHDF5 would fail when attempting to
+      read or write greater than 2GB of data in a single IO operation.
+      This issue stems principally from an MPI API whose definitions
+      utilize 32 bit integers to describe the number of data elements
+      and datatype that MPI should use to effect a data transfer.
+      Historically, HDF5 has invoked MPI-IO with the number of
+      elements in a contiguous buffer represented as the length
+      of that buffer in bytes.
+
+      Resolving the issue and thus enabling larger MPI-IO transfers
+      is accomplished first, by detecting when a user IO request would
+      exceed the 2GB limit as described above.  Once a transfer request
+      is identified as requiring special handling, PHDF5 now creates a
+      derived datatype consisting of a vector of fixed sized blocks
+      which is in turn wrapped within a single MPI_Type_struct to
+      contain the vector and any remaining data.   The newly created
+      datatype is then used in place of MPI_BYTE and can be used to
+      fulfill the original user request without encountering API
+      errors.
+
+      (RAW  2017/07/11, HDFFV-8839)
+
+    Fortran Library:
+    ----------------
+    -
+
+    C++ Library:
+    ------------
+    -
+
+    Tools:
+    ------
+    -
+
+    High-Level APIs:
+    ---------------
+    -
+
+    C Packet Table API
+    ------------------
+    -
+
+    Internal header file
+    --------------------
+    -
+
+    Documentation
+    -------------
+    -
+
+Support for new platforms, languages and compilers.
+=======================================
+    -
+
+Bug Fixes since HDF5-1.10.1 release
+==================================
+
+    Library
+    -------
+    -
+
+    Configuration
+    -------------
+    - cmake
+
+      Too many commands for POST_BUILD step caused command line to be
+      too big on windows.
+
+      Changed foreach of copy command to use a custom command with the
+      use of the HDFTEST_COPY_FILE macro.
+
+      (ADB - 2017/07/12, HDFFV-10254)
+
+    Performance
+    -------------
+    -
+
+    Fortran
+    --------
+    -
+
+    Tools
+    -----
+    - h5dump
+
+      h5dump segfaulted on output of XML file.
+
+      Function that escape'd strings used the full buffer length
+      instead of just the length of the replacement string in a
+      strncpy call. Using the correct length fixed the issue.
+
+      (ADB - 2017/08/01, HDFFV-10256)
+
+    - h5diff
+
+      h5diff segfaulted on compare of a  NULL variable length string.
+
+      Improved h5diff compare of strings by adding a check for
+      NULL strings and setting the lengths to zero.
+
+      (ADB - 2017/07/25, HDFFV-10246)
+
+    - h5import
+
+      h5import crashed trying to import data from a subset of a dataset.
+
+      Improved h5import by adding the SUBSET keyword. h5import understands
+      to use the Count times the Block as the size of the dimensions.
+      Added INPUT_B_ORDER keyword to old-style configuration files.
+      The import from h5dump function expects the binary files to use native
+      types (FILE '-b' option) in the binary file.
+
+      (ADB - 2017/06/15, HDFFV-10219)
+
+    - h5repack
+
+      h5repack did not maintain the creation order flag of the root
+      group.
+
+      Improved h5repack by reading the creation order and applying the
+      flag to the new root group. Also added arguments to set the
+      order and index direction, which applies to the traversing of the
+      original file, on the command line.
+
+      (ADB - 2017/05/26, HDFFV-8611)
+
+    - h5diff
+
+      h5diff failed to account for strpad type and null terminators
+      of char strings. Also, h5diff failed to account for string length
+      differences and would give a different result depending on file
+      order in the command line.
+
+      Improved h5diff compare of strings and arrays by adding a check for
+      string lengths and if the strpad was null filled.
+
+      (ADB - 2017/05/18, HDFFV-9055, HDFFV-10128)
+
+    High-Level APIs:
+    ------
+    -
+
+    Fortran High-Level APIs:
+    ------
+    -
+
+    Documentation
+    -------------
+    -
+
+    F90 APIs
+    --------
+    -
+
+    C++ APIs
+    --------
+    -
+
+    Testing
+    -------
+    -
+
+Supported Platforms
+===================
+
+    Linux 2.6.32-573.22.1.el6    GNU C (gcc), Fortran (gfortran), C++ (g++)
+    #1 SMP x86_64 GNU/Linux       compilers:
+    (mayll/platypus)                 Version 4.4.7 20120313
+                                     Version 4.8.4
+                                  PGI C, Fortran, C++ for 64-bit target on
+                                  x86-64;
+                                      Version 16.10-0
+                                  Intel(R) C (icc), C++ (icpc), Fortran (icc)
+                                  compilers:
+                                     Version 15.0.3.187 (Build 20150407)
+                                  MPICH 3.1.4 compiled with GCC 4.9.3
+
+    Linux 2.6.32-573.18.1.el6.ppc64 gcc (GCC) 4.4.7 20120313 (Red Hat 4.4.7-4)
+    #1 SMP ppc64 GNU/Linux        g++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-4)
+    (ostrich)                     GNU Fortran (GCC) 4.4.7 20120313 (Red Hat 4.4.7-4)
+                                  IBM XL C/C++ V13.1
+                                  IBM XL Fortran V15.1
+
+    Linux 3.10.0-327.10.1.el7   GNU C (gcc), Fortran (gfortran), C++ (g++)
+    #1 SMP x86_64 GNU/Linux       compilers:
+    (kituo/moohan)                  Version 4.8.5 20150623 (Red Hat 4.8.5-4)
+                                    Version 4.9.3, Version 5.2.0
+                                  Intel(R) C (icc), C++ (icpc), Fortran (icc)
+                                  compilers:
+                                     Version 15.0.3.187 Build 20150407
+                                  MPICH 3.1.4 compiled with GCC 4.9.3
+
+    SunOS 5.11 32- and 64-bit     Sun C 5.12 SunOS_sparc
+    (emu)                         Sun Fortran 95 8.6 SunOS_sparc
+                                  Sun C++ 5.12 SunOS_sparc
+
+    Windows 7                     Visual Studio 2012 w/ Intel Fortran 15 (cmake)
+                                  Visual Studio 2013 w/ Intel Fortran 15 (cmake)
+                                  Visual Studio 2015 w/ Intel Fortran 16 (cmake)
+                                  Cygwin(CYGWIN_NT-6.1 2.2.1(0.289/5/3) gcc(4.9.3) compiler and gfortran)
+                                  (cmake and autotools)
+
+    Windows 7 x64                 Visual Studio 2012 w/ Intel Fortran 15 (cmake)
+                                  Visual Studio 2013 w/ Intel Fortran 15 (cmake)
+                                  Visual Studio 2015 w/ Intel Fortran 16 (cmake)
+                                  Visual Studio 2015 w/ Intel Parallel Studio 2017 (cmake)
+
+    Windows 10                    Visual Studio 2015 w/ Intel Fortran 16 (cmake)
+
+    Windows 10 x64                Visual Studio 2015 w/ Intel Fortran 16 (cmake)
+
+    Mac OS X Mt. Lion 10.8.5      Apple clang/clang++ version 5.1 from Xcode 5.1
+    64-bit                        gfortran GNU Fortran (GCC) 4.8.2
+    (swallow/kite)                Intel icc/icpc/ifort version 15.0.3
+
+    Mac OS X Mavericks 10.9.5     Apple clang/clang++ version 6.0 from Xcode 6.2
+    64-bit                        gfortran GNU Fortran (GCC) 4.9.2
+    (wren/quail)                  Intel icc/icpc/ifort version 15.0.3
+
+    Mac OS X Yosemite 10.10.5     Apple clang/clang++ version 6.1 from Xcode 7.0
+    64-bit                        gfortran GNU Fortran (GCC) 4.9.2
+    (osx1010dev/osx1010test)      Intel icc/icpc/ifort version 15.0.3
+
+    Mac OS X El Capitan 10.11.6   Apple clang/clang++ version 7.3.0 from Xcode 7.3
+    64-bit                        gfortran GNU Fortran (GCC) 5.2.0
+    (osx1010dev/osx1010test)      Intel icc/icpc/ifort version 16.0.2
+
+
+Tested Configuration Features Summary
+=====================================
+
+    In the tables below
+          y   = tested
+          n   = not tested in this release
+          C   = Cluster
+          W   = Workstation
+          x   = not working in this release
+          dna = does not apply
+          ( ) = footnote appears below second table
+          <blank> = testing incomplete on this feature or platform
+
+Platform                              C         F90/   F90      C++  zlib  SZIP
+                                      parallel  F2003  parallel
+Solaris2.11 32-bit                      n        y/y    n        y    y     y
+Solaris2.11 64-bit                      n        y/n    n        y    y     y
+Windows 7                               y        y/y    n        y    y     y
+Windows 7 x64                           y        y/y    y        y    y     y
+Windows 7 Cygwin                        n        y/n    n        y    y     y
+Windows 7 x64 Cygwin                    n        y/n    n        y    y     y
+Windows 10                              y        y/y    n        y    y     y
+Windows 10 x64                          y        y/y    n        y    y     y
+Mac OS X Mountain Lion 10.8.5 64-bit    n        y/y    n        y    y     y
+Mac OS X Mavericks 10.9.5 64-bit        n        y/y    n        y    y     ?
+Mac OS X Yosemite 10.10.5 64-bit        n        y/y    n        y    y     ?
+Mac OS X El Capitan 10.11.6 64-bit      n        y/y    n        y    y     ?
+CentOS 6.7 Linux 2.6.18 x86_64 GNU      n        y/y    n        y    y     y
+CentOS 6.7 Linux 2.6.18 x86_64 Intel    n        y/y    n        y    y     y
+CentOS 6.7 Linux 2.6.32 x86_64 PGI      n        y/y    n        y    y     y
+CentOS 7.2 Linux 2.6.32 x86_64 GNU      y        y/y    y        y    y     y
+CentOS 7.2 Linux 2.6.32 x86_64 Intel    n        y/y    n        y    y     y
+Linux 2.6.32-573.18.1.el6.ppc64         n        y/n    n        y    y     y
+
+
+Platform                                 Shared  Shared    Shared    Thread-
+                                         C libs  F90 libs  C++ libs  safe
+Solaris2.11 32-bit                         y       y         y         y
+Solaris2.11 64-bit                         y       y         y         y
+Windows 7                                  y       y         y         y
+Windows 7 x64                              y       y         y         y
+Windows 7 Cygwin                           n       n         n         y
+Windows 7 x64 Cygwin                       n       n         n         y
+Windows 10                                 y       y         y         y
+Windows 10 x64                             y       y         y         y
+Mac OS X Mountain Lion 10.8.5 64-bit       y       n         y         y
+Mac OS X Mavericks 10.9.5 64-bit           y       n         y         y
+Mac OS X Yosemite 10.10.5 64-bit           y       n         y         y
+Mac OS X El Capitan 10.11.6 64-bit         y       n         y         y
+CentOS 6.7 Linux 2.6.18 x86_64 GNU         y       y         y         y
+CentOS 6.7 Linux 2.6.18 x86_64 Intel       y       y         y         n
+CentOS 6.7 Linux 2.6.32 x86_64 PGI         y       y         y         n
+CentOS 7.2 Linux 2.6.32 x86_64 GNU         y       y         y         n
+CentOS 7.2 Linux 2.6.32 x86_64 Intel       y       y         y         n
+Linux 2.6.32-573.18.1.el6.ppc64            y       y         y         n
+
+Compiler versions for each platform are listed in the preceding
+"Supported Platforms" table.
+
+
+More Tested Platforms
+=====================
+The following platforms are not supported but have been tested for this release.
+
+    Linux 2.6.32-573.22.1.el6    GNU C (gcc), Fortran (gfortran), C++ (g++)
+    #1 SMP x86_64 GNU/Linux       compilers:
+    (mayll/platypus)                 Version 4.4.7 20120313
+                                     Version 4.8.4
+                                  PGI C, Fortran, C++ for 64-bit target on
+                                  x86-64;
+                                      Version 16.10-0
+                                  Intel(R) C (icc), C++ (icpc), Fortran (icc)
+                                  compilers:
+                                     Version 15.0.3.187 (Build 20150407)
+                                  MPICH 3.1.4 compiled with GCC 4.9.3
+
+    Linux 3.10.0-327.18.2.el7     GNU C (gcc) and C++ (g++) compilers
+    #1 SMP x86_64 GNU/Linux          Version 4.8.5 20150623 (Red Hat 4.8.5-4)
+    (jelly)                       with NAG Fortran Compiler Release 6.1(Tozai)
+                                  Intel(R) C (icc) and C++ (icpc) compilers
+                                     Version 15.0.3.187 (Build 20150407)
+                                  with NAG Fortran Compiler Release 6.1(Tozai)
+
+    Linux 2.6.32-573.18.1.el6.ppc64  MPICH mpich 3.1.4 compiled with
+    #1 SMP ppc64 GNU/Linux           IBM XL C/C++ for Linux, V13.1
+    (ostrich)                        and IBM XL Fortran for Linux, V15.1
+
+    Debian 8.4 3.16.0-4-amd64 #1 SMP Debian 3.16.36-1 x86_64 GNU/Linux
+                                  gcc, g++ (Debian 4.9.2-10) 4.9.2
+                                  GNU Fortran (Debian 4.9.2-10) 4.9.2
+                                  (cmake and autotools)
+
+    Fedora 24  4.7.2-201.fc24.x86_64 #1 SMP x86_64 x86_64 x86_64 GNU/Linux
+                                  gcc, g++ (GCC) 6.1.1 20160621
+                                      (Red Hat 6.1.1-3)
+                                  GNU Fortran (GCC) 6.1.1 20160621
+                                      (Red Hat 6.1.1-3)
+                                  (cmake and autotools)
+
+    Ubuntu 16.04.1 4.4.0-38-generic #57-Ubuntu SMP x86_64 GNU/Linux
+                                  gcc, g++ (Ubuntu 5.4.0-6ubuntu1~16.04.2)
+                                      5.4.0 20160609
+                                  GNU Fortran (Ubuntu 5.4.0-6ubuntu1~16.04.2)
+                                      5.4.0 20160609
+                                  (cmake and autotools)
+
+
+Known Problems
+==============
+
+    At present, metadata cache images may not be generated by parallel
+    applications.  Parallel applications can read files with metadata cache
+    images, but since this is a collective operation, a deadlock is possible
+    if one or more processes do not participate.
+
+    Known problems in previous releases can be found in the HISTORY*.txt files
+    in the HDF5 source. Please report any new problems found to
+    help@hdfgroup.org.
+
diff --git a/install/share/USING_HDF5_CMake.txt b/install/share/USING_HDF5_CMake.txt
new file mode 100644
index 0000000000..ecf972daa1
--- /dev/null
+++ b/install/share/USING_HDF5_CMake.txt
@@ -0,0 +1,425 @@
+************************************************************************
+* Build and Install HDF5 Applications with CMake                       *
+************************************************************************
+
+Notes: This short instruction is written for users who want to quickly
+       build HDF5 applications using the CMake tools. Users can adapt
+       these instructions for their own applications. For more information,
+       see the "Minimum C Project Files for CMake" section.
+
+       More information about using CMake can be found at the KitWare
+       site, www.cmake.org.
+
+       CMake uses the command line; however, the visual CMake tool is
+       available for the configuration step. The steps are similar for
+       all of the operating systems supported by CMake.
+
+       NOTES:
+         1. Using CMake for building and using HDF5 is under active
+            development. While we have attempted to provide error-free
+            files, please understand that development with CMake has not
+            been extensively tested outside of HDF. The CMake specific
+            files may change before the next release.
+
+         2. CMake for HDF5 development should be usable on any system
+            where CMake is supported. Please send us any comments on how
+            CMake support can be improved on any system.
+
+         3. See the appendix at the bottom of this file for an example
+            of using a ctest script for building and testing. See
+            INSTALL_CMake.txt for more information.
+
+
+
+========================================================================
+I. Preconditions
+========================================================================
+
+   1. We suggest you obtain the latest CMake for windows from the Kitware
+      web site. The HDF5 1.10.x product requires a minimum CMake version
+      of 3.2.2.
+
+   2. You have installed the HDF5 library built with CMake, by executing
+      the HDF Install Utility (the *.msi file in the binary package for
+      Windows). If you are using a Windows platform, you can obtain a
+      pre-built Windows binary from The HDF Group's website at
+      www.hdfgroup.org.
+
+   3. Set the environment variable HDF5_DIR to the installed location of
+      the config files for HDF5. On Windows:
+            HDF5_DIR=C:/Program Files/HDF_Group/HDF5/1.10.x/cmake
+
+      (Note there are no quote characters used on Windows and all platforms
+      use forward slashes)
+
+   4. Created separate source and build directories.
+      (CMake commands are executed in the build directory)
+
+   5. Created a CMakeLists.txt file(s) for your source. See Section III
+      below.
+
+
+
+========================================================================
+II. Building HDF5 Applications with CMake
+========================================================================
+
+Go through these steps to build HDF5 applications with CMake.
+   (The application must support building with CMake.)
+
+   1. Run CMake
+   2. Configure the cache settings
+   3. Build HDF5 Applications
+   4. Test HDF5 Applications
+
+These steps are described in more detail below.
+
+
+
+   1. Run CMake
+
+      The visual CMake executable is named "cmake-gui.exe" on Windows and should be
+      available in your Start menu. For Linux, UNIX, and Mac users the
+      executable is named "cmake-gui" and can be found where CMake was
+      installed.
+
+      Specify the source and build directories. Make the build and source
+      directories different. For example on Windows, if the source is at
+      c:\MyHDFstuff\hdf5, then use c:\MyHDFstuff\hdf5\build or
+      c:\MyHDFstuff\build\hdf5 for the build directory.
+
+      PREFERRED:
+        Users can perform the configuration step without using the visual
+        cmake-gui program. The following is an example command line
+        configuration step executed within the build directory:
+
+        cmake -G "<generator>"  [-D<options>]  <sourcepath>
+
+        Where <generator> is
+            * MinGW Makefiles
+            * NMake Makefiles
+            * Unix Makefiles
+            * Visual Studio 12 2013
+            * Visual Studio 12 2013 Win64
+            * Visual Studio 11 2012
+            * Visual Studio 11 2012 Win64
+            * Visual Studio 14 2015
+            * Visual Studio 14 2015 Win64
+
+        <options> is:
+            * BUILD_TESTING:BOOL=ON
+            * BUILD_SHARED_LIBS:BOOL=[ON | OFF]
+
+   2. Configure the cache settings
+
+      2.1  Visual CMake users, click the Configure button. If this is the first time you are
+           running cmake-gui in this directory, you will be prompted for the
+           generator you wish to use (for example on Windows, Visual Studio 12 2013).
+           CMake will read in the CMakeLists.txt files from the source directory and
+           display options for the HDF5 project. After the first configure you
+           can adjust the cache settings and/or specify locations of other programs.
+
+           Any conflicts or new values will be highlighted by the configure
+           process in red. Once you are happy with all the settings and there are no
+           more values in red, click the Generate button to produce the appropriate
+           build files.
+
+           On Windows, if you are using a Visual Studio generator, the solution and
+           project files will be created in the build folder.
+
+           On linux, if you are using the Unix Makefiles generator, the Makefiles will
+           be created in the build folder.
+
+      2.2  Alternative command line example on Windows in c:\MyHDFstuff\hdf5\build directory:
+
+           cmake -G "Visual Studio 12 2013" -DBUILD_TESTING:BOOL=ON ..
+
+   3. Build HDF5 Applications
+
+      On Windows, you can build HDF5 applications using either the Visual Studio Environment
+      or the command line. The command line is normally used on linux, Unix, and Mac.
+
+      To build from the command line, navigate to your build directory and
+      execute the following:
+
+              cmake --build . --config {Debug | Release}
+
+      NOTE: "--config {Debug | Release}" may be optional on your platform. We
+            recommend choosing either Debug or Release on Windows. If you are
+            using the pre-built binaries from HDF, use Release.
+
+      3.1  If you wish to use the Visual Studio environment, open the solution
+           file in your build directory. Be sure to select either Debug or
+           Release and build the solution.
+
+   4. Test HDF5 Applications
+
+      To test the build, navigate to your build directory and execute:
+
+              ctest . -C {Debug | Release}
+
+      NOTE: "-C {Debug | Release}" may be optional on your platform. We
+            recommend choosing either Debug or Release to match the build
+            step on Windows.
+
+   5. The files that support building with CMake are all of the files in the
+      config/cmake folder, the CMakeLists.txt files in each source folder, and
+      CTestConfig.cmake. CTestConfig.cmake is specific to the internal testing
+      performed by The HDF Group. It should be altered for the user's
+      installation and needs. The cacheinit.cmake file settings are used by
+      The HDF Group for daily testing. It should be altered/ignored for the user's
+      installation and needs.
+
+
+
+========================================================================
+III. Minimum C Project Files for CMake
+========================================================================
+
+Given the preconditions in section I, create a CMakeLists.txt file at the
+source root. Include the following text in the file:
+
+##########################################################
+cmake_minimum_required (VERSION 3.2.2)
+project (HDF5MyApp C CXX)
+
+set (LIB_TYPE STATIC) # or SHARED
+string(TOLOWER ${LIB_TYPE} SEARCH_TYPE)
+
+find_package (HDF5 NAMES hdf5 COMPONENTS C ${SEARCH_TYPE})
+# find_package (HDF5) # Find non-cmake built HDF5
+INCLUDE_DIRECTORIES (${HDF5_INCLUDE_DIR})
+set (LINK_LIBS ${LINK_LIBS} ${HDF5_C_${LIB_TYPE}_LIBRARY})
+
+set (example hdf_example)
+
+add_executable (${example} ${PROJECT_SOURCE_DIR}/${example}.c)
+TARGET_NAMING (${example} ${LIB_TYPE})
+TARGET_C_PROPERTIES (${example} ${LIB_TYPE} " " " ")
+target_link_libraries (${example} ${LINK_LIBS})
+
+enable_testing ()
+include (CTest)
+
+add_test (NAME test_example COMMAND ${example})
+##########################################################
+
+
+
+========================================================================
+IV. APPENDIX
+========================================================================
+
+Below is an example of a ctest script that can be used to build the examples.
+Adjust the values as necessary. Note that the defaults can be entered on the
+command line and the build folder is created as a sub-folder. Windows should
+adjust the forward slash to double backslashes, except for the HDF_DIR
+environment variable.
+
+NOTE: this file is available at the HDF web site:
+    http://www.hdfgroup.org/HDF5/release/cmakebuild.html
+
+    HDF5_Examples.cmake
+
+Also available at the HDF web site is a CMake application framework template.
+You can quickly add files to the framework and execute the script to compile
+your application with an installed HDF5 binary.
+
+========================================================================
+ctest
+========================================================================
+
+cmake_minimum_required(VERSION 3.2.2 FATAL_ERROR)
+###############################################################################################################
+# This script will build and run the examples from a folder
+# Execute from a command line:
+#     ctest -S HDF5_Examples.cmake,OPTION=VALUE -C Release -V -O test.log
+###############################################################################################################
+
+set (CTEST_CMAKE_GENERATOR "@CMAKE_GENERATOR@")
+set (CTEST_DASHBOARD_ROOT ${CTEST_SCRIPT_DIRECTORY})
+
+# handle input parameters to script.
+#INSTALLDIR - HDF5 root folder
+#CTEST_CONFIGURATION_TYPE - Release, Debug, RelWithDebInfo
+#CTEST_SOURCE_NAME - name of source folder; HDF4Examples
+#STATIC_ONLY - Default is YES
+#FORTRAN_LIBRARIES - Default is NO
+#JAVA_LIBRARIES - Default is NO
+##NO_MAC_FORTRAN - set to TRUE to allow shared libs on a Mac)
+if (DEFINED CTEST_SCRIPT_ARG)
+    # transform ctest script arguments of the form
+    # script.ctest,var1=value1,var2=value2
+    # to variables with the respective names set to the respective values
+    string (REPLACE "," ";" script_args "${CTEST_SCRIPT_ARG}")
+    foreach (current_var ${script_args})
+        if ("${current_var}" MATCHES "^([^=]+)=(.+)$")
+            set("${CMAKE_MATCH_1}" "${CMAKE_MATCH_2}")
+        endif ()
+    endforeach ()
+endif ()
+if (NOT DEFINED INSTALLDIR)
+    set (INSTALLDIR "@CMAKE_INSTALL_PREFIX@")
+endif ()
+if (NOT DEFINED CTEST_CONFIGURATION_TYPE)
+    set (CTEST_CONFIGURATION_TYPE "Release")
+endif ()
+if (NOT DEFINED CTEST_SOURCE_NAME)
+    set (CTEST_SOURCE_NAME "HDF5Examples")
+endif ()
+if (NOT DEFINED STATIC_ONLY)
+    set (STATICONLYLIBRARIES "YES")
+else ()
+    set (STATICONLYLIBRARIES "NO")
+endif ()
+if (NOT DEFINED FORTRAN_LIBRARIES)
+    set (FORTRANLIBRARIES "NO")
+else ()
+    set (FORTRANLIBRARIES "YES")
+endif ()
+if (NOT DEFINED JAVA_LIBRARIES)
+    set (JAVALIBRARIES "NO")
+else ()
+    set (JAVALIBRARIES "YES")
+endif ()
+
+#TAR_SOURCE - name of tarfile
+#if (NOT DEFINED TAR_SOURCE)
+#  set (CTEST_USE_TAR_SOURCE "HDF5Examples-1.10.1-Source")
+#endif ()
+
+###############################################################################################################
+#     Adjust the following SET Commands as needed
+###############################################################################################################
+if (WIN32)
+  if (${STATICONLYLIBRARIES})
+    set (BUILD_OPTIONS "${BUILD_OPTIONS} -DBUILD_SHARED_LIBS:BOOL=OFF")
+  endif ()
+  set (ENV{HDF5_DIR} "${INSTALLDIR}/cmake")
+  set (CTEST_BINARY_NAME ${CTEST_SOURCE_NAME}\\build)
+  set (CTEST_SOURCE_DIRECTORY "${CTEST_DASHBOARD_ROOT}\\${CTEST_SOURCE_NAME}")
+  set (CTEST_BINARY_DIRECTORY "${CTEST_DASHBOARD_ROOT}\\${CTEST_BINARY_NAME}")
+else (WIN32)
+  if (${STATICONLYLIBRARIES})
+    set (BUILD_OPTIONS "${BUILD_OPTIONS} -DBUILD_SHARED_LIBS:BOOL=OFF -DCMAKE_ANSI_CFLAGS:STRING=-fPIC")
+  endif ()
+  set (ENV{HDF5_DIR} "${INSTALLDIR}/share/cmake")
+  set (ENV{LD_LIBRARY_PATH} "${INSTALLDIR}/lib")
+  set (CTEST_BINARY_NAME ${CTEST_SOURCE_NAME}/build)
+  set (CTEST_SOURCE_DIRECTORY "${CTEST_DASHBOARD_ROOT}/${CTEST_SOURCE_NAME}")
+  set (CTEST_BINARY_DIRECTORY "${CTEST_DASHBOARD_ROOT}/${CTEST_BINARY_NAME}")
+endif(WIN32)
+if (${FORTRANLIBRARIES})
+  set (BUILD_OPTIONS "${BUILD_OPTIONS} -DHDF_BUILD_FORTRAN:BOOL=ON")
+else ()
+  set (BUILD_OPTIONS "${BUILD_OPTIONS} -DHDF_BUILD_FORTRAN:BOOL=OFF")
+endif ()
+if (${JAVALIBRARIES})
+  set (BUILD_OPTIONS "${BUILD_OPTIONS} -DHDF_BUILD_JAVA:BOOL=ON")
+else ()
+  set (BUILD_OPTIONS "${BUILD_OPTIONS} -DHDF_BUILD_JAVA:BOOL=OFF")
+endif ()
+set (BUILD_OPTIONS "${BUILD_OPTIONS} -DHDF5_PACKAGE_NAME:STRING=@HDF5_PACKAGE@@HDF_PACKAGE_EXT@")
+
+###############################################################################################################
+# For any comments please contact cdashhelp@hdfgroup.org
+#
+###############################################################################################################
+
+#-----------------------------------------------------------------------------
+# MAC machines need special option
+#-----------------------------------------------------------------------------
+if (APPLE)
+  # Compiler choice
+  execute_process (COMMAND xcrun --find cc OUTPUT_VARIABLE XCODE_CC OUTPUT_STRIP_TRAILING_WHITESPACE)
+  execute_process (COMMAND xcrun --find c++ OUTPUT_VARIABLE XCODE_CXX OUTPUT_STRIP_TRAILING_WHITESPACE)
+  set (ENV{CC} "${XCODE_CC}")
+  set (ENV{CXX} "${XCODE_CXX}")
+  if (NOT NO_MAC_FORTRAN)
+    # Shared fortran is not supported, build static
+    set (BUILD_OPTIONS "${BUILD_OPTIONS} -DBUILD_SHARED_LIBS:BOOL=OFF -DCMAKE_ANSI_CFLAGS:STRING=-fPIC")
+  else ()
+    set (BUILD_OPTIONS "${BUILD_OPTIONS} -DHDF_BUILD_FORTRAN:BOOL=OFF")
+  endif ()
+  set (BUILD_OPTIONS "${BUILD_OPTIONS} -DCTEST_USE_LAUNCHERS:BOOL=ON -DCMAKE_BUILD_WITH_INSTALL_RPATH:BOOL=OFF")
+endif ()
+
+#-----------------------------------------------------------------------------
+set (CTEST_CMAKE_COMMAND "\"${CMAKE_COMMAND}\"")
+## --------------------------
+if (CTEST_USE_TAR_SOURCE)
+  ## Uncompress source if tar or zip file provided
+  ## --------------------------
+  if (WIN32)
+    message (STATUS "extracting... [${CMAKE_EXECUTABLE_NAME} -E tar -xvf ${CTEST_USE_TAR_SOURCE}.zip]")
+    execute_process (COMMAND ${CMAKE_EXECUTABLE_NAME} -E tar -xvf ${CTEST_DASHBOARD_ROOT}\\${CTEST_USE_TAR_SOURCE}.zip RESULT_VARIABLE rv)
+  else ()
+    message (STATUS "extracting... [${CMAKE_EXECUTABLE_NAME} -E tar -xvf ${CTEST_USE_TAR_SOURCE}.tar]")
+    execute_process (COMMAND ${CMAKE_EXECUTABLE_NAME} -E tar -xvf ${CTEST_DASHBOARD_ROOT}/${CTEST_USE_TAR_SOURCE}.tar RESULT_VARIABLE rv)
+  endif ()
+
+  if (NOT rv EQUAL 0)
+    message (STATUS "extracting... [error-(${rv}) clean up]")
+    file (REMOVE_RECURSE "${CTEST_SOURCE_DIRECTORY}")
+    message (FATAL_ERROR "error: extract of ${CTEST_SOURCE_NAME} failed")
+  endif ()
+endif ()
+
+#-----------------------------------------------------------------------------
+## Clear the build directory
+## --------------------------
+set (CTEST_START_WITH_EMPTY_BINARY_DIRECTORY TRUE)
+if (EXISTS "${CTEST_BINARY_DIRECTORY}" AND IS_DIRECTORY "${CTEST_BINARY_DIRECTORY}")
+  ctest_empty_binary_directory (${CTEST_BINARY_DIRECTORY})
+else ()
+  file (MAKE_DIRECTORY "${CTEST_BINARY_DIRECTORY}")
+endif ()
+
+# Use multiple CPU cores to build
+include (ProcessorCount)
+ProcessorCount (N)
+if (NOT N EQUAL 0)
+  if (NOT WIN32)
+    set (CTEST_BUILD_FLAGS -j${N})
+  endif ()
+  set (ctest_test_args ${ctest_test_args} PARALLEL_LEVEL ${N})
+endif ()
+set (CTEST_CONFIGURE_COMMAND
+    "${CTEST_CMAKE_COMMAND} -C \"${CTEST_SOURCE_DIRECTORY}/config/cmake/cacheinit.cmake\" -DCMAKE_BUILD_TYPE:STRING=${CTEST_CONFIGURATION_TYPE} ${BUILD_OPTIONS} \"-G${CTEST_CMAKE_GENERATOR}\" \"${CTEST_SOURCE_DIRECTORY}\""
+)
+
+#-----------------------------------------------------------------------------
+## -- set output to english
+set ($ENV{LC_MESSAGES}  "en_EN")
+
+#-----------------------------------------------------------------------------
+configure_file (${CTEST_SOURCE_DIRECTORY}/config/cmake/CTestCustom.cmake ${CTEST_BINARY_DIRECTORY}/CTestCustom.cmake)
+ctest_read_custom_files ("${CTEST_BINARY_DIRECTORY}")
+## NORMAL process
+## --------------------------
+ctest_start (Experimental)
+ctest_configure (BUILD "${CTEST_BINARY_DIRECTORY}")
+if (LOCAL_SUBMIT)
+  ctest_submit (PARTS Configure Notes)
+endif ()
+ctest_build (BUILD "${CTEST_BINARY_DIRECTORY}" APPEND)
+if (LOCAL_SUBMIT)
+  ctest_submit (PARTS Build)
+endif ()
+ctest_test (BUILD "${CTEST_BINARY_DIRECTORY}" APPEND ${ctest_test_args} RETURN_VALUE res)
+if (LOCAL_SUBMIT)
+  ctest_submit (PARTS Test)
+endif ()
+if (res GREATER 0)
+  message (FATAL_ERROR "tests FAILED")
+endif ()
+#-----------------------------------------------------------------------------
+##############################################################################################################
+
+
+
+========================================================================
+For further assistance, send email to help@hdfgroup.org
+========================================================================
+
+
diff --git a/install/share/cmake/hdf5-config-version.cmake b/install/share/cmake/hdf5-config-version.cmake
new file mode 100644
index 0000000000..34fcbdb3eb
--- /dev/null
+++ b/install/share/cmake/hdf5-config-version.cmake
@@ -0,0 +1,58 @@
+#
+# Copyright by The HDF Group.
+# All rights reserved.
+#
+# This file is part of HDF5.  The full HDF5 copyright notice, including
+# terms governing use, modification, and redistribution, is contained in
+# the COPYING file, which can be found at the root of the source code
+# distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.
+# If you do not have access to either file, you may request a copy from
+# help@hdfgroup.org.
+#
+#-----------------------------------------------------------------------------
+# HDF5 Version file for install directory
+#-----------------------------------------------------------------------------
+#
+# The created file sets PACKAGE_VERSION_EXACT if the current version string and
+# the requested version string are exactly the same and it sets
+# PACKAGE_VERSION_COMPATIBLE if the current version is >= requested version,
+# but only if the requested major.minor version is the same as the current one.
+# The variable HDF5_VERSION_STRING must be set before calling configure_file().
+
+set (PACKAGE_VERSION "1.11.0")
+
+if("${PACKAGE_VERSION}" VERSION_LESS "${PACKAGE_FIND_VERSION}" )
+  set(PACKAGE_VERSION_COMPATIBLE FALSE)
+else ()
+  if ("${PACKAGE_FIND_VERSION_MAJOR}" STREQUAL "1")
+
+    # exact match for version 1.11
+    if ("${PACKAGE_FIND_VERSION_MINOR}" STREQUAL "11")
+
+      # compatible with any version 1.11.x
+      set (PACKAGE_VERSION_COMPATIBLE TRUE)
+
+      if ("${PACKAGE_FIND_VERSION_PATCH}" STREQUAL "0")
+        set (PACKAGE_VERSION_EXACT TRUE)
+
+        if ("${PACKAGE_FIND_VERSION_TWEAK}" STREQUAL "")
+          # not using this yet
+        endif ()
+      endif ()
+    else ()
+      set (PACKAGE_VERSION_COMPATIBLE FALSE)
+    endif ()
+  endif ()
+endif ()
+
+# if the installed or the using project don't have CMAKE_SIZEOF_VOID_P set, ignore it:
+if("${CMAKE_SIZEOF_VOID_P}"  STREQUAL ""  OR "8" STREQUAL "")
+   return()
+endif ()
+
+# check that the installed version has the same 32/64bit-ness as the one which is currently searching:
+if(NOT "${CMAKE_SIZEOF_VOID_P}" STREQUAL "8")
+  math(EXPR installedBits "8 * 8")
+  set(PACKAGE_VERSION "${PACKAGE_VERSION} (${installedBits}bit)")
+  set(PACKAGE_VERSION_UNSUITABLE TRUE)
+endif ()
diff --git a/install/share/cmake/hdf5-config.cmake b/install/share/cmake/hdf5-config.cmake
new file mode 100644
index 0000000000..d6d886bf59
--- /dev/null
+++ b/install/share/cmake/hdf5-config.cmake
@@ -0,0 +1,209 @@
+#
+# Copyright by The HDF Group.
+# All rights reserved.
+#
+# This file is part of HDF5.  The full HDF5 copyright notice, including
+# terms governing use, modification, and redistribution, is contained in
+# the COPYING file, which can be found at the root of the source code
+# distribution tree, or in https://support.hdfgroup.org/ftp/HDF5/releases.
+# If you do not have access to either file, you may request a copy from
+# help@hdfgroup.org.
+#
+#-----------------------------------------------------------------------------
+# HDF5 Config file for compiling against hdf5 build/install directory
+#-----------------------------------------------------------------------------
+
+####### Expanded from @PACKAGE_INIT@ by configure_package_config_file() #######
+####### Any changes to this file will be overwritten by the next CMake run ####
+####### The input file was hdf5-config.cmake.in                            ########
+
+get_filename_component(PACKAGE_PREFIX_DIR "${CMAKE_CURRENT_LIST_DIR}/../../" ABSOLUTE)
+
+macro(set_and_check _var _file)
+  set(${_var} "${_file}")
+  if(NOT EXISTS "${_file}")
+    message(FATAL_ERROR "File or directory ${_file} referenced by variable ${_var} does not exist !")
+  endif()
+endmacro()
+
+macro(check_required_components _NAME)
+  foreach(comp ${${_NAME}_FIND_COMPONENTS})
+    if(NOT ${_NAME}_${comp}_FOUND)
+      if(${_NAME}_FIND_REQUIRED_${comp})
+        set(${_NAME}_FOUND FALSE)
+      endif()
+    endif()
+  endforeach()
+endmacro()
+
+####################################################################################
+
+string(TOUPPER hdf5 HDF5_PACKAGE_NAME)
+
+set (${HDF5_PACKAGE_NAME}_VALID_COMPONENTS
+    static
+    shared
+    C
+    CXX
+    Fortran
+    HL
+    CXX_HL
+    Fortran_HL
+    Java
+    Tools
+)
+
+#-----------------------------------------------------------------------------
+# User Options
+#-----------------------------------------------------------------------------
+set (${HDF5_PACKAGE_NAME}_ENABLE_PARALLEL OFF)
+set (${HDF5_PACKAGE_NAME}_BUILD_FORTRAN   OFF)
+set (${HDF5_PACKAGE_NAME}_BUILD_CPP_LIB   ON)
+set (${HDF5_PACKAGE_NAME}_BUILD_JAVA      OFF)
+set (${HDF5_PACKAGE_NAME}_BUILD_TOOLS     ON)
+set (${HDF5_PACKAGE_NAME}_BUILD_HL_LIB    ON)
+set (${HDF5_PACKAGE_NAME}_ENABLE_Z_LIB_SUPPORT OFF)
+set (${HDF5_PACKAGE_NAME}_ENABLE_SZIP_SUPPORT  OFF)
+set (${HDF5_PACKAGE_NAME}_ENABLE_SZIP_ENCODING )
+set (${HDF5_PACKAGE_NAME}_BUILD_SHARED_LIBS    ON)
+set (${HDF5_PACKAGE_NAME}_PACKAGE_EXTLIBS      OFF)
+set (${HDF5_PACKAGE_NAME}_EXPORT_LIBRARIES hdf5-static;hdf5-shared;hdf5_tools-static;hdf5_tools-shared;hdf5_hl-static;hdf5_hl-shared;hdf5_cpp-static;hdf5_cpp-shared;hdf5_hl_cpp-static;hdf5_hl_cpp-shared)
+set (${HDF5_PACKAGE_NAME}_TOOLSET "")
+
+#-----------------------------------------------------------------------------
+# Dependencies
+#-----------------------------------------------------------------------------
+if (${HDF5_PACKAGE_NAME}_ENABLE_PARALLEL)
+  set (${HDF5_PACKAGE_NAME}_MPI_C_INCLUDE_PATH "")
+  set (${HDF5_PACKAGE_NAME}_MPI_C_LIBRARIES    "")
+endif ()
+
+if (${HDF5_PACKAGE_NAME}_BUILD_JAVA)
+  set (${HDF5_PACKAGE_NAME}_JAVA_INCLUDE_DIRS
+      ${PACKAGE_PREFIX_DIR}/lib/jarhdf5-1.11.0.jar
+      ${PACKAGE_PREFIX_DIR}/lib/slf4j-api-1.7.5.jar
+      ${PACKAGE_PREFIX_DIR}/lib/slf4j-nop-1.7.5.jar
+  )
+  set (${HDF5_PACKAGE_NAME}_JAVA_LIBRARY "${PACKAGE_PREFIX_DIR}/lib")
+  set (${HDF5_PACKAGE_NAME}_JAVA_LIBRARIES "${${HDF5_PACKAGE_NAME}_JAVA_LIBRARY}")
+endif ()
+
+#-----------------------------------------------------------------------------
+# Directories
+#-----------------------------------------------------------------------------
+set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR "${PACKAGE_PREFIX_DIR}/include" "${${HDF5_PACKAGE_NAME}_MPI_C_INCLUDE_PATH}")
+
+set (${HDF5_PACKAGE_NAME}_SHARE_DIR "${PACKAGE_PREFIX_DIR}/share/cmake")
+set_and_check (${HDF5_PACKAGE_NAME}_BUILD_DIR "${PACKAGE_PREFIX_DIR}")
+
+if (${HDF5_PACKAGE_NAME}_BUILD_CPP_LIB)
+  set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR_CPP "${PACKAGE_PREFIX_DIR}/include")
+endif ()
+
+if (${HDF5_PACKAGE_NAME}_BUILD_HL_LIB)
+  set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR_HL "${PACKAGE_PREFIX_DIR}/include")
+endif ()
+
+if (${HDF5_PACKAGE_NAME}_BUILD_HL_LIB AND ${HDF5_PACKAGE_NAME}_BUILD_CPP_LIB)
+  set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR_HL_CPP "${PACKAGE_PREFIX_DIR}/include")
+endif ()
+
+if (${HDF5_PACKAGE_NAME}_BUILD_TOOLS)
+  set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR_TOOLS "${PACKAGE_PREFIX_DIR}/include")
+  set_and_check (${HDF5_PACKAGE_NAME}_TOOLS_DIR "${PACKAGE_PREFIX_DIR}/bin")
+endif ()
+
+#-----------------------------------------------------------------------------
+# Version Strings
+#-----------------------------------------------------------------------------
+set (HDF5_VERSION_STRING 1.11.0)
+set (HDF5_VERSION_MAJOR  1.11)
+set (HDF5_VERSION_MINOR  0)
+
+#-----------------------------------------------------------------------------
+# Don't include targets if this file is being picked up by another
+# project which has already built hdf5 as a subproject
+#-----------------------------------------------------------------------------
+if (NOT TARGET "hdf5")
+  if (${HDF5_PACKAGE_NAME}_ENABLE_Z_LIB_SUPPORT AND ${HDF5_PACKAGE_NAME}_PACKAGE_EXTLIBS AND NOT TARGET "zlib")
+    include (${PACKAGE_PREFIX_DIR}/share/cmake/-targets.cmake)
+  endif ()
+  if (${HDF5_PACKAGE_NAME}_ENABLE_SZIP_SUPPORT AND ${HDF5_PACKAGE_NAME}_PACKAGE_EXTLIBS AND NOT TARGET "szip")
+    include (${PACKAGE_PREFIX_DIR}/share/cmake/-targets.cmake)
+  endif ()
+  include (${PACKAGE_PREFIX_DIR}/share/cmake/hdf5-targets.cmake)
+endif ()
+
+# Handle default component(static) :
+if (NOT ${HDF5_PACKAGE_NAME}_FIND_COMPONENTS)
+    set (${HDF5_PACKAGE_NAME}_LIB_TYPE)
+    set (${HDF5_PACKAGE_NAME}_FIND_COMPONENTS C HL static)
+    set (${HDF5_PACKAGE_NAME}_FIND_REQUIRED_static_C true)
+endif ()
+
+# Handle requested components:
+list (REMOVE_DUPLICATES ${HDF5_PACKAGE_NAME}_FIND_COMPONENTS)
+foreach (comp IN LISTS ${HDF5_PACKAGE_NAME}_FIND_COMPONENTS)
+  if (${comp} STREQUAL "shared")
+    list (REMOVE_ITEM ${HDF5_PACKAGE_NAME}_FIND_COMPONENTS ${comp})
+    set (${HDF5_PACKAGE_NAME}_LIB_TYPE ${${HDF5_PACKAGE_NAME}_LIB_TYPE} ${comp})
+
+    if (${HDF5_PACKAGE_NAME}_BUILD_FORTRAN)
+      set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR_FORTRAN "${PACKAGE_PREFIX_DIR}/include/shared")
+    endif ()
+  elseif (${comp} STREQUAL "static")
+    list (REMOVE_ITEM ${HDF5_PACKAGE_NAME}_FIND_COMPONENTS ${comp})
+    set (${HDF5_PACKAGE_NAME}_LIB_TYPE ${${HDF5_PACKAGE_NAME}_LIB_TYPE} ${comp})
+
+    if (${HDF5_PACKAGE_NAME}_BUILD_FORTRAN)
+      set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR_FORTRAN "${PACKAGE_PREFIX_DIR}/include/static")
+    endif ()
+  endif ()
+endforeach ()
+foreach (libtype IN LISTS ${HDF5_PACKAGE_NAME}_LIB_TYPE)
+  foreach (comp IN LISTS ${HDF5_PACKAGE_NAME}_FIND_COMPONENTS)
+    set (hdf5_comp2)
+    if (${comp} STREQUAL "C")
+      set (hdf5_comp "hdf5")
+    elseif (${comp} STREQUAL "CXX")
+      set (hdf5_comp "hdf5_cpp")
+    elseif (${comp} STREQUAL "HL")
+      set (hdf5_comp "hdf5_hl")
+    elseif (${comp} STREQUAL "CXX_HL")
+      set (hdf5_comp "hdf5_hl_cpp")
+    elseif (${comp} STREQUAL "Java")
+      set (hdf5_comp "hdf5_java")
+    elseif (${comp} STREQUAL "Tools")
+      set (hdf5_comp "hdf5_tools")
+    elseif (${comp} STREQUAL "Fortran")
+      set (hdf5_comp2 "hdf5_f90cstub")
+      set (hdf5_comp "hdf5_fortran")
+    elseif (${comp} STREQUAL "Fortran_HL")
+      set (hdf5_comp2 "hdf5_hl_f90cstub")
+      set (hdf5_comp "hdf5_hl_fortran")
+    endif ()
+    list (FIND ${HDF5_PACKAGE_NAME}_EXPORT_LIBRARIES "${hdf5_comp}-${libtype}" HAVE_COMP)
+    if (${HAVE_COMP} LESS 0)
+      set (${HDF5_PACKAGE_NAME}_${libtype}_${comp}_FOUND 0)
+    else ()
+      if (hdf5_comp2)
+        list (FIND ${HDF5_PACKAGE_NAME}_EXPORT_LIBRARIES "${hdf5_comp2}-${libtype}" HAVE_COMP2)
+        if (${HAVE_COMP2} LESS 0)
+          set (${HDF5_PACKAGE_NAME}_${libtype}_${comp}_FOUND 0)
+        else ()
+          set (${HDF5_PACKAGE_NAME}_${libtype}_${comp}_FOUND 1)
+          string(TOUPPER ${HDF5_PACKAGE_NAME}_${comp}_${libtype}_LIBRARY COMP_LIBRARY)
+          set (${COMP_LIBRARY} ${${COMP_LIBRARY}} hdf5::${hdf5_comp2}-${libtype} hdf5::${hdf5_comp}-${libtype})
+        endif ()
+      else ()
+        set (${HDF5_PACKAGE_NAME}_${libtype}_${comp}_FOUND 1)
+        string(TOUPPER ${HDF5_PACKAGE_NAME}_${comp}_${libtype}_LIBRARY COMP_LIBRARY)
+        set (${COMP_LIBRARY} ${${COMP_LIBRARY}} hdf5::${hdf5_comp}-${libtype})
+      endif ()
+    endif ()
+  endforeach ()
+endforeach ()
+
+foreach (libtype IN LISTS ${HDF5_PACKAGE_NAME}_LIB_TYPE)
+  check_required_components(${HDF5_PACKAGE_NAME}_${libtype})
+endforeach ()
diff --git a/install/share/cmake/hdf5-targets-release.cmake b/install/share/cmake/hdf5-targets-release.cmake
new file mode 100644
index 0000000000..89f2b789c0
--- /dev/null
+++ b/install/share/cmake/hdf5-targets-release.cmake
@@ -0,0 +1,307 @@
+#----------------------------------------------------------------
+# Generated CMake target import file for configuration "Release".
+#----------------------------------------------------------------
+
+# Commands may need to know the format version.
+set(CMAKE_IMPORT_FILE_VERSION 1)
+
+# Import target "hdf5::hdf5-static" for configuration "Release"
+set_property(TARGET hdf5::hdf5-static APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::hdf5-static PROPERTIES
+  IMPORTED_LINK_INTERFACE_LANGUAGES_RELEASE "C"
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5.a"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::hdf5-static )
+list(APPEND _cmake_import_check_files_for_hdf5::hdf5-static "${_IMPORT_PREFIX}/lib/libhdf5.a" )
+
+# Import target "hdf5::hdf5-shared" for configuration "Release"
+set_property(TARGET hdf5::hdf5-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::hdf5-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5.so.1.11.0"
+  IMPORTED_SONAME_RELEASE "libhdf5.so.1000.0.0"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::hdf5-shared )
+list(APPEND _cmake_import_check_files_for_hdf5::hdf5-shared "${_IMPORT_PREFIX}/lib/libhdf5.so.1.11.0" )
+
+# Import target "hdf5::hdf5_tools-static" for configuration "Release"
+set_property(TARGET hdf5::hdf5_tools-static APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::hdf5_tools-static PROPERTIES
+  IMPORTED_LINK_INTERFACE_LANGUAGES_RELEASE "C"
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5_tools.a"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::hdf5_tools-static )
+list(APPEND _cmake_import_check_files_for_hdf5::hdf5_tools-static "${_IMPORT_PREFIX}/lib/libhdf5_tools.a" )
+
+# Import target "hdf5::hdf5_tools-shared" for configuration "Release"
+set_property(TARGET hdf5::hdf5_tools-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::hdf5_tools-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5_tools.so.1.11.0"
+  IMPORTED_SONAME_RELEASE "libhdf5_tools.so.1000.0.0"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::hdf5_tools-shared )
+list(APPEND _cmake_import_check_files_for_hdf5::hdf5_tools-shared "${_IMPORT_PREFIX}/lib/libhdf5_tools.so.1.11.0" )
+
+# Import target "hdf5::h5diff" for configuration "Release"
+set_property(TARGET hdf5::h5diff APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5diff PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5diff"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5diff )
+list(APPEND _cmake_import_check_files_for_hdf5::h5diff "${_IMPORT_PREFIX}/bin/h5diff" )
+
+# Import target "hdf5::h5diff-shared" for configuration "Release"
+set_property(TARGET hdf5::h5diff-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5diff-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5diff-shared"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5diff-shared )
+list(APPEND _cmake_import_check_files_for_hdf5::h5diff-shared "${_IMPORT_PREFIX}/bin/h5diff-shared" )
+
+# Import target "hdf5::h5ls" for configuration "Release"
+set_property(TARGET hdf5::h5ls APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5ls PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5ls"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5ls )
+list(APPEND _cmake_import_check_files_for_hdf5::h5ls "${_IMPORT_PREFIX}/bin/h5ls" )
+
+# Import target "hdf5::h5ls-shared" for configuration "Release"
+set_property(TARGET hdf5::h5ls-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5ls-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5ls-shared"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5ls-shared )
+list(APPEND _cmake_import_check_files_for_hdf5::h5ls-shared "${_IMPORT_PREFIX}/bin/h5ls-shared" )
+
+# Import target "hdf5::h5debug" for configuration "Release"
+set_property(TARGET hdf5::h5debug APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5debug PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5debug"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5debug )
+list(APPEND _cmake_import_check_files_for_hdf5::h5debug "${_IMPORT_PREFIX}/bin/h5debug" )
+
+# Import target "hdf5::h5repart" for configuration "Release"
+set_property(TARGET hdf5::h5repart APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5repart PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5repart"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5repart )
+list(APPEND _cmake_import_check_files_for_hdf5::h5repart "${_IMPORT_PREFIX}/bin/h5repart" )
+
+# Import target "hdf5::h5mkgrp" for configuration "Release"
+set_property(TARGET hdf5::h5mkgrp APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5mkgrp PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5mkgrp"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5mkgrp )
+list(APPEND _cmake_import_check_files_for_hdf5::h5mkgrp "${_IMPORT_PREFIX}/bin/h5mkgrp" )
+
+# Import target "hdf5::h5import" for configuration "Release"
+set_property(TARGET hdf5::h5import APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5import PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5import"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5import )
+list(APPEND _cmake_import_check_files_for_hdf5::h5import "${_IMPORT_PREFIX}/bin/h5import" )
+
+# Import target "hdf5::h5repack" for configuration "Release"
+set_property(TARGET hdf5::h5repack APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5repack PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5repack"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5repack )
+list(APPEND _cmake_import_check_files_for_hdf5::h5repack "${_IMPORT_PREFIX}/bin/h5repack" )
+
+# Import target "hdf5::h5repack-shared" for configuration "Release"
+set_property(TARGET hdf5::h5repack-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5repack-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5repack-shared"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5repack-shared )
+list(APPEND _cmake_import_check_files_for_hdf5::h5repack-shared "${_IMPORT_PREFIX}/bin/h5repack-shared" )
+
+# Import target "hdf5::h5jam" for configuration "Release"
+set_property(TARGET hdf5::h5jam APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5jam PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5jam"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5jam )
+list(APPEND _cmake_import_check_files_for_hdf5::h5jam "${_IMPORT_PREFIX}/bin/h5jam" )
+
+# Import target "hdf5::h5unjam" for configuration "Release"
+set_property(TARGET hdf5::h5unjam APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5unjam PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5unjam"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5unjam )
+list(APPEND _cmake_import_check_files_for_hdf5::h5unjam "${_IMPORT_PREFIX}/bin/h5unjam" )
+
+# Import target "hdf5::h5copy" for configuration "Release"
+set_property(TARGET hdf5::h5copy APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5copy PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5copy"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5copy )
+list(APPEND _cmake_import_check_files_for_hdf5::h5copy "${_IMPORT_PREFIX}/bin/h5copy" )
+
+# Import target "hdf5::h5copy-shared" for configuration "Release"
+set_property(TARGET hdf5::h5copy-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5copy-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5copy-shared"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5copy-shared )
+list(APPEND _cmake_import_check_files_for_hdf5::h5copy-shared "${_IMPORT_PREFIX}/bin/h5copy-shared" )
+
+# Import target "hdf5::h5stat" for configuration "Release"
+set_property(TARGET hdf5::h5stat APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5stat PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5stat"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5stat )
+list(APPEND _cmake_import_check_files_for_hdf5::h5stat "${_IMPORT_PREFIX}/bin/h5stat" )
+
+# Import target "hdf5::h5stat-shared" for configuration "Release"
+set_property(TARGET hdf5::h5stat-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5stat-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5stat-shared"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5stat-shared )
+list(APPEND _cmake_import_check_files_for_hdf5::h5stat-shared "${_IMPORT_PREFIX}/bin/h5stat-shared" )
+
+# Import target "hdf5::h5dump" for configuration "Release"
+set_property(TARGET hdf5::h5dump APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5dump PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5dump"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5dump )
+list(APPEND _cmake_import_check_files_for_hdf5::h5dump "${_IMPORT_PREFIX}/bin/h5dump" )
+
+# Import target "hdf5::h5dump-shared" for configuration "Release"
+set_property(TARGET hdf5::h5dump-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5dump-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5dump-shared"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5dump-shared )
+list(APPEND _cmake_import_check_files_for_hdf5::h5dump-shared "${_IMPORT_PREFIX}/bin/h5dump-shared" )
+
+# Import target "hdf5::h5format_convert" for configuration "Release"
+set_property(TARGET hdf5::h5format_convert APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5format_convert PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5format_convert"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5format_convert )
+list(APPEND _cmake_import_check_files_for_hdf5::h5format_convert "${_IMPORT_PREFIX}/bin/h5format_convert" )
+
+# Import target "hdf5::hdf5_hl-static" for configuration "Release"
+set_property(TARGET hdf5::hdf5_hl-static APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::hdf5_hl-static PROPERTIES
+  IMPORTED_LINK_INTERFACE_LANGUAGES_RELEASE "C"
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5_hl.a"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::hdf5_hl-static )
+list(APPEND _cmake_import_check_files_for_hdf5::hdf5_hl-static "${_IMPORT_PREFIX}/lib/libhdf5_hl.a" )
+
+# Import target "hdf5::hdf5_hl-shared" for configuration "Release"
+set_property(TARGET hdf5::hdf5_hl-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::hdf5_hl-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5_hl.so.1.11.0"
+  IMPORTED_SONAME_RELEASE "libhdf5_hl.so.1000.0.0"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::hdf5_hl-shared )
+list(APPEND _cmake_import_check_files_for_hdf5::hdf5_hl-shared "${_IMPORT_PREFIX}/lib/libhdf5_hl.so.1.11.0" )
+
+# Import target "hdf5::gif2h5" for configuration "Release"
+set_property(TARGET hdf5::gif2h5 APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::gif2h5 PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/gif2h5"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::gif2h5 )
+list(APPEND _cmake_import_check_files_for_hdf5::gif2h5 "${_IMPORT_PREFIX}/bin/gif2h5" )
+
+# Import target "hdf5::h52gif" for configuration "Release"
+set_property(TARGET hdf5::h52gif APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h52gif PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h52gif"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h52gif )
+list(APPEND _cmake_import_check_files_for_hdf5::h52gif "${_IMPORT_PREFIX}/bin/h52gif" )
+
+# Import target "hdf5::h5watch" for configuration "Release"
+set_property(TARGET hdf5::h5watch APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::h5watch PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5watch"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::h5watch )
+list(APPEND _cmake_import_check_files_for_hdf5::h5watch "${_IMPORT_PREFIX}/bin/h5watch" )
+
+# Import target "hdf5::hdf5_cpp-static" for configuration "Release"
+set_property(TARGET hdf5::hdf5_cpp-static APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::hdf5_cpp-static PROPERTIES
+  IMPORTED_LINK_INTERFACE_LANGUAGES_RELEASE "CXX"
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5_cpp.a"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::hdf5_cpp-static )
+list(APPEND _cmake_import_check_files_for_hdf5::hdf5_cpp-static "${_IMPORT_PREFIX}/lib/libhdf5_cpp.a" )
+
+# Import target "hdf5::hdf5_cpp-shared" for configuration "Release"
+set_property(TARGET hdf5::hdf5_cpp-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::hdf5_cpp-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5_cpp.so.1.11.0"
+  IMPORTED_SONAME_RELEASE "libhdf5_cpp.so.1000.0.0"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::hdf5_cpp-shared )
+list(APPEND _cmake_import_check_files_for_hdf5::hdf5_cpp-shared "${_IMPORT_PREFIX}/lib/libhdf5_cpp.so.1.11.0" )
+
+# Import target "hdf5::hdf5_hl_cpp-static" for configuration "Release"
+set_property(TARGET hdf5::hdf5_hl_cpp-static APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::hdf5_hl_cpp-static PROPERTIES
+  IMPORTED_LINK_INTERFACE_LANGUAGES_RELEASE "CXX"
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5_hl_cpp.a"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::hdf5_hl_cpp-static )
+list(APPEND _cmake_import_check_files_for_hdf5::hdf5_hl_cpp-static "${_IMPORT_PREFIX}/lib/libhdf5_hl_cpp.a" )
+
+# Import target "hdf5::hdf5_hl_cpp-shared" for configuration "Release"
+set_property(TARGET hdf5::hdf5_hl_cpp-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5::hdf5_hl_cpp-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5_hl_cpp.so.1.11.0"
+  IMPORTED_SONAME_RELEASE "libhdf5_hl_cpp.so.1000.0.0"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5::hdf5_hl_cpp-shared )
+list(APPEND _cmake_import_check_files_for_hdf5::hdf5_hl_cpp-shared "${_IMPORT_PREFIX}/lib/libhdf5_hl_cpp.so.1.11.0" )
+
+# Commands beyond this point should not need to know the version.
+set(CMAKE_IMPORT_FILE_VERSION)
diff --git a/install/share/cmake/hdf5-targets.cmake b/install/share/cmake/hdf5-targets.cmake
new file mode 100644
index 0000000000..4c5f0090d5
--- /dev/null
+++ b/install/share/cmake/hdf5-targets.cmake
@@ -0,0 +1,249 @@
+# Generated by CMake
+
+if("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}" LESS 2.8)
+   message(FATAL_ERROR "CMake >= 2.8.0 required")
+endif()
+if(CMAKE_VERSION VERSION_LESS "2.8.3")
+   message(FATAL_ERROR "CMake >= 2.8.3 required")
+endif()
+cmake_policy(PUSH)
+cmake_policy(VERSION 2.8.3...3.26)
+#----------------------------------------------------------------
+# Generated CMake target import file.
+#----------------------------------------------------------------
+
+# Commands may need to know the format version.
+set(CMAKE_IMPORT_FILE_VERSION 1)
+
+# Protect against multiple inclusion, which would fail when already imported targets are added once more.
+set(_cmake_targets_defined "")
+set(_cmake_targets_not_defined "")
+set(_cmake_expected_targets "")
+foreach(_cmake_expected_target IN ITEMS hdf5::hdf5-static hdf5::hdf5-shared hdf5::hdf5_tools-static hdf5::hdf5_tools-shared hdf5::h5diff hdf5::h5diff-shared hdf5::h5ls hdf5::h5ls-shared hdf5::h5debug hdf5::h5repart hdf5::h5mkgrp hdf5::h5import hdf5::h5repack hdf5::h5repack-shared hdf5::h5jam hdf5::h5unjam hdf5::h5copy hdf5::h5copy-shared hdf5::h5stat hdf5::h5stat-shared hdf5::h5dump hdf5::h5dump-shared hdf5::h5format_convert hdf5::hdf5_hl-static hdf5::hdf5_hl-shared hdf5::gif2h5 hdf5::h52gif hdf5::h5watch hdf5::hdf5_cpp-static hdf5::hdf5_cpp-shared hdf5::hdf5_hl_cpp-static hdf5::hdf5_hl_cpp-shared)
+  list(APPEND _cmake_expected_targets "${_cmake_expected_target}")
+  if(TARGET "${_cmake_expected_target}")
+    list(APPEND _cmake_targets_defined "${_cmake_expected_target}")
+  else()
+    list(APPEND _cmake_targets_not_defined "${_cmake_expected_target}")
+  endif()
+endforeach()
+unset(_cmake_expected_target)
+if(_cmake_targets_defined STREQUAL _cmake_expected_targets)
+  unset(_cmake_targets_defined)
+  unset(_cmake_targets_not_defined)
+  unset(_cmake_expected_targets)
+  unset(CMAKE_IMPORT_FILE_VERSION)
+  cmake_policy(POP)
+  return()
+endif()
+if(NOT _cmake_targets_defined STREQUAL "")
+  string(REPLACE ";" ", " _cmake_targets_defined_text "${_cmake_targets_defined}")
+  string(REPLACE ";" ", " _cmake_targets_not_defined_text "${_cmake_targets_not_defined}")
+  message(FATAL_ERROR "Some (but not all) targets in this export set were already defined.\nTargets Defined: ${_cmake_targets_defined_text}\nTargets not yet defined: ${_cmake_targets_not_defined_text}\n")
+endif()
+unset(_cmake_targets_defined)
+unset(_cmake_targets_not_defined)
+unset(_cmake_expected_targets)
+
+
+# Compute the installation prefix relative to this file.
+get_filename_component(_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)
+get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
+get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
+if(_IMPORT_PREFIX STREQUAL "/")
+  set(_IMPORT_PREFIX "")
+endif()
+
+# Create imported target hdf5::hdf5-static
+add_library(hdf5::hdf5-static STATIC IMPORTED)
+
+set_target_properties(hdf5::hdf5-static PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "m;dl;dl"
+)
+
+# Create imported target hdf5::hdf5-shared
+add_library(hdf5::hdf5-shared SHARED IMPORTED)
+
+set_target_properties(hdf5::hdf5-shared PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "H5_BUILT_AS_DYNAMIC_LIB=1"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "m;dl;dl"
+)
+
+# Create imported target hdf5::hdf5_tools-static
+add_library(hdf5::hdf5_tools-static STATIC IMPORTED)
+
+set_target_properties(hdf5::hdf5_tools-static PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5-static"
+)
+
+# Create imported target hdf5::hdf5_tools-shared
+add_library(hdf5::hdf5_tools-shared SHARED IMPORTED)
+
+set_target_properties(hdf5::hdf5_tools-shared PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "H5_BUILT_AS_DYNAMIC_LIB=1"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5-shared"
+)
+
+# Create imported target hdf5::h5diff
+add_executable(hdf5::h5diff IMPORTED)
+
+# Create imported target hdf5::h5diff-shared
+add_executable(hdf5::h5diff-shared IMPORTED)
+
+# Create imported target hdf5::h5ls
+add_executable(hdf5::h5ls IMPORTED)
+
+# Create imported target hdf5::h5ls-shared
+add_executable(hdf5::h5ls-shared IMPORTED)
+
+# Create imported target hdf5::h5debug
+add_executable(hdf5::h5debug IMPORTED)
+
+# Create imported target hdf5::h5repart
+add_executable(hdf5::h5repart IMPORTED)
+
+# Create imported target hdf5::h5mkgrp
+add_executable(hdf5::h5mkgrp IMPORTED)
+
+# Create imported target hdf5::h5import
+add_executable(hdf5::h5import IMPORTED)
+
+# Create imported target hdf5::h5repack
+add_executable(hdf5::h5repack IMPORTED)
+
+# Create imported target hdf5::h5repack-shared
+add_executable(hdf5::h5repack-shared IMPORTED)
+
+# Create imported target hdf5::h5jam
+add_executable(hdf5::h5jam IMPORTED)
+
+# Create imported target hdf5::h5unjam
+add_executable(hdf5::h5unjam IMPORTED)
+
+# Create imported target hdf5::h5copy
+add_executable(hdf5::h5copy IMPORTED)
+
+# Create imported target hdf5::h5copy-shared
+add_executable(hdf5::h5copy-shared IMPORTED)
+
+# Create imported target hdf5::h5stat
+add_executable(hdf5::h5stat IMPORTED)
+
+# Create imported target hdf5::h5stat-shared
+add_executable(hdf5::h5stat-shared IMPORTED)
+
+# Create imported target hdf5::h5dump
+add_executable(hdf5::h5dump IMPORTED)
+
+# Create imported target hdf5::h5dump-shared
+add_executable(hdf5::h5dump-shared IMPORTED)
+
+# Create imported target hdf5::h5format_convert
+add_executable(hdf5::h5format_convert IMPORTED)
+
+# Create imported target hdf5::hdf5_hl-static
+add_library(hdf5::hdf5_hl-static STATIC IMPORTED)
+
+set_target_properties(hdf5::hdf5_hl-static PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5-static"
+)
+
+# Create imported target hdf5::hdf5_hl-shared
+add_library(hdf5::hdf5_hl-shared SHARED IMPORTED)
+
+set_target_properties(hdf5::hdf5_hl-shared PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "H5_BUILT_AS_DYNAMIC_LIB=1"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5-shared"
+)
+
+# Create imported target hdf5::gif2h5
+add_executable(hdf5::gif2h5 IMPORTED)
+
+# Create imported target hdf5::h52gif
+add_executable(hdf5::h52gif IMPORTED)
+
+# Create imported target hdf5::h5watch
+add_executable(hdf5::h5watch IMPORTED)
+
+# Create imported target hdf5::hdf5_cpp-static
+add_library(hdf5::hdf5_cpp-static STATIC IMPORTED)
+
+set_target_properties(hdf5::hdf5_cpp-static PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5-static"
+)
+
+# Create imported target hdf5::hdf5_cpp-shared
+add_library(hdf5::hdf5_cpp-shared SHARED IMPORTED)
+
+set_target_properties(hdf5::hdf5_cpp-shared PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "H5_BUILT_AS_DYNAMIC_LIB=1"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5-shared"
+)
+
+# Create imported target hdf5::hdf5_hl_cpp-static
+add_library(hdf5::hdf5_hl_cpp-static STATIC IMPORTED)
+
+set_target_properties(hdf5::hdf5_hl_cpp-static PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5_hl-static;hdf5::hdf5-static"
+)
+
+# Create imported target hdf5::hdf5_hl_cpp-shared
+add_library(hdf5::hdf5_hl_cpp-shared SHARED IMPORTED)
+
+set_target_properties(hdf5::hdf5_hl_cpp-shared PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "H5_BUILT_AS_DYNAMIC_LIB=1"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5::hdf5_hl-shared;hdf5::hdf5-shared"
+)
+
+if(CMAKE_VERSION VERSION_LESS 2.8.12)
+  message(FATAL_ERROR "This file relies on consumers using CMake 2.8.12 or greater.")
+endif()
+
+# Load information for each installed configuration.
+file(GLOB _cmake_config_files "${CMAKE_CURRENT_LIST_DIR}/hdf5-targets-*.cmake")
+foreach(_cmake_config_file IN LISTS _cmake_config_files)
+  include("${_cmake_config_file}")
+endforeach()
+unset(_cmake_config_file)
+unset(_cmake_config_files)
+
+# Cleanup temporary variables.
+set(_IMPORT_PREFIX)
+
+# Loop over all imported files and verify that they actually exist
+foreach(_cmake_target IN LISTS _cmake_import_check_targets)
+  foreach(_cmake_file IN LISTS "_cmake_import_check_files_for_${_cmake_target}")
+    if(NOT EXISTS "${_cmake_file}")
+      message(FATAL_ERROR "The imported target \"${_cmake_target}\" references the file
+   \"${_cmake_file}\"
+but this file does not exist.  Possible reasons include:
+* The file was deleted, renamed, or moved to another location.
+* An install or uninstall procedure did not complete successfully.
+* The installation package was faulty and contained
+   \"${CMAKE_CURRENT_LIST_FILE}\"
+but not all the files it references.
+")
+    endif()
+  endforeach()
+  unset(_cmake_file)
+  unset("_cmake_import_check_files_for_${_cmake_target}")
+endforeach()
+unset(_cmake_target)
+unset(_cmake_import_check_targets)
+
+# This file does not depend on other imported targets which have
+# been exported from the same project but in a separate export set.
+
+# Commands beyond this point should not need to know the version.
+set(CMAKE_IMPORT_FILE_VERSION)
+cmake_policy(POP)
diff --git a/src/H5Gnode.c b/src/H5Gnode.c
index 20924ee2b6..6d09718837 100644
--- a/src/H5Gnode.c
+++ b/src/H5Gnode.c
@@ -461,7 +461,8 @@ H5G_node_cmp3(void *_lt_key, void *_udata, void *_rt_key)
     H5G_node_key_t	*rt_key = (H5G_node_key_t *) _rt_key;
     const char		*s;
     const char          *base;              /* Base of heap */
-    int                  ret_value = 0;       /* Return value */
+    int ret_value = 0; /* Return value */
+    size_t heap_size;
 
     FUNC_ENTER_NOAPI_NOINIT_NOERR
 
@@ -474,16 +475,25 @@ H5G_node_cmp3(void *_lt_key, void *_udata, void *_rt_key)
     base = (const char *)H5HL_offset_into(udata->heap, (size_t)0);
     HDassert(base);
 
+    heap_size = H5HL_get_dblk_size(udata->heap);
+
     /* left side */
+    if(lt_key->offset >= heap_size) {
+        /* Offset out of bounds, return error or handle gracefully */
+        FUNC_LEAVE_NOAPI(-1)
+    }
     s = base + lt_key->offset;
-    if(HDstrcmp(udata->name, s) <= 0)
-	ret_value = (-1);
-    else {
-        /* right side */
+    if(HDstrcmp(udata->name, s) <= 0) {
+        ret_value = (-1);
+    } else {
+        if(rt_key->offset >= heap_size) {
+            /* Offset out of bounds, return error or handle gracefully */
+            FUNC_LEAVE_NOAPI(-1)
+        }
         s = base + rt_key->offset;
         if(HDstrcmp(udata->name, s) > 0)
             ret_value = 1;
-    } /* end else */
+    }
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5G_node_cmp3() */
diff --git a/src/H5HL.c b/src/H5HL.c
index fa577c3b6b..18909c3614 100644
--- a/src/H5HL.c
+++ b/src/H5HL.c
@@ -1044,4 +1044,20 @@ CATCH
         H5E_THROW(H5E_CANTUNPROTECT, "unable to release local heap prefix");
 
 END_FUNC(PRIV) /* end H5HL_heapsize() */
-
+/*-------------------------------------------------------------------------
+ * Function:    H5HL_get_dblk_size
+ *
+ * Purpose:     Returns the size of the heap data block.
+ *
+ * Return:      Success:    Size of the heap data block.
+ *              Failure:    0 (if heap is NULL)
+ *
+ *-------------------------------------------------------------------------
+ */
+size_t H5HL_get_dblk_size(const H5HL_t *heap)
+{
+    if(heap)
+        return heap->dblk_size;
+    else
+        return 0;
+}
diff --git a/src/H5HLprivate.h b/src/H5HLprivate.h
index 054d396305..ec330616b8 100644
--- a/src/H5HLprivate.h
+++ b/src/H5HLprivate.h
@@ -67,7 +67,7 @@ H5_DLL H5HL_t *H5HL_protect(H5F_t *f, hid_t dxpl_id, haddr_t addr, unsigned flag
 H5_DLL herr_t H5HL_remove(H5F_t *f, hid_t dxpl_id, H5HL_t *heap, size_t offset,
     size_t size);
 H5_DLL herr_t H5HL_unprotect(H5HL_t *heap);
-
+H5_DLL size_t H5HL_get_dblk_size(const H5HL_t *heap);
 /* Debugging routines for dumping file structures */
 H5_DLL herr_t H5HL_debug(H5F_t *f, hid_t dxpl_id, haddr_t addr, FILE * stream, int indent,
     int fwidth);
