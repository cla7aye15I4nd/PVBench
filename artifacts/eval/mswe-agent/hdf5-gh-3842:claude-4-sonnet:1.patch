
diff --git a/.gitignore b/.gitignore
index cbaccb29d3..2067bd60aa 100644
--- a/.gitignore
+++ b/.gitignore
@@ -42,3 +42,14 @@ src/H5version.h
 
 /.classpath
 /CMakeUserPresets.json
+build/
+Build/
+bin/
+lib/
+*.o
+*.out
+*.obj
+*.exe
+*.dll
+*.so
+*.dylib
diff --git a/conversion_test.h5 b/conversion_test.h5
new file mode 100644
index 0000000000..be0074833b
Binary files /dev/null and b/conversion_test.h5 differ
diff --git a/install/cmake/hdf5-config-version.cmake b/install/cmake/hdf5-config-version.cmake
new file mode 100644
index 0000000000..1de56f387e
--- /dev/null
+++ b/install/cmake/hdf5-config-version.cmake
@@ -0,0 +1,85 @@
+# This is a basic version file for the Config-mode of find_package().
+# It is used by write_basic_package_version_file() as input file for configure_file()
+# to create a version-file which can be installed along a config.cmake file.
+#
+# The created file sets PACKAGE_VERSION_EXACT if the current version string and
+# the requested version string are exactly the same and it sets
+# PACKAGE_VERSION_COMPATIBLE if the current version is >= requested version,
+# but only if the requested major and minor versions are the same as the current
+# one.
+# The variable CVF_VERSION must be set before calling configure_file().
+
+
+set(PACKAGE_VERSION "1.15.0")
+
+if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)
+  set(PACKAGE_VERSION_COMPATIBLE FALSE)
+else()
+
+  if("1.15.0" MATCHES "^([0-9]+)\\.([0-9]+)")
+    set(CVF_VERSION_MAJOR "${CMAKE_MATCH_1}")
+    set(CVF_VERSION_MINOR "${CMAKE_MATCH_2}")
+
+    if(NOT CVF_VERSION_MAJOR VERSION_EQUAL 0)
+      string(REGEX REPLACE "^0+" "" CVF_VERSION_MAJOR "${CVF_VERSION_MAJOR}")
+    endif()
+    if(NOT CVF_VERSION_MINOR VERSION_EQUAL 0)
+      string(REGEX REPLACE "^0+" "" CVF_VERSION_MINOR "${CVF_VERSION_MINOR}")
+    endif()
+  else()
+    set(CVF_VERSION_MAJOR "1.15.0")
+    set(CVF_VERSION_MINOR "")
+  endif()
+
+  if(PACKAGE_FIND_VERSION_RANGE)
+    # both endpoints of the range must have the expected major and minor versions
+    math (EXPR CVF_VERSION_MINOR_NEXT "${CVF_VERSION_MINOR} + 1")
+    if (NOT (PACKAGE_FIND_VERSION_MIN_MAJOR STREQUAL CVF_VERSION_MAJOR
+          AND PACKAGE_FIND_VERSION_MIN_MINOR STREQUAL CVF_VERSION_MINOR)
+        OR ((PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "INCLUDE"
+            AND NOT (PACKAGE_FIND_VERSION_MAX_MAJOR STREQUAL CVF_VERSION_MAJOR
+              AND PACKAGE_FIND_VERSION_MAX_MINOR STREQUAL CVF_VERSION_MINOR))
+          OR (PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "EXCLUDE"
+            AND NOT PACKAGE_FIND_VERSION_MAX VERSION_LESS_EQUAL ${CVF_VERSION_MAJOR}.${CVF_VERSION_MINOR_NEXT})))
+      set(PACKAGE_VERSION_COMPATIBLE FALSE)
+    elseif(PACKAGE_FIND_VERSION_MIN_MAJOR STREQUAL CVF_VERSION_MAJOR
+        AND PACKAGE_FIND_VERSION_MIN_MINOR STREQUAL CVF_VERSION_MINOR
+        AND ((PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "INCLUDE" AND PACKAGE_VERSION VERSION_LESS_EQUAL PACKAGE_FIND_VERSION_MAX)
+        OR (PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "EXCLUDE" AND PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION_MAX)))
+      set(PACKAGE_VERSION_COMPATIBLE TRUE)
+    else()
+      set(PACKAGE_VERSION_COMPATIBLE FALSE)
+    endif()
+  else()
+    if(NOT PACKAGE_FIND_VERSION_MAJOR VERSION_EQUAL 0)
+      string(REGEX REPLACE "^0+" "" PACKAGE_FIND_VERSION_MAJOR "${PACKAGE_FIND_VERSION_MAJOR}")
+    endif()
+    if(NOT PACKAGE_FIND_VERSION_MINOR VERSION_EQUAL 0)
+      string(REGEX REPLACE "^0+" "" PACKAGE_FIND_VERSION_MINOR "${PACKAGE_FIND_VERSION_MINOR}")
+    endif()
+
+    if((PACKAGE_FIND_VERSION_MAJOR STREQUAL CVF_VERSION_MAJOR) AND
+        (PACKAGE_FIND_VERSION_MINOR STREQUAL CVF_VERSION_MINOR))
+      set(PACKAGE_VERSION_COMPATIBLE TRUE)
+    else()
+      set(PACKAGE_VERSION_COMPATIBLE FALSE)
+    endif()
+
+    if(PACKAGE_FIND_VERSION STREQUAL PACKAGE_VERSION)
+      set(PACKAGE_VERSION_EXACT TRUE)
+    endif()
+  endif()
+endif()
+
+
+# if the installed or the using project don't have CMAKE_SIZEOF_VOID_P set, ignore it:
+if("${CMAKE_SIZEOF_VOID_P}" STREQUAL "" OR "8" STREQUAL "")
+  return()
+endif()
+
+# check that the installed version has the same 32/64bit-ness as the one which is currently searching:
+if(NOT CMAKE_SIZEOF_VOID_P STREQUAL "8")
+  math(EXPR installedBits "8 * 8")
+  set(PACKAGE_VERSION "${PACKAGE_VERSION} (${installedBits}bit)")
+  set(PACKAGE_VERSION_UNSUITABLE TRUE)
+endif()
diff --git a/install/cmake/hdf5-config.cmake b/install/cmake/hdf5-config.cmake
new file mode 100644
index 0000000000..bcea7fdb37
--- /dev/null
+++ b/install/cmake/hdf5-config.cmake
@@ -0,0 +1,259 @@
+#
+# Copyright by The HDF Group.
+# All rights reserved.
+#
+# This file is part of HDF5.  The full HDF5 copyright notice, including
+# terms governing use, modification, and redistribution, is contained in
+# the COPYING file, which can be found at the root of the source code
+# distribution tree, or in https://www.hdfgroup.org/licenses.
+# If you do not have access to either file, you may request a copy from
+# help@hdfgroup.org.
+#
+#-----------------------------------------------------------------------------
+# HDF5 Config file for compiling against hdf5 build/install directory
+#-----------------------------------------------------------------------------
+
+####### Expanded from @PACKAGE_INIT@ by configure_package_config_file() #######
+####### Any changes to this file will be overwritten by the next CMake run ####
+####### The input file was hdf5-config.cmake.in                            ########
+
+get_filename_component(PACKAGE_PREFIX_DIR "${CMAKE_CURRENT_LIST_DIR}/../" ABSOLUTE)
+
+macro(set_and_check _var _file)
+  set(${_var} "${_file}")
+  if(NOT EXISTS "${_file}")
+    message(FATAL_ERROR "File or directory ${_file} referenced by variable ${_var} does not exist !")
+  endif()
+endmacro()
+
+macro(check_required_components _NAME)
+  foreach(comp ${${_NAME}_FIND_COMPONENTS})
+    if(NOT ${_NAME}_${comp}_FOUND)
+      if(${_NAME}_FIND_REQUIRED_${comp})
+        set(${_NAME}_FOUND FALSE)
+      endif()
+    endif()
+  endforeach()
+endmacro()
+
+####################################################################################
+
+string(TOUPPER hdf5 HDF5_PACKAGE_NAME)
+
+set (${HDF5_PACKAGE_NAME}_VALID_COMPONENTS
+    static
+    shared
+    C
+    CXX
+    Fortran
+    HL
+    CXX_HL
+    Fortran_HL
+    Java
+    Tools
+)
+
+#-----------------------------------------------------------------------------
+# User Options
+#-----------------------------------------------------------------------------
+# Languages:
+set (${HDF5_PACKAGE_NAME}_BUILD_FORTRAN        OFF)
+set (${HDF5_PACKAGE_NAME}_BUILD_CPP_LIB        OFF)
+set (${HDF5_PACKAGE_NAME}_BUILD_JAVA           OFF)
+set (${HDF5_PACKAGE_NAME}_INSTALL_MOD_FORTRAN "")
+#-----------------------------------------------------------------------------
+# Features:
+set (${HDF5_PACKAGE_NAME}_ENABLE_PARALLEL       OFF)
+set (${HDF5_PACKAGE_NAME}_PARALLEL_FILTERED_WRITES )
+set (${HDF5_PACKAGE_NAME}_LARGE_PARALLEL_IO     )
+set (${HDF5_PACKAGE_NAME}_BUILD_HL_LIB          ON)
+set (${HDF5_PACKAGE_NAME}_BUILD_DIMENSION_SCALES_WITH_NEW_REF )
+set (${HDF5_PACKAGE_NAME}_BUILD_TOOLS           ON)
+set (${HDF5_PACKAGE_NAME}_BUILD_HL_GIF_TOOLS    OFF)
+set (${HDF5_PACKAGE_NAME}_ENABLE_THREADSAFE     OFF)
+set (${HDF5_PACKAGE_NAME}_DEFAULT_API_VERSION  "v116")
+set (${HDF5_PACKAGE_NAME}_ENABLE_DEPRECATED_SYMBOLS ON)
+set (${HDF5_PACKAGE_NAME}_ENABLE_Z_LIB_SUPPORT  ON)
+set (${HDF5_PACKAGE_NAME}_ENABLE_SZIP_SUPPORT   OFF)
+set (${HDF5_PACKAGE_NAME}_ENABLE_SZIP_ENCODING  ON)
+set (${HDF5_PACKAGE_NAME}_ENABLE_MAP_API        )
+set (${HDF5_PACKAGE_NAME}_ENABLE_DIRECT_VFD     )
+set (${HDF5_PACKAGE_NAME}_ENABLE_MIRROR_VFD     )
+set (${HDF5_PACKAGE_NAME}_ENABLE_SUBFILING_VFD  OFF)
+set (${HDF5_PACKAGE_NAME}_ENABLE_ROS3_VFD       OFF)
+set (${HDF5_PACKAGE_NAME}_ENABLE_HDFS_VFD       )
+set (${HDF5_PACKAGE_NAME}_ENABLE_PLUGIN_SUPPORT OFF)
+#-----------------------------------------------------------------------------
+set (${HDF5_PACKAGE_NAME}_BUILD_SHARED_LIBS    YES)
+set (${HDF5_PACKAGE_NAME}_BUILD_STATIC_LIBS    YES)
+set (${HDF5_PACKAGE_NAME}_PACKAGE_EXTLIBS      OFF)
+set (${HDF5_PACKAGE_NAME}_EXPORT_LIBRARIES     hdf5-static;hdf5-shared;hdf5_tools-static;hdf5_tools-shared;hdf5_hl-static;hdf5_hl-shared)
+set (${HDF5_PACKAGE_NAME}_ARCHITECTURE        "")
+set (${HDF5_PACKAGE_NAME}_TOOLSET             "")
+
+#-----------------------------------------------------------------------------
+# Dependencies
+#-----------------------------------------------------------------------------
+if (${HDF5_PACKAGE_NAME}_ENABLE_PARALLEL)
+  set (${HDF5_PACKAGE_NAME}_MPI_C_INCLUDE_PATH "")
+  set (${HDF5_PACKAGE_NAME}_MPI_C_LIBRARIES    "")
+  if (${HDF5_PACKAGE_NAME}_BUILD_FORTRAN)
+    set (${HDF5_PACKAGE_NAME}_MPI_Fortran_INCLUDE_PATH "")
+    set (${HDF5_PACKAGE_NAME}_MPI_Fortran_LIBRARIES    "")
+  endif ()
+
+  find_package(MPI QUIET REQUIRED)
+endif ()
+
+if (${HDF5_PACKAGE_NAME}_ENABLE_THREADSAFE OR ${HDF5_PACKAGE_NAME}_ENABLE_SUBFILING_VFD)
+  set(THREADS_PREFER_PTHREAD_FLAG ON)
+  find_package(Threads QUIET REQUIRED)
+endif ()
+
+if (${HDF5_PACKAGE_NAME}_BUILD_JAVA)
+  set (${HDF5_PACKAGE_NAME}_JAVA_INCLUDE_DIRS
+      ${PACKAGE_PREFIX_DIR}/lib/jarhdf5-1.15.0.jar
+      ${PACKAGE_PREFIX_DIR}/lib/slf4j-api-2.0.6.jar
+      ${PACKAGE_PREFIX_DIR}/lib/slf4j-nop-2.0.6.jar
+  )
+  set (${HDF5_PACKAGE_NAME}_JAVA_LIBRARY "${PACKAGE_PREFIX_DIR}/lib")
+  set (${HDF5_PACKAGE_NAME}_JAVA_LIBRARIES "${${HDF5_PACKAGE_NAME}_JAVA_LIBRARY}")
+endif ()
+
+#-----------------------------------------------------------------------------
+# Directories
+#-----------------------------------------------------------------------------
+set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR "${PACKAGE_PREFIX_DIR}/include" "${${HDF5_PACKAGE_NAME}_MPI_C_INCLUDE_DIRS}")
+
+set (${HDF5_PACKAGE_NAME}_SHARE_DIR "${PACKAGE_PREFIX_DIR}/cmake")
+set_and_check (${HDF5_PACKAGE_NAME}_BUILD_DIR "${PACKAGE_PREFIX_DIR}")
+
+if (${HDF5_PACKAGE_NAME}_BUILD_CPP_LIB)
+  set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR_CPP "${PACKAGE_PREFIX_DIR}/include")
+endif ()
+
+if (${HDF5_PACKAGE_NAME}_BUILD_HL_LIB)
+  set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR_HL "${PACKAGE_PREFIX_DIR}/include")
+endif ()
+
+if (${HDF5_PACKAGE_NAME}_BUILD_HL_LIB AND ${HDF5_PACKAGE_NAME}_BUILD_CPP_LIB)
+  set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR_HL_CPP "${PACKAGE_PREFIX_DIR}/include")
+endif ()
+
+if (${HDF5_PACKAGE_NAME}_BUILD_TOOLS)
+  set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR_TOOLS "${PACKAGE_PREFIX_DIR}/include")
+  set_and_check (${HDF5_PACKAGE_NAME}_TOOLS_DIR "${PACKAGE_PREFIX_DIR}/bin")
+endif ()
+
+#-----------------------------------------------------------------------------
+# Version Strings
+#-----------------------------------------------------------------------------
+set (${HDF5_PACKAGE_NAME}_VERSION_STRING 1.15.0)
+set (${HDF5_PACKAGE_NAME}_VERSION_MAJOR  1.15)
+set (${HDF5_PACKAGE_NAME}_VERSION_MINOR  0)
+
+#-----------------------------------------------------------------------------
+# Don't include targets if this file is being picked up by another
+# project which has already built hdf5 as a subproject
+#-----------------------------------------------------------------------------
+if (NOT TARGET "hdf5")
+  if (${HDF5_PACKAGE_NAME}_ENABLE_Z_LIB_SUPPORT AND ${HDF5_PACKAGE_NAME}_PACKAGE_EXTLIBS)
+    include (${PACKAGE_PREFIX_DIR}/cmake/-targets.cmake)
+  endif ()
+  if (${HDF5_PACKAGE_NAME}_ENABLE_SZIP_SUPPORT AND ${HDF5_PACKAGE_NAME}_PACKAGE_EXTLIBS)
+    include (${PACKAGE_PREFIX_DIR}/cmake/-targets.cmake)
+  endif ()
+  include (${PACKAGE_PREFIX_DIR}/cmake/hdf5-targets.cmake)
+endif ()
+
+# Handle default component(static) :
+if (NOT ${HDF5_PACKAGE_NAME}_FIND_COMPONENTS)
+  if (${HDF5_PACKAGE_NAME}_BUILD_STATIC_LIBS)
+    set (${HDF5_PACKAGE_NAME}_LIB_TYPE)
+    set (${HDF5_PACKAGE_NAME}_FIND_COMPONENTS C HL static)
+    set (${HDF5_PACKAGE_NAME}_FIND_REQUIRED_static_C true)
+  else ()
+    set (${HDF5_PACKAGE_NAME}_LIB_TYPE)
+    set (${HDF5_PACKAGE_NAME}_FIND_COMPONENTS C HL shared)
+    set (${HDF5_PACKAGE_NAME}_FIND_REQUIRED_shared_C true)
+  endif ()
+endif ()
+
+# Handle requested components:
+list (REMOVE_DUPLICATES ${HDF5_PACKAGE_NAME}_FIND_COMPONENTS)
+foreach (comp IN LISTS ${HDF5_PACKAGE_NAME}_FIND_COMPONENTS)
+  if (comp STREQUAL "shared")
+    list (REMOVE_ITEM ${HDF5_PACKAGE_NAME}_FIND_COMPONENTS ${comp})
+    set (${HDF5_PACKAGE_NAME}_LIB_TYPE ${${HDF5_PACKAGE_NAME}_LIB_TYPE} ${comp})
+
+    if (${HDF5_PACKAGE_NAME}_BUILD_FORTRAN AND ${HDF5_PACKAGE_NAME}_INSTALL_MOD_FORTRAN STREQUAL "SHARED")
+      set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR_FORTRAN "${PACKAGE_PREFIX_DIR}/include/shared")
+    endif ()
+  elseif (comp STREQUAL "static")
+    list (REMOVE_ITEM ${HDF5_PACKAGE_NAME}_FIND_COMPONENTS ${comp})
+    set (${HDF5_PACKAGE_NAME}_LIB_TYPE ${${HDF5_PACKAGE_NAME}_LIB_TYPE} ${comp})
+
+    if (${HDF5_PACKAGE_NAME}_BUILD_FORTRAN AND ${HDF5_PACKAGE_NAME}_INSTALL_MOD_FORTRAN STREQUAL "STATIC")
+      set (${HDF5_PACKAGE_NAME}_INCLUDE_DIR_FORTRAN "${PACKAGE_PREFIX_DIR}/include/static")
+    endif ()
+  endif ()
+endforeach ()
+foreach (libtype IN LISTS ${HDF5_PACKAGE_NAME}_LIB_TYPE)
+  foreach (comp IN LISTS ${HDF5_PACKAGE_NAME}_FIND_COMPONENTS)
+    set (hdf5_comp2)
+    if (comp STREQUAL "C")
+      set (hdf5_comp "hdf5")
+    elseif (comp STREQUAL "CXX")
+      set (hdf5_comp "hdf5_cpp")
+    elseif (comp STREQUAL "HL")
+      set (hdf5_comp "hdf5_hl")
+    elseif (comp STREQUAL "CXX_HL")
+      set (hdf5_comp "hdf5_hl_cpp")
+    elseif (comp STREQUAL "Java")
+      set (hdf5_comp "hdf5_java")
+    elseif (comp STREQUAL "Tools")
+      set (hdf5_comp "hdf5_tools")
+    elseif (comp STREQUAL "Fortran")
+      set (hdf5_comp2 "hdf5_f90cstub")
+      set (hdf5_comp "hdf5_fortran")
+    elseif (comp STREQUAL "Fortran_HL")
+      set (hdf5_comp2 "hdf5_hl_f90cstub")
+      set (hdf5_comp "hdf5_hl_fortran")
+    endif ()
+    if (comp STREQUAL "Java")
+      list (FIND ${HDF5_PACKAGE_NAME}_EXPORT_LIBRARIES "${hdf5_comp}" HAVE_COMP)
+    else ()
+      list (FIND ${HDF5_PACKAGE_NAME}_EXPORT_LIBRARIES "${hdf5_comp}-${libtype}" HAVE_COMP)
+    endif ()
+    if (${HAVE_COMP} LESS 0)
+      if (comp STREQUAL "Java")
+        set (${HDF5_PACKAGE_NAME}_${comp}_FOUND 0)
+      else ()
+        set (${HDF5_PACKAGE_NAME}_${libtype}_${comp}_FOUND 0)
+      endif ()
+    else ()
+      if (hdf5_comp2)
+        list (FIND ${HDF5_PACKAGE_NAME}_EXPORT_LIBRARIES "${hdf5_comp2}-${libtype}" HAVE_COMP2)
+        if (${HAVE_COMP2} LESS 0)
+          set (${HDF5_PACKAGE_NAME}_${libtype}_${comp}_FOUND 0)
+        else ()
+          set (${HDF5_PACKAGE_NAME}_${libtype}_${comp}_FOUND 1)
+          string(TOUPPER ${HDF5_PACKAGE_NAME}_${comp}_${libtype}_LIBRARY COMP_LIBRARY)
+          set (${COMP_LIBRARY} ${${COMP_LIBRARY}} ${hdf5_comp2}-${libtype} ${hdf5_comp}-${libtype})
+        endif ()
+      elseif (comp STREQUAL "Java")
+        set (${HDF5_PACKAGE_NAME}_${comp}_FOUND 1)
+        string(TOUPPER ${HDF5_PACKAGE_NAME}_${comp}_LIBRARY COMP_LIBRARY)
+        set (${COMP_LIBRARY} ${${COMP_LIBRARY}} ${hdf5_comp})
+      else ()
+        set (${HDF5_PACKAGE_NAME}_${libtype}_${comp}_FOUND 1)
+        string(TOUPPER ${HDF5_PACKAGE_NAME}_${comp}_${libtype}_LIBRARY COMP_LIBRARY)
+        set (${COMP_LIBRARY} ${${COMP_LIBRARY}} ${hdf5_comp}-${libtype})
+      endif ()
+    endif ()
+  endforeach ()
+endforeach ()
+
+foreach (libtype IN LISTS ${HDF5_PACKAGE_NAME}_LIB_TYPE)
+  check_required_components(${HDF5_PACKAGE_NAME}_${libtype})
+endforeach ()
diff --git a/install/cmake/hdf5-targets-release.cmake b/install/cmake/hdf5-targets-release.cmake
new file mode 100644
index 0000000000..39d1ead39f
--- /dev/null
+++ b/install/cmake/hdf5-targets-release.cmake
@@ -0,0 +1,384 @@
+#----------------------------------------------------------------
+# Generated CMake target import file for configuration "Release".
+#----------------------------------------------------------------
+
+# Commands may need to know the format version.
+set(CMAKE_IMPORT_FILE_VERSION 1)
+
+# Import target "hdf5-static" for configuration "Release"
+set_property(TARGET hdf5-static APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5-static PROPERTIES
+  IMPORTED_LINK_INTERFACE_LANGUAGES_RELEASE "C"
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5.a"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5-static )
+list(APPEND _cmake_import_check_files_for_hdf5-static "${_IMPORT_PREFIX}/lib/libhdf5.a" )
+
+# Import target "hdf5-shared" for configuration "Release"
+set_property(TARGET hdf5-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5.so.1000.0.0"
+  IMPORTED_SONAME_RELEASE "libhdf5.so.1000"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5-shared )
+list(APPEND _cmake_import_check_files_for_hdf5-shared "${_IMPORT_PREFIX}/lib/libhdf5.so.1000.0.0" )
+
+# Import target "mirror_server" for configuration "Release"
+set_property(TARGET mirror_server APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(mirror_server PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/mirror_server"
+  )
+
+list(APPEND _cmake_import_check_targets mirror_server )
+list(APPEND _cmake_import_check_files_for_mirror_server "${_IMPORT_PREFIX}/bin/mirror_server" )
+
+# Import target "mirror_server_stop" for configuration "Release"
+set_property(TARGET mirror_server_stop APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(mirror_server_stop PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/mirror_server_stop"
+  )
+
+list(APPEND _cmake_import_check_targets mirror_server_stop )
+list(APPEND _cmake_import_check_files_for_mirror_server_stop "${_IMPORT_PREFIX}/bin/mirror_server_stop" )
+
+# Import target "hdf5_tools-static" for configuration "Release"
+set_property(TARGET hdf5_tools-static APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5_tools-static PROPERTIES
+  IMPORTED_LINK_INTERFACE_LANGUAGES_RELEASE "C"
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5_tools.a"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5_tools-static )
+list(APPEND _cmake_import_check_files_for_hdf5_tools-static "${_IMPORT_PREFIX}/lib/libhdf5_tools.a" )
+
+# Import target "hdf5_tools-shared" for configuration "Release"
+set_property(TARGET hdf5_tools-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5_tools-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5_tools.so.1000.0.0"
+  IMPORTED_SONAME_RELEASE "libhdf5_tools.so.1000"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5_tools-shared )
+list(APPEND _cmake_import_check_files_for_hdf5_tools-shared "${_IMPORT_PREFIX}/lib/libhdf5_tools.so.1000.0.0" )
+
+# Import target "h5diff" for configuration "Release"
+set_property(TARGET h5diff APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5diff PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5diff"
+  )
+
+list(APPEND _cmake_import_check_targets h5diff )
+list(APPEND _cmake_import_check_files_for_h5diff "${_IMPORT_PREFIX}/bin/h5diff" )
+
+# Import target "h5diff-shared" for configuration "Release"
+set_property(TARGET h5diff-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5diff-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5diff-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5diff-shared )
+list(APPEND _cmake_import_check_files_for_h5diff-shared "${_IMPORT_PREFIX}/bin/h5diff-shared" )
+
+# Import target "h5ls" for configuration "Release"
+set_property(TARGET h5ls APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5ls PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5ls"
+  )
+
+list(APPEND _cmake_import_check_targets h5ls )
+list(APPEND _cmake_import_check_files_for_h5ls "${_IMPORT_PREFIX}/bin/h5ls" )
+
+# Import target "h5ls-shared" for configuration "Release"
+set_property(TARGET h5ls-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5ls-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5ls-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5ls-shared )
+list(APPEND _cmake_import_check_files_for_h5ls-shared "${_IMPORT_PREFIX}/bin/h5ls-shared" )
+
+# Import target "h5debug" for configuration "Release"
+set_property(TARGET h5debug APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5debug PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5debug"
+  )
+
+list(APPEND _cmake_import_check_targets h5debug )
+list(APPEND _cmake_import_check_files_for_h5debug "${_IMPORT_PREFIX}/bin/h5debug" )
+
+# Import target "h5repart" for configuration "Release"
+set_property(TARGET h5repart APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5repart PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5repart"
+  )
+
+list(APPEND _cmake_import_check_targets h5repart )
+list(APPEND _cmake_import_check_files_for_h5repart "${_IMPORT_PREFIX}/bin/h5repart" )
+
+# Import target "h5mkgrp" for configuration "Release"
+set_property(TARGET h5mkgrp APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5mkgrp PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5mkgrp"
+  )
+
+list(APPEND _cmake_import_check_targets h5mkgrp )
+list(APPEND _cmake_import_check_files_for_h5mkgrp "${_IMPORT_PREFIX}/bin/h5mkgrp" )
+
+# Import target "h5clear" for configuration "Release"
+set_property(TARGET h5clear APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5clear PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5clear"
+  )
+
+list(APPEND _cmake_import_check_targets h5clear )
+list(APPEND _cmake_import_check_files_for_h5clear "${_IMPORT_PREFIX}/bin/h5clear" )
+
+# Import target "h5delete" for configuration "Release"
+set_property(TARGET h5delete APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5delete PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5delete"
+  )
+
+list(APPEND _cmake_import_check_targets h5delete )
+list(APPEND _cmake_import_check_files_for_h5delete "${_IMPORT_PREFIX}/bin/h5delete" )
+
+# Import target "h5debug-shared" for configuration "Release"
+set_property(TARGET h5debug-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5debug-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5debug-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5debug-shared )
+list(APPEND _cmake_import_check_files_for_h5debug-shared "${_IMPORT_PREFIX}/bin/h5debug-shared" )
+
+# Import target "h5repart-shared" for configuration "Release"
+set_property(TARGET h5repart-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5repart-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5repart-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5repart-shared )
+list(APPEND _cmake_import_check_files_for_h5repart-shared "${_IMPORT_PREFIX}/bin/h5repart-shared" )
+
+# Import target "h5mkgrp-shared" for configuration "Release"
+set_property(TARGET h5mkgrp-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5mkgrp-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5mkgrp-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5mkgrp-shared )
+list(APPEND _cmake_import_check_files_for_h5mkgrp-shared "${_IMPORT_PREFIX}/bin/h5mkgrp-shared" )
+
+# Import target "h5clear-shared" for configuration "Release"
+set_property(TARGET h5clear-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5clear-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5clear-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5clear-shared )
+list(APPEND _cmake_import_check_files_for_h5clear-shared "${_IMPORT_PREFIX}/bin/h5clear-shared" )
+
+# Import target "h5delete-shared" for configuration "Release"
+set_property(TARGET h5delete-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5delete-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5delete-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5delete-shared )
+list(APPEND _cmake_import_check_files_for_h5delete-shared "${_IMPORT_PREFIX}/bin/h5delete-shared" )
+
+# Import target "h5import" for configuration "Release"
+set_property(TARGET h5import APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5import PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5import"
+  )
+
+list(APPEND _cmake_import_check_targets h5import )
+list(APPEND _cmake_import_check_files_for_h5import "${_IMPORT_PREFIX}/bin/h5import" )
+
+# Import target "h5import-shared" for configuration "Release"
+set_property(TARGET h5import-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5import-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5import-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5import-shared )
+list(APPEND _cmake_import_check_files_for_h5import-shared "${_IMPORT_PREFIX}/bin/h5import-shared" )
+
+# Import target "h5repack" for configuration "Release"
+set_property(TARGET h5repack APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5repack PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5repack"
+  )
+
+list(APPEND _cmake_import_check_targets h5repack )
+list(APPEND _cmake_import_check_files_for_h5repack "${_IMPORT_PREFIX}/bin/h5repack" )
+
+# Import target "h5repack-shared" for configuration "Release"
+set_property(TARGET h5repack-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5repack-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5repack-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5repack-shared )
+list(APPEND _cmake_import_check_files_for_h5repack-shared "${_IMPORT_PREFIX}/bin/h5repack-shared" )
+
+# Import target "h5jam" for configuration "Release"
+set_property(TARGET h5jam APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5jam PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5jam"
+  )
+
+list(APPEND _cmake_import_check_targets h5jam )
+list(APPEND _cmake_import_check_files_for_h5jam "${_IMPORT_PREFIX}/bin/h5jam" )
+
+# Import target "h5unjam" for configuration "Release"
+set_property(TARGET h5unjam APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5unjam PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5unjam"
+  )
+
+list(APPEND _cmake_import_check_targets h5unjam )
+list(APPEND _cmake_import_check_files_for_h5unjam "${_IMPORT_PREFIX}/bin/h5unjam" )
+
+# Import target "h5jam-shared" for configuration "Release"
+set_property(TARGET h5jam-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5jam-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5jam-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5jam-shared )
+list(APPEND _cmake_import_check_files_for_h5jam-shared "${_IMPORT_PREFIX}/bin/h5jam-shared" )
+
+# Import target "h5unjam-shared" for configuration "Release"
+set_property(TARGET h5unjam-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5unjam-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5unjam-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5unjam-shared )
+list(APPEND _cmake_import_check_files_for_h5unjam-shared "${_IMPORT_PREFIX}/bin/h5unjam-shared" )
+
+# Import target "h5copy" for configuration "Release"
+set_property(TARGET h5copy APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5copy PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5copy"
+  )
+
+list(APPEND _cmake_import_check_targets h5copy )
+list(APPEND _cmake_import_check_files_for_h5copy "${_IMPORT_PREFIX}/bin/h5copy" )
+
+# Import target "h5copy-shared" for configuration "Release"
+set_property(TARGET h5copy-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5copy-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5copy-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5copy-shared )
+list(APPEND _cmake_import_check_files_for_h5copy-shared "${_IMPORT_PREFIX}/bin/h5copy-shared" )
+
+# Import target "h5stat" for configuration "Release"
+set_property(TARGET h5stat APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5stat PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5stat"
+  )
+
+list(APPEND _cmake_import_check_targets h5stat )
+list(APPEND _cmake_import_check_files_for_h5stat "${_IMPORT_PREFIX}/bin/h5stat" )
+
+# Import target "h5stat-shared" for configuration "Release"
+set_property(TARGET h5stat-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5stat-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5stat-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5stat-shared )
+list(APPEND _cmake_import_check_files_for_h5stat-shared "${_IMPORT_PREFIX}/bin/h5stat-shared" )
+
+# Import target "h5dump" for configuration "Release"
+set_property(TARGET h5dump APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5dump PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5dump"
+  )
+
+list(APPEND _cmake_import_check_targets h5dump )
+list(APPEND _cmake_import_check_files_for_h5dump "${_IMPORT_PREFIX}/bin/h5dump" )
+
+# Import target "h5dump-shared" for configuration "Release"
+set_property(TARGET h5dump-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5dump-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5dump-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5dump-shared )
+list(APPEND _cmake_import_check_files_for_h5dump-shared "${_IMPORT_PREFIX}/bin/h5dump-shared" )
+
+# Import target "h5format_convert" for configuration "Release"
+set_property(TARGET h5format_convert APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5format_convert PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5format_convert"
+  )
+
+list(APPEND _cmake_import_check_targets h5format_convert )
+list(APPEND _cmake_import_check_files_for_h5format_convert "${_IMPORT_PREFIX}/bin/h5format_convert" )
+
+# Import target "h5format_convert-shared" for configuration "Release"
+set_property(TARGET h5format_convert-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5format_convert-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5format_convert-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5format_convert-shared )
+list(APPEND _cmake_import_check_files_for_h5format_convert-shared "${_IMPORT_PREFIX}/bin/h5format_convert-shared" )
+
+# Import target "h5perf_serial" for configuration "Release"
+set_property(TARGET h5perf_serial APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5perf_serial PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5perf_serial"
+  )
+
+list(APPEND _cmake_import_check_targets h5perf_serial )
+list(APPEND _cmake_import_check_files_for_h5perf_serial "${_IMPORT_PREFIX}/bin/h5perf_serial" )
+
+# Import target "hdf5_hl-static" for configuration "Release"
+set_property(TARGET hdf5_hl-static APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5_hl-static PROPERTIES
+  IMPORTED_LINK_INTERFACE_LANGUAGES_RELEASE "C"
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5_hl.a"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5_hl-static )
+list(APPEND _cmake_import_check_files_for_hdf5_hl-static "${_IMPORT_PREFIX}/lib/libhdf5_hl.a" )
+
+# Import target "hdf5_hl-shared" for configuration "Release"
+set_property(TARGET hdf5_hl-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(hdf5_hl-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/lib/libhdf5_hl.so.1000.0.0"
+  IMPORTED_SONAME_RELEASE "libhdf5_hl.so.1000"
+  )
+
+list(APPEND _cmake_import_check_targets hdf5_hl-shared )
+list(APPEND _cmake_import_check_files_for_hdf5_hl-shared "${_IMPORT_PREFIX}/lib/libhdf5_hl.so.1000.0.0" )
+
+# Import target "h5watch" for configuration "Release"
+set_property(TARGET h5watch APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5watch PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5watch"
+  )
+
+list(APPEND _cmake_import_check_targets h5watch )
+list(APPEND _cmake_import_check_files_for_h5watch "${_IMPORT_PREFIX}/bin/h5watch" )
+
+# Import target "h5watch-shared" for configuration "Release"
+set_property(TARGET h5watch-shared APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
+set_target_properties(h5watch-shared PROPERTIES
+  IMPORTED_LOCATION_RELEASE "${_IMPORT_PREFIX}/bin/h5watch-shared"
+  )
+
+list(APPEND _cmake_import_check_targets h5watch-shared )
+list(APPEND _cmake_import_check_files_for_h5watch-shared "${_IMPORT_PREFIX}/bin/h5watch-shared" )
+
+# Commands beyond this point should not need to know the version.
+set(CMAKE_IMPORT_FILE_VERSION)
diff --git a/install/cmake/hdf5-targets.cmake b/install/cmake/hdf5-targets.cmake
new file mode 100644
index 0000000000..9f2e65b6e9
--- /dev/null
+++ b/install/cmake/hdf5-targets.cmake
@@ -0,0 +1,254 @@
+# Generated by CMake
+
+if("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}" LESS 2.8)
+   message(FATAL_ERROR "CMake >= 2.8.0 required")
+endif()
+if(CMAKE_VERSION VERSION_LESS "2.8.3")
+   message(FATAL_ERROR "CMake >= 2.8.3 required")
+endif()
+cmake_policy(PUSH)
+cmake_policy(VERSION 2.8.3...3.26)
+#----------------------------------------------------------------
+# Generated CMake target import file.
+#----------------------------------------------------------------
+
+# Commands may need to know the format version.
+set(CMAKE_IMPORT_FILE_VERSION 1)
+
+# Protect against multiple inclusion, which would fail when already imported targets are added once more.
+set(_cmake_targets_defined "")
+set(_cmake_targets_not_defined "")
+set(_cmake_expected_targets "")
+foreach(_cmake_expected_target IN ITEMS hdf5-static hdf5-shared mirror_server mirror_server_stop hdf5_tools-static hdf5_tools-shared h5diff h5diff-shared h5ls h5ls-shared h5debug h5repart h5mkgrp h5clear h5delete h5debug-shared h5repart-shared h5mkgrp-shared h5clear-shared h5delete-shared h5import h5import-shared h5repack h5repack-shared h5jam h5unjam h5jam-shared h5unjam-shared h5copy h5copy-shared h5stat h5stat-shared h5dump h5dump-shared h5format_convert h5format_convert-shared h5perf_serial hdf5_hl-static hdf5_hl-shared h5watch h5watch-shared)
+  list(APPEND _cmake_expected_targets "${_cmake_expected_target}")
+  if(TARGET "${_cmake_expected_target}")
+    list(APPEND _cmake_targets_defined "${_cmake_expected_target}")
+  else()
+    list(APPEND _cmake_targets_not_defined "${_cmake_expected_target}")
+  endif()
+endforeach()
+unset(_cmake_expected_target)
+if(_cmake_targets_defined STREQUAL _cmake_expected_targets)
+  unset(_cmake_targets_defined)
+  unset(_cmake_targets_not_defined)
+  unset(_cmake_expected_targets)
+  unset(CMAKE_IMPORT_FILE_VERSION)
+  cmake_policy(POP)
+  return()
+endif()
+if(NOT _cmake_targets_defined STREQUAL "")
+  string(REPLACE ";" ", " _cmake_targets_defined_text "${_cmake_targets_defined}")
+  string(REPLACE ";" ", " _cmake_targets_not_defined_text "${_cmake_targets_not_defined}")
+  message(FATAL_ERROR "Some (but not all) targets in this export set were already defined.\nTargets Defined: ${_cmake_targets_defined_text}\nTargets not yet defined: ${_cmake_targets_not_defined_text}\n")
+endif()
+unset(_cmake_targets_defined)
+unset(_cmake_targets_not_defined)
+unset(_cmake_expected_targets)
+
+
+# Compute the installation prefix relative to this file.
+get_filename_component(_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)
+get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
+if(_IMPORT_PREFIX STREQUAL "/")
+  set(_IMPORT_PREFIX "")
+endif()
+
+# Create imported target hdf5-static
+add_library(hdf5-static STATIC IMPORTED)
+
+set_target_properties(hdf5-static PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "_POSIX_C_SOURCE=200809L;_GNU_SOURCE;_FILE_OFFSET_BITS=64;_LARGEFILE64_SOURCE;_LARGEFILE_SOURCE"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "\$<LINK_ONLY:m>;\$<LINK_ONLY:dl>;/usr/lib/x86_64-linux-gnu/libz.so;\$<\$<NOT:\$<PLATFORM_ID:Windows>>:dl>;\$<\$<BOOL:OFF>:MPI::MPI_C>;\$<LINK_ONLY:\$<\$<OR:\$<BOOL:OFF>,\$<BOOL:OFF>>:Threads::Threads>>"
+)
+
+# Create imported target hdf5-shared
+add_library(hdf5-shared SHARED IMPORTED)
+
+set_target_properties(hdf5-shared PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "H5_BUILT_AS_DYNAMIC_LIB;_POSIX_C_SOURCE=200809L;_GNU_SOURCE;_FILE_OFFSET_BITS=64;_LARGEFILE64_SOURCE;_LARGEFILE_SOURCE"
+  INTERFACE_INCLUDE_DIRECTORIES "\$<\$<BOOL:OFF>:>;${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "\$<\$<NOT:\$<PLATFORM_ID:Windows>>:dl>;\$<\$<BOOL:OFF>:MPI::MPI_C>"
+)
+
+# Create imported target mirror_server
+add_executable(mirror_server IMPORTED)
+
+# Create imported target mirror_server_stop
+add_executable(mirror_server_stop IMPORTED)
+
+# Create imported target hdf5_tools-static
+add_library(hdf5_tools-static STATIC IMPORTED)
+
+set_target_properties(hdf5_tools-static PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5-static;\$<LINK_ONLY:\$<\$<BOOL:OFF>:MPI::MPI_C>>"
+)
+
+# Create imported target hdf5_tools-shared
+add_library(hdf5_tools-shared SHARED IMPORTED)
+
+set_target_properties(hdf5_tools-shared PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "H5_BUILT_AS_DYNAMIC_LIB"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5-shared"
+)
+
+# Create imported target h5diff
+add_executable(h5diff IMPORTED)
+
+# Create imported target h5diff-shared
+add_executable(h5diff-shared IMPORTED)
+
+# Create imported target h5ls
+add_executable(h5ls IMPORTED)
+
+# Create imported target h5ls-shared
+add_executable(h5ls-shared IMPORTED)
+
+# Create imported target h5debug
+add_executable(h5debug IMPORTED)
+
+# Create imported target h5repart
+add_executable(h5repart IMPORTED)
+
+# Create imported target h5mkgrp
+add_executable(h5mkgrp IMPORTED)
+
+# Create imported target h5clear
+add_executable(h5clear IMPORTED)
+
+# Create imported target h5delete
+add_executable(h5delete IMPORTED)
+
+# Create imported target h5debug-shared
+add_executable(h5debug-shared IMPORTED)
+
+# Create imported target h5repart-shared
+add_executable(h5repart-shared IMPORTED)
+
+# Create imported target h5mkgrp-shared
+add_executable(h5mkgrp-shared IMPORTED)
+
+# Create imported target h5clear-shared
+add_executable(h5clear-shared IMPORTED)
+
+# Create imported target h5delete-shared
+add_executable(h5delete-shared IMPORTED)
+
+# Create imported target h5import
+add_executable(h5import IMPORTED)
+
+# Create imported target h5import-shared
+add_executable(h5import-shared IMPORTED)
+
+# Create imported target h5repack
+add_executable(h5repack IMPORTED)
+
+# Create imported target h5repack-shared
+add_executable(h5repack-shared IMPORTED)
+
+# Create imported target h5jam
+add_executable(h5jam IMPORTED)
+
+# Create imported target h5unjam
+add_executable(h5unjam IMPORTED)
+
+# Create imported target h5jam-shared
+add_executable(h5jam-shared IMPORTED)
+
+# Create imported target h5unjam-shared
+add_executable(h5unjam-shared IMPORTED)
+
+# Create imported target h5copy
+add_executable(h5copy IMPORTED)
+
+# Create imported target h5copy-shared
+add_executable(h5copy-shared IMPORTED)
+
+# Create imported target h5stat
+add_executable(h5stat IMPORTED)
+
+# Create imported target h5stat-shared
+add_executable(h5stat-shared IMPORTED)
+
+# Create imported target h5dump
+add_executable(h5dump IMPORTED)
+
+# Create imported target h5dump-shared
+add_executable(h5dump-shared IMPORTED)
+
+# Create imported target h5format_convert
+add_executable(h5format_convert IMPORTED)
+
+# Create imported target h5format_convert-shared
+add_executable(h5format_convert-shared IMPORTED)
+
+# Create imported target h5perf_serial
+add_executable(h5perf_serial IMPORTED)
+
+# Create imported target hdf5_hl-static
+add_library(hdf5_hl-static STATIC IMPORTED)
+
+set_target_properties(hdf5_hl-static PROPERTIES
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5-static"
+)
+
+# Create imported target hdf5_hl-shared
+add_library(hdf5_hl-shared SHARED IMPORTED)
+
+set_target_properties(hdf5_hl-shared PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "H5_BUILT_AS_DYNAMIC_LIB"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include;${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "hdf5-shared"
+)
+
+# Create imported target h5watch
+add_executable(h5watch IMPORTED)
+
+# Create imported target h5watch-shared
+add_executable(h5watch-shared IMPORTED)
+
+if(CMAKE_VERSION VERSION_LESS 2.8.12)
+  message(FATAL_ERROR "This file relies on consumers using CMake 2.8.12 or greater.")
+endif()
+
+# Load information for each installed configuration.
+file(GLOB _cmake_config_files "${CMAKE_CURRENT_LIST_DIR}/hdf5-targets-*.cmake")
+foreach(_cmake_config_file IN LISTS _cmake_config_files)
+  include("${_cmake_config_file}")
+endforeach()
+unset(_cmake_config_file)
+unset(_cmake_config_files)
+
+# Cleanup temporary variables.
+set(_IMPORT_PREFIX)
+
+# Loop over all imported files and verify that they actually exist
+foreach(_cmake_target IN LISTS _cmake_import_check_targets)
+  foreach(_cmake_file IN LISTS "_cmake_import_check_files_for_${_cmake_target}")
+    if(NOT EXISTS "${_cmake_file}")
+      message(FATAL_ERROR "The imported target \"${_cmake_target}\" references the file
+   \"${_cmake_file}\"
+but this file does not exist.  Possible reasons include:
+* The file was deleted, renamed, or moved to another location.
+* An install or uninstall procedure did not complete successfully.
+* The installation package was faulty and contained
+   \"${CMAKE_CURRENT_LIST_FILE}\"
+but not all the files it references.
+")
+    endif()
+  endforeach()
+  unset(_cmake_file)
+  unset("_cmake_import_check_files_for_${_cmake_target}")
+endforeach()
+unset(_cmake_target)
+unset(_cmake_import_check_targets)
+
+# This file does not depend on other imported targets which have
+# been exported from the same project but in a separate export set.
+
+# Commands beyond this point should not need to know the version.
+set(CMAKE_IMPORT_FILE_VERSION)
+cmake_policy(POP)
diff --git a/install/include/H5ACpublic.h b/install/include/H5ACpublic.h
new file mode 100644
index 0000000000..71292b679a
--- /dev/null
+++ b/install/include/H5ACpublic.h
@@ -0,0 +1,778 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5ACpublic.h
+ *
+ * Purpose:             Public include file for cache functions
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef H5ACpublic_H
+#define H5ACpublic_H
+
+#include "H5public.h"  /* Generic Functions                        */
+#include "H5Cpublic.h" /* Cache                                    */
+
+/****************************************************************************
+ *
+ * structure H5AC_cache_config_t
+ *
+ * H5AC_cache_config_t is a public structure intended for use in public APIs.
+ * At least in its initial incarnation, it is basically a copy of struct
+ * H5C_auto_size_ctl_t, minus the report_fcn field, and plus the
+ * dirty_bytes_threshold field.
+ *
+ * The report_fcn field is omitted, as including it would require us to
+ * make H5C_t structure public.
+ *
+ * The dirty_bytes_threshold field does not appear in H5C_auto_size_ctl_t,
+ * as synchronization between caches on different processes is handled at
+ * the H5AC level, not at the level of H5C.  Note however that there is
+ * considerable interaction between this value and the other fields in this
+ * structure.
+ *
+ * Similarly, the open_trace_file, close_trace_file, and trace_file_name
+ * fields do not appear in H5C_auto_size_ctl_t, as most trace file
+ * issues are handled at the H5AC level.  The one exception is storage of
+ * the pointer to the trace file, which is handled by H5C.
+ *
+ * The structure is in H5ACpublic.h as we may wish to allow different
+ * configuration options for metadata and raw data caches.
+ *
+ * The fields of the structure are discussed individually below:
+ *
+ * version: Integer field containing the version number of this version
+ *      of the H5AC_cache_config_t structure.  Any instance of
+ *      H5AC_cache_config_t passed to the cache must have a known
+ *      version number, or an error will be flagged.
+ *
+ * rpt_fcn_enabled: Boolean field used to enable and disable the default
+ *    reporting function.  This function is invoked every time the
+ *    automatic cache resize code is run, and reports on its activities.
+ *
+ *    This is a debugging function, and should normally be turned off.
+ *
+ * open_trace_file: Boolean field indicating whether the trace_file_name
+ *     field should be used to open a trace file for the cache.
+ *
+ *      *** DEPRECATED *** Use H5Fstart/stop logging functions instead
+ *
+ *     The trace file is a debugging feature that allow the capture of
+ *     top level metadata cache requests for purposes of debugging and/or
+ *     optimization.  This field should normally be set to false, as
+ *     trace file collection imposes considerable overhead.
+ *
+ *     This field should only be set to true when the trace_file_name
+ *     contains the full path of the desired trace file, and either
+ *     there is no open trace file on the cache, or the close_trace_file
+ *     field is also true.
+ *
+ * close_trace_file: Boolean field indicating whether the current trace
+ *     file (if any) should be closed.
+ *
+ *      *** DEPRECATED *** Use H5Fstart/stop logging functions instead
+ *
+ *     See the above comments on the open_trace_file field.  This field
+ *     should be set to false unless there is an open trace file on the
+ *     cache that you wish to close.
+ *
+ * trace_file_name: Full path of the trace file to be opened if the
+ *     open_trace_file field is true.
+ *
+ *      *** DEPRECATED *** Use H5Fstart/stop logging functions instead
+ *
+ *     In the parallel case, an ascii representation of the mpi rank of
+ *     the process will be appended to the file name to yield a unique
+ *     trace file name for each process.
+ *
+ *     The length of the path must not exceed H5AC__MAX_TRACE_FILE_NAME_LEN
+ *     characters.
+ *
+ * evictions_enabled:  Boolean field used to either report the current
+ *     evictions enabled status of the cache, or to set the cache's
+ *    evictions enabled status.
+ *
+ *     In general, the metadata cache should always be allowed to
+ *     evict entries.  However, in some cases it is advantageous to
+ *     disable evictions briefly, and thereby postpone metadata
+ *     writes.  However, this must be done with care, as the cache
+ *     can grow quickly.  If you do this, re-enable evictions as
+ *     soon as possible and monitor cache size.
+ *
+ *     At present, evictions can only be disabled if automatic
+ *     cache resizing is also disabled (that is, ( incr_mode ==
+ *    H5C_incr__off ) && ( decr_mode == H5C_decr__off )).  There
+ *    is no logical reason why this should be so, but it simplifies
+ *    implementation and testing, and I can't think of any reason
+ *    why it would be desirable.  If you can think of one, I'll
+ *    revisit the issue.
+ *
+ * set_initial_size: Boolean flag indicating whether the size of the
+ *      initial size of the cache is to be set to the value given in
+ *      the initial_size field.  If set_initial_size is false, the
+ *      initial_size field is ignored.
+ *
+ * initial_size: If enabled, this field contain the size the cache is
+ *      to be set to upon receipt of this structure.  Needless to say,
+ *      initial_size must lie in the closed interval [min_size, max_size].
+ *
+ * min_clean_fraction: double in the range 0 to 1 indicating the fraction
+ *      of the cache that is to be kept clean.  This field is only used
+ *      in parallel mode.  Typical values are 0.1 to 0.5.
+ *
+ * max_size: Maximum size to which the cache can be adjusted.  The
+ *      supplied value must fall in the closed interval
+ *      [MIN_MAX_CACHE_SIZE, MAX_MAX_CACHE_SIZE].  Also, max_size must
+ *      be greater than or equal to min_size.
+ *
+ * min_size: Minimum size to which the cache can be adjusted.  The
+ *      supplied value must fall in the closed interval
+ *      [H5C__MIN_MAX_CACHE_SIZE, H5C__MAX_MAX_CACHE_SIZE].  Also, min_size
+ *      must be less than or equal to max_size.
+ *
+ * epoch_length: Number of accesses on the cache over which to collect
+ *      hit rate stats before running the automatic cache resize code,
+ *      if it is enabled.
+ *
+ *      At the end of an epoch, we discard prior hit rate data and start
+ *      collecting afresh.  The epoch_length must lie in the closed
+ *      interval [H5C__MIN_AR_EPOCH_LENGTH, H5C__MAX_AR_EPOCH_LENGTH].
+ *
+ *
+ * Cache size increase control fields:
+ *
+ * incr_mode: Instance of the H5C_cache_incr_mode enumerated type whose
+ *      value indicates how we determine whether the cache size should be
+ *      increased.  At present there are two possible values:
+ *
+ *      H5C_incr__off:  Don't attempt to increase the size of the cache
+ *              automatically.
+ *
+ *              When this increment mode is selected, the remaining fields
+ *              in the cache size increase section ar ignored.
+ *
+ *      H5C_incr__threshold: Attempt to increase the size of the cache
+ *              whenever the average hit rate over the last epoch drops
+ *              below the value supplied in the lower_hr_threshold
+ *              field.
+ *
+ *              Note that this attempt will fail if the cache is already
+ *              at its maximum size, or if the cache is not already using
+ *              all available space.
+ *
+ *      Note that you must set decr_mode to H5C_incr__off if you
+ *      disable metadata cache entry evictions.
+ *
+ * lower_hr_threshold: Lower hit rate threshold.  If the increment mode
+ *      (incr_mode) is H5C_incr__threshold and the hit rate drops below the
+ *      value supplied in this field in an epoch, increment the cache size by
+ *      size_increment.  Note that cache size may not be incremented above
+ *      max_size, and that the increment may be further restricted by the
+ *      max_increment field if it is enabled.
+ *
+ *      When enabled, this field must contain a value in the range [0.0, 1.0].
+ *      Depending on the incr_mode selected, it may also have to be less than
+ *      upper_hr_threshold.
+ *
+ * increment:  Double containing the multiplier used to derive the new
+ *      cache size from the old if a cache size increment is triggered.
+ *      The increment must be greater than 1.0, and should not exceed 2.0.
+ *
+ *      The new cache size is obtained my multiplying the current max cache
+ *      size by the increment, and then clamping to max_size and to stay
+ *      within the max_increment as necessary.
+ *
+ * apply_max_increment:  Boolean flag indicating whether the max_increment
+ *      field should be used to limit the maximum cache size increment.
+ *
+ * max_increment: If enabled by the apply_max_increment field described
+ *      above, this field contains the maximum number of bytes by which the
+ *      cache size can be increased in a single re-size.
+ *
+ * flash_incr_mode:  Instance of the H5C_cache_flash_incr_mode enumerated
+ *      type whose value indicates whether and by which algorithm we should
+ *      make flash increases in the size of the cache to accommodate insertion
+ *      of large entries and large increases in the size of a single entry.
+ *
+ *      The addition of the flash increment mode was occasioned by performance
+ *      problems that appear when a local heap is increased to a size in excess
+ *      of the current cache size.  While the existing re-size code dealt with
+ *      this eventually, performance was very bad for the remainder of the
+ *      epoch.
+ *
+ *      At present, there are two possible values for the flash_incr_mode:
+ *
+ *      H5C_flash_incr__off:  Don't perform flash increases in the size of
+ *              the cache.
+ *
+ *      H5C_flash_incr__add_space:  Let x be either the size of a newly
+ *              newly inserted entry, or the number of bytes by which the
+ *              size of an existing entry has been increased.
+ *
+ *              If
+ *                      x > flash_threshold * current max cache size,
+ *
+ *              increase the current maximum cache size by x * flash_multiple
+ *              less any free space in the cache, and star a new epoch.  For
+ *              now at least, pay no attention to the maximum increment.
+ *
+ *      In both of the above cases, the flash increment pays no attention to
+ *      the maximum increment (at least in this first incarnation), but DOES
+ *      stay within max_size.
+ *
+ *      With a little thought, it should be obvious that the above flash
+ *      cache size increase algorithm is not sufficient for all circumstances
+ *      -- for example, suppose the user round robins through
+ *      (1/flash_threshold) +1 groups, adding one data set to each on each
+ *      pass.  Then all will increase in size at about the same time, requiring
+ *      the max cache size to at least double to maintain acceptable
+ *      performance, however the above flash increment algorithm will not be
+ *      triggered.
+ *
+ *      Hopefully, the add space algorithms detailed above will be sufficient
+ *      for the performance problems encountered to date.  However, we should
+ *      expect to revisit the issue.
+ *
+ * flash_multiple: Double containing the multiple described above in the
+ *      H5C_flash_incr__add_space section of the discussion of the
+ *      flash_incr_mode section.  This field is ignored unless flash_incr_mode
+ *      is H5C_flash_incr__add_space.
+ *
+ * flash_threshold: Double containing the factor by which current max cache
+ *      size is multiplied to obtain the size threshold for the add_space flash
+ *      increment algorithm.  The field is ignored unless flash_incr_mode is
+ *      H5C_flash_incr__add_space.
+ *
+ *
+ * Cache size decrease control fields:
+ *
+ * decr_mode: Instance of the H5C_cache_decr_mode enumerated type whose
+ *      value indicates how we determine whether the cache size should be
+ *      decreased.  At present there are four possibilities.
+ *
+ *      H5C_decr__off:  Don't attempt to decrease the size of the cache
+ *              automatically.
+ *
+ *              When this increment mode is selected, the remaining fields
+ *              in the cache size decrease section are ignored.
+ *
+ *      H5C_decr__threshold: Attempt to decrease the size of the cache
+ *              whenever the average hit rate over the last epoch rises
+ *              above the value supplied in the upper_hr_threshold
+ *              field.
+ *
+ *      H5C_decr__age_out:  At the end of each epoch, search the cache for
+ *              entries that have not been accessed for at least the number
+ *              of epochs specified in the epochs_before_eviction field, and
+ *              evict these entries.  Conceptually, the maximum cache size
+ *              is then decreased to match the new actual cache size.  However,
+ *              this reduction may be modified by the min_size, the
+ *              max_decrement, and/or the empty_reserve.
+ *
+ *      H5C_decr__age_out_with_threshold:  Same as age_out, but we only
+ *              attempt to reduce the cache size when the hit rate observed
+ *              over the last epoch exceeds the value provided in the
+ *              upper_hr_threshold field.
+ *
+ *      Note that you must set decr_mode to H5C_decr__off if you
+ *      disable metadata cache entry evictions.
+ *
+ * upper_hr_threshold: Upper hit rate threshold.  The use of this field
+ *      varies according to the current decr_mode:
+ *
+ *      H5C_decr__off or H5C_decr__age_out:  The value of this field is
+ *              ignored.
+ *
+ *      H5C_decr__threshold:  If the hit rate exceeds this threshold in any
+ *              epoch, attempt to decrement the cache size by size_decrement.
+ *
+ *              Note that cache size may not be decremented below min_size.
+ *
+ *              Note also that if the upper_threshold is 1.0, the cache size
+ *              will never be reduced.
+ *
+ *      H5C_decr__age_out_with_threshold:  If the hit rate exceeds this
+ *              threshold in any epoch, attempt to reduce the cache size
+ *              by evicting entries that have not been accessed for more
+ *              than the specified number of epochs.
+ *
+ * decrement: This field is only used when the decr_mode is
+ *      H5C_decr__threshold.
+ *
+ *      The field is a double containing the multiplier used to derive the
+ *      new cache size from the old if a cache size decrement is triggered.
+ *      The decrement must be in the range 0.0 (in which case the cache will
+ *      try to contract to its minimum size) to 1.0 (in which case the
+ *      cache will never shrink).
+ *
+ * apply_max_decrement:  Boolean flag used to determine whether decrements
+ *      in cache size are to be limited by the max_decrement field.
+ *
+ * max_decrement: Maximum number of bytes by which the cache size can be
+ *      decreased in a single re-size.  Note that decrements may also be
+ *      restricted by the min_size of the cache, and (in age out modes) by
+ *      the empty_reserve field.
+ *
+ * epochs_before_eviction:  Integer field used in H5C_decr__age_out and
+ *      H5C_decr__age_out_with_threshold decrement modes.
+ *
+ *      This field contains the number of epochs an entry must remain
+ *      unaccessed before it is evicted in an attempt to reduce the
+ *      cache size.  If applicable, this field must lie in the range
+ *      [1, H5C__MAX_EPOCH_MARKERS].
+ *
+ * apply_empty_reserve:  Boolean field controlling whether the empty_reserve
+ *      field is to be used in computing the new cache size when the
+ *      decr_mode is H5C_decr__age_out or H5C_decr__age_out_with_threshold.
+ *
+ * empty_reserve:  To avoid a constant racheting down of cache size by small
+ *      amounts in the H5C_decr__age_out and H5C_decr__age_out_with_threshold
+ *      modes, this field allows one to require that any cache size
+ *      reductions leave the specified fraction of unused space in the cache.
+ *
+ *      The value of this field must be in the range [0.0, 1.0].  I would
+ *      expect typical values to be in the range of 0.01 to 0.1.
+ *
+ *
+ * Parallel Configuration Fields:
+ *
+ * In PHDF5, all operations that modify metadata must be executed collectively.
+ *
+ * We used to think that this was enough to ensure consistency across the
+ * metadata caches, but since we allow processes to read metadata individually,
+ * the order of dirty entries in the LRU list can vary across processes,
+ * which can result in inconsistencies between the caches.
+ *
+ * PHDF5 uses several strategies to prevent such inconsistencies in metadata,
+ * all of which use the fact that the same stream of dirty metadata is seen
+ * by all processes for purposes of synchronization.  This is done by
+ * having each process count the number of bytes of dirty metadata generated,
+ * and then running a "sync point" whenever this count exceeds a user
+ * specified threshold (see dirty_bytes_threshold below).
+ *
+ * The current metadata write strategy is indicated by the
+ * metadata_write_strategy field.  The possible values of this field, along
+ * with the associated metadata write strategies are discussed below.
+ *
+ * dirty_bytes_threshold:  Threshold of dirty byte creation used to
+ *     synchronize updates between caches. (See above for outline and
+ *    motivation.)
+ *
+ *    This value MUST be consistent across all processes accessing the
+ *    file.  This field is ignored unless HDF5 has been compiled for
+ *    parallel.
+ *
+ * metadata_write_strategy: Integer field containing a code indicating the
+ *    desired metadata write strategy.  The valid values of this field
+ *    are enumerated and discussed below:
+ *
+ *
+ *    H5AC_METADATA_WRITE_STRATEGY__PROCESS_0_ONLY:
+ *
+ *    When metadata_write_strategy is set to this value, only process
+ *    zero is allowed to write dirty metadata to disk.  All other
+ *    processes must retain dirty metadata until they are informed at
+ *    a sync point that the dirty metadata in question has been written
+ *    to disk.
+ *
+ *    When the sync point is reached (or when there is a user generated
+ *    flush), process zero flushes sufficient entries to bring it into
+ *    compliance with its min clean size (or flushes all dirty entries in
+ *    the case of a user generated flush), broad casts the list of
+ *    entries just cleaned to all the other processes, and then exits
+ *    the sync point.
+ *
+ *    Upon receipt of the broadcast, the other processes mark the indicated
+ *    entries as clean, and leave the sync point as well.
+ *
+ *
+ *    H5AC_METADATA_WRITE_STRATEGY__DISTRIBUTED:
+ *
+ *    In the distributed metadata write strategy, process zero still makes
+ *    the decisions as to what entries should be flushed, but the actual
+ *    flushes are distributed across the processes in the computation to
+ *    the extent possible.
+ *
+ *    In this strategy, when a sync point is triggered (either by dirty
+ *    metadata creation or manual flush), all processes enter a barrier.
+ *
+ *    On the other side of the barrier, process 0 constructs an ordered
+ *    list of the entries to be flushed, and then broadcasts this list
+ *    to the caches in all the processes.
+ *
+ *    All processes then scan the list of entries to be flushed, flushing
+ *    some, and marking the rest as clean.  The algorithm for this purpose
+ *    ensures that each entry in the list is flushed exactly once, and
+ *    all are marked clean in each cache.
+ *
+ *    Note that in the case of a flush of the cache, no message passing
+ *    is necessary, as all processes have the same list of dirty entries,
+ *    and all of these entries must be flushed.  Thus in this case it is
+ *    sufficient for each process to sort its list of dirty entries after
+ *    leaving the initial barrier, and use this list as if it had been
+ *    received from process zero.
+ *
+ *    To avoid possible messages from the past/future, all caches must
+ *    wait until all caches are done before leaving the sync point.
+ *
+ ****************************************************************************/
+
+#define H5AC__CURR_CACHE_CONFIG_VERSION 1
+#define H5AC__MAX_TRACE_FILE_NAME_LEN   1024
+
+#define H5AC_METADATA_WRITE_STRATEGY__PROCESS_0_ONLY 0
+#define H5AC_METADATA_WRITE_STRATEGY__DISTRIBUTED    1
+
+/**
+ * H5AC_cache_config_t is a public structure intended for use in public APIs.
+ * At least in its initial incarnation, it is basically a copy of \c struct
+ * \c H5C_auto_size_ctl_t, minus the \c report_fcn field, and plus the
+ * \c dirty_bytes_threshold field.
+ *
+ * The \c report_fcn field is omitted, as including it would require us to make
+ * \c H5C_t structure public.
+ *
+ * The \c dirty_bytes_threshold field does not appear in \c H5C_auto_size_ctl_t,
+ * as synchronization between caches on different processes is handled at the \c
+ * H5AC level, not at the level of \c H5C.  Note however that there is
+ * considerable interaction between this value and the other fields in this
+ * structure.
+ *
+ * Similarly, the \c open_trace_file, \c close_trace_file, and \c
+ * trace_file_name fields do not appear in \c H5C_auto_size_ctl_t, as most trace
+ * file issues are handled at the \c H5AC level.  The one exception is storage
+ * of the pointer to the trace file, which is handled by \c H5C.
+ *
+ * The structure is in H5ACpublic.h as we may wish to allow different
+ * configuration options for metadata and raw data caches.
+ */
+
+//! <!-- [H5AC_cache_config_t_snip] -->
+typedef struct H5AC_cache_config_t {
+    /* general configuration fields: */
+    //! <!-- [H5AC_cache_config_t_general_snip] -->
+    int version;
+    /**< Integer field indicating the version of the H5AC_cache_config_t
+     * in use. This field should be set to #H5AC__CURR_CACHE_CONFIG_VERSION
+     * (defined in H5ACpublic.h). */
+
+    hbool_t rpt_fcn_enabled;
+    /**< Boolean flag indicating whether the adaptive cache resize report
+     * function is enabled. This field should almost always be set to disabled
+     * (0). Since resize algorithm activity is reported via stdout, it MUST be
+     * set to disabled (0) on Windows machines.\n
+     * The report function is not supported code, and can be expected to change
+     * between versions of the library. Use it at your own risk. */
+
+    hbool_t open_trace_file;
+    /**< Boolean field indicating whether the
+     * \ref H5AC_cache_config_t.trace_file_name "trace_file_name"
+     * field should be used to open a trace file for the cache.\n
+     * The trace file is a debugging feature that allows the capture
+     * of top level metadata cache requests for purposes of debugging
+     * and/or optimization. This field should normally be set to 0, as
+     * trace file collection imposes considerable overhead.\n
+     * This field should only be set to 1 when the
+     * \ref H5AC_cache_config_t.trace_file_name "trace_file_name"
+     * contains the full path of the desired trace file, and either
+     * there is no open trace file on the cache, or the
+     * \ref H5AC_cache_config_t.close_trace_file "close_trace_file"
+     * field is also 1.\n
+     * The trace file feature is unsupported unless used at the
+     * direction of The HDF Group. It is intended to allow The HDF
+     * Group to collect a trace of cache activity in cases of occult
+     * failures and/or poor performance seen in the field, so as to aid
+     * in reproduction in the lab. If you use it absent the direction
+     * of The HDF Group, you are on your own. */
+
+    hbool_t close_trace_file;
+    /**< Boolean field indicating whether the current trace file
+     *(if any) should be closed.\n
+     * See the above comments on the \ref H5AC_cache_config_t.open_trace_file
+     * "open_trace_file" field. This field should be set to 0 unless there is
+     * an open trace file on the cache that you wish to close.\n
+     * The trace file feature is unsupported unless used at the direction of
+     * The HDF Group. It is intended to allow The HDF Group to collect a trace
+     * of cache activity in cases of occult failures and/or poor performance
+     * seen in the field, so as to aid in reproduction in the lab. If you use
+     * it absent the direction of The HDF Group, you are on your own. */
+
+    char trace_file_name[H5AC__MAX_TRACE_FILE_NAME_LEN + 1];
+    /**< Full path of the trace file to be opened if the
+     * \ref H5AC_cache_config_t.open_trace_file "open_trace_file" field is set
+     * to 1.\n
+     * In the parallel case, an ascii representation of the MPI rank of the
+     * process will be appended to the file name to yield a unique trace file
+     * name for each process.\n
+     * The length of the path must not exceed #H5AC__MAX_TRACE_FILE_NAME_LEN
+     * characters.\n
+     * The trace file feature is unsupported unless used at the direction of
+     * The HDF Group. It is intended to allow The HDF Group to collect a trace
+     * of cache activity in cases of occult failures and/or poor performance
+     * seen in the field, so as to aid in reproduction in the lab. If you use
+     * it absent the direction of The HDF Group, you are on your own. */
+
+    hbool_t evictions_enabled;
+    /**< A boolean flag indicating whether evictions from the metadata cache
+     * are enabled. This flag is initially set to enabled (1).\n
+     * In rare circumstances, the raw data throughput quirements may be so high
+     * that the user wishes to postpone metadata writes so as to reserve I/O
+     * throughput for raw data. The \p evictions_enabled field exists to allow
+     * this. However, this is an extreme step, and you have no business doing
+     * it unless you have read the User Guide section on metadata caching, and
+     * have considered all other options carefully.\n
+     * The \p evictions_enabled field may not be set to disabled (0)
+     * unless all adaptive cache resizing code is disabled via the
+     * \ref H5AC_cache_config_t.incr_mode "incr_mode",
+     * \ref H5AC_cache_config_t.flash_incr_mode "flash_incr_mode",
+     * \ref H5AC_cache_config_t.decr_mode "decr_mode" fields.\n
+     * When this flag is set to disabled (\c 0), the metadata cache will not
+     * attempt to evict entries to make space for new entries, and thus will
+     * grow without bound.\n
+     * Evictions will be re-enabled when this field is set back to \c 1.
+     * This should be done as soon as possible. */
+
+    hbool_t set_initial_size;
+    /**< Boolean flag indicating whether the cache should be created
+     * with a user specified initial size. */
+
+    size_t initial_size;
+    /**< If \ref H5AC_cache_config_t.set_initial_size "set_initial_size"
+     * is set to 1, \p initial_size must contain he desired initial size in
+     * bytes. This value must lie in the closed interval
+     * [ \p min_size, \p max_size ]. (see below) */
+
+    double min_clean_fraction;
+    /**< This field specifies the minimum fraction of the cache
+     * that must be kept either clean or empty.\n
+     * The value must lie in the interval [0.0, 1.0]. 0.01 is a good place to
+     * start in the serial case. In the parallel case, a larger value is needed
+     * -- see the overview of the metadata cache in the
+     * Metadata Caching in HDF5 section of the -- <em>\ref UG</em>
+     * for details. */
+
+    size_t max_size;
+    /**< Upper bound (in bytes) on the range of values that the
+     * adaptive cache resize code can select as the maximum cache size. */
+
+    size_t min_size;
+    /**< Lower bound (in bytes) on the range of values that the
+     * adaptive cache resize code can select as the minimum cache * size. */
+
+    long int epoch_length;
+    /**< Number of cache accesses between runs of the adaptive cache resize
+     * code. 50,000 is a good starting number. */
+    //! <!-- [H5AC_cache_config_t_general_snip] -->
+
+    /* size increase control fields: */
+    //! <!-- [H5AC_cache_config_t_incr_snip] -->
+    enum H5C_cache_incr_mode incr_mode;
+    /**< Enumerated value indicating the operational mode of the automatic
+     * cache size increase code. At present, only two values listed in
+     * #H5C_cache_incr_mode are legal. */
+
+    double lower_hr_threshold;
+    /**< Hit rate threshold used by the hit rate threshold cache size
+     * increment algorithm.\n
+     * When the hit rate over an epoch is below this threshold and the cache
+     * is full, the maximum size of the cache is multiplied by increment
+     * (below), and then clipped as necessary to stay within \p max_size, and
+     * possibly \p max_increment.\n
+     * This field must lie in the interval [0.0, 1.0]. 0.8 or 0.9 is a good
+     * place to start. */
+
+    double increment;
+    /**< Factor by which the hit rate threshold cache size increment
+     * algorithm multiplies the current cache max size to obtain a tentative
+     * new cache size.\n
+     * The actual cache size increase will be clipped to satisfy the \p max_size
+     * specified in the general configuration, and possibly max_increment
+     * below.\n
+     * The parameter must be greater than or equal to 1.0 -- 2.0 is a reasonable
+     * value.\n
+     * If you set it to 1.0, you will effectively disable cache size increases.
+     */
+
+    hbool_t apply_max_increment;
+    /**< Boolean flag indicating whether an upper limit should be applied to
+     * the size of cache size increases. */
+
+    size_t max_increment;
+    /**< Maximum number of bytes by which cache size can be increased in a
+     * single step -- if applicable. */
+
+    enum H5C_cache_flash_incr_mode flash_incr_mode;
+    /**< Enumerated value indicating the operational mode of the flash cache
+     * size increase code. At present, only two listed  values in
+     * #H5C_cache_flash_incr_mode are legal.*/
+
+    double flash_multiple;
+    /**< The factor by which the size of the triggering entry / entry size
+     * increase is multiplied to obtain the initial cache size increment. This
+     * increment may be reduced to reflect existing free space in the cache and
+     * the \p max_size field above.\n
+     * The parameter must lie in the interval [0.0, 1.0]. 0.1 or 0.05 is a good
+     * place to start.\n
+     * At present, this field must lie in the range [0.1, 10.0]. */
+
+    double flash_threshold;
+    /**< The factor by which the current maximum cache size is multiplied to
+     * obtain the minimum size entry / entry size increase which may trigger a
+     * flash cache size increase. \n
+     * At present, this value must lie in the range [0.1, 1.0]. */
+    //! <!-- [H5AC_cache_config_t_incr_snip] -->
+
+    /* size decrease control fields: */
+    //! <!-- [H5AC_cache_config_t_decr_snip] -->
+    enum H5C_cache_decr_mode decr_mode;
+    /**< Enumerated value indicating the operational mode of the tomatic
+     * cache size decrease code. At present, the values listed in
+     * #H5C_cache_decr_mode are legal.*/
+
+    double upper_hr_threshold;
+    /**< Hit rate threshold for the hit rate threshold and ageout with hit
+     * rate threshold cache size decrement algorithms.\n
+     * When \p decr_mode is #H5C_decr__threshold, and the hit rate over a given
+     * epoch exceeds the supplied threshold, the current maximum cache
+     * size is multiplied by decrement to obtain a tentative new (and smaller)
+     * maximum cache size.\n
+     * When \p decr_mode is #H5C_decr__age_out_with_threshold, there is
+     * no attempt to find and evict aged out entries unless the hit rate in
+     * the previous epoch exceeded the supplied threshold.\n
+     * This field must lie in the interval [0.0, 1.0].\n
+     * For #H5C_incr__threshold, .9995 or .99995 is a good place to start.\n
+     * For #H5C_decr__age_out_with_threshold, .999 might be more useful.*/
+
+    double decrement;
+    /**< In the hit rate threshold cache size decrease algorithm, this
+     * parameter contains the factor by which the current max cache size is
+     * multiplied to produce a tentative new cache size.\n
+     * The actual cache size decrease will be clipped to satisfy the
+     * \ref H5AC_cache_config_t.min_size "min_size" specified in the general
+     * configuration, and possibly \ref H5AC_cache_config_t.max_decrement
+     * "max_decrement".\n
+     * The parameter must be be in the interval [0.0, 1.0].\n
+     * If you set it to 1.0, you will effectively
+     * disable cache size decreases. 0.9 is a reasonable starting point. */
+
+    hbool_t apply_max_decrement;
+    /**< Boolean flag indicating ether an upper limit should be applied to
+     * the size of cache size decreases. */
+
+    size_t max_decrement;
+    /**< Maximum number of bytes by which the maximum cache size can be
+     * decreased in any single step -- if applicable.*/
+
+    int epochs_before_eviction;
+    /**< In the ageout based cache size reduction algorithms, this field
+     * contains the minimum number of epochs an entry must remain unaccessed in
+     * cache before the cache size reduction algorithm tries to evict it. 3 is a
+     * reasonable value. */
+
+    hbool_t apply_empty_reserve;
+    /**< Boolean flag indicating whether the ageout based decrement
+     * algorithms will maintain a empty reserve when decreasing cache size. */
+
+    double empty_reserve;
+    /**< Empty reserve as a fraction maximum cache size if applicable.\n When
+     * so directed, the ageout based algorithms will not decrease the maximum
+     * cache size unless the empty reserve can be met.\n The parameter must lie
+     * in the interval [0.0, 1.0]. 0.1 or 0.05 is a good place to start. */
+    //! <!-- [H5AC_cache_config_t_decr_snip] -->
+
+    /* parallel configuration fields: */
+    //! <!-- [H5AC_cache_config_t_parallel_snip] -->
+    size_t dirty_bytes_threshold;
+    /**< Threshold number of bytes of dirty metadata generation for
+     * triggering synchronizations of the metadata caches serving the target
+     * file in the parallel case.\n Synchronization occurs whenever the number
+     * of bytes of dirty metadata created since the last synchronization exceeds
+     * this limit.\n This field only applies to the parallel case. While it is
+     * ignored elsewhere, it can still draw a value out of bounds error.\n It
+     * must be consistent across all caches on any given file.\n By default,
+     * this field is set to 256 KB. It shouldn't be more than half the current
+     * max cache size times the min clean fraction. */
+
+    int metadata_write_strategy;
+    /**< Desired metadata write strategy. The valid values for this field
+     * are:\n #H5AC_METADATA_WRITE_STRATEGY__PROCESS_0_ONLY: Specifies the only
+     * process zero is allowed to write dirty metadata to disk.\n
+     * #H5AC_METADATA_WRITE_STRATEGY__DISTRIBUTED: Specifies that process zero
+     * still makes the decisions as to what entries should be flushed, but the
+     * actual flushes are distributed across the processes in the computation to
+     * the extent possible.\n The src/H5ACpublic.h include file in the HDF5
+     * library has detailed information on each strategy. */
+    //! <!-- [H5AC_cache_config_t_parallel_snip] -->
+} H5AC_cache_config_t;
+//! <!-- [H5AC_cache_config_t_snip] -->
+
+#define H5AC__CURR_CACHE_IMAGE_CONFIG_VERSION 1
+
+#define H5AC__CACHE_IMAGE__ENTRY_AGEOUT__NONE -1
+#define H5AC__CACHE_IMAGE__ENTRY_AGEOUT__MAX  100
+
+//! <!-- [H5AC_cache_image_config_t_snip] -->
+/**
+ * H5AC_cache_image_config_t is a public structure intended for use in public
+ * APIs.  At least in its initial incarnation, it is a copy of \c struct \c
+ * H5C_cache_image_ctl_t.
+ */
+
+typedef struct H5AC_cache_image_config_t {
+    int version;
+    /**< Integer field containing the version number of this version of the \c
+     *  H5C_image_ctl_t structure.  Any instance of \c H5C_image_ctl_t passed
+     *  to the cache must have a known version number, or an error will be
+     *  flagged.
+     */
+    hbool_t generate_image;
+    /**< Boolean flag indicating whether a cache image should be created on file
+     *   close.
+     */
+    hbool_t save_resize_status;
+    /**< Boolean flag indicating whether the cache image should include the
+     *  adaptive cache resize configuration and status.  Note that this field
+     *  is ignored at present.
+     */
+    int entry_ageout;
+    /**< Integer field indicating the maximum number of times a
+     *   prefetched entry can appear in subsequent cache images.  This field
+     *   exists to allow the user to avoid the buildup of infrequently used
+     *   entries in long sequences of cache images.
+     *
+     *   The value of this field must lie in the range \ref
+     *   H5AC__CACHE_IMAGE__ENTRY_AGEOUT__NONE (-1) to \ref
+     *   H5AC__CACHE_IMAGE__ENTRY_AGEOUT__MAX (100).
+     *
+     *   \ref H5AC__CACHE_IMAGE__ENTRY_AGEOUT__NONE means that no limit is
+     *   imposed on number of times a prefetched entry can appear in subsequent
+     *   cache images.
+     *
+     *   A value of 0 prevents prefetched entries from being included in cache
+     *   images.
+     *
+     *   Positive integers restrict prefetched entries to the specified number
+     *   of appearances.
+     *
+     *   Note that the number of subsequent cache images that a prefetched entry
+     *   has appeared in is tracked in an 8 bit field.  Thus, while \ref
+     *   H5AC__CACHE_IMAGE__ENTRY_AGEOUT__MAX can be increased from its current
+     *   value, any value in excess of 255 will be the functional equivalent of
+     *   \ref H5AC__CACHE_IMAGE__ENTRY_AGEOUT__NONE.
+     */
+} H5AC_cache_image_config_t;
+
+//! <!-- [H5AC_cache_image_config_t_snip] -->
+
+#endif
diff --git a/install/include/H5Apublic.h b/install/include/H5Apublic.h
new file mode 100644
index 0000000000..232ae0af64
--- /dev/null
+++ b/install/include/H5Apublic.h
@@ -0,0 +1,1263 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5A module.
+ */
+#ifndef H5Apublic_H
+#define H5Apublic_H
+
+#include "H5public.h"  /* Generic Functions                        */
+#include "H5Ipublic.h" /* Identifiers                              */
+#include "H5Opublic.h" /* Object Headers                           */
+#include "H5Tpublic.h" /* Datatypes                                */
+
+//! <!-- [H5A_info_t_snip] -->
+/**
+ * Information struct for H5Aget_info() / H5Aget_info_by_idx()
+ */
+typedef struct {
+    hbool_t           corder_valid; /**< Indicate if creation order is valid */
+    H5O_msg_crt_idx_t corder;       /**< Creation order                 */
+    H5T_cset_t        cset;         /**< Character set of attribute name */
+    hsize_t           data_size;    /**< Size of raw data		  */
+} H5A_info_t;
+//! <!-- [H5A_info_t_snip] -->
+
+//! <!-- [H5A_operator2_t_snip] -->
+/**
+ * Typedef for H5Aiterate2() / H5Aiterate_by_name() callbacks
+ * \param[in] location_id The identifier for the group, dataset
+ *            or named datatype being iterated over
+ * \param[in] attr_name The name of the current object attribute
+ * \param[in] ainfo The attribute's info struct
+ * \param[in,out] op_data A pointer to the operator data passed into
+ *                H5Aiterate2() or H5Aiterate_by_name()
+ * \returns The return values from an operator are:
+ *          \li Zero causes the iterator to continue, returning zero when
+ *              all attributes have been processed.
+ *          \li Positive causes the iterator to immediately return that
+ *              positive value, indicating short-circuit success. The
+ *              iterator can be restarted at the next attribute.
+ *          \li Negative causes the iterator to immediately return that value,
+ *              indicating failure. The iterator can be restarted at the next
+ *              attribute.
+ */
+typedef herr_t (*H5A_operator2_t)(hid_t location_id /*in*/, const char *attr_name /*in*/,
+                                  const H5A_info_t *ainfo /*in*/, void *op_data /*in,out*/);
+//! <!-- [H5A_operator2_t_snip] -->
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Closes the specified attribute
+ *
+ * \attr_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Aclose() terminates access to the attribute through
+ *          \p attr_id and releases the identifier.
+ *
+ * \par Example
+ * \snippet H5A_examples.c create
+ *
+ * \since 1.0.0
+ *
+ * \see H5Acreate(), H5Aopen()
+ */
+H5_DLL herr_t H5Aclose(hid_t attr_id);
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup ASYNC
+ * \async_variant_of{H5Aclose}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Aclose_async(const char *app_file, const char *app_func, unsigned app_line, hid_t attr_id,
+                             hid_t es_id);
+#else
+H5_DLL herr_t H5Aclose_async(hid_t attr_id, hid_t es_id);
+#endif
+/* --------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Creates an attribute attached to a specified object
+ *
+ * \fgdt_loc_id
+ * \param[in] attr_name  Name of attribute
+ * \param[in] type_id    Attribute datatype identifier
+ * \space_id
+ * \acpl_id
+ * \aapl_id
+ *
+ * \return \hid_tv{attribute}
+ *
+ * \details H5Acreate2() creates an attribute, \p attr_name, which is attached
+ *          to the object specified by the identifier \p loc_id.
+ *
+ *          The attribute name, \p attr_name, must be unique for the object.
+ *
+ *          The attribute is created with the specified datatype and dataspace,
+ *          \p type_id and \p space_id.
+ *
+ *          \plist_unused{aapl_id}
+ *
+ *          The attribute identifier returned by this function must be released
+ *          with H5Aclose() or resource leaks will develop.
+ *
+ * \note If \p loc_id is a file identifier, the attribute will be attached to
+ *       that file's root group.
+ *
+ * \par Example
+ * \snippet H5A_examples.c create
+ *
+ * \since 1.8.0
+ *
+ * \see H5Aclose()
+ *
+ */
+H5_DLL hid_t H5Acreate2(hid_t loc_id, const char *attr_name, hid_t type_id, hid_t space_id, hid_t acpl_id,
+                        hid_t aapl_id);
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup ASYNC
+ * \async_variant_of{H5Acreate}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Acreate_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                             const char *attr_name, hid_t type_id, hid_t space_id, hid_t acpl_id,
+                             hid_t aapl_id, hid_t es_id);
+#else
+H5_DLL hid_t  H5Acreate_async(hid_t loc_id, const char *attr_name, hid_t type_id, hid_t space_id,
+                              hid_t acpl_id, hid_t aapl_id, hid_t es_id);
+#endif
+
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief  Creates an attribute attached to a specified object
+ *
+ * \fgdt_loc_id
+ * \param[in] obj_name  Name, relative to \p loc_id, of object that
+ *                      attribute is to be attached to
+ * \param[in] attr_name Attribute name
+ * \param[in] type_id   Attribute datatype identifier
+ * \space_id
+ * \acpl_id
+ * \aapl_id
+ * \lapl_id
+ *
+ * \return \hid_tv{attribute}
+ *
+ * \details H5Acreate_by_name() creates an attribute, \p attr_name, which is
+ *          attached to the object specified by \p loc_id and \p obj_name.
+ *
+ *          \p loc_id is a location identifier; \p obj_name is the object
+ *          name relative to \p loc_id.
+ *
+ *          The attribute name, \p attr_name, must be unique for the object.
+ *
+ *          The attribute is created with the specified datatype and
+ *          dataspace, \p type_id and \p space_id.
+ *
+ *          \plist_unused{aapl_id}
+ *
+ *          The link access property list, \p lapl_id, may provide
+ *          information regarding the properties of links required to access
+ *          the object, \p obj_name.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Acreate_by_name(hid_t loc_id, const char *obj_name, const char *attr_name, hid_t type_id,
+                               hid_t space_id, hid_t acpl_id, hid_t aapl_id, hid_t lapl_id);
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup ASYNC
+ * \async_variant_of{H5Acreate_by_name}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Acreate_by_name_async(const char *app_file, const char *app_func, unsigned app_line,
+                                     hid_t loc_id, const char *obj_name, const char *attr_name, hid_t type_id,
+                                     hid_t space_id, hid_t acpl_id, hid_t aapl_id, hid_t lapl_id,
+                                     hid_t es_id);
+#else
+H5_DLL hid_t H5Acreate_by_name_async(hid_t loc_id, const char *obj_name, const char *attr_name, hid_t type_id,
+                                     hid_t space_id, hid_t acpl_id, hid_t aapl_id, hid_t lapl_id,
+                                     hid_t es_id);
+#endif
+
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Deletes an attribute from a specified location
+ *
+ * \fgdt_loc_id
+ * \param[in] attr_name  Name of the attribute to delete
+ *
+ * \return \herr_t
+ *
+ * \details H5Adelete() removes the attribute specified by its name,
+ *          \p attr_name, from a file, dataset, group, or named datatype.
+ *
+ * \attention This function should not be used when other attribute identifiers
+ *            are open on \p loc_id. This may cause the internal indexes of
+ *            the attributes to change and future writes to the open
+ *            attributes to produce incorrect results.
+ *
+ * \par Example
+ * \snippet H5A_examples.c delete
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Adelete(hid_t loc_id, const char *attr_name);
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Deletes an attribute from an object according to index order
+ *
+ * \fgdt_loc_id
+ * \param[in] obj_name Name of object, relative to location, from which
+ *                     attribute is to be removed
+ * \param[in] idx_type Type of index
+ * \param[in] order    Order in which to iterate over the index
+ * \param[in] n        Offset within the index
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Adelete_by_idx() removes an attribute specified by its
+ *          location in an index, from an object.
+ *
+ *          The object from which the attribute is to be removed is
+ *          specified by a location identifier and name, \p loc_id and
+ *          \p obj_name, respectively.
+ *
+ *          The attribute to be removed is specified by a position in an
+ *          index, \p n. The type of index is specified by \p idx_type.
+ *          The order in which the index is to be traversed is specified by
+ *          \p order. For example, if \p idx_type, \p order,
+ *          and \p n are set to #H5_INDEX_NAME, #H5_ITER_INC, and 5,
+ *          respectively, the fifth attribute in the lexicographic order of
+ *          attribute names will be removed.
+ *
+ *          The link access property list, \p lapl_id, may provide
+ *          information regarding the properties of links required to access
+ *          the object, \p obj_name.
+
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Adelete_by_idx(hid_t loc_id, const char *obj_name, H5_index_t idx_type, H5_iter_order_t order,
+                               hsize_t n, hid_t lapl_id);
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Removes an attribute from a specified location
+ *
+ * \fgdt_loc_id
+ * \param[in] obj_name  Name of object, relative to location, from which
+ *                      attribute is to be removed
+ * \param[in] attr_name Name of attribute to delete
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Adelete_by_name() removes the attribute \p attr_name
+ *          from an object specified by location and name, \p loc_id and
+ *          \p obj_name, respectively.
+ *
+ *          The link access property list, \p lapl_id, may provide
+ *          information regarding the properties of links required to
+ *          access the object, \p obj_name.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Adelete_by_name(hid_t loc_id, const char *obj_name, const char *attr_name, hid_t lapl_id);
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Determines whether an attribute with a given name exists on an
+ *        object
+ *
+ * \fgdt_loc_id{obj_id}
+ * \param[in] attr_name  Attribute name
+ *
+ * \return \htri_t
+ *
+ * \details H5Aexists() determines whether the attribute \p attr_name
+ *          exists on the object specified by \p obj_id.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL htri_t H5Aexists(hid_t obj_id, const char *attr_name);
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup ASYNC
+ * \async_variant_of{H5Aexists}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Aexists_async(const char *app_file, const char *app_func, unsigned app_line, hid_t obj_id,
+                              const char *attr_name, hbool_t *exists, hid_t es_id);
+#else
+H5_DLL herr_t H5Aexists_async(hid_t obj_id, const char *attr_name, hbool_t *exists, hid_t es_id);
+#endif
+
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief  Determines whether an attribute with a given name exists on an
+ *         object
+ *
+ * \fgdt_loc_id{obj_id}
+ * \param[in] obj_name  Object name
+ * \param[in] attr_name Attribute name
+ * \lapl_id
+ *
+ * \return \htri_t
+ *
+ * \details H5Aexists_by_name() determines whether the attribute
+ *          \p attr_name exists on an object. That object is specified by
+ *          its location and name, \p loc_id and \p obj_name, respectively.
+ *
+ *          \p loc_id specifies a location in the file containing the object.
+ *          \p obj_name is the name of the object to which the attribute is
+ *          attached and can be a relative name, relative to \p loc_id,
+ *          or an absolute name, based on the root group of the file.
+ *
+ *          The link access property list, \p lapl_id, may provide
+ *          information regarding the properties of links required to access
+ *          \p obj_name.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL htri_t H5Aexists_by_name(hid_t obj_id, const char *obj_name, const char *attr_name, hid_t lapl_id);
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup ASYNC
+ * \async_variant_of{H5Aexists_by_name}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Aexists_by_name_async(const char *app_file, const char *app_func, unsigned app_line,
+                                      hid_t loc_id, const char *obj_name, const char *attr_name,
+                                      hbool_t *exists, hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL herr_t H5Aexists_by_name_async(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                      hbool_t *exists, hid_t lapl_id, hid_t es_id);
+#endif
+
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Gets an attribute creation property list identifier
+ *
+ * \attr_id
+ *
+ * \return \hid_tv{attribute's creation property list}
+ *
+ * \details H5Aget_create_plist() returns an identifier for the attribute
+ *          creation property list associated with the attribute specified
+ *          by \p attr_id.
+ *
+ *          The creation property list identifier should be released with
+ *          H5Pclose() to prevent resource leaks.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Aget_create_plist(hid_t attr_id);
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Retrieves attribute information by attribute identifier
+ *
+ * \attr_id
+ * \param[out]  ainfo   Attribute information struct
+ *
+ * \return \herr_t
+ *
+ * \details H5Aget_info() retrieves attribute information, locating the
+ *          attribute with an attribute identifier, \p attr_id. The
+ *          attribute information is returned in the \p ainfo struct.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Aget_info(hid_t attr_id, H5A_info_t *ainfo /*out*/);
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Retrieves attribute information by attribute index position
+ *
+ * \fgdt_loc_id
+ * \param[in]  obj_name  Name of object to which attribute is attached,
+ *                       relative to location
+ * \param[in]  idx_type  Type of index
+ * \param[in]  order     Index traversal order
+ * \param[in]  n         Attribute's position in index
+ * \param[out] ainfo     Struct containing returned attribute information
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Aget_info_by_idx() retrieves information for an attribute
+ *          that is attached to an object, which is specified by its
+ *          location and name, \p loc_id and \p obj_name, respectively.
+ *          The attribute is located by its index position, and the attribute
+ *          information is returned in the \p ainfo struct.
+ *
+ *          The attribute is located by means of an index type, an index
+ *          traversal order, and a position in the index, \p idx_type,
+ *          \p order and \p n, respectively.
+ *
+ *          The link access property list, \p lapl_id, may provide
+ *          information regarding the properties of links required to access
+ *          the object, \p obj_name.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Aget_info_by_idx(hid_t loc_id, const char *obj_name, H5_index_t idx_type,
+                                 H5_iter_order_t order, hsize_t n, H5A_info_t *ainfo /*out*/, hid_t lapl_id);
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Retrieves attribute information by attribute name
+ *
+ * \fgdt_loc_id
+ * \param[in] obj_name   Name of the object to which an attribute is attached,
+ *                       relative to location
+ * \param[in] attr_name  Attribute name
+ * \param[out] ainfo     Struct containing returned attribute information
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Aget_info_by_name() retrieves information for an attribute,
+ *          \p attr_name, that is attached to an object specified by its
+ *          location and name, \p loc_id and \p obj_name, respectively.
+ *          The attribute information is returned in the \p ainfo struct.
+ *
+ *          The link access property list, \p lapl_id, may provide
+ *          information regarding the properties of links required to
+ *          access the object, \p obj_name.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Aget_info_by_name(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                  H5A_info_t *ainfo /*out*/, hid_t lapl_id);
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Gets an attribute name
+ *
+ * \attr_id
+ * \param[in]  buf_size  The size of the buffer to store the name in
+ * \param[out] buf       Buffer to store name in
+ *
+ * \return  Returns the length of the attribute's name, which may be longer
+ *          than \p buf_size, if successful. Otherwise, returns a negative
+ *          value.
+ *
+ * \details H5Aget_name() retrieves the name of an attribute specified by
+ *          the identifier, \p attr_id. Up to \p buf_size characters are
+ *          stored in \p buf followed by a \0 string terminator. If the
+ *          name of the attribute is longer than (\p buf_size -1), the
+ *          string terminator is stored in the last position of the buffer
+ *          to properly terminate the string.
+ *
+ *          If the user only wants to retrieve the name length, the
+ *          values 0 and NULL should be passed for the parameters
+ *          \p bufsize and \p buf.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL ssize_t H5Aget_name(hid_t attr_id, size_t buf_size, char *buf);
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Gets an attribute name by attribute index position
+ *
+ * \fgdt_loc_id
+ * \param[in]  obj_name   Name of object to which attribute is attached,
+ *                        relative to location
+ * \param[in]  idx_type   Type of index
+ * \param[in]  order      Index traversal order
+ * \param[in]  n          Attribute's position in index
+ * \param[out] name       Attribute name
+ * \param[in]  size       Size, in bytes, of attribute name
+ * \lapl_id
+ *
+ * \return Returns attribute name size, in bytes, if successful;
+ *         otherwise, returns a negative value.
+ *
+ * \details H5Aget_name_by_idx() retrieves the name of an attribute that is
+ *          attached to an object, which is specified by its location and
+ *          name, \p loc_id and \p obj_name, respectively. The attribute is
+ *          located by its index position, the size of the name is specified
+ *          in \p size, and the attribute name is returned in \p name.
+ *
+ *          The attribute is located by means of an index type, an index
+ *          traversal order, and a position in the index, \p idx_type,
+ *          \p order and \p n, respectively.
+ *
+ *          If the attribute name's size is unknown, the values 0 and NULL
+ *          can be passed in for the parameters \p size and \p name. The
+ *          function's return value will provide the correct value for
+ *          \p size.
+ *
+ *          The link access property list, \p lapl_id, may provide
+ *          information regarding the properties of links required to access
+ *          the object, \p obj_name.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL ssize_t H5Aget_name_by_idx(hid_t loc_id, const char *obj_name, H5_index_t idx_type,
+                                  H5_iter_order_t order, hsize_t n, char *name /*out*/, size_t size,
+                                  hid_t lapl_id);
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Gets a copy of the dataspace for an attribute
+ *
+ * \attr_id
+ *
+ * \return \hid_tv{attribute dataspace}
+ *
+ * \details  H5Aget_space() retrieves a copy of the dataspace for an
+ *           attribute. The dataspace identifier returned from this
+ *           function must be released with H5Sclose() or resource leaks
+ *           will develop.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL hid_t H5Aget_space(hid_t attr_id);
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Returns the amount of storage used to store an attribute
+ *
+ * \attr_id
+ *
+ * \return Returns the amount of storage size allocated for the attribute;
+ *         otherwise, returns 0 (zero).
+ *
+ * \details H5Aget_storage_size() returns the amount of storage that is
+ *          required for the specified attribute, \p attr_id.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL hsize_t H5Aget_storage_size(hid_t attr_id);
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Gets an attribute's datatype
+ *
+ * \attr_id
+ *
+ * \return \hid_t{datatype}
+ *
+ * \details H5Aget_type() retrieves a copy of the attribute's datatype.
+ *          The datatype is reopened if it is a named type before returning
+ *          it to the application. The datatypes returned by this function
+ *          are always read-only.
+ *
+ *          The datatype identifier returned from this function must be
+ *          released with H5Tclose() or resource leaks will develop.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL hid_t H5Aget_type(hid_t attr_id);
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Calls a user-defined function for each attribute on an object
+ *
+ * \fgdt_loc_id
+ * \param[in]     idx_type Type of index
+ * \param[in]     order    Order in which to iterate over index
+ * \param[in,out] idx      Initial and returned offset within index
+ * \param[in]     op       User-defined function to pass each attribute to
+ * \param[in,out] op_data  User data to pass through to and to be returned
+ *                         by iterator operator function
+ *
+ * \return \herr_t
+ *       Further note that this function returns the return value of the
+ *       last operator if it was non-zero, which can be a negative value,
+ *       zero if all attributes were processed, or a positive value
+ *       indicating short-circuit success.
+ *
+ * \details H5Aiterate2() iterates over the attributes attached to a
+ *          dataset, named datatype, or group, as specified by \p loc_id.
+ *          For each attribute, user-provided data, \p op_data, with
+ *          additional information, as defined below, is passed to a
+ *          user-defined function, \p op, which operates on that
+ *          attribute.
+ *
+ *          The order of the iteration and the attributes iterated over
+ *          are specified by three parameters: the index type,
+ *          \p idx_type; the order in which the index is to be traversed,
+ *          \p order; and the attribute's position in the index, \p idx.
+ *          The next attribute to be operated on is specified by \p idx,
+ *          a position in the index.
+ *
+ *          For example, if \p idx_type, \p order, and \p idx are set to
+ *          #H5_INDEX_NAME, #H5_ITER_INC, and 5, respectively, the attribute
+ *          in question is the fifth attribute from the beginning of the
+ *          alphanumeric index of attribute names. If \p order were set to
+ *          #H5_ITER_DEC, it would be the fifth attribute from the end of
+ *          the index.
+ *
+ *          The parameter \p idx is passed in on an H5Aiterate2() call with
+ *          one value and may be returned with another value. The value
+ *          passed in identifies the parameter to be operated on first;
+ *          the value returned identifies the parameter to be operated on
+ *          in the next step of the iteration.
+ *
+ * \note This function is also available through the H5Aiterate() macro.
+ *
+ * \warning   Adding or removing attributes to the object during iteration
+ *            will lead to undefined behavior.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Aiterate2(hid_t loc_id, H5_index_t idx_type, H5_iter_order_t order, hsize_t *idx,
+                          H5A_operator2_t op, void *op_data);
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Calls user-defined function for each attribute on an object
+ *
+ * \fgdt_loc_id
+ * \param[in] obj_name    Name of object, relative to location
+ * \param[in] idx_type    Type of index
+ * \param[in] order       Order in which to iterate over index
+ * \param[in,out] idx     Initial and returned offset within index
+ * \param[in] op          User-defined function to pass each attribute to
+ * \param[in,out] op_data User data to pass through to and to be returned
+ *                        by iterator operator function
+ * \lapl_id
+ *
+ * \return \herr_t
+ *         Further note that this function returns the return value of
+ *         the last operator if it is non-zero, which can be a negative
+ *         value, zero if all attributes were processed, or a positive value
+ *         indicating short-circuit success.
+ *
+ * \details H5Aiterate_by_name() iterates over the attributes attached
+ *          to the dataset or group specified with \p loc_id and \p obj_name.
+ *          For each attribute, user-provided data, \p op_data, with
+ *          additional information, as defined below, is passed to a
+ *          user-defined function, \p op, which operates on that attribute.
+ *
+ *          The order of the iteration and the attributes iterated over
+ *          are specified by three parameters: the index type, \p idx_type;
+ *          the order in which the index is to be traversed, \p order;
+ *          and the attribute's position in the index, \p idx.
+ *          The next attribute to be operated on is specified by \p idx,
+ *          a position in the index.
+ *
+ *          For example, if \p idx_type, \p order, and \p idx are set to
+ *          #H5_INDEX_NAME, #H5_ITER_INC, and 5, respectively, the attribute
+ *          in question is the fifth attribute from the beginning of the
+ *          alphanumeric index of attribute names. If \p order were set to
+ *          #H5_ITER_DEC, it would be the fifth attribute from the end of
+ *          the index.
+ *
+ *          The parameter \p idx is passed in on an H5Aiterate_by_name()
+ *          call with one value and may be returned with another value. The
+ *          value passed in identifies the parameter to be operated on first;
+ *          the value returned identifies the parameter to be operated on in
+ *          the next step of the iteration.
+ *
+ *          The link access property list, \p lapl_id, may provide
+ *          information regarding the properties of links required to access
+ *          the object, \p obj_name.
+ *
+ * \warning   Adding or removing attributes to the object during iteration
+ *            will lead to undefined behavior.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Aiterate_by_name(hid_t loc_id, const char *obj_name, H5_index_t idx_type,
+                                 H5_iter_order_t order, hsize_t *idx, H5A_operator2_t op, void *op_data,
+                                 hid_t lapl_id);
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Opens an attribute for an object specified by object identifier and
+ *        attribute name
+ *
+ * \fgdt_loc_id{obj_id}
+ * \param[in]  attr_name    Name of attribute to open
+ * \aapl_id
+ *
+ * \return \hid_tv{attribute}
+ *
+ * \details H5Aopen() opens an existing attribute, \p attr_name, that is
+ *          attached to the object specified by an object identifier, \p obj_id.
+ *
+ *          \plist_unused{aapl_id}
+ *
+ *          This function, H5Aopen_by_idx() or H5Aopen_by_name() must be called
+ *          before the attribute can be accessed for any further purpose,
+ *          including reading, writing, or any modification.
+ *
+ *          The attribute identifier returned by this function must be released
+ *          with H5Aclose() or resource leaks will develop.
+ *
+ * \par Example
+ * \snippet H5A_examples.c read
+ *
+ * \since 1.8.0
+ *
+ * \see H5Aclose(), H5Acreate()
+ */
+H5_DLL hid_t H5Aopen(hid_t obj_id, const char *attr_name, hid_t aapl_id);
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup ASYNC
+ * \async_variant_of{H5Aopen}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Aopen_async(const char *app_file, const char *app_func, unsigned app_line, hid_t obj_id,
+                           const char *attr_name, hid_t aapl_id, hid_t es_id);
+#else
+H5_DLL hid_t  H5Aopen_async(hid_t obj_id, const char *attr_name, hid_t aapl_id, hid_t es_id);
+#endif
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Opens the nth attribute attached to an object
+ *
+ * \loc_id
+ * \param[in] obj_name  Name of object to which attribute is attached,
+ *                      relative to location
+ * \param[in] idx_type  Type of index
+ * \param[in] order     Index traversal order
+ * \param[in] n         Attribute's position in index
+ * \aapl_id
+ * \lapl_id
+ *
+ * \return \hid_tv{attribute}
+ *
+ * \details H5Aopen_by_idx() opens an existing attribute that is attached
+ *          to an object specified by location and name, \p loc_id and
+ *          \p obj_name, respectively.
+ *
+ *          The attribute is identified by an index type, an index traversal
+ *          order, and a position in the index, \p idx_type, \p order and
+ *          \p n, respectively.
+ *
+ *          \plist_unused{aapl_id}
+ *
+ *          The link access property list, \p lapl_id, may provide
+ *          information regarding the properties of links required to access
+ *          the object, \p obj_name.
+ *
+ *          This function, H5Aopen(), or H5Aopen_by_name() must be called
+ *          before an attribute can be accessed for any further purpose,
+ *          including reading, writing, or any modification.
+ *
+ *          The attribute identifier returned by this function must be
+ *          released with H5Aclose() or resource leaks will develop.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Aopen_by_idx(hid_t loc_id, const char *obj_name, H5_index_t idx_type, H5_iter_order_t order,
+                            hsize_t n, hid_t aapl_id, hid_t lapl_id);
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup ASYNC
+ * \async_variant_of{H5Aopen_by_idx}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Aopen_by_idx_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                                  const char *obj_name, H5_index_t idx_type, H5_iter_order_t order, hsize_t n,
+                                  hid_t aapl_id, hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL hid_t  H5Aopen_by_idx_async(hid_t loc_id, const char *obj_name, H5_index_t idx_type,
+                                   H5_iter_order_t order, hsize_t n, hid_t aapl_id, hid_t lapl_id,
+                                   hid_t es_id);
+#endif
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Opens an attribute for an object by object name and attribute name
+ *
+ * \fgdt_loc_id
+ * \param[in] obj_name   Name of object to which attribute is attached,
+ *                       relative to \p loc_id
+ * \param[in] attr_name  Name of attribute to open
+ * \aapl_id
+ * \lapl_id
+ *
+ * \return \hid_tv{attribute}
+ *
+ * \details H5Aopen_by_name() opens an existing attribute, \p attr_name,
+ *          that is attached to an object specified by location and name,
+ *          \p loc_id and \p obj_name, respectively.
+ *
+ *          \p loc_id specifies a location from which the target object can
+ *          be located and \p obj_name is an object name relative to
+ *          \p loc_id.
+ *
+ *          \plist_unused{aapl_id}
+ *
+ *          The link access property list, \p lapl_id, may provide
+ *          information regarding the properties of links required to access
+ *          the object, \p obj_name.
+ *
+ *          This function, H5Aopen(), or H5Aopen_by_idx() must be called
+ *          before an attribute can be accessed for any further purpose,
+ *          including reading, writing, or any modification.
+ *
+ *          The attribute identifier returned by this function must be
+ *          released with H5Aclose() or resource leaks will develop.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Aopen_by_name(hid_t loc_id, const char *obj_name, const char *attr_name, hid_t aapl_id,
+                             hid_t lapl_id);
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup ASYNC
+ * \async_variant_of{H5Aopen_by_name}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Aopen_by_name_async(const char *app_file, const char *app_func, unsigned app_line,
+                                   hid_t loc_id, const char *obj_name, const char *attr_name, hid_t aapl_id,
+                                   hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL hid_t  H5Aopen_by_name_async(hid_t loc_id, const char *obj_name, const char *attr_name, hid_t aapl_id,
+                                    hid_t lapl_id, hid_t es_id);
+#endif
+
+/*-------------------------------------------------------------------------- */
+/**
+ * \ingroup H5A
+ *
+ * \brief Reads the value of an attribute
+ *
+ * \attr_id
+ * \mem_type_id{type_id}
+ * \param[out] buf        Buffer for data to be read
+ *
+ * \return \herr_t
+ *
+ * \details H5Aread() reads an attribute, specified with \p attr_id. The
+ *          attribute's in-memory datatype is specified with \p type_id. The
+ *          entire attribute is read into \p buf from the file.
+ *
+ *          Datatype conversion takes place at the time of a read or write and
+ *          is automatic.
+ *
+ * \par Example
+ * \snippet H5A_examples.c read
+ *
+ * \version 1.8.8  Fortran updated to Fortran2003.
+ * \version 1.4.2  The \p dims parameter was added to the Fortran API in this
+ *                 release.
+ * \since   1.0.0
+ *
+ * \see H5Awrite()
+ *
+ */
+H5_DLL herr_t H5Aread(hid_t attr_id, hid_t type_id, void *buf);
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup ASYNC
+ * \async_variant_of{H5Aread}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Aread_async(const char *app_file, const char *app_func, unsigned app_line, hid_t attr_id,
+                            hid_t dtype_id, void *buf, hid_t es_id);
+#else
+H5_DLL herr_t H5Aread_async(chid_t attr_id, hid_t dtype_id, void *buf, hid_t es_id);
+#endif
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Renames an attribute
+ *
+ * \fgdt_loc_id
+ * \param[in] old_name   Name of the attribute to be changed
+ * \param[in] new_name   New name for the attribute
+ *
+ * \return \herr_t
+ *
+ * \details H5Arename() changes the name of the attribute located at
+ *          \p loc_id.
+ *
+ *          The old name, \p old_name, is changed to the new name,
+ *          \p new_name.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Arename(hid_t loc_id, const char *old_name, const char *new_name);
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup ASYNC
+ * \async_variant_of{H5Arename}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Arename_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                              const char *old_name, const char *new_name, hid_t es_id);
+#else
+H5_DLL herr_t H5Arename_async(hid_t loc_id, const char *old_name, const char *new_name, hid_t es_id);
+#endif
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup ASYNC
+ * \async_variant_of{H5Arename_by_name}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Arename_by_name_async(const char *app_file, const char *app_func, unsigned app_line,
+                                      hid_t loc_id, const char *obj_name, const char *old_attr_name,
+                                      const char *new_attr_name, hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL herr_t H5Arename_by_name_async(hid_t loc_id, const char *obj_name, const char *old_attr_name,
+                                      const char *new_attr_name, hid_t lapl_id, hid_t es_id);
+#endif
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Writes data to an attribute
+ *
+ * \attr_id
+ * \mem_type_id{type_id}
+ * \param[out]  buf       Data to be written
+ *
+ * \return \herr_t
+ *
+ * \details H5Awrite() writes an attribute, specified with \p attr_id. The
+ *          attribute's in-memory datatype is specified with \p type_id.
+ *          The entire attribute is written from \p buf to the file.
+ *
+ *          Datatype conversion takes place at the time of a read or write and
+ *          is automatic.
+ *
+ * \par Example
+ * \snippet H5A_examples.c update
+ *
+ * \version 1.8.8   Fortran updated to Fortran2003.
+ * \version 1.4.2   Fortran \p dims parameter added in this release
+ * \since 1.0.0
+ * \see H5Aread()
+ *
+ */
+H5_DLL herr_t H5Awrite(hid_t attr_id, hid_t type_id, const void *buf);
+/*--------------------------------------------------------------------------*/
+/**
+ * \ingroup ASYNC
+ * \async_variant_of{H5Awrite}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Awrite_async(const char *app_file, const char *app_func, unsigned app_line, hid_t attr_id,
+                             hid_t type_id, const void *buf, hid_t es_id);
+#else
+H5_DLL herr_t H5Awrite_async(hid_t attr_id, hid_t type_id, const void *buf, hid_t es_id);
+#endif
+/*-------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \fgdt_loc_id
+ * \param[in] obj_name      Name of object, relative to location, whose
+ *                          attribute is to be renamed
+ * \param[in] old_attr_name Prior attribute name
+ * \param[in] new_attr_name New attribute name
+ * \lapl_id
+ *
+ * \details H5Arename_by_name() changes the name of attribute that is
+ *          attached to the object specified by \p loc_id and \p obj_name.
+ *          The attribute named \p old_attr_name is renamed
+ *          \p new_attr_name.
+ *
+ *          The link access property list, \p lapl_id, may provide
+ *          information regarding the properties of links required to
+ *          access the object, \p obj_name.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Arename_by_name(hid_t loc_id, const char *obj_name, const char *old_attr_name,
+                                const char *new_attr_name, hid_t lapl_id);
+
+/// \cond DEV
+/* API Wrappers for async routines */
+/* (Must be defined _after_ the function prototype) */
+/* (And must only defined when included in application code, not the library) */
+#ifndef H5A_MODULE
+#define H5Acreate_async(...)         H5Acreate_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Acreate_by_name_async(...) H5Acreate_by_name_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Aopen_async(...)           H5Aopen_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Aopen_by_name_async(...)   H5Aopen_by_name_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Aopen_by_idx_async(...)    H5Aopen_by_idx_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Awrite_async(...)          H5Awrite_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Aread_async(...)           H5Aread_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Arename_async(...)         H5Arename_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Arename_by_name_async(...) H5Arename_by_name_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Aexists_async(...)         H5Aexists_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Aexists_by_name_async(...) H5Aexists_by_name_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Aclose_async(...)          H5Aclose_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+
+/* Define "wrapper" versions of function calls, to allow compile-time values to
+ *      be passed in by language wrapper or library layer on top of HDF5.
+ */
+#define H5Acreate_async_wrap         H5_NO_EXPAND(H5Acreate_async)
+#define H5Acreate_by_name_async_wrap H5_NO_EXPAND(H5Acreate_by_name_async)
+#define H5Aopen_async_wrap           H5_NO_EXPAND(H5Aopen_async)
+#define H5Aopen_by_name_async_wrap   H5_NO_EXPAND(H5Aopen_by_name_async)
+#define H5Aopen_by_idx_async_wrap    H5_NO_EXPAND(H5Aopen_by_idx_async)
+#define H5Awrite_async_wrap          H5_NO_EXPAND(H5Awrite_async)
+#define H5Aread_async_wrap           H5_NO_EXPAND(H5Aread_async)
+#define H5Arename_async_wrap         H5_NO_EXPAND(H5Arename_async)
+#define H5Arename_by_name_async_wrap H5_NO_EXPAND(H5Arename_by_name_async)
+#define H5Aexists_async_wrap         H5_NO_EXPAND(H5Aexists_async)
+#define H5Aexists_by_name_async_wrap H5_NO_EXPAND(H5Aexists_by_name_async)
+#define H5Aclose_async_wrap          H5_NO_EXPAND(H5Aclose_async)
+#endif /* H5A_MODULE */
+/// \endcond
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+
+/* Typedefs */
+
+//! <!-- [H5A_operator1_t_snip] -->
+/**
+ * \brief Typedef for H5Aiterate1() callbacks
+ *
+ * \param[in] location_id The identifier for the group, dataset
+ *            or named datatype being iterated over
+ * \param[in] attr_name The name of the current object attribute
+ * \param[in,out] operator_data A pointer to the operator data passed into
+ *                H5Aiterate1()
+ * \returns The return values from an operator are:
+ *          \li Zero causes the iterator to continue, returning zero when
+ *              all attributes have been processed.
+ *          \li Positive causes the iterator to immediately return that
+ *              positive value, indicating short-circuit success. The
+ *              iterator can be restarted at the next attribute.
+ *          \li Negative causes the iterator to immediately return that value,
+ *              indicating failure. The iterator can be restarted at the next
+ *              attribute.
+ */
+typedef herr_t (*H5A_operator1_t)(hid_t location_id /*in*/, const char *attr_name /*in*/,
+                                  void *operator_data /*in,out*/);
+//! <!-- [H5A_operator1_t_snip] -->
+
+/* Function prototypes */
+/* --------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Creates an attribute attached to a specified object
+ *
+ * \fgdt_loc_id
+ * \param[in] name     Name of attribute to locate and open
+ * \param[in] type_id  Identifier of attribute datatype
+ * \space_id
+ * \acpl_id
+ *
+ * \return \hid_tv{attribute}
+ *
+ * \deprecation_note{H5Acreate2()}
+ *
+ * \plist_unused{acpl}
+ *
+ * \details H5Acreate1() creates an attribute, \p name, which is attached
+ *          to the object specified by the identifier \p loc_id.
+ *
+ *          The attribute name, \p name, must be unique for the object.
+ *
+ *          The attribute is created with the specified datatype and dataspace,
+ *          \p type_id and \p space_id.
+ *
+ * \since 1.8.0
+ *
+ * \version 1.8.0 The function H5Acreate() was renamed to H5Acreate1() and
+ *          deprecated in this release.
+ *
+ * \see H5Aclose()
+ *
+ */
+H5_DLL hid_t H5Acreate1(hid_t loc_id, const char *name, hid_t type_id, hid_t space_id, hid_t acpl_id);
+/* --------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Determines the number of attributes attached to an object
+ *
+ * \fgdt_loc_id
+ *
+ * \return Returns the number of attributes if successful; otherwise, returns
+ *         a negative value.
+ *
+ * \deprecation_note{H5Oget_info(), H5Oget_info_by_name(), and H5Oget_info_by_idx()}
+ *
+ * \details H5Aget_num_attrs() returns the number of attributes attached to
+ *          the object specified by its identifier, \p loc_id.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL int H5Aget_num_attrs(hid_t loc_id);
+/* --------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Calls a user's function for each attribute on an object
+ *
+ * \loc_id
+ * \param[in,out] idx     Starting (in) and ending (out) attribute index
+ * \param[in]     op      User's function to pass each attribute to
+ * \param[in,out] op_data User's data to pass through to the iterator operator
+ *                        function
+ *
+ * \return \herr_t
+ *
+ * \deprecation_note{H5Aiterate2()}
+ *
+ * \details H5Aiterate1() iterates over the attributes of the object
+ *          specified by its identifier, \p loc_id. The object can be a
+ *          group, dataset, or named datatype. For each attribute of the
+ *          object, the \p op_data and some additional information specified
+ *          below are passed to the operator function \p op. The iteration
+ *          begins with the attribute specified by its index, \p idx; the
+ *          index for the next attribute to be processed by the operator,
+ *          \p op, is returned in \p idx. If \p idx is the null pointer,
+ *          then all attributes are processed.
+ *
+ * \warning   Adding or removing attributes to the object during iteration
+ *            will lead to undefined behavior.
+ *
+ * \version 1.8.0 The function \p H5Aiterate was renamed to H5Aiterate1()
+ *                and deprecated in this release.
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Aiterate1(hid_t loc_id, unsigned *idx, H5A_operator1_t op, void *op_data);
+/* --------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Opens the attribute specified by its index
+ *
+ * \loc_id
+ * \param[in] idx Index of the attribute to open
+ *
+ * \return \hid_tv{attribute}
+ *
+ * \deprecation_note{H5Aopen_by_idx()}
+ *
+ * \details H5Aopen_idx() opens an attribute that is attached to the
+ *          object specified with \p loc_id. The location object may be
+ *          either a group, dataset, or named datatype, all of which may
+ *          have any sort of attribute. The attribute specified by the index,
+ *          \p idx, indicates the attribute to access. The value of \p idx
+ *          is a 0-based, non-negative integer. The attribute identifier
+ *          returned from this function must be released with H5Aclose()
+ *          or resource leaks will develop.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL hid_t H5Aopen_idx(hid_t loc_id, unsigned idx);
+/* --------------------------------------------------------------------------*/
+/**
+ * \ingroup H5A
+ *
+ * \brief Opens an attribute specified by name
+ *
+ * \loc_id
+ * \param[in] name Attribute name
+ *
+ * \return \hid_tv{attribute}
+ *
+ * \deprecation_note{H5Aopen_by_name()}
+ *
+ * \details H5Aopen_name() opens an attribute specified by its name,
+ *          \p name, which is attached to the object specified with
+ *          \p loc_id. The location object may be either a group, dataset,
+ *          or named datatype, which may have any sort of attribute. The
+ *          attribute identifier returned from this function must be
+ *          released with H5Aclose() or resource leaks will develop.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL hid_t H5Aopen_name(hid_t loc_id, const char *name);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5Apublic_H */
diff --git a/install/include/H5Cpublic.h b/install/include/H5Cpublic.h
new file mode 100644
index 0000000000..69c86cdef9
--- /dev/null
+++ b/install/include/H5Cpublic.h
@@ -0,0 +1,56 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:     H5Cpublic.h
+ *
+ * Purpose:     Public header file for cache functions
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef H5Cpublic_H
+#define H5Cpublic_H
+
+#include "H5public.h" /* Generic Functions                        */
+
+enum H5C_cache_incr_mode {
+    H5C_incr__off,
+    /**<Automatic cache size increase is disabled, and the remaining increment fields are ignored.*/
+
+    H5C_incr__threshold
+    /**<Automatic cache size increase is enabled using the hit rate threshold algorithm.*/
+};
+
+enum H5C_cache_flash_incr_mode {
+    H5C_flash_incr__off,
+    /**<Flash cache size increase is disabled.*/
+
+    H5C_flash_incr__add_space
+    /**<Flash cache size increase is enabled using the add space algorithm.*/
+};
+
+enum H5C_cache_decr_mode {
+    H5C_decr__off,
+    /**<Automatic cache size decrease is disabled.*/
+
+    H5C_decr__threshold,
+    /**<Automatic cache size decrease is enabled  using the hit rate threshold algorithm.*/
+
+    H5C_decr__age_out,
+    /**<Automatic cache size decrease is enabled using the ageout algorithm. */
+
+    H5C_decr__age_out_with_threshold
+    /**<Automatic cache size decrease is enabled using the ageout with hit rate threshold algorithm.*/
+};
+
+#endif
diff --git a/install/include/H5DOpublic.h b/install/include/H5DOpublic.h
new file mode 100644
index 0000000000..887e65973e
--- /dev/null
+++ b/install/include/H5DOpublic.h
@@ -0,0 +1,250 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef H5DOpublic_H
+#define H5DOpublic_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** \page H5DO_UG The HDF5 High Level Optimizations
+ * @todo Under Construction
+ */
+
+/**\defgroup H5DO HDF5 Optimizations APIs (H5DO)
+ *
+ * <em>Bypassing default HDF5 behavior in order to optimize for specific
+ * use cases (H5DO)</em>
+ *
+ * HDF5 functions described is this section are implemented in the HDF5 High-level
+ * library as optimized functions. These functions generally require careful setup
+ * and testing as they enable an application to bypass portions of the HDF5
+ * library's I/O pipeline for performance purposes.
+ *
+ * These functions are distributed in the standard HDF5 distribution and are
+ * available any time the HDF5 High-level library is available.
+ *
+ * - \ref H5DOappend
+ *    \n Appends data to a dataset along a specified dimension.
+ * - \ref H5DOread_chunk
+ *   \n Reads a raw data chunk directly from a dataset in a file into a buffer (DEPRECATED)
+ * - \ref H5DOwrite_chunk
+ *   \n  Writes a raw data chunk from a buffer directly to a dataset in a file (DEPRECATED)
+ *
+ */
+
+/*-------------------------------------------------------------------------
+ *
+ * "Optimized dataset" routines.
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5DO
+ *
+ * \brief Appends data to a dataset along a specified dimension.
+ *
+ * \param[in] dset_id   Dataset identifier
+ * \param[in] dxpl_id   Dataset transfer property list identifier
+ * \param[in] axis      Dataset Dimension (0-based) for the append
+ * \param[in] extension Number of elements to append for the
+ *                      axis-th dimension
+ * \param[in] memtype   The memory datatype identifier
+ * \param[in] buf       Buffer with data for the append
+ *
+ * \return \herr_t
+ *
+ * \details The H5DOappend() routine extends a dataset by \p extension
+ *          number of elements along a dimension specified by a
+ *          dimension \p axis and writes \p buf of elements to the
+ *          dataset. Dimension \p axis is 0-based. Elements type
+ *          is described by \p memtype.
+ *
+ *          This routine combines calling H5Dset_extent(),
+ *          H5Sselect_hyperslab(), and H5Dwrite() into a single routine
+ *          that simplifies application development for the common case
+ *          of appending elements to an existing dataset.
+ *
+ *          For a multi-dimensional dataset, appending to one dimension
+ *          will write a contiguous hyperslab over the other dimensions.
+ *          For example, if a 3-D dataset has dimension sizes (3, 5, 8),
+ *          extending the 0th dimension (currently of size 3) by 3 will
+ *          append 3*5*8 = 120 elements (which must be pointed to by the
+ *          \p buffer parameter) to the dataset, making its final
+ *          dimension sizes (6, 5, 8).
+ *
+ *          If a dataset has more than one unlimited dimension, any of
+ *          those dimensions may be appended to, although only along
+ *          one dimension per call to H5DOappend().
+ *
+ * \since   1.10.0
+ *
+ */
+H5_HLDLL herr_t H5DOappend(hid_t dset_id, hid_t dxpl_id, unsigned axis, size_t extension, hid_t memtype,
+                           const void *buf);
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Compatibility wrappers for functionality moved to H5D */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5DO
+ *
+ * \brief Writes a raw data chunk from a buffer directly to a dataset in a file.
+ *
+ * \param[in] dset_id       Identifier for the dataset to write to
+ * \param[in] dxpl_id       Transfer property list identifier for
+ *                          this I/O operation
+ * \param[in] filters       Mask for identifying the filters in use
+ * \param[in] offset        Logical position of the chunk's first element
+ *                          in the dataspace
+ * \param[in] data_size     Size of the actual data to be written in bytes
+ * \param[in] buf           Buffer containing data to be written to the chunk
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function was deprecated in favor of the function
+ *             H5Dwrite_chunk() of HDF5-1.10.3.
+ *             The functionality of H5DOwrite_chunk() was moved
+ *             to H5Dwrite_chunk().
+ * \deprecated For compatibility, this API call has been left as a stub which
+ *             simply calls H5Dwrite_chunk(). New code should use H5Dwrite_chunk().
+ *
+ * \details The H5DOwrite_chunk() writes a raw data chunk as specified by its
+ *          logical \p offset in a chunked dataset \p dset_id from the application
+ *          memory buffer \p buf to the dataset in the file. Typically, the data
+ *          in \p buf is preprocessed in memory by a custom transformation, such as
+ *          compression. The chunk will bypass the library's internal data
+ *          transfer pipeline, including filters, and will be written directly to the file.
+ *
+ *          \p dxpl_id is a data transfer property list identifier.
+ *
+ *          \p filters is a mask providing a record of which filters are used
+ *          with the chunk. The default value of the mask is zero (\c 0),
+ *          indicating that all enabled filters are applied. A filter is skipped
+ *          if the bit corresponding to the filter's position in the pipeline
+ *          (<tt>0  position < 32</tt>) is turned on. This mask is saved
+ *          with the chunk in the file.
+ *
+ *          \p offset is an array specifying the logical position of the first
+ *          element of the chunk in the dataset's dataspace. The length of the
+ *          offset array must equal the number of dimensions, or rank, of the
+ *          dataspace. The values in \p offset must not exceed the dimension limits
+ *          and must specify a point that falls on a dataset chunk boundary.
+ *
+ *          \p data_size is the size in bytes of the chunk, representing the number of
+ *          bytes to be read from the buffer \p buf. If the data chunk has been
+ *          precompressed, \p data_size should be the size of the compressed data.
+ *
+ *          \p buf is the memory buffer containing data to be written to the chunk in the file.
+ *
+ * \attention   Exercise caution when using H5DOread_chunk() and H5DOwrite_chunk(),
+ *              as they read and write data chunks directly in a file.
+ *              H5DOwrite_chunk() bypasses hyperslab selection, the conversion of data
+ *              from one datatype to another, and the filter pipeline to write the chunk.
+ *              Developers should have experience with these processes before
+ *              using this function. Please see
+ *              <a href="https://portal.hdfgroup.org/display/HDF5/Using+the+Direct+Chunk+Write+Function">
+ *              Using the Direct Chunk Write Function</a>
+ *              for more information.
+ *
+ * \note    H5DOread_chunk() and H5DOwrite_chunk() are not
+ *          supported under parallel and do not support variable length types.
+ *
+ * \par Example
+ * The following code illustrates the use of H5DOwrite_chunk to write
+ * an entire dataset, chunk by chunk:
+ * \snippet H5DO_examples.c H5DOwrite
+ *
+ * \version 1.10.3  Function deprecated in favor of H5Dwrite_chunk.
+ *
+ * \since   1.8.11
+ */
+H5_HLDLL herr_t H5DOwrite_chunk(hid_t dset_id, hid_t dxpl_id, uint32_t filters, const hsize_t *offset,
+                                size_t data_size, const void *buf);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5DO
+ *
+ * \brief Reads a raw data chunk directly from a dataset in a file into a buffer.
+ *
+ * \param[in] dset_id           Identifier for the dataset to be read
+ * \param[in] dxpl_id           Transfer property list identifier for
+ *                              this I/O operation
+ * \param[in] offset            Logical position of the chunk's first
+                                element in the dataspace
+ * \param[in,out] filters       Mask for identifying the filters used
+ *                              with the chunk
+ * \param[in] buf               Buffer containing the chunk read from
+ *                              the dataset
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function was deprecated in favor of the function
+ *             H5Dread_chunk() as of HDF5-1.10.3.
+ *             In HDF5 1.10.3, the functionality of H5DOread_chunk()
+ *             was moved to H5Dread_chunk().
+ * \deprecated For compatibility, this API call has been left as a stub which
+ *             simply calls H5Dread_chunk().  New code should use H5Dread_chunk().
+ *
+ * \details The H5DOread_chunk() reads a raw data chunk as specified
+ *          by its logical \p offset in a chunked dataset \p dset_id
+ *          from the dataset in the file into the application memory
+ *          buffer \p buf. The data in \p buf is read directly from the file
+ *          bypassing the library's internal data transfer pipeline,
+ *          including filters.
+ *
+ *          \p dxpl_id is a data transfer property list identifier.
+ *
+ *          The mask \p filters indicates which filters are used with the
+ *          chunk when written. A zero value indicates that all enabled filters
+ *          are applied on the chunk. A filter is skipped if the bit corresponding
+ *          to the filter's position in the pipeline
+ *          (<tt>0  position < 32</tt>) is turned on.
+ *
+ *          \p offset is an array specifying the logical position of the first
+ *          element of the chunk in the dataset's dataspace. The length of the
+ *          offset array must equal the number of dimensions, or rank, of the
+ *          dataspace. The values in \p offset must not exceed the dimension
+ *          limits and must specify a point that falls on a dataset chunk boundary.
+ *
+ *          \p buf is the memory buffer containing the chunk read from the dataset
+ *          in the file.
+ *
+ * \par Example
+ * The following code illustrates the use of H5DOread_chunk()
+ * to read a chunk from a dataset:
+ * \snippet H5DO_examples.c H5DOread
+ *
+ * \version 1.10.3  Function deprecated in favor of H5Dread_chunk.
+ *
+ * \since   1.10.2, 1.8.19
+ */
+H5_HLDLL herr_t H5DOread_chunk(hid_t dset_id, hid_t dxpl_id, const hsize_t *offset, uint32_t *filters /*out*/,
+                               void *buf /*out*/);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5DSpublic.h b/install/include/H5DSpublic.h
new file mode 100644
index 0000000000..edbebdbaf2
--- /dev/null
+++ b/install/include/H5DSpublic.h
@@ -0,0 +1,413 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef H5DSpublic_H
+#define H5DSpublic_H
+
+#define DIMENSION_SCALE_CLASS "DIMENSION_SCALE"
+#define DIMENSION_LIST        "DIMENSION_LIST"
+#define REFERENCE_LIST        "REFERENCE_LIST"
+#define DIMENSION_LABELS      "DIMENSION_LABELS"
+
+/**
+ * \brief Prototype for H5DSiterate_scales() operator
+ *
+ */
+//! <!-- [H5DS_iterate_t_snip] -->
+typedef herr_t (*H5DS_iterate_t)(hid_t dset, unsigned dim, hid_t scale, void *visitor_data);
+//! <!-- [H5DS_iterate_t_snip] -->
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** \page H5DS_UG The HDF5 High Level Dimension Scales
+ * @todo Under Construction
+ */
+
+/**\defgroup H5DS HDF5 Dimension Scales APIs (H5DS)
+ *
+ * <em>Creating and manipulating HDF5 datasets that are associated with
+ * the dimension of another HDF5 dataset (H5DS)</em>
+ *
+ * \note \Bold{Programming hints:}
+ * \note To use any of these functions or subroutines,
+ *       you must first include the relevant include file (C) or
+ *       module (Fortran) in your application.
+ * \note The following line includes the HDF5 Dimension Scale package,
+ *       H5DS, in C applications:
+ *       \code #include "hdf5_hl.h" \endcode
+ * \note This line includes the H5DS module in Fortran applications:
+ *       \code use h5ds \endcode
+ *
+ * - \ref H5DSwith_new_ref
+ *   \n Determines if new references are used with dimension scales.
+ * - \ref H5DSattach_scale
+ *   \n Attach dimension scale dsid to dimension idx of dataset did.
+ * - \ref H5DSdetach_scale
+ *   \n Detach dimension scale dsid from the dimension idx of Dataset did.
+ * - \ref H5DSget_label
+ *   \n Read the label for dimension idx of did into buffer label.
+ * - \ref H5DSget_num_scales
+ *   \n Determines how many Dimension Scales are attached
+ *      to dimension idx of did.
+ * - \ref H5DSget_scale_name
+ *   \n Retrieves name of scale did into buffer name.
+ * - \ref H5DSis_attached
+ *   \n Report if dimension scale dsid is currently attached
+ *      to dimension idx of dataset did.
+ * - \ref H5DSis_scale
+ *   \n Determines whether dset is a Dimension Scale.
+ * - \ref H5DSiterate_scales
+ *   \n Iterates the operation visitor through the scales
+ *      attached to dimension dim.
+ * - \ref H5DSset_label
+ *   \n Set label for the dimension idx of did to the value label.
+ * - \ref H5DSset_scale
+ *   \n Convert dataset dsid to a dimension scale,
+ *      with optional name, dimname.
+ *
+ */
+
+/* THIS IS A NEW ROUTINE NOT ON OLD PORTAL */
+/**
+ *  --------------------------------------------------------------------------
+ *  \ingroup H5DS
+ *
+ *  \brief Determines if new references are used with dimension scales.
+ *
+ *  \param[in] obj_id        Object identifier
+ *  \param[out] with_new_ref New references are used or not
+ *
+ *  \return \herr_t
+ *
+ *  \details H5DSwith_new_ref() takes any object identifier and checks
+ *           if new references are used for dimension scales. Currently,
+ *           new references are used when non-native VOL connector is
+ *           used or when H5_DIMENSION_SCALES_WITH_NEW_REF is set up
+ *           via configure option.
+ *
+ */
+H5_HLDLL herr_t H5DSwith_new_ref(hid_t obj_id, hbool_t *with_new_ref);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5DS
+ *
+ * \brief Attach dimension scale \p dsid to dimension \p idx of
+ *        dataset did.
+ *
+ * \param[in] did   The dataset
+ * \param[in] dsid  The scale to be attached
+ * \param[in] idx   The dimension of \p did that \p dsid is associated with
+ *
+ * \return \herr_t
+ *
+ * \details Define Dimension Scale \p dsid to be associated with
+ *          dimension \p idx of dataset \p did.
+ *
+ *          Entries are created in the #DIMENSION_LIST and
+ *          #REFERENCE_LIST attributes, as defined in section 4.2 of
+ *          <a href="https://support.hdfgroup.org/HDF5/doc/HL/H5DS_Spec.pdf">
+ *          HDF5 Dimension Scale Specification</a>.
+ *
+ *          Fails if:
+ *          - Bad arguments
+ *          - If \p dsid is not a Dimension Scale
+ *          - If \p did is a Dimension Scale
+ *            (A Dimension Scale cannot have scales.)
+ *
+ * \note The Dimension Scale \p dsid can be attached to the
+ *       same dimension more than once, which has no effect.
+ */
+H5_HLDLL herr_t H5DSattach_scale(hid_t did, hid_t dsid, unsigned int idx);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5DS
+ *
+ * \brief Detach dimension scale \p dsid from the dimension \p idx of dataset \p did.
+ *
+ * \param[in] did   The dataset
+ * \param[in] dsid  The scale to be detached
+ * \param[in] idx   The dimension of \p did to detach
+ *
+ * \return \herr_t
+ *
+ * \details If possible, deletes association of Dimension Scale \p dsid with
+ *          dimension \p idx of dataset \p did. This deletes the entries in the
+ *          #DIMENSION_LIST and #REFERENCE_LIST attributes,
+ *          as defined in section 4.2 of
+ *          <a href="https://support.hdfgroup.org/HDF5/doc/HL/H5DS_Spec.pdf">
+ *          HDF5 Dimension Scale Specification</a>.
+ *
+ *          Fails if:
+ *          - Bad arguments
+ *          - The dataset \p did or \p dsid do not exist
+ *          - The \p dsid is not a Dimension Scale
+ *          - \p dsid is not attached to \p did
+ *
+ * \note A scale may be associated with more than dimension of the
+ *       same dataset. If so, the detach operation only deletes one
+ *       of the associations, for \p did.
+ *
+ */
+H5_HLDLL herr_t H5DSdetach_scale(hid_t did, hid_t dsid, unsigned int idx);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5DS
+ *
+ * \brief Convert dataset \p dsid to a dimension scale,
+ *        with optional name, \p dimname.
+ *
+ * \param[in] dsid      The dataset to be made a Dimemsion Scale
+ * \param[in] dimname   The dimension name (optional), NULL if the
+ *                      dimension has no name.
+ *
+ * \return \herr_t
+ *
+ * \details The dataset \p dsid is converted to a Dimension Scale dataset,
+ *          as defined above. Creates the CLASS attribute, set to the value
+ *          "DIMENSION_SCALE" and an empty #REFERENCE_LIST attribute,
+ *          as described in
+ *          <a href="https://support.hdfgroup.org/HDF5/doc/HL/H5DS_Spec.pdf">
+ *          HDF5 Dimension Scale Specification</a>.
+ *          (PDF, see section 4.2).
+ *
+ *          If \p dimname is specified, then an attribute called NAME
+ *          is created, with the value \p dimname.
+ *
+ *          Fails if:
+ *          - Bad arguments
+ *          - If \p dsid is already a scale
+ *          - If \p dsid is a dataset which already has dimension scales
+ *
+ *          If the dataset was created with the Table, Image, or Palette interface [9],
+ *          it is not recommended to convert to a Dimension Scale.
+ *          (These Datasets will have a CLASS Table, Image, or Palette.)
+ *
+ * \todo what is [9] after Palette interface?
+ */
+H5_HLDLL herr_t H5DSset_scale(hid_t dsid, const char *dimname);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5DS
+ *
+ * \brief Determines how many Dimension Scales are attached
+ *        to dimension \p idx of \p did.
+ *
+ * \param[in] did   The dataset to query
+ * \param[in] idx   The dimension of \p did to query
+ *
+ * \return Returns the number of Dimension Scales associated
+ *         with \p did, if successful, otherwise returns a
+ *         negative value.
+ *
+ * \details H5DSget_num_scales() determines how many Dimension
+ *          Scales are attached to dimension \p idx of
+ *          dataset \p did.
+ *
+ */
+H5_HLDLL int H5DSget_num_scales(hid_t did, unsigned int idx);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5DS
+ *
+ * \brief Set label for the dimension \p idx of \p did
+ *        to the value \p label.
+ *
+ * \param[in] did   The dataset
+ * \param[in] idx   The dimension
+ * \param[in] label The label
+ *
+ * \return  \herr_t
+ *
+ * \details Sets the #DIMENSION_LABELS for dimension \p idx of
+ *          dataset \p did. If the dimension had a label,
+ *          the new value replaces the old.
+ *
+ *          Fails if:
+ *          - Bad arguments
+ *
+ */
+H5_HLDLL herr_t H5DSset_label(hid_t did, unsigned int idx, const char *label);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5DS
+ *
+ * \brief Read the label for dimension \p idx of \p did into buffer \p label.
+ *
+ * \param[in] did       The dataset
+ * \param[in] idx       The dimension
+ * \param[out] label    The label
+ * \param[in] size      The length of the label buffer
+ *
+ * \return  Upon success, size of label or zero if no label found.
+ *          Negative if fail.
+ *
+ * \details Returns the value of the #DIMENSION_LABELS for
+ *          dimension \p idx of dataset \p did, if set.
+ *          Up to \p size characters of the name are copied into
+ *          the buffer \p label.  If the label is longer than
+ *          \p size, it will be truncated to fit.  The parameter
+ *          \p size is set to the size of the returned \p label.
+ *
+ *          If \p did has no label, the return value of
+ *          \p label is NULL.
+ *
+ *          Fails if:
+ *          - Bad arguments
+ *
+ */
+H5_HLDLL ssize_t H5DSget_label(hid_t did, unsigned int idx, char *label, size_t size);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5DS
+ *
+ * \brief Retrieves name of scale \p did into buffer \p name.
+ *
+ * \param[in] did       Dimension scale identifier
+ * \param[out] name     Buffer to contain the returned name
+ * \param[in] size      Size in bytes, of the \p name buffer
+ *
+ * \return  Upon success, the length of the scale name or zero if no name found.
+ *          Negative if fail.
+ *
+ * \details H5DSget_scale_name() retrieves the name attribute
+ *          for scale \p did.
+ *
+ *          Up to \p size characters of the scale name are returned
+ *          in \p name; additional characters, if any, are not returned
+ *          to the user application.
+ *
+ *          If the length of the name, which determines the required value of
+ *          \p size, is unknown, a preliminary H5DSget_scale_name() call can
+ *          be made by setting \p name to NULL. The return value of this call
+ *          will be the size of the scale name; that value plus one (1) can then
+ *          be assigned to \p size for a second H5DSget_scale_name() call,
+ *          which will retrieve the actual name.  (The value passed in with the
+ *          parameter \p size must be one greater than size in bytes of the actual
+ *          name in order to accommodate the null terminator;
+ *          if \p size is set to the exact size of the name, the last byte
+ *          passed back will contain the null terminator and the last character
+ *          will be missing from the name passed back to the calling application.)
+ */
+H5_HLDLL ssize_t H5DSget_scale_name(hid_t did, char *name, size_t size);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5DS
+ *
+ * \brief Determines whether \p did is a Dimension Scale.
+ *
+ * \param[in] did   The dataset to query
+ *
+ * \return  \htri_t
+ *
+ * \details H5DSis_scale() determines if \p did is a Dimension Scale,
+ *          i.e., has class="DIMENSION_SCALE").
+ *
+ */
+H5_HLDLL htri_t H5DSis_scale(hid_t did);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5DS
+ *
+ * \brief Iterates the operation visitor through the scales
+ *        attached to dimension \p dim.
+ *
+ * \param[in]       did             The dataset
+ * \param[in]       dim             The dimension of dataset \p did
+ * \param[in,out]   idx             Input the index to start iterating,
+ *                                  output the next index to visit.
+ *                                  If NULL, start at the first position.
+ * \param[in]       visitor         The visitor function
+ * \param[in]       visitor_data    Arbitrary data to pass to the
+ *                                  visitor function
+ *
+ * \return  Returns the return value of the last operator if it was
+ *          non-zero, or zero if all scales were processed.
+ *
+ * \details H5DSiterate_scales() iterates over the scales attached to
+ *          dimension \p dim of dataset \p did. For each scale in the
+ *          list, the \p visitor_data and some additional information,
+ *          specified below, are passed to the \p visitor function.
+ *          The iteration begins with the \p idx object in the
+ *          group and the next element to be processed by the operator
+ *          is returned in \p idx. If \p idx is NULL, then the
+ *          iterator starts at the first group member; since no
+ *          stopping point is returned in this case,
+ *          the iterator cannot be restarted if one of the calls
+ *          to its operator returns non-zero.
+ *
+ *          The prototype for \ref H5DS_iterate_t is:
+ *          \snippet this H5DS_iterate_t_snip
+ *
+ *          The operation receives the Dimension Scale dataset
+ *          identifier, \p scale, and the pointer to the operator
+ *          data passed in to H5DSiterate_scales(), \p visitor_data.
+ *
+ *          The return values from an operator are:
+ *
+ *          - Zero causes the iterator to continue, returning zero
+ *            when all group members have been processed.
+ *          - Positive causes the iterator to immediately return that
+ *            positive value, indicating short-circuit success.
+ *            The iterator can be restarted at the next group member.
+ *          - Negative causes the iterator to immediately return
+ *            that value, indicating failure. The iterator can be
+ *            restarted at the next group member.
+ *
+ *          H5DSiterate_scales() assumes that the scales of the
+ *          dimension identified by \p dim remain unchanged through
+ *          the iteration. If the membership changes during the iteration,
+ *          the function's behavior is undefined.
+ */
+H5_HLDLL herr_t H5DSiterate_scales(hid_t did, unsigned int dim, int *idx, H5DS_iterate_t visitor,
+                                   void *visitor_data);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5DS
+ *
+ * \brief Report if dimension scale \p dsid is currently attached to
+ *        dimension \p idx of dataset \p did.
+ *
+ * \param[in] did   The dataset
+ * \param[in] dsid  The scale to be attached
+ * \param[in] idx   The dimension of \p did that \p dsid is associated with
+ *
+ * \return  \htri_t
+ *
+ * \details Report if dimension scale \p dsid is currently attached to
+ *          dimension \p idx of dataset \p did.
+ *
+ *          Fails if:
+ *          - Bad arguments
+ *          - If \p dsid is not a Dimension Scale
+ *          - The \p dsid is not a Dimension Scale
+ *          - If \p did is a Dimension Scale (A Dimension Scale cannot have scales.)
+ *
+ */
+H5_HLDLL htri_t H5DSis_attached(hid_t did, hid_t dsid, unsigned int idx);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5Dpublic.h b/install/include/H5Dpublic.h
new file mode 100644
index 0000000000..a4c60cd4b5
--- /dev/null
+++ b/install/include/H5Dpublic.h
@@ -0,0 +1,1858 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5D module.
+ */
+#ifndef H5Dpublic_H
+#define H5Dpublic_H
+
+#include "H5public.h"  /* Generic Functions                        */
+#include "H5Ipublic.h" /* Identifiers                              */
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* Macros used to "unset" chunk cache configuration parameters */
+#define H5D_CHUNK_CACHE_NSLOTS_DEFAULT SIZE_MAX
+#define H5D_CHUNK_CACHE_NBYTES_DEFAULT SIZE_MAX
+#define H5D_CHUNK_CACHE_W0_DEFAULT     (-1.0)
+
+/**
+ * Bit flags for the H5Pset_chunk_opts() and H5Pget_chunk_opts()
+ */
+#define H5D_CHUNK_DONT_FILTER_PARTIAL_CHUNKS (0x0002u)
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+//! <!-- [H5D_layout_t_snip] -->
+/**
+ * Values for the H5D_LAYOUT property
+ */
+typedef enum H5D_layout_t {
+    H5D_LAYOUT_ERROR = -1, /**< error */
+    H5D_COMPACT      = 0,  /**< raw data is small (< 64KB) */
+    H5D_CONTIGUOUS   = 1,  /**< contiguous layout */
+    H5D_CHUNKED      = 2,  /**< chunked or tiled layout */
+    H5D_VIRTUAL      = 3,  /**< actual data is stored in other datasets */
+    H5D_NLAYOUTS     = 4   /**< this one must be last! */
+} H5D_layout_t;
+//! <!-- [H5D_layout_t_snip] -->
+
+//! <!-- [H5D_chunk_index_t_snip] -->
+/**
+ * Types of chunk index data structures
+ */
+typedef enum H5D_chunk_index_t {
+    H5D_CHUNK_IDX_BTREE = 0, /**< v1 B-tree index (default)                */
+    H5D_CHUNK_IDX_SINGLE =
+        1, /**< Single Chunk index (cur dims[]=max dims[]=chunk dims[]; filtered & non-filtered) */
+    H5D_CHUNK_IDX_NONE   = 2, /**< Implicit: No Index (#H5D_ALLOC_TIME_EARLY, non-filtered, fixed dims) */
+    H5D_CHUNK_IDX_FARRAY = 3, /**< Fixed array (for 0 unlimited dims)       */
+    H5D_CHUNK_IDX_EARRAY = 4, /**< Extensible array (for 1 unlimited dim)   */
+    H5D_CHUNK_IDX_BT2    = 5, /**< v2 B-tree index (for >1 unlimited dims)  */
+    H5D_CHUNK_IDX_NTYPES      /**< This one must be last!                   */
+} H5D_chunk_index_t;
+//! <!-- [H5D_chunk_index_t_snip] -->
+
+//! <!-- [H5D_alloc_time_t_snip] -->
+/**
+ * Values for the space allocation time property
+ */
+typedef enum H5D_alloc_time_t {
+    H5D_ALLOC_TIME_ERROR   = -1, /**< Error */
+    H5D_ALLOC_TIME_DEFAULT = 0,  /**< Default (layout dependent) */
+    H5D_ALLOC_TIME_EARLY   = 1,  /**< Allocate on creation */
+    H5D_ALLOC_TIME_LATE    = 2,  /**< Allocate on first write */
+    H5D_ALLOC_TIME_INCR    = 3   /**< Allocate incrementally (by chunk) */
+} H5D_alloc_time_t;
+//! <!-- [H5D_alloc_time_t_snip] -->
+
+//! <!-- [H5D_space_status_t_snip] -->
+/**
+ * Values for the status of space allocation
+ */
+typedef enum H5D_space_status_t {
+    H5D_SPACE_STATUS_ERROR          = -1, /**< Error */
+    H5D_SPACE_STATUS_NOT_ALLOCATED  = 0,  /**< Space has not been allocated for this dataset. */
+    H5D_SPACE_STATUS_PART_ALLOCATED = 1,  /**< Space has been partially allocated for this dataset.
+                                               (Used only for datasets with chunked storage.) */
+    H5D_SPACE_STATUS_ALLOCATED = 2        /**< Space has been allocated for this dataset. */
+} H5D_space_status_t;
+//! <!-- [H5D_space_status_t_snip] -->
+
+//! <!-- [H5D_fill_time_t_snip] -->
+/**
+ * Values for time of writing fill value property
+ */
+typedef enum H5D_fill_time_t {
+    H5D_FILL_TIME_ERROR = -1, /**< Error */
+    H5D_FILL_TIME_ALLOC = 0,  /**< Fill on allocation */
+    H5D_FILL_TIME_NEVER = 1,  /**< Never write fill values */
+    H5D_FILL_TIME_IFSET = 2   /**< Fill if fill-value was set */
+} H5D_fill_time_t;
+//! <!-- [H5D_fill_time_t_snip] -->
+
+//! <!-- [H5D_fill_value_t_snip] -->
+/**
+ * Values for fill value status
+ */
+typedef enum H5D_fill_value_t {
+    H5D_FILL_VALUE_ERROR        = -1, /**< Error */
+    H5D_FILL_VALUE_UNDEFINED    = 0,  /**< No fill value defined */
+    H5D_FILL_VALUE_DEFAULT      = 1,  /**< Default fill-value */
+    H5D_FILL_VALUE_USER_DEFINED = 2   /**< User-defined fill-value */
+} H5D_fill_value_t;
+//! <!-- [H5D_fill_value_t_snip] -->
+
+//! <!-- [H5D_vds_view_t_snip] -->
+/**
+ * Values for VDS bounds option
+ */
+typedef enum H5D_vds_view_t {
+    H5D_VDS_ERROR          = -1, /**< Error */
+    H5D_VDS_FIRST_MISSING  = 0,  /**< Include all data before the first missing mapped data */
+    H5D_VDS_LAST_AVAILABLE = 1   /**< Include all available mapped data */
+} H5D_vds_view_t;
+//! <!-- [H5D_vds_view_t_snip] -->
+
+//! <!-- [H5D_append_cb_t_snip] -->
+/**
+ * \brief Callback for H5Pset_append_flush()
+ *
+ * \dset_id{dataset_id}
+ * \param[in] cur_dims The current extent of the dataset's dimensions
+ * \param[in,out] op_data User context
+ *
+ * \return \herr_t
+ *
+ */
+typedef herr_t (*H5D_append_cb_t)(hid_t dataset_id, hsize_t *cur_dims, void *op_data);
+//! <!-- [H5D_append_cb_t_snip] -->
+
+//! <!-- [H5D_operator_t_snip] -->
+/**
+ * \brief Callback for H5Diterate()
+ *
+ * \param[in,out] elem Pointer to the memory buffer containing the current dataset
+ *                     element
+ * \param[in] type_id Datatype identifier of the elements stored in \p elem
+ * \param[in] ndim Number of dimensions for the \p point array
+ * \param[in] point Array containing the location of the element within
+ *                  the original dataspace
+ * \param[in,out] operator_data Pointer to any user-defined data associated with
+ *                the operation
+ * \return \herr_t_iter
+ *
+ */
+typedef herr_t (*H5D_operator_t)(void *elem, hid_t type_id, unsigned ndim, const hsize_t *point,
+                                 void *operator_data);
+//! <!-- [H5D_operator_t_snip] -->
+
+//! <!-- [H5D_scatter_func_t_snip] -->
+/**
+ * \brief Callback for H5Dscatter()
+ *
+ * \param[out] src_buf Pointer to the buffer holding the next set of elements to
+ *                     scatter. On entry, the value of where \p src_buf points to
+ *                     is undefined. The callback function should set \p src_buf
+ *                     to point to the next set of elements.
+ * \param[out] src_buf_bytes_used Pointer to the number of valid bytes in \p src_buf.
+ *                                On entry, the value where \p src_buf_bytes_used points
+ *                                to is undefined. The callback function should set
+ *                                \p src_buf_bytes_used to the of valid bytes in \p src_buf.
+ *                                This number must be a multiple of the datatype size.
+ * \param[in,out] op_data User-defined pointer to data required by the callback
+ *                        function. A pass-through of the \p op_data pointer provided
+ *                        with the H5Dscatter() function call.
+ * \return herr_t
+ *
+ * \details The callback function should always return at least one
+ *          element in \p src_buf, and must not return more elements
+ *          than are remaining to be scattered. This function will be
+ *          repeatedly called until all elements to be scattered have
+ *          been returned. The callback function should return zero (0)
+ *          to indicate success, and a negative value to indicate failure.
+ *
+ */
+typedef herr_t (*H5D_scatter_func_t)(const void **src_buf /*out*/, size_t *src_buf_bytes_used /*out*/,
+                                     void *op_data);
+//! <!-- [H5D_scatter_func_t_snip] -->
+
+//! <!-- [H5D_gather_func_t_snip] -->
+/**
+ * \brief Callback for H5Dgather()
+ *
+ * \param[in] dst_buf Pointer to the destination buffer which has been filled
+ *                    with the next set of elements gathered. This will always
+ *                    be identical to the \p dst_buf passed to H5Dgather()
+ * \param[in] dst_buf_bytes_used  Pointer to the number of valid bytes in
+ *                                \p dst_buf. This number must be a multiple of
+ *                                the datatype size.
+ * \param[in,out] op_data User-defined pointer to data required by the callback
+ *                        function; a pass-through of the \p op_data pointer
+ *                        provided with the H5Dgather() function call.
+ * \returns \herr_t
+ *
+ * \details The callback function should process, store, or otherwise make use
+ *          of the data returned in dst_buf before it returns, because the
+ *          buffer will be overwritten unless it is the last call to the
+ *          callback. This function will be repeatedly called until all gathered
+ *          elements have been passed to the callback in dst_buf. The callback
+ *          function should return zero (0) to indicate success, and a negative
+ *          value to indicate failure.
+ *
+ */
+typedef herr_t (*H5D_gather_func_t)(const void *dst_buf, size_t dst_buf_bytes_used, void *op_data);
+//! <!-- [H5D_gather_func_t_snip] -->
+
+//! <!-- [H5D_chunk_iter_op_t_snip] -->
+/**
+ * \brief Callback for H5Dchunk_iter()
+ *
+ * \param[in]     offset      Logical position of the chunk's first element in units of dataset elements
+ * \param[in]     filter_mask Bitmask indicating the filters used when the chunk was written
+ * \param[in]     addr        Chunk address in the file
+ * \param[in]     size        Chunk size in bytes, 0 if the chunk does not exist
+ * \param[in,out] op_data     Pointer to any user-defined data associated with
+ *                            the operation.
+ * \returns \li Zero (#H5_ITER_CONT) causes the iterator to continue, returning
+ *              zero when all elements have been processed.
+ *          \li A positive value (#H5_ITER_STOP) causes the iterator to
+ *              immediately return that value, indicating short-circuit success.
+ *          \li A negative (#H5_ITER_ERROR) causes the iterator to immediately
+ *              return that value, indicating failure.
+ */
+typedef int (*H5D_chunk_iter_op_t)(const hsize_t *offset, unsigned filter_mask, haddr_t addr, hsize_t size,
+                                   void *op_data);
+//! <!-- [H5D_chunk_iter_op_t_snip] -->
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Creates a new dataset and links it into the file
+ *
+ * \fgdta_loc_id
+ * \param[in] name Name of the dataset to create
+ * \type_id
+ * \space_id
+ * \lcpl_id
+ * \dcpl_id
+ * \dapl_id
+ *
+ * \return \hid_t{dataset}
+ *
+ * \details H5Dcreate2() creates a new dataset named \p name at
+ *          the location specified by \p loc_id, and associates constant
+ *          and initial persistent properties with that dataset, including
+ *          the datatype \p dtype_id, the dataspace \p space_id, and
+ *          other properties as specified by the dataset creation property
+ *          list \p dcpl_id and the access property list \p dapl_id,
+ *          respectively. Once created, the dataset is opened for access.
+ *
+ *          \p loc_id may specify a file, group, dataset, named datatype,
+ *          or attribute.  If an attribute, dataset, or named datatype is
+ *          specified, then the dataset will be created at the location
+ *          where the attribute, dataset, or named datatype is attached.
+ *
+ *          \p name may be either an absolute path in the file or a relative
+ *          path from \p loc_id naming the dataset.
+ *
+ *          If \p dtype_id is a committed datatype, and if the file location
+ *          associated with the committed datatype is different from the
+ *          file location where the dataset will be created, the datatype
+ *          is copied and converted to a transient type.
+ *
+ *          The link creation property list, \p lcpl_id, governs the creation
+ *          of the link(s) by which the new dataset is accessed and the
+ *          creation of any intermediate groups that may be missing.
+ *
+ *          The datatype and dataspace properties and the dataset creation
+ *          and access property lists are attached to the dataset, so the
+ *          caller may derive new datatypes, dataspaces, and creation and
+ *          access properties from the old ones and reuse them in calls to
+ *          create additional datasets.  Once created, the dataset can be
+ *          read from or written to. Reading data from a dataset that was
+ *          not previously written, the HDF5 library will return default
+ *          or user-defined fill values.
+ *
+ * \par Example
+ * \snippet H5D_examples.c create
+ *
+ * \since 1.8.0
+ *
+ * \see H5Dopen2(), H5Dclose(), H5Tset_size()
+ *
+ */
+H5_DLL hid_t H5Dcreate2(hid_t loc_id, const char *name, hid_t type_id, hid_t space_id, hid_t lcpl_id,
+                        hid_t dcpl_id, hid_t dapl_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Dcreate}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Dcreate_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                             const char *name, hid_t type_id, hid_t space_id, hid_t lcpl_id, hid_t dcpl_id,
+                             hid_t dapl_id, hid_t es_id);
+#else
+H5_DLL hid_t  H5Dcreate_async(hid_t loc_id, const char *name, hid_t type_id, hid_t space_id, hid_t lcpl_id,
+                              hid_t dcpl_id, hid_t dapl_id, hid_t es_id);
+#endif
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Creates a dataset in a file without linking it into the file
+ *        structure
+ *
+ * \fgdta_loc_id
+ * \type_id
+ * \space_id
+ * \dcpl_id
+ * \dapl_id
+ *
+ * \return \hid_t{dataset}
+ *
+ * \details H5Dcreate_anon() creates a dataset in the file specified
+ *          by \p loc_id.
+ *
+ *          \p loc_id may specify a file, group, dataset, named datatype,
+ *          or attribute.  If an attribute, dataset, or named datatype is
+ *          specified, then the dataset will be created at the location
+ *          where the attribute, dataset, or named datatype is attached.
+ *
+ *          The dataset's datatype and dataspace are specified by
+ *          \p type_id and \p space_id, respectively. These are the
+ *          datatype and dataspace of the dataset as they will exist in
+ *          the file, which may differ from the datatype and dataspace
+ *          in application memory.
+ *
+ *          H5Dcreate_anon() returns a new dataset identifier. Using
+ *          this identifier, the new dataset must be linked into the
+ *          HDF5 file structure with H5Olink() or it will be deleted
+ *          when the file is closed.
+ *
+ * \since 1.8.0
+ *
+ * \see H5Olink(), H5Dcreate()
+ *
+ */
+H5_DLL hid_t H5Dcreate_anon(hid_t loc_id, hid_t type_id, hid_t space_id, hid_t dcpl_id, hid_t dapl_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Opens an existing dataset
+ *
+ * \fgdta_loc_id
+ * \param[in] name      Name of the dataset to open
+ * \dapl_id
+ *
+ * \return \hid_t{dataset}
+ *
+ * \details H5Dopen2() opens the existing dataset specified
+ *          by a location identifier and name, \p loc_id and \p name,
+ *          respectively.
+ *
+ *          \p loc_id may specify a file, group, dataset, named datatype,
+ *          or attribute.  If an attribute, dataset, or named datatype is
+ *          specified then the dataset will be opened at the location
+ *          where the attribute, dataset, or named datatype is attached.
+ *
+ * \since 1.8.0
+ *
+ * \see H5Dcreate2(), H5Dclose()
+ *
+ */
+H5_DLL hid_t H5Dopen2(hid_t loc_id, const char *name, hid_t dapl_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Dopen}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Dopen_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                           const char *name, hid_t dapl_id, hid_t es_id);
+#else
+H5_DLL hid_t  H5Dopen_async(hid_t loc_id, const char *name, hid_t dapl_id, hid_t es_id);
+#endif
+
+/**
+ * --------------------------------------------------------------------------
+ *\ingroup H5D
+ *
+ * \brief Returns an identifier for a copy of the dataspace for a dataset
+ *
+ * \dset_id
+ *
+ * \return \hid_t{dataspace}
+ *
+ * \details H5Dget_space() makes a copy of the dataspace of
+ *          the dataset specified by \p dset_id. The function returns an
+ *          identifier for the new copy of the dataspace.
+ *
+ *          A dataspace identifier returned from this function should
+ *          be released with H5Sclose() when the identifier is no longer
+ *          needed so that resource leaks will not occur.
+ *
+ * \par Example
+ * \snippet H5D_examples.c update
+ *
+ * \see H5Sclose()
+ *
+ */
+H5_DLL hid_t H5Dget_space(hid_t dset_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Dget_space}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Dget_space_async(const char *app_file, const char *app_func, unsigned app_line, hid_t dset_id,
+                                hid_t es_id);
+#else
+H5_DLL hid_t  H5Dget_space_async(hid_t dset_id, hid_t es_id);
+#endif
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Determines whether space has been allocated for a dataset
+ *
+ * \dset_id
+ * \param[out] allocation Space allocation status
+ *
+ * \return \herr_t
+ *
+ * \details H5Dget_space_status() determines whether space has been allocated
+ *          for the dataset \p dset_id.
+ *
+ * \note \Bold{BUG:} Prior to the HDF5 1.14.0, 1.12.2 and 1.10.9 releases,
+ *       H5Dget_space_status() may return incorrect space allocation status
+ *       values for datasets with filters applied to them.
+ *       H5Dget_space_status() calculated the space allocation status by
+ *       comparing the sum of the sizes of all the allocated chunks in the
+ *       dataset against the total data size of the dataset, as calculated by
+ *       the number of elements in the dataset's dataspace multiplied by the
+ *       dataset's datatype size. If the dataset had any compression filters
+ *       applied to it and the dataset chunks were successfully compressed,
+ *       the sum of the sizes of the allocated dataset chunks would generally
+ *       always be less than the total data size of the dataset, and
+ *       H5Dget_space_status() wouldn't ever return
+ *       `H5D_SPACE_STATUS_ALLOCATED`.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Dget_space_status(hid_t dset_id, H5D_space_status_t *allocation);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Returns an identifier for a copy of the datatype for a dataset
+ *
+ * \dset_id
+ *
+ * \return \hid_t{datatype}
+ *
+ * \details H5Dget_type() returns an identifier of a copy of
+ *          the datatype for a dataset.
+ *
+ *          If a dataset has a named datatype, then an identifier to the
+ *          opened datatype is returned. Otherwise, the returned datatype
+ *          is read-only.
+ *
+ */
+H5_DLL hid_t H5Dget_type(hid_t dset_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Returns an identifier for a copy of the dataset creation
+ *        property list for a dataset
+ *
+ * \dset_id
+ *
+ * \return \hid_t{dataset creation property list}
+ *
+ * \details H5Dget_create_plist() returns an identifier for
+ *          a copy of the dataset creation property list associated with
+ *          the dataset specified by \p dset_id.
+ *
+ *          The creation property list identifier should be released with
+ *          H5Pclose() to prevent resource leaks.
+ *
+ */
+H5_DLL hid_t H5Dget_create_plist(hid_t dset_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Returns the dataset access property list associated with
+ *        a dataset
+ *
+ * \dset_id
+ *
+ * \return \hid_t{dataset access property list}
+ *
+ * \details H5Dget_access_plist() returns a copy of the
+ *          dataset access property list used to open the specified
+ *          dataset, \p dset_id. Modifications to the returned property
+ *          list will have no effect on the dataset it was retrieved from.
+ *
+ *          The chunk cache parameters in the returned property lists will
+ *          be those used by the dataset. If the properties in the file
+ *          access property list were used to determine the dataset's
+ *          chunk cache configuration, then those properties will be
+ *          present in the returned dataset access property list. If
+ *          the dataset does not use a chunked layout, then the chunk
+ *          cache properties will be set to the default. The chunk cache
+ *          properties in the returned list are considered to be set,
+ *          and any use of this list will override the corresponding
+ *          properties in the file's file access property list.
+ *
+ *          All link access properties in the returned list will be set
+ *          to the default values.
+ *
+ * \since 1.8.3
+ *
+ */
+H5_DLL hid_t H5Dget_access_plist(hid_t dset_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Returns the amount of storage allocated for a dataset
+ *
+ * \dset_id
+ *
+ * \return Returns the amount of storage space, in bytes, or 0 (zero).
+ *
+ * \details H5Dget_storage_size() returns the amount of storage,
+ *          in bytes, that is allocated in the file for the raw data of
+ *          the dataset specified by \p dset_id.
+ *          H5Dget_storage_size() reports only the space required to store
+ *          the dataset elements, excluding any metadata.
+ *          \li For contiguous datasets, the returned size equals the current
+ *          allocated size of the raw data.
+ *          \li For unfiltered chunked datasets, the returned size is the
+ *          number of allocated chunks times the chunk size.
+ *          \li For filtered chunked datasets, the returned size is the
+ *          space required to store the filtered data. For example, if a
+ *          compression filter is in use, H5Dget_storage_size() will return
+ *          the total space required to store the compressed chunks.
+ *
+ * \note Note that H5Dget_storage_size() is not generally an
+ *       appropriate function to use when determining the amount
+ *       of memory required to work with a dataset. In such
+ *       circumstances, you must determine the number of data
+ *       points in a dataset and the size of an individual dataset
+ *       element. H5Sget_simple_extent_npoints() and H5Tget_size()
+ *       can be used to calculate that amount.
+ *
+ * \warning H5Dget_storage_size() does not differentiate between 0 (zero),
+ *          the value returned for the storage size of a dataset
+ *          with no stored values, and 0 (zero), the value returned to
+ *          indicate an error.
+ *
+ *
+ */
+H5_DLL hsize_t H5Dget_storage_size(hid_t dset_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Returns the amount of storage allocated within the file for a
+ * raw data chunk in a dataset
+ *
+ * \dset_id
+ * \param[in]  offset   Logical offset in the dataset for the chunk to query
+ * \param[out] chunk_bytes The size in bytes for the chunk
+ *
+ * \return \herr_t
+ *
+ * \details H5Dget_chunk_storage_size() returns the size in bytes
+ *          allocated in the file for a raw data chunk as specified by
+ *          its logical \p offset in the dataset \p dset_id. The size is
+ *          returned in \p chunk_nbytes. It is the size of the compressed
+ *          data if the chunk is filtered and the size may be zero if no
+ *          storage is allocated yet for the dataset.
+ *
+ * \since 1.10.2
+ *
+ */
+H5_DLL herr_t H5Dget_chunk_storage_size(hid_t dset_id, const hsize_t *offset, hsize_t *chunk_bytes);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Retrieves number of chunks that have nonempty intersection with a
+ *        specified selection
+ *
+ * \dset_id
+ * \param[in]  fspace_id   File dataspace selection identifier
+ * \param[out] nchunks     Number of chunks in the selection
+ *
+ * \return \herr_t
+ *
+ * \details H5Dget_num_chunks() retrieves the number of chunks
+ *          nchunks in a set of selected elements specified by \p fspace_id
+ *          for a dataset specified by the identifier \p dset_id. If \p
+ *          fspace_id is #H5S_ALL, the function will retrieve the total
+ *          number of chunks stored for the dataset.
+ *
+ *          \p fspace_id specifies the file dataspace selection.  It is
+ *          intended to take #H5S_ALL for specifying the current selection.
+ *
+ *          \note Please be aware that this function currently does not
+ *          support non-trivial selections, thus \p fspace_id has no
+ *          effect. Also, the implementation does not handle the #H5S_ALL
+ *          macro correctly.  As a workaround, application can get
+ *          the dataspace for the dataset using H5Dget_space() and pass that
+ *          in for \p fspace_id.  This will be fixed in a future release.
+ *
+ * \since 1.10.5
+ *
+ */
+H5_DLL herr_t H5Dget_num_chunks(hid_t dset_id, hid_t fspace_id, hsize_t *nchunks);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Retrieves information about a chunk specified by its coordinates
+ *
+ * \dset_id
+ * \param[in]  offset      Logical position of the chunk's first element in units of dataset elements
+ * \param[out] filter_mask Bitmask indicating the filters used when the chunk was written
+ * \param[out] addr        Chunk address in the file
+ * \param[out] size        Chunk size in bytes, 0 if the chunk does not exist
+ *
+ * \return \herr_t
+ *
+ * \details H5Dget_chunk_info_by_coord() retrieves the \p filter_mask, \p size,
+ *          and \p addr for a chunk in the dataset specified by \p dset_id,
+ *          using the coordinates specified by \p offset.
+ *
+ *          If the queried chunk does not exist in the file, \p size will
+ *          be set to 0, \p addr to \c HADDR_UNDEF, and the buffer \p
+ *          filter_mask will not be modified.
+ *
+ *          \p offset is a pointer to a one-dimensional array with a size
+ *          equal to the dataset's rank. Each element is the logical
+ *          position of the chunk's first element in a dimension.
+ *
+ * \since 1.10.5
+ *
+ */
+H5_DLL herr_t H5Dget_chunk_info_by_coord(hid_t dset_id, const hsize_t *offset, unsigned *filter_mask,
+                                         haddr_t *addr, hsize_t *size);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Iterate over all chunks of a chunked dataset
+ *
+ * \dset_id
+ * \param[in]  dxpl_id  Identifier of a transfer property list
+ * \param[in]  cb       User callback function, called for every chunk.
+ * \param[in]  op_data  User-defined pointer to data required by op
+ *
+ * \return \herr_t
+ *
+ * \details H5Dchunk_iter iterates over all chunks in the dataset, calling the
+ *          user supplied callback with the details of the chunk and the supplied
+ *          context \p op_data.
+ *
+ * \par Example
+ * For each chunk, print the allocated chunk size (0 for unallocated chunks).
+ * \snippet H5D_examples.c H5Dchunk_iter_cb
+ * Iterate over all chunked datasets and chunks in a file.
+ * \snippet H5D_examples.c H5Ovisit_cb
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5Dchunk_iter(hid_t dset_id, hid_t dxpl_id, H5D_chunk_iter_op_t cb, void *op_data);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Retrieves information about a chunk specified by its index
+ *
+ * \dset_id
+ * \param[in]  fspace_id File dataspace selection identifier (See Note below)
+ * \param[in]  chk_idx   Index of the chunk
+ * \param[out] offset    Logical position of the chunk's first element in units of dataset elements
+ * \param[out] filter_mask Bitmask indicating the filters used when the chunk was written
+ * \param[out] addr      Chunk address in the file
+ * \param[out] size      Chunk size in bytes, 0 if the chunk does not exist
+ *
+ * \return \herr_t
+ *
+ * \details H5Dget_chunk_info() retrieves the offset coordinates,
+ *          \p offset, filter mask, \p filter_mask, size, \p size, and address
+ *          \p addr for the dataset specified by the identifier \p dset_id and the chunk
+ *          specified by the index \p index. The chunk belongs to a set of
+ *          chunks in the selection specified by \p fspace_id. If the queried
+ *          chunk does not exist in the file, the size will be set to 0 and
+ *          address to #HADDR_UNDEF. The value pointed to by filter_mask will
+ *          not be modified. \c NULL can be passed in for any \p out parameters.
+ *
+ *          \p chk_idx is the chunk index in the selection. The index value
+ *          may have a value of 0 up to the number of chunks stored in
+ *          the file that has a nonempty intersection with the file
+ *          dataspace selection.
+ *
+ *          \note As of 1.10.5, the dataspace intersection is not yet
+ *          supported. Hence, the index is of all the written chunks.
+ *
+ *          \p fspace_id specifies the file dataspace selection.  It is
+ *          intended to take #H5S_ALL to specify the current selection.
+ *
+ *          \note Please be aware that this function currently does not
+ *          support non-trivial selections; thus \p fspace_id has no
+ *          effect. Also, the implementation does not handle the #H5S_ALL
+ *          macro correctly.  As a workaround, an application can get
+ *          the dataspace for the dataset using H5Dget_space() and pass that
+ *          in for \p fspace_id.  This will be fixed in a future release.
+ *
+ * \since 1.10.5
+ *
+ */
+H5_DLL herr_t H5Dget_chunk_info(hid_t dset_id, hid_t fspace_id, hsize_t chk_idx, hsize_t *offset,
+                                unsigned *filter_mask, haddr_t *addr, hsize_t *size);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Returns dataset address in file
+ *
+ * \dset_id
+ *
+ * \return Returns the offset in bytes; otherwise, returns #HADDR_UNDEF,
+ *         a negative value.
+ *
+ * \details H5Dget_offset() returns the address in the file of
+ *          the dataset, \p dset_id. That address is expressed as the
+ *          offset in bytes from the beginning of the file.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL haddr_t H5Dget_offset(hid_t dset_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Reads raw data from a dataset into a provided buffer
+ *
+ * \dset_id                 Identifier of the dataset to read from
+ * \param[in] mem_type_id   Identifier of the memory datatype
+ * \param[in] mem_space_id  Identifier of the memory dataspace
+ * \param[in] file_space_id Identifier of the dataset's dataspace in the file
+ * \param[in] dxpl_id       Identifier of a transfer property list
+ * \param[out] buf          Buffer to receive data read from file
+ *
+ * \return \herr_t
+ *
+ * \details H5Dread() reads a dataset, specified by its identifier
+ *          \p dset_id, from the file into an application memory buffer \p
+ *          buf. Data transfer properties are defined by the argument \p
+ *          dxpl_id. The memory datatype of the (partial) dataset
+ *          is identified by the identifier \p mem_type_id. The part
+ *          of the dataset to read is defined by \p mem_space_id and \p
+ *          file_space_id.
+ *
+ *          \p file_space_id is used to specify only the selection within
+ *          the file dataset's dataspace. Any dataspace specified in \p
+ *          file_space_id is ignored by the library and the dataset's
+ *          dataspace is always used. \p file_space_id can be the constant
+ *          #H5S_ALL, which indicates that the entire file dataspace,
+ *          as defined by the current dimensions of the dataset, is to
+ *          be selected.
+ *
+ *          \p mem_space_id is used to specify both the memory dataspace
+ *          and the selection within that dataspace. \p mem_space_id can
+ *          be the constant #H5S_ALL, in which case the file dataspace is
+ *          used for the memory dataspace and the selection defined with \p
+ *          file_space_id is used for the selection within that dataspace.
+ *
+ *          The number of elements selected in the memory dataspace \Emph{must}
+ *          be equal to the number of elements selected in the file dataspace.
+ *
+ *          The behavior of the library for the various combinations of
+ *          valid dataspace identifiers and #H5S_ALL for the \p mem_space_id
+ *          and the \p file_space_id parameters is described below:
+ *
+ *          <table>
+ *            <tr>
+ *              <th>mem_space_id</th>
+ *              <th>file_space_id</th>
+ *              <th>Behavior</th>
+ *            </tr>
+ *            <tr>
+ *              <td>valid dataspace ID</td>
+ *              <td>valid dataspace ID</td>
+ *              <td>\p mem_space_id specifies the memory dataspace and the
+ *                  selection within it. \p file_space_id specifies the
+ *                  selection within the file dataset's dataspace.</td>
+ *            </tr>
+ *            <tr>
+ *              <td>#H5S_ALL</td>
+ *              <td>valid dataspace ID</td>
+ *              <td>The file dataset's dataspace is used for the memory
+ *                  dataspace and the selection specified with \p file_space_id
+ *                  specifies the selection within it. The combination of the
+ *                  file dataset's dataspace and the selection from
+ *                  \p file_space_id is used for memory also.</td>
+ *            </tr>
+ *            <tr>
+ *              <td>valid dataspace ID</td>
+ *              <td>#H5S_ALL</td>
+ *              <td>\p mem_space_id specifies the memory dataspace and the
+ *                  selection within it. The selection within the file
+ *                  dataset's dataspace is set to the "all" selection.</td>
+ *            </tr>
+ *            <tr>
+ *              <td>#H5S_ALL</td>
+ *              <td>#H5S_ALL</td>
+ *              <td>The file dataset's dataspace is used for the memory
+ *                  dataspace and the selection within the memory dataspace
+ *                  is set to the "all" selection. The selection within the
+ *                  file dataset's dataspace is set to the "all" selection.</td>
+ *            </tr>
+ *          </table>
+ *
+ * \note If no storage space was allocated for the dataset
+ *       and a fill value is defined, the returned buffer \p buf
+ *       is filled with the fill value.
+ *
+ * \par Example
+ * \snippet H5D_examples.c read
+ *
+ */
+H5_DLL herr_t H5Dread(hid_t dset_id, hid_t mem_type_id, hid_t mem_space_id, hid_t file_space_id,
+                      hid_t dxpl_id, void *buf /*out*/);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Reads raw data from a set of datasets into the provided buffers
+ *
+ * \param[in] count         Number of datasets to read from
+ * \param[in] dset_id       Identifiers of the datasets to read from
+ * \param[in] mem_type_id   Identifiers of the memory datatypes
+ * \param[in] mem_space_id  Identifiers of the memory dataspaces
+ * \param[in] file_space_id Identifiers of the datasets' dataspaces in the file
+ * \param[in] dxpl_id       Identifier of a transfer property list
+ * \param[out] buf          Buffers to receive data read from file
+ *
+ * \return \herr_t
+ *
+ * \details H5Dread_multi() reads data from \p count datasets, whose identifiers
+ *          are listed in the \p dset_id array, from the file into multiple
+ *          application memory buffers listed in the \p buf array. Data transfer
+ *          properties are defined by the argument \p dxpl_id. The memory
+ *          datatypes of each dataset are listed by identifier in the \p
+ *          mem_type_id array. The parts of each dataset to read are listed by
+ *          identifier in the \p file_space_id array, and the parts of each
+ *          application memory buffer to read to are listed by identifier in the
+ *          \p mem_space_id array. All array parameters have length \p count.
+ *
+ *          This function will produce the same results as \p count calls to
+ *          H5Dread(). Information listed in that function about the specifics
+ *          of its behavior also applies to H5Dread_multi(). By calling
+ *          H5Dread_multi() instead of multiple calls to H5Dread(), however, the
+ *          library can in some cases pass information about the entire I/O
+ *          operation to the file driver, which can improve performance.
+ *
+ *          All datasets must be in the same HDF5 file, and each unique dataset
+ *          may only be listed once. If this function is called collectively in
+ *          parallel, each rank must pass exactly the same list of datasets in
+ *          \p dset_id , though the other parameters may differ.
+ *
+ * \since 1.14.0
+ *
+ * \see H5Dread()
+ *
+ */
+H5_DLL herr_t H5Dread_multi(size_t count, hid_t dset_id[], hid_t mem_type_id[], hid_t mem_space_id[],
+                            hid_t file_space_id[], hid_t dxpl_id, void *buf[] /*out*/);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Dread}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Dread_async(const char *app_file, const char *app_func, unsigned app_line, hid_t dset_id,
+                            hid_t mem_type_id, hid_t mem_space_id, hid_t file_space_id, hid_t dxpl_id,
+                            void *buf /*out*/, hid_t es_id);
+#else
+H5_DLL herr_t H5Dread_async(hid_t dset_id, hid_t mem_type_id, hid_t mem_space_id, hid_t file_space_id,
+                            hid_t dxpl_id, void *buf /*out*/, hid_t es_id);
+#endif
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Dread_multi}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Dread_multi_async(const char *app_file, const char *app_func, unsigned app_line, size_t count,
+                                  hid_t dset_id[], hid_t mem_type_id[], hid_t mem_space_id[],
+                                  hid_t file_space_id[], hid_t dxpl_id, void *buf[] /*out*/, hid_t es_id);
+#else
+H5_DLL herr_t H5Dread_multi_async(size_t count, hid_t dset_id[], hid_t mem_type_id[], hid_t mem_space_id[],
+                                  hid_t file_space_id[], hid_t dxpl_id, void *buf[] /*out*/, hid_t es_id);
+#endif
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Writes raw data from a buffer to a dataset
+ *
+ * \param[in] dset_id        Identifier of the dataset to read from
+ * \param[in] mem_type_id    Identifier of the memory datatype
+ * \param[in] mem_space_id   Identifier of the memory dataspace
+ * \param[in] file_space_id  Identifier of the dataset's dataspace in the file
+ * \dxpl_id
+ * \param[out] buf           Buffer with data to be written to the file
+ *
+ * \return \herr_t
+ *
+ * \details H5Dwrite() writes a (partial) dataset, specified by
+ *          its identifier \p dset_id, from the application memory buffer \p
+ *          buf into the file. Data transfer properties are defined by the
+ *          argument \p dxpl_id. The memory datatype of the (partial)
+ *          dataset is identified by the identifier \p mem_type_id. The
+ *          part of the dataset to write is defined by \p mem_space_id
+ *          and \p file_space_id.
+ *
+ *          If \p mem_type_id is either a fixed-length or variable-length
+ *          string, it is important to set the string length when defining
+ *          the datatype. String datatypes are derived from #H5T_C_S1
+ *          (or #H5T_FORTRAN_S1 for Fortran codes), which defaults
+ *          to 1 character in size. See H5Tset_size() and Creating
+ *          variable-length string datatypes.
+ *
+ *          \p file_space_id is used to specify only the selection within
+ *          the file dataset's dataspace. Any dataspace specified in \p
+ *          file_space_id is ignored by the library and the dataset's
+ *          dataspace is always used. \p file_space_id can be the constant
+ *          #H5S_ALL, which indicates that the entire file dataspace,
+ *          as defined by the current dimensions of the dataset, is to
+ *          be selected.
+ *
+ *          \p mem_space_id is used to specify both the memory dataspace
+ *          and the selection within that dataspace. mem_space_id can be
+ *          the constant #H5S_ALL, in which case the file dataspace is
+ *          used for the memory dataspace and the selection defined with \p
+ *          file_space_id is used for the selection within that dataspace.
+ *
+ *          The behavior of the library for the various combinations of
+ *          valid dataspace IDs and #H5S_ALL for the mem_space_id and
+ *          thefile_space_id parameters is described below:
+ *
+ *          <table>
+ *          <tr><th>\c mem_space_id</th>
+ *          <th>\c file_space_id</th>
+ *          <th>Behavior</th></tr>
+ *          <tr><td>valid dataspace ID</td>
+ *              <td>valid dataspace ID</td>
+ *              <td>\p mem_space_id specifies the memory dataspace and the
+ *                  selection within it. \p file_space_id specifies the
+ *                  selection within the file dataset's dataspace.</td></tr>
+ *          <tr><td>#H5S_ALL</td>
+ *              <td>valid dataspace ID</td>
+ *              <td>The file dataset's dataspace is used for the memory
+ *                  dataspace and the selection specified with \p file_space_id
+ *                  specifies the selection within it. The combination of the
+ *                  file dataset's dataspace and the selection from \p
+ *                  file_space_id is used for memory also. valid dataspace
+ *                  ID</td></tr>
+ *          <tr><td>valid dataspace ID</td>
+ *              <td>#H5S_ALL</td>
+ *              <td>\p mem_space_id specifies the memory dataspace and the
+ *                  selection within it. The selection within the file
+ *                  dataset's dataspace is set to "all" selection.</td></tr>
+ *          <tr><td>#H5S_ALL</td>
+ *              <td>#H5S_ALL</td>
+ *              <td>The file dataset's dataspace is used for the memory
+ *                  dataspace and the selection within the memory dataspace is
+ *                  set to the "all" selection. The selection within the file
+ *                  dataset's dataspace is set to the "all"
+ *                  selection.</td></tr>
+ *          </table>
+ *          Setting an "all" selection indicates that the entire dataspace,
+ *          as defined by the current dimensions of a dataspace, will
+ *          be selected. The number of elements selected in the memory
+ *          dataspace must match the number of elements selected in the
+ *          file dataspace.
+ *
+ *          \p dxpl_id can be the constant #H5P_DEFAULT, in which
+ *          case the default data transfer properties are used.
+ *
+ *          Writing to a dataset will fail if the HDF5 file was not opened
+ *          with write access permissions.
+ *
+ *          If the dataset's space allocation time is set to
+ *          #H5D_ALLOC_TIME_LATE or #H5D_ALLOC_TIME_INCR and the space for
+ *          the dataset has not yet been allocated, that space is allocated
+ *          when the first raw data is written to the dataset. Unused space
+ *          in the dataset will be written with fill values at the same
+ *          time if the dataset's fill time is set to #H5D_FILL_TIME_IFSET
+ *          or #H5D_FILL_TIME_ALLOC.
+ *
+ * \par_compr_note
+ *
+ * \attention If a dataset's storage layout is 'compact', care must be
+ *          taken when writing data to the dataset in parallel. A compact
+ *          dataset's raw data is cached in memory and may be flushed
+ *          to the file from any of the parallel processes, so parallel
+ *          applications should always attempt to write identical data to
+ *          the dataset from all processes.
+ *
+ * \par Example
+ * \snippet H5D_examples.c update
+ *
+ * \see H5Pset_fill_time(), H5Pset_alloc_time()
+ *
+ */
+H5_DLL herr_t H5Dwrite(hid_t dset_id, hid_t mem_type_id, hid_t mem_space_id, hid_t file_space_id,
+                       hid_t dxpl_id, const void *buf);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Writes raw data from a set buffers to a set of datasets
+ *
+ * \param[in] count         Number of datasets to write to
+ * \param[in] dset_id       Identifiers of the datasets to write to
+ * \param[in] mem_type_id   Identifiers of the memory datatypes
+ * \param[in] mem_space_id  Identifiers of the memory dataspaces
+ * \param[in] file_space_id Identifiers of the datasets' dataspaces in the file
+ * \param[in] dxpl_id       Identifier of a transfer property list
+ * \param[in] buf           Buffers with data to be written to the file
+ *
+ * \return \herr_t
+ *
+ * \details H5Dwrite_multi() writes data to \p count datasets, whose identifiers
+ *          are listed in the \p dset_id array, from multiple application memory
+ *          buffers listed in the \p buf array. Data transfer properties are
+ *          defined by the argument \p dxpl_id. The memory datatypes of each
+ *          dataset are listed by identifier in the \p mem_type_id array. The
+ *          parts of each dataset to write are listed by identifier in the \p
+ *          file_space_id array, and the parts of each application memory buffer
+ *          to write from are listed by identifier in the \p mem_space_id array.
+ *          All array parameters have length \p count.
+ *
+ *          This function will produce the same results as \p count calls to
+ *          H5Dwrite(). Information listed in that function's documentation
+ *          about the specifics of its behaviour also apply to H5Dwrite_multi().
+ *          By calling H5Dwrite_multi() instead of multiple calls to H5Dwrite(),
+ *          however, the library can in some cases pass information about the
+ *          entire I/O operation to the file driver, which can improve
+ *          performance.
+ *
+ *          All datasets must be in the same HDF5 file, and each unique dataset
+ *          may only be listed once. If this function is called collectively in
+ *          parallel, each rank must pass exactly the same list of datasets in
+ *          \p dset_id , though the other parameters may differ.
+ *
+ * \since 1.14.0
+ *
+ * \see H5Dwrite()
+ *
+ */
+H5_DLL herr_t H5Dwrite_multi(size_t count, hid_t dset_id[], hid_t mem_type_id[], hid_t mem_space_id[],
+                             hid_t file_space_id[], hid_t dxpl_id, const void *buf[]);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Dwrite}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Dwrite_async(const char *app_file, const char *app_func, unsigned app_line, hid_t dset_id,
+                             hid_t mem_type_id, hid_t mem_space_id, hid_t file_space_id, hid_t dxpl_id,
+                             const void *buf, hid_t es_id);
+#else
+H5_DLL herr_t H5Dwrite_async(hid_t dset_id, hid_t mem_type_id, hid_t mem_space_id, hid_t file_space_id,
+                             hid_t dxpl_id, const void *buf, hid_t es_id);
+#endif
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Dwrite_multi}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Dwrite_multi_async(const char *app_file, const char *app_func, unsigned app_line,
+                                   size_t count, hid_t dset_id[], hid_t mem_type_id[], hid_t mem_space_id[],
+                                   hid_t file_space_id[], hid_t dxpl_id, const void *buf[], hid_t es_id);
+#else
+H5_DLL herr_t H5Dwrite_multi_async(size_t count, hid_t dset_id[], hid_t mem_type_id[], hid_t mem_space_id[],
+                                   hid_t file_space_id[], hid_t dxpl_id, const void *buf[], hid_t es_id);
+#endif
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Writes a raw data chunk from a buffer directly to a dataset in a file
+ *
+ * \dset_id
+ * \dxpl_id
+ * \param[in]  filters  Mask for identifying the filters in use
+ * \param[in]  offset   Logical position of the chunk's first element in the
+ *                      dataspace
+ * \param[in]  data_size    Size of the actual data to be written in bytes
+ * \param[in]  buf          Buffer containing data to be written to the chunk
+ *
+ * \return \herr_t
+ *
+ * \details H5Dwrite_chunk() writes a raw data chunk as specified
+ *          by its logical offset \p offset in a chunked dataset \p dset_id
+ *          from the application memory buffer \p buf to the dataset in
+ *          the file. Typically, the data in \p buf is preprocessed in
+ *          memory by a custom transformation, such as compression. The
+ *          chunk will bypass the library's internal data transfer
+ *          pipeline, including filters, and will be written directly to
+ *          the file. Only one chunk can be written with this function.
+ *
+ *          \p filters is a mask providing a record of which filters are
+ *          used with the chunk. The default value of the mask is
+ *          zero (0), indicating that all enabled filters are applied. A
+ *          filter is skipped if the bit corresponding to the filter's
+ *          position in the pipeline (0  position < 32) is turned on.
+ *          This mask is saved with the chunk in the file.
+ *
+ *          \p offset is an array specifying the logical position of the
+ *          first element of the chunk in the dataset's dataspace. The
+ *          length of the offset array must equal the number of dimensions,
+ *          or rank, of the dataspace. The values in offset must not exceed
+ *          the dimension limits and must specify a point that falls on
+ *          a dataset chunk boundary.
+ *
+ *          \p data_size is the size in bytes of the chunk, representing
+ *          the number of bytes to be read from the buffer \p buf. If the
+ *          data chunk has been precompressed, \p data_size should be the
+ *          size of the compressed data.
+ *
+ *          \p buf is the memory buffer containing data to be written to
+ *          the chunk in the file.
+ *
+ * \attention Exercise caution when using H5Dread_chunk() and
+ *          H5Dwrite_chunk(), as they read and write data chunks directly
+ *          in a file. H5Dwrite_chunk() bypasses hyperslab selection, the
+ *          conversion of data from one datatype to another, and the filter
+ *          pipeline to write the chunk. Developers should have experience
+ *          with these processes before using this function.
+ *
+ * \note    H5Dread_chunk() and H5Dwrite_chunk() are currently not supported
+ *          with parallel HDF5 and do not support variable-length types.
+ *
+ * \since 1.10.2
+ *
+ */
+H5_DLL herr_t H5Dwrite_chunk(hid_t dset_id, hid_t dxpl_id, uint32_t filters, const hsize_t *offset,
+                             size_t data_size, const void *buf);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Reads a raw data chunk directly from a dataset in a file into
+ * a buffer
+ *
+ * \dset_id
+ * \dxpl_id
+ * \param[in]  offset   Logical position of the chunk's first element in the
+ *                      dataspace
+ * \param[in,out]  filters  Mask for identifying the filters in use
+ * \param[out]  buf     Buffer containing data to be read from the chunk
+ *
+ * \return \herr_t
+ *
+ * \details H5Dread_chunk() reads a raw data chunk as specified by
+ *          its logical offset \p offset in a chunked dataset \p dset_id
+ *          from the dataset in the file into the application memory
+ *          buffer \p buf. The data in \p buf is read directly from the
+ *          file bypassing the library's internal data transfer pipeline,
+ *          including filters.
+ *
+ *          \p offset is an array specifying the logical position of the
+ *          first element of the chunk in the dataset's dataspace. The
+ *          length of the \p offset array must equal the number of dimensions,
+ *          or rank, of the dataspace. The values in \p offset must not exceed
+ *          the dimension limits and must specify a point that falls on
+ *          a dataset chunk boundary.
+ *
+ *          The mask \p filters indicates which filters were used when the
+ *          chunk was written. A zero value (all bits 0) indicates that all
+ *          enabled filters are applied on the chunk. A filter is skipped if
+ *          the bit corresponding to the filter's position in the pipeline
+ *          (0  position < 32) is turned on.
+ *
+ *          \p buf is the memory buffer containing the chunk read from
+ *          the dataset in the file.
+ *
+ * \attention Exercise caution when using H5Dread_chunk() and
+ *          H5Dwrite_chunk(), as they read and write data chunks directly
+ *          in a file. H5Dwrite_chunk() bypasses hyperslab selection, the
+ *          conversion of data from one datatype to another, and the filter
+ *          pipeline to write the chunk. Developers should have experience
+ *          with these processes before using this function. Please see
+ *          Using the Direct Chunk Write Function for more information.
+ *
+ * \note H5Dread_chunk() and H5Dwrite_chunk() are currently not supported
+ *       with parallel HDF5 and do not support variable-length datatypes.
+ *
+ * \since 1.10.2
+ *
+ */
+H5_DLL herr_t H5Dread_chunk(hid_t dset_id, hid_t dxpl_id, const hsize_t *offset, uint32_t *filters,
+                            void *buf);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Iterates over all selected elements in a dataspace
+ *
+ * \param[in,out] buf Buffer containing the elements to iterate over
+ * \type_id
+ * \space_id
+ * \param[in] op Function pointer
+ * \param[in,out] operator_data User-defined data
+ *
+ * \return \success{The return value of the first operator that returns
+ *                  non-zero, or zero if all members were processed with no
+ *                  operator returning non-zero.}
+ * \return \failure{Negative if an error occurs in the library, or the negative
+ *                  value returned by one of the operators.}
+ *
+ * \details H5Diterate() iterates over all the data elements
+ *          in the memory buffer \p buf, executing the callback function
+ *          \p op once for each such data element.
+ *
+ * \attention Unlike other HDF5 iterators, this iteration operation cannot
+ *            be restarted at the point of exit; a second H5Diterate()
+ *            call will always restart at the beginning.
+ *
+ * \warning   Modifying the selection of \p space_id during iteration
+ *            will lead to undefined behavior.
+ *
+ * \since 1.10.2
+ *
+ */
+H5_DLL herr_t H5Diterate(void *buf, hid_t type_id, hid_t space_id, H5D_operator_t op, void *operator_data);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Determines the number of bytes required to store variable-length
+ *        (VL) data
+ *
+ * \dset_id
+ * \type_id
+ * \space_id
+ * \param[out] size Size in bytes of the memory buffer required to store
+ *        the VL data
+ *
+ * \return \herr_t
+ *
+ * \details H5Dvlen_get_buf_size() determines the number of bytes
+ *          required to store the VL data from the dataset, using \p
+ *          space_id for the selection in the dataset on disk and the \p
+ *          type_id for the memory representation of the VL data in memory.
+ *          \p size is returned with the number of bytes required to store
+ *          the VL data in memory.
+ *
+ * \since 1.10.2
+ *
+ */
+H5_DLL herr_t H5Dvlen_get_buf_size(hid_t dset_id, hid_t type_id, hid_t space_id, hsize_t *size);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Fills dataspace elements with a fill value in a memory buffer
+ *
+ * \param[in] fill          Pointer to the fill value to be used
+ * \param[in] fill_type_id  Fill value datatype identifier
+ * \param[in,out] buf       Pointer to the memory buffer containing the
+ *                          selection to be filled
+ * \param[in] buf_type_id   Datatype of dataspace elements to be filled
+ * \space_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Dfill() fills the dataspace selection, \p space_id, in memory
+ *          with the fill value specified in \p fill. If \p fill is NULL,
+ *          a fill value of 0 (zero) is used.
+ *
+ *          \p fill_type_id specifies the datatype of the fill value.
+ *          \p buf specifies the buffer in which the fill elements
+ *          will be written. \p buf_type_id specifies the datatype of
+ *          those data elements.
+ *
+ * \note Note that if the fill value datatype differs from the memory
+ *       buffer datatype, the fill value will be converted to the memory
+ *       buffer datatype before filling the selection.
+ *
+ * \note Applications sometimes write data only to portions of an
+ *       allocated dataset. It is often useful in such cases to fill
+ *       the unused space with a known fill value.
+ *
+ * \see H5Pset_fill_value(), H5Pget_fill_value(), H5Pfill_value_defined(),
+ *      H5Pset_fill_time(), H5Pget_fill_time(), H5Pcreate(), H5Dcreate_anon()
+ *
+ */
+H5_DLL herr_t H5Dfill(const void *fill, hid_t fill_type_id, void *buf, hid_t buf_type_id, hid_t space_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Changes the sizes of a dataset's dimensions
+ *
+ * \dset_id
+ * \param[in] size[]   Array containing the new magnitude of each dimension
+ *                     of the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5Dset_extent() sets the current dimensions of the
+ *          chunked dataset \p dset_id to the sizes specified in size.
+ *
+ *          \p size is a 1-dimensional array with n elements, where \p n is
+ *          the rank of the dataset's current dataspace.
+ *
+ *          This function can be applied to the following datasets:
+ *          - A chunked dataset with unlimited dimensions
+ *          - A chunked dataset with fixed dimensions if the new dimension
+ *          sizes are less than the maximum sizes set with maxdims (see
+ *          H5Screate_simple())
+ *          - An external dataset with unlimited dimensions
+ *          - An external dataset with fixed dimensions if the new dimension
+ *          sizes are less than the maximum sizes set with \p maxdims
+ *
+ *          Note that external datasets are always contiguous and can be
+ *          extended only along the first dimension.
+ *
+ *          Space on disk is immediately allocated for the new dataset extent if
+ *          the dataset's space allocation time is set to #H5D_ALLOC_TIME_EARLY.
+ *
+ *          Fill values will be written to the dataset in either of the
+ *          following situations, but not otherwise:
+ *
+ *          - If the dataset's fill time is set to #H5D_FILL_TIME_IFSET and a
+ *            fill value is defined (see H5Pset_fill_time() and
+ *            H5Pset_fill_value())
+ *          - If the dataset's fill time is set to #H5D_FILL_TIME_ALLOC
+ *            (see H5Pset_alloc_time())
+ *
+ * \note If the sizes specified in \p size array are smaller than the dataset's
+ *       current dimension sizes, H5Dset_extent() will reduce the dataset's
+ *       dimension sizes to the specified values. It is the user application's
+ *       responsibility to ensure that valuable data is not lost as
+ *       H5Dset_extent() does not check.
+ *
+ * \note Except for external datasets, H5Dset_extent() is for use with
+ *       chunked datasets only, not contiguous datasets.
+ *
+ * \note A call to H5Dset_extent() affects the dataspace of a dataset.  If a
+ *       dataspace handle was opened for a dataset prior to a call to
+ *       H5Dset_extent() then that dataspace handle will no longer reflect the
+ *       correct dataspace extent of the dataset. H5Dget_space() must be called
+ *       (after closing the previous handle) to obtain the current dataspace
+ *       extent.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Dset_extent(hid_t dset_id, const hsize_t size[]);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Dset_extent}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Dset_extent_async(const char *app_file, const char *app_func, unsigned app_line,
+                                  hid_t dset_id, const hsize_t size[], hid_t es_id);
+#else
+H5_DLL herr_t H5Dset_extent_async(hid_t dset_id, const hsize_t size[], hid_t es_id);
+#endif
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Flushes all buffers associated with a dataset to disk
+ *
+ * \dset_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Dflush() causes all buffers associated with a
+ *          dataset to be immediately flushed to disk without removing
+ *          the data from the cache.
+ *
+ *          \note HDF5 does not possess full control over buffering.
+ *          H5Dflush() flushes the internal HDF5 buffers and then asks the
+ *          operating system (the OS) to flush the system buffers for the
+ *          open files. After that, the OS is responsible for ensuring
+ *          that the data is actually flushed to disk.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Dflush(hid_t dset_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Refreshes all buffers associated with a dataset
+ *
+ * \dset_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Drefresh() causes all buffers associated with a
+ *          dataset to be cleared and immediately re-loaded with updated
+ *          contents from disk.
+ *
+ *          This function essentially closes the dataset, evicts all
+ *          metadata associated with it from the cache, and then re-opens
+ *          the dataset. The reopened dataset is automatically re-registered
+ *          with the same identifier.
+ *
+ * \since 1.10.2
+ *
+ */
+H5_DLL herr_t H5Drefresh(hid_t dset_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Scatters data into a selection within a memory buffer
+ *
+ * \param[in]  op       Callback function which provides data to be scattered
+ * \param[in]  op_data  User-defined pointer to data required by op
+ * \param[in]  type_id  Identifier for the datatype describing the data in
+ *                      both the source and destination buffers
+ * \param[in]  dst_space_id    Identifier for the dataspace for destination
+ * \param[out] dst_buf  Destination buffer which the data will be scattered to
+ *
+ * \return \herr_t
+ *
+ * \details H5Dscatter() retrieves data from the supplied callback
+ *          \p op and scatters it to the supplied buffer \p dst_buf in a
+ *          manner similar to data being written to a dataset.
+ *
+ *          \p dst_space_id is a dataspace that defines the extent of \p
+ *          dst_buf and the selection within it to scatter the data to.
+ *
+ *          \p type_id is the datatype of the data to be scattered in both
+ *          the source and destination buffers.
+ *
+ *          \p dst_buf must be at least as large as the number of elements
+ *          in the extent of \p dst_space_id times the size in bytes of
+ *          \p type_id.
+ *
+ *          To retrieve the data to be scattered, H5Dscatter() repeatedly
+ *          calls \p op, which should return a valid source buffer, until
+ *          enough data to fill the selection has been retrieved.
+ *
+ * \since 1.10.2
+ *
+ */
+H5_DLL herr_t H5Dscatter(H5D_scatter_func_t op, void *op_data, hid_t type_id, hid_t dst_space_id,
+                         void *dst_buf);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Gathers data from a selection within a memory buffer
+ * raw data chunk in a dataset
+ *
+ * \param[in]  src_space_id  Dataspace identifier for the source buffer
+ * \param[in]  src_buf   Source buffer which the data will be gathered from
+ * \param[in]  type_id   Datatype identifier for the source
+ * \param[in]  dst_buf_size   Size in bytes of \p dst_buf
+ * \param[out] dst_buf   Destination buffer for the gathered data
+ * \param[in]  op   Callback function which handles the gathered data
+ * \param[in]  op_data   User-defined pointer to data required by \p op
+ *
+ * \return \herr_t
+ *
+ * \details H5Dgather() retrieves data from a selection within the supplied
+ *          buffer src_buf and passes it to the supplied callback function
+ *          \p op in a contiguous form.
+ *
+ *          The dataspace \p src_space_id describes both the dimensions of
+ *          the source buffer and the selection within the source buffer
+ *          to gather data from.
+ *
+ *          \p src_buf must be at least the size of the gathered data, that
+ *          is, the number of elements in the extent of \p src_space_id
+ *          times the size in bytes of \p type_id.
+ *
+ *          The datatype \p type_id describes the data in both the source
+ *          and destination buffers. This information is used to calculate
+ *          the element size.
+ *
+ *          The data is gathered into \p dst_buf, which needs to be large
+ *          enough to hold all the data if the callback function \p op is
+ *          not provided.
+ *
+ *          \p op is a callback function that handles the gathered data.
+ *          It is optional if \p dst_buf is large enough to hold all of the
+ *          gathered data; required otherwise.
+ *
+ *          If no callback function is provided, H5Dgather() simply gathers
+ *          the data into \p dst_buf and returns. If a callback function is
+ *          provided, H5Dgather() repeatedly gathers up to \p dst_buf_size
+ *          bytes to process the serialized data.
+ *
+ *          The callback function \p op should process, store, or otherwise,
+ *          make use of the data returned in \p dst_buf before it returns,
+ *          because the buffer will be overwritten unless it is the last
+ *          call to the callback. This function will be repeatedly called
+ *          until all gathered elements have been passed to the callback
+ *          in \p dst_buf. The callback function should return zero (0)
+ *          to indicate success, and a negative value to indicate failure.
+ *
+ * \since 1.10.2
+ *
+ */
+H5_DLL herr_t H5Dgather(hid_t src_space_id, const void *src_buf, hid_t type_id, size_t dst_buf_size,
+                        void *dst_buf, H5D_gather_func_t op, void *op_data);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Closes the specified dataset
+ *
+ * \dset_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Dclose() terminates access to a dataset via the identifier
+ *          \p dset_id and releases the underlying resources.
+ *
+ * \par Example
+ * \snippet H5D_examples.c read
+ *
+ * \since 1.8.0
+ *
+ * \see H5Dcreate2(), H5Dopen2()
+ *
+ */
+H5_DLL herr_t H5Dclose(hid_t dset_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Dclose}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Dclose_async(const char *app_file, const char *app_func, unsigned app_line, hid_t dset_id,
+                             hid_t es_id);
+#else
+H5_DLL herr_t H5Dclose_async(hid_t dset_id, hid_t es_id);
+#endif
+/// \cond DEV
+/* Internal API routines */
+H5_DLL herr_t H5Ddebug(hid_t dset_id);
+H5_DLL herr_t H5Dformat_convert(hid_t dset_id);
+H5_DLL herr_t H5Dget_chunk_index_type(hid_t did, H5D_chunk_index_t *idx_type);
+/// \endcond
+
+/// \cond DEV
+/* API Wrappers for async routines */
+/* (Must be defined _after_ the function prototype) */
+/* (And must only defined when included in application code, not the library) */
+#ifndef H5D_MODULE
+#define H5Dcreate_async(...)      H5Dcreate_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Dopen_async(...)        H5Dopen_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Dget_space_async(...)   H5Dget_space_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Dread_async(...)        H5Dread_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Dread_multi_async(...)  H5Dread_multi_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Dwrite_async(...)       H5Dwrite_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Dwrite_multi_async(...) H5Dwrite_multi_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Dset_extent_async(...)  H5Dset_extent_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Dclose_async(...)       H5Dclose_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+
+/* Define "wrapper" versions of function calls, to allow compile-time values to
+ *      be passed in by language wrapper or library layer on top of HDF5.
+ */
+#define H5Dcreate_async_wrap     H5_NO_EXPAND(H5Dcreate_async)
+#define H5Dopen_async_wrap       H5_NO_EXPAND(H5Dopen_async)
+#define H5Dget_space_async_wrap  H5_NO_EXPAND(H5Dget_space_async)
+#define H5Dread_async_wrap       H5_NO_EXPAND(H5Dread_async)
+#define H5Dwrite_async_wrap      H5_NO_EXPAND(H5Dwrite_async)
+#define H5Dset_extent_async_wrap H5_NO_EXPAND(H5Dset_extent_async)
+#define H5Dclose_async_wrap      H5_NO_EXPAND(H5Dclose_async)
+#endif /* H5D_MODULE */
+/// \endcond
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+#define H5D_CHUNK_BTREE H5D_CHUNK_IDX_BTREE
+
+/* Formerly used to support the H5DOread/write_chunk() API calls.
+ * These symbols are no longer used in the library.
+ */
+/* Property names for H5DOwrite_chunk */
+#define H5D_XFER_DIRECT_CHUNK_WRITE_FLAG_NAME     "direct_chunk_flag"
+#define H5D_XFER_DIRECT_CHUNK_WRITE_FILTERS_NAME  "direct_chunk_filters"
+#define H5D_XFER_DIRECT_CHUNK_WRITE_OFFSET_NAME   "direct_chunk_offset"
+#define H5D_XFER_DIRECT_CHUNK_WRITE_DATASIZE_NAME "direct_chunk_datasize"
+/* Property names for H5DOread_chunk */
+#define H5D_XFER_DIRECT_CHUNK_READ_FLAG_NAME    "direct_chunk_read_flag"
+#define H5D_XFER_DIRECT_CHUNK_READ_OFFSET_NAME  "direct_chunk_read_offset"
+#define H5D_XFER_DIRECT_CHUNK_READ_FILTERS_NAME "direct_chunk_read_filters"
+
+/* Typedefs */
+
+/* Function prototypes */
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Creates a dataset at the specified location
+ *
+ * \fgdta_loc_id
+ * \param[in] name Name of the dataset to create
+ * \type_id
+ * \space_id
+ * \dcpl_id
+ *
+ * \return \hid_t{dataset}
+ *
+ * \deprecation_note{H5Dcreate2() or the macro H5Dcreate()}
+ *
+ * \details H5Dcreate1() creates a data set with a name, \p name, in the
+ *          location specified by the identifier \p loc_id. \p loc_id may be a
+ *          file, group, dataset, named datatype or attribute.  If an attribute,
+ *          dataset, or named datatype is specified for \p loc_id then the
+ *          dataset will be created at the location where the attribute,
+ *          dataset, or named datatype is attached.
+ *
+ *          \p name can be a relative path based at \p loc_id or an absolute
+ *          path from the root of the file. Use of this function requires that
+ *          any intermediate groups specified in the path already exist.
+ *
+ *          The dataset's datatype and dataspace are specified by \p type_id and
+ *          \p space_id, respectively. These are the datatype and dataspace of
+ *          the dataset as it will exist in the file, which may differ from the
+ *          datatype and dataspace in application memory.
+ *
+ *          Names within a group are unique: H5Dcreate1() will return an error
+ *          if a link with the name specified in name already exists at the
+ *          location specified in \p loc_id.
+ *
+ *          As is the case for any object in a group, the length of a dataset
+ *          name is not limited.
+ *
+ *          \p dcpl_id is an #H5P_DATASET_CREATE property list created with \p
+ *          H5reate1() and initialized with various property list functions
+ *          described in Property List Interface.
+ *
+ *          H5Dcreate() and H5Dcreate_anon() return an error if the dataset's
+ *          datatype includes a variable-length (VL) datatype and the fill value
+ *          is undefined, i.e., set to \c NULL in the dataset creation property
+ *          list. Such a VL datatype may be directly included, indirectly
+ *          included as part of a compound or array datatype, or indirectly
+ *          included as part of a nested compound or array datatype.
+ *
+ *          H5Dcreate() and H5Dcreate_anon() return a dataset identifier for
+ *          success or a negative value for failure. The dataset identifier
+ *          should eventually be closed by calling H5Dclose() to release the
+ *          resources it uses.
+ *
+ *          See H5Dcreate_anon() for a discussion of the differences between
+ *          H5Dcreate() and H5Dcreate_anon().
+ *
+ *          The HDF5 library provides flexible means of specifying a fill value,
+ *          of specifying when space will be allocated for a dataset, and of
+ *          specifying when fill values will be written to a dataset.
+ *
+ * \version 1.8.0 Function H5Dcreate() renamed to H5Dcreate1() and deprecated in this release.
+ * \since 1.0.0
+ *
+ * \see H5Dopen2(), H5Dclose(), H5Tset_size()
+ *
+ */
+H5_DLL hid_t H5Dcreate1(hid_t loc_id, const char *name, hid_t type_id, hid_t space_id, hid_t dcpl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Opens an existing dataset
+ *
+ * \fgdta_loc_id
+ * \param[in] name Name of the dataset to access
+ *
+ * \return \hid_t{dataset}
+ *
+ * \deprecation_note{H5Dopen2() or the macro H5Dopen()}
+ *
+ * \details H5Dopen1() opens an existing dataset for access at the location
+ *          specified by \p loc_id.  \p loc_id may be a file, group, dataset,
+ *          named datatype or attribute.  If an attribute, dataset, or named
+ *          datatype is specified for loc_id then the dataset will be opened at
+ *          the location where the attribute, dataset, or named datatype is
+ *          attached. name is a dataset name and is used to identify the dataset
+ *          in the file.
+ *
+ *          A dataset opened with this function should be closed with H5Dclose()
+ *          when the dataset is no longer needed so that resource leaks will not
+ *          develop.
+ *
+ * \version 1.8.0 Function H5Dopen() renamed to H5Dopen1() and deprecated in this release.
+ * \since 1.0.0
+ *
+ */
+H5_DLL hid_t H5Dopen1(hid_t loc_id, const char *name);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Extends a dataset
+ *
+ * \dset_id
+ * \param[in] size Array containing the new size of each dimension
+ *
+ * \return \herr_t
+ *
+ * \deprecation_note{H5Dset_extent()}
+ *
+ * \details H5Dextend() verifies that the dataset is at least of size \p size,
+ *          extending it if necessary. The length of \p size is the same as
+ *          that of the dataspace of the dataset being changed.
+ *
+ *          This function can be applied to the following datasets:
+ *          \li Any dataset with unlimited dimensions
+ *          \li A dataset with fixed dimensions if the current dimension sizes
+ *              are less than the maximum sizes set with \c maxdims
+ *              (see H5Screate_simple())
+ *
+ *          Space on disk is immediately allocated for the new dataset extent if
+ *          the dataset's space allocation time is set to
+ *          #H5D_ALLOC_TIME_EARLY. Fill values will be written to the dataset if
+ *          the dataset's fill time is set to #H5D_FILL_TIME_IFSET or
+ *          #H5D_FILL_TIME_ALLOC. (See H5Pset_fill_time() and
+ *          H5Pset_alloc_time().)
+ *
+ *          This function ensures that the dataset dimensions are of at least
+ *          the sizes specified in size. The function H5Dset_extent() must be
+ *          used if the dataset dimension sizes are to be reduced.
+ *
+ * \version 1.8.0 Function deprecated in this release. Parameter size
+ *                syntax changed to \Code{const hsize_t size[]} in this release.
+ *
+ */
+H5_DLL herr_t H5Dextend(hid_t dset_id, const hsize_t size[]);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5D
+ *
+ * \brief Reclaims variable-length (VL) datatype memory buffers
+ *
+ * \type_id
+ * \space_id
+ * \dxpl_id
+ * \param[in] buf Pointer to the buffer to be reclaimed
+ *
+ * \return \herr_t
+ *
+ * \deprecation_note{H5Treclaim()}
+ *
+ * \details H5Dvlen_reclaim() reclaims memory buffers created to store VL
+ *          datatypes.
+ *
+ *          The \p type_id must be the datatype stored in the buffer. The \p
+ *          space_id describes the selection for the memory buffer to free the
+ *          VL datatypes within. The \p dxpl_id is the dataset transfer property
+ *          list that was used for the I/O transfer to create the buffer. And
+ *          \p buf is the pointer to the buffer to be reclaimed.
+ *
+ *          The VL structures (\ref hvl_t) in the user's buffer are modified to
+ *          zero out the VL information after the memory has been reclaimed.
+ *
+ *          If nested VL datatypes were used to create the buffer, this routine
+ *          frees them from the bottom up, releasing all the memory without
+ *          creating memory leaks.
+ *
+ * \version 1.12.0 Function was deprecated
+ *
+ */
+H5_DLL herr_t H5Dvlen_reclaim(hid_t type_id, hid_t space_id, hid_t dxpl_id, void *buf);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* H5Dpublic_H */
diff --git a/install/include/H5ESdevelop.h b/install/include/H5ESdevelop.h
new file mode 100644
index 0000000000..b2facaacec
--- /dev/null
+++ b/install/include/H5ESdevelop.h
@@ -0,0 +1,52 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5ES (event set) developer
+ *      support routines.
+ */
+
+#ifndef H5ESdevelop_H
+#define H5ESdevelop_H
+
+/* Include package's public header */
+#include "H5ESpublic.h"
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5_DLL herr_t H5ESinsert_request(hid_t es_id, hid_t connector_id, void *request);
+H5_DLL herr_t H5ESget_requests(hid_t es_id, H5_iter_order_t order, hid_t *connector_ids, void **requests,
+                               size_t array_len, size_t *count);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5ESdevelop_H */
diff --git a/install/include/H5ESpublic.h b/install/include/H5ESpublic.h
new file mode 100644
index 0000000000..b5f2af48f7
--- /dev/null
+++ b/install/include/H5ESpublic.h
@@ -0,0 +1,387 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5ES (event set) module.
+ */
+
+#ifndef H5ESpublic_H
+#define H5ESpublic_H
+
+#include "H5public.h"  /* Generic Functions                        */
+#include "H5Ipublic.h" /* Identifiers                              */
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/**
+ * Default value for "no event set" / synchronous execution. Used in
+ * place of a @ref hid_t identifier.
+ */
+#define H5ES_NONE 0
+
+/* Special "wait" timeout values */
+#define H5ES_WAIT_FOREVER (UINT64_MAX) /**< Wait until all operations complete */
+
+/**
+ * Don't wait for operations to complete, just check their status.
+ * (This allows @ref H5ESwait to behave like a 'test' operation)
+ */
+#define H5ES_WAIT_NONE (0)
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/**
+ * Asynchronous operation status
+ */
+typedef enum H5ES_status_t {
+    H5ES_STATUS_IN_PROGRESS, /**< Operation(s) have not yet completed         */
+    H5ES_STATUS_SUCCEED,     /**< Operation(s) have completed, successfully   */
+    H5ES_STATUS_CANCELED,    /**< Operation(s) has been canceled              */
+    H5ES_STATUS_FAIL         /**< An operation has completed, but failed      */
+} H5ES_status_t;
+
+/**
+ * Information about operations in an event set
+ */
+typedef struct H5ES_op_info_t {
+    /* API call info */
+    const char *api_name; /**< Name of HDF5 API routine called */
+    char       *api_args; /**< "Argument string" for arguments to HDF5 API routine called */
+
+    /* Application info */
+    const char *app_file_name; /**< Name of source file where the HDF5 API routine was called */
+    const char *app_func_name; /**< Name of function where the HDF5 API routine was called */
+    unsigned    app_line_num;  /**< Line # of source file where the HDF5 API routine was called */
+
+    /* Operation info */
+    uint64_t op_ins_count; /**< Counter of operation's insertion into event set */
+    uint64_t op_ins_ts;    /**< Timestamp for when the operation was inserted into the event set */
+    uint64_t op_exec_ts;   /**< Timestamp for when the operation began execution */
+    uint64_t op_exec_time; /**< Execution time for operation (in ns) */
+} H5ES_op_info_t;
+
+//! <!-- [H5ES_err_info_t_snip] -->
+/**
+ * Information about failed operations in event set
+ */
+typedef struct H5ES_err_info_t {
+    /* API call info */
+    char *api_name; /**< Name of HDF5 API routine called */
+    char *api_args; /**< "Argument string" for arguments to HDF5 API routine called */
+
+    /* Application info */
+    char    *app_file_name; /**< Name of source file where the HDF5 API routine was called */
+    char    *app_func_name; /**< Name of function where the HDF5 API routine was called */
+    unsigned app_line_num;  /**< Line # of source file where the HDF5 API routine was called */
+
+    /* Operation info */
+    uint64_t op_ins_count; /**< Counter of operation's insertion into event set */
+    uint64_t op_ins_ts;    /**< Timestamp for when the operation was inserted into the event set */
+    uint64_t op_exec_ts;   /**< Timestamp for when the operation began execution */
+    uint64_t op_exec_time; /**< Execution time for operation (in ns) */
+
+    /* Error info */
+    hid_t err_stack_id; /**< ID for error stack from failed operation */
+} H5ES_err_info_t;
+//! <!-- [H5ES_err_info_t_snip] -->
+
+/*
+More Possible Info for H5ES_op_info_t:
+    Parent Operation's request token (*) -> "parent event count"? -- Could be
+        used to "prune" child operations from reported errors, with flag
+        to H5ESget_err_info?
+
+Possible debugging routines:  (Should also be configured from Env Var)
+    H5ESdebug_signal(hid_t es_id, signal_t sig, uint64_t <event count>);
+    H5ESdebug_err_trace_log(hid_t es_id, const char *filename);
+    H5ESdebug_err_trace_fh(hid_t es_id, FILE *fh);
+    H5ESdebug_err_signal(hid_t es_id, signal_t sig);
+[Possibly option to allow operations to be inserted into event set with error?]
+
+    Example usage:
+        es_id = H5EScreate();
+        H5ESdebug...(es_id, ...);
+        ...
+        H5Dwrite_async(..., es_id);
+
+How to Trace Async Operations?
+    <Example of stacking Logging VOL Connector w/Async VOL Connector>
+
+*/
+
+/**
+ * Callback for H5ESregister_insert_func()
+ */
+typedef int (*H5ES_event_insert_func_t)(const H5ES_op_info_t *op_info, void *ctx);
+
+/**
+ * Callback for H5ESregister_complete_func()
+ */
+typedef int (*H5ES_event_complete_func_t)(const H5ES_op_info_t *op_info, H5ES_status_t status,
+                                          hid_t err_stack, void *ctx);
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \ingroup H5ES
+ *
+ * \brief Creates an event set
+ *
+ * \returns \hid_t{event set}
+ *
+ * \details H5EScreate() creates a new event set and returns a corresponding
+ *          event set identifier.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL hid_t H5EScreate(void);
+
+/**
+ * \ingroup H5ES
+ *
+ * \brief Waits for operations in event set to complete
+ *
+ * \es_id
+ * \param[in] timeout Total time in nanoseconds to wait for all operations in
+ *            the event set to complete
+ * \param[out] num_in_progress The number of operations still in progress
+ * \param[out] err_occurred Flag if an operation in the event set failed
+ * \returns \herr_t
+ *
+ * \details H5ESwait() waits for operations in an event set \p es_id to wait
+ *          with \p timeout.
+ *
+ *          Timeout value is in nanoseconds, and is for the H5ESwait() call and
+ *          not for each individual operation in the event set. For example, if
+ *          "10" is passed as a timeout value and the event set waited 4
+ *          nanoseconds for the first operation to complete, the remaining
+ *          operations would be allowed to wait for at most 6 nanoseconds more,
+ *          i.e., the timeout value used across all operations in the event set
+ *          until it reaches 0, then any remaining operations are only checked
+ *          for completion, not waited on.
+ *
+ *          This call will stop waiting on operations and will return
+ *          immediately if an operation fails. If a failure occurs, the value
+ *          returned for the number of operations in progress may be inaccurate.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5ESwait(hid_t es_id, uint64_t timeout, size_t *num_in_progress, hbool_t *err_occurred);
+
+/**
+ * \ingroup H5ES
+ *
+ * \brief Attempt to cancel operations in an event set
+ *
+ * \es_id
+ * \param[out] num_not_canceled The number of events not canceled
+ * \param[out] err_occurred Status indicating if error is present in the event set
+ * \returns \herr_t
+ *
+ * \details H5EScancel() attempts to cancel operations in an event set specified
+ *          by \p es_id. H5ES_NONE is a valid value for \p es_id, but functions as a no-op.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5EScancel(hid_t es_id, size_t *num_not_canceled, hbool_t *err_occurred);
+
+/**
+ * \ingroup H5ES
+ *
+ * \brief Retrieves number of events in an event set
+ *
+ * \es_id
+ * \param[out] count The number of events in the event set
+ * \returns \herr_t
+ *
+ * \details H5ESget_count() retrieves number of events in an event set specified
+ *          by \p es_id.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5ESget_count(hid_t es_id, size_t *count);
+
+/**
+ * \ingroup H5ES
+ *
+ * \brief Retrieves the accumulative operation counter for an event set
+ *
+ * \es_id
+ * \param[out] counter The accumulative counter value for an event set
+ * \returns \herr_t
+ *
+ * \details H5ESget_op_counter() retrieves the current accumulative count of
+ *          event set operations since the event set creation of \p es_id.
+ *
+ * \note This is designed for wrapper libraries mainly, to use as a mechanism
+ *       for matching operations inserted into the event set with possible
+ *       errors that occur.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5ESget_op_counter(hid_t es_id, uint64_t *counter);
+
+/**
+ * \ingroup H5ES
+ *
+ * \brief Checks for failed operations
+ *
+ * \es_id
+ * \param[out] err_occurred Status indicating if error is present in the event
+ *             set
+ * \returns \herr_t
+ *
+ * \details H5ESget_err_status() checks if event set specified by es_id has
+ *          failed operations.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5ESget_err_status(hid_t es_id, hbool_t *err_occurred);
+
+/**
+ * \ingroup H5ES
+ *
+ * \brief Retrieves the number of failed operations
+ *
+ * \es_id
+ * \param[out] num_errs Number of errors
+ * \returns \herr_t
+ *
+ * \details H5ESget_err_count() retrieves the number of failed operations in an
+ *          event set specified by \p es_id.
+ *
+ *          The function does not wait for active operations to complete, so
+ *          count may not include all failures.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5ESget_err_count(hid_t es_id, size_t *num_errs);
+
+/**
+ * \ingroup H5ES
+ *
+ * \brief Retrieves information about failed operations
+ *
+ * \es_id
+ * \param[in] num_err_info The number of elements in \p err_info array
+ * \param[out] err_info Array of structures
+ * \param[out] err_cleared Number of cleared errors
+ * \returns \herr_t
+ *
+ * \details H5ESget_err_info() retrieves information about failed operations in
+ *          an event set specified by \p es_id.  The strings retrieved for each
+ *          error info must be released by calling H5free_memory().
+ *
+ *          Below is the description of the \ref H5ES_err_info_t structure:
+ *          \snippet this H5ES_err_info_t_snip
+ *          \click4more
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5ESget_err_info(hid_t es_id, size_t num_err_info, H5ES_err_info_t err_info[],
+                               size_t *err_cleared);
+/**
+ * \ingroup H5ES
+ *
+ * \brief Convenience routine to free an array of H5ES_err_info_t structs
+ *
+ * \param[in] num_err_info The number of elements in \p err_info array
+ * \param[in] err_info Array of structures
+ * \returns \herr_t
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5ESfree_err_info(size_t num_err_info, H5ES_err_info_t err_info[]);
+
+/**
+ * \ingroup H5ES
+ *
+ * \brief Registers a callback to invoke when a new operation is inserted into
+ *        an event set
+ *
+ * \es_id
+ * \param[in] func The insert function to register
+ * \param[in] ctx User-specified information (context) to pass to \p func
+ * \returns \herr_t
+ *
+ * \details Only one insert callback can be registered for each event set.
+ *          Registering a new callback will replace the existing one.
+ *          H5ES_NONE is a valid value for 'es_id', but functions as a no-op
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5ESregister_insert_func(hid_t es_id, H5ES_event_insert_func_t func, void *ctx);
+
+/**
+ * \ingroup H5ES
+ *
+ * \brief Registers a callback to invoke when an operation completes within an
+ *        event set
+ *
+ * \es_id
+ * \param[in] func The completion function to register
+ * \param[in] ctx User-specified information (context) to pass to \p func
+ * \returns \herr_t
+ *
+ * \details Only one complete callback can be registered for each event set.
+ *          Registering a new callback will replace the existing one.
+ *          H5ES_NONE is a valid value for 'es_id', but functions as a no-op
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5ESregister_complete_func(hid_t es_id, H5ES_event_complete_func_t func, void *ctx);
+
+/**
+ * \ingroup H5ES
+ *
+ * \brief Terminates access to an event set
+ *
+ * \es_id
+ * \returns \herr_t
+ *
+ * \details H5ESclose() terminates access to an event set specified by \p es_id.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5ESclose(hid_t es_id);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5ESpublic_H */
diff --git a/install/include/H5Epubgen.h b/install/include/H5Epubgen.h
new file mode 100644
index 0000000000..46c5c18a28
--- /dev/null
+++ b/install/include/H5Epubgen.h
@@ -0,0 +1,441 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Generated automatically by bin/make_err -- do not edit */
+/* Add new errors to H5err.txt file */
+
+
+#ifndef H5Epubgen_H
+#define H5Epubgen_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*********************/
+/* Major error codes */
+/*********************/
+
+#define H5E_ERROR            (H5OPEN H5E_ERROR_g)
+#define H5E_VOL              (H5OPEN H5E_VOL_g)
+#define H5E_LIB              (H5OPEN H5E_LIB_g)
+#define H5E_ID               (H5OPEN H5E_ID_g)
+#define H5E_RESOURCE         (H5OPEN H5E_RESOURCE_g)
+#define H5E_EVENTSET         (H5OPEN H5E_EVENTSET_g)
+#define H5E_TST              (H5OPEN H5E_TST_g)
+#define H5E_STORAGE          (H5OPEN H5E_STORAGE_g)
+#define H5E_ATTR             (H5OPEN H5E_ATTR_g)
+#define H5E_VFL              (H5OPEN H5E_VFL_g)
+#define H5E_EARRAY           (H5OPEN H5E_EARRAY_g)
+#define H5E_IO               (H5OPEN H5E_IO_g)
+#define H5E_CONTEXT          (H5OPEN H5E_CONTEXT_g)
+#define H5E_DATATYPE         (H5OPEN H5E_DATATYPE_g)
+#define H5E_CACHE            (H5OPEN H5E_CACHE_g)
+#define H5E_DATASET          (H5OPEN H5E_DATASET_g)
+#define H5E_EFL              (H5OPEN H5E_EFL_g)
+#define H5E_PAGEBUF          (H5OPEN H5E_PAGEBUF_g)
+#define H5E_SOHM             (H5OPEN H5E_SOHM_g)
+#define H5E_SYM              (H5OPEN H5E_SYM_g)
+#define H5E_NONE_MAJOR       (H5OPEN H5E_NONE_MAJOR_g)
+#define H5E_DATASPACE        (H5OPEN H5E_DATASPACE_g)
+#define H5E_INTERNAL         (H5OPEN H5E_INTERNAL_g)
+#define H5E_FUNC             (H5OPEN H5E_FUNC_g)
+#define H5E_HEAP             (H5OPEN H5E_HEAP_g)
+#define H5E_MAP              (H5OPEN H5E_MAP_g)
+#define H5E_OHDR             (H5OPEN H5E_OHDR_g)
+#define H5E_RS               (H5OPEN H5E_RS_g)
+#define H5E_SLIST            (H5OPEN H5E_SLIST_g)
+#define H5E_FILE             (H5OPEN H5E_FILE_g)
+#define H5E_ARGS             (H5OPEN H5E_ARGS_g)
+#define H5E_PLINE            (H5OPEN H5E_PLINE_g)
+#define H5E_FSPACE           (H5OPEN H5E_FSPACE_g)
+#define H5E_PLIST            (H5OPEN H5E_PLIST_g)
+#define H5E_LINK             (H5OPEN H5E_LINK_g)
+#define H5E_BTREE            (H5OPEN H5E_BTREE_g)
+#define H5E_PLUGIN           (H5OPEN H5E_PLUGIN_g)
+#define H5E_REFERENCE        (H5OPEN H5E_REFERENCE_g)
+#define H5E_FARRAY           (H5OPEN H5E_FARRAY_g)
+H5_DLLVAR hid_t H5E_ERROR_g;         /* Error API */
+H5_DLLVAR hid_t H5E_VOL_g;           /* Virtual Object Layer */
+H5_DLLVAR hid_t H5E_LIB_g;           /* General library infrastructure */
+H5_DLLVAR hid_t H5E_ID_g;            /* Object ID */
+H5_DLLVAR hid_t H5E_RESOURCE_g;      /* Resource unavailable */
+H5_DLLVAR hid_t H5E_EVENTSET_g;      /* Event Set */
+H5_DLLVAR hid_t H5E_TST_g;           /* Ternary Search Trees */
+H5_DLLVAR hid_t H5E_STORAGE_g;       /* Data storage */
+H5_DLLVAR hid_t H5E_ATTR_g;          /* Attribute */
+H5_DLLVAR hid_t H5E_VFL_g;           /* Virtual File Layer */
+H5_DLLVAR hid_t H5E_EARRAY_g;        /* Extensible Array */
+H5_DLLVAR hid_t H5E_IO_g;            /* Low-level I/O */
+H5_DLLVAR hid_t H5E_CONTEXT_g;       /* API Context */
+H5_DLLVAR hid_t H5E_DATATYPE_g;      /* Datatype */
+H5_DLLVAR hid_t H5E_CACHE_g;         /* Object cache */
+H5_DLLVAR hid_t H5E_DATASET_g;       /* Dataset */
+H5_DLLVAR hid_t H5E_EFL_g;           /* External file list */
+H5_DLLVAR hid_t H5E_PAGEBUF_g;       /* Page Buffering */
+H5_DLLVAR hid_t H5E_SOHM_g;          /* Shared Object Header Messages */
+H5_DLLVAR hid_t H5E_SYM_g;           /* Symbol table */
+H5_DLLVAR hid_t H5E_NONE_MAJOR_g;    /* No error */
+H5_DLLVAR hid_t H5E_DATASPACE_g;     /* Dataspace */
+H5_DLLVAR hid_t H5E_INTERNAL_g;      /* Internal error (too specific to document in detail) */
+H5_DLLVAR hid_t H5E_FUNC_g;          /* Function entry/exit */
+H5_DLLVAR hid_t H5E_HEAP_g;          /* Heap */
+H5_DLLVAR hid_t H5E_MAP_g;           /* Map */
+H5_DLLVAR hid_t H5E_OHDR_g;          /* Object header */
+H5_DLLVAR hid_t H5E_RS_g;            /* Reference Counted Strings */
+H5_DLLVAR hid_t H5E_SLIST_g;         /* Skip Lists */
+H5_DLLVAR hid_t H5E_FILE_g;          /* File accessibility */
+H5_DLLVAR hid_t H5E_ARGS_g;          /* Invalid arguments to routine */
+H5_DLLVAR hid_t H5E_PLINE_g;         /* Data filters */
+H5_DLLVAR hid_t H5E_FSPACE_g;        /* Free Space Manager */
+H5_DLLVAR hid_t H5E_PLIST_g;         /* Property lists */
+H5_DLLVAR hid_t H5E_LINK_g;          /* Links */
+H5_DLLVAR hid_t H5E_BTREE_g;         /* B-Tree node */
+H5_DLLVAR hid_t H5E_PLUGIN_g;        /* Plugin for dynamically loaded library */
+H5_DLLVAR hid_t H5E_REFERENCE_g;     /* References */
+H5_DLLVAR hid_t H5E_FARRAY_g;        /* Fixed Array */
+
+/*********************/
+/* Minor error codes */
+/*********************/
+
+/* Object header related errors */
+#define H5E_LINKCOUNT        (H5OPEN H5E_LINKCOUNT_g)
+#define H5E_VERSION          (H5OPEN H5E_VERSION_g)
+#define H5E_ALIGNMENT        (H5OPEN H5E_ALIGNMENT_g)
+#define H5E_BADMESG          (H5OPEN H5E_BADMESG_g)
+#define H5E_CANTDELETE       (H5OPEN H5E_CANTDELETE_g)
+#define H5E_BADITER          (H5OPEN H5E_BADITER_g)
+#define H5E_CANTPACK         (H5OPEN H5E_CANTPACK_g)
+#define H5E_CANTRESET        (H5OPEN H5E_CANTRESET_g)
+#define H5E_CANTRENAME       (H5OPEN H5E_CANTRENAME_g)
+H5_DLLVAR hid_t H5E_LINKCOUNT_g;     /* Bad object header link count */
+H5_DLLVAR hid_t H5E_VERSION_g;       /* Wrong version number */
+H5_DLLVAR hid_t H5E_ALIGNMENT_g;     /* Alignment error */
+H5_DLLVAR hid_t H5E_BADMESG_g;       /* Unrecognized message */
+H5_DLLVAR hid_t H5E_CANTDELETE_g;    /* Can't delete message */
+H5_DLLVAR hid_t H5E_BADITER_g;       /* Iteration failed */
+H5_DLLVAR hid_t H5E_CANTPACK_g;      /* Can't pack messages */
+H5_DLLVAR hid_t H5E_CANTRESET_g;     /* Can't reset object */
+H5_DLLVAR hid_t H5E_CANTRENAME_g;    /* Unable to rename object */
+
+/* Asynchronous operation errors */
+#define H5E_CANTWAIT         (H5OPEN H5E_CANTWAIT_g)
+#define H5E_CANTCANCEL       (H5OPEN H5E_CANTCANCEL_g)
+H5_DLLVAR hid_t H5E_CANTWAIT_g;      /* Can't wait on operation */
+H5_DLLVAR hid_t H5E_CANTCANCEL_g;    /* Can't cancel operation */
+
+/* B-tree related errors */
+#define H5E_NOTFOUND         (H5OPEN H5E_NOTFOUND_g)
+#define H5E_EXISTS           (H5OPEN H5E_EXISTS_g)
+#define H5E_CANTENCODE       (H5OPEN H5E_CANTENCODE_g)
+#define H5E_CANTDECODE       (H5OPEN H5E_CANTDECODE_g)
+#define H5E_CANTSPLIT        (H5OPEN H5E_CANTSPLIT_g)
+#define H5E_CANTREDISTRIBUTE (H5OPEN H5E_CANTREDISTRIBUTE_g)
+#define H5E_CANTSWAP         (H5OPEN H5E_CANTSWAP_g)
+#define H5E_CANTINSERT       (H5OPEN H5E_CANTINSERT_g)
+#define H5E_CANTLIST         (H5OPEN H5E_CANTLIST_g)
+#define H5E_CANTMODIFY       (H5OPEN H5E_CANTMODIFY_g)
+#define H5E_CANTREMOVE       (H5OPEN H5E_CANTREMOVE_g)
+#define H5E_CANTFIND         (H5OPEN H5E_CANTFIND_g)
+H5_DLLVAR hid_t H5E_NOTFOUND_g;      /* Object not found */
+H5_DLLVAR hid_t H5E_EXISTS_g;        /* Object already exists */
+H5_DLLVAR hid_t H5E_CANTENCODE_g;    /* Unable to encode value */
+H5_DLLVAR hid_t H5E_CANTDECODE_g;    /* Unable to decode value */
+H5_DLLVAR hid_t H5E_CANTSPLIT_g;     /* Unable to split node */
+H5_DLLVAR hid_t H5E_CANTREDISTRIBUTE_g; /* Unable to redistribute records */
+H5_DLLVAR hid_t H5E_CANTSWAP_g;      /* Unable to swap records */
+H5_DLLVAR hid_t H5E_CANTINSERT_g;    /* Unable to insert object */
+H5_DLLVAR hid_t H5E_CANTLIST_g;      /* Unable to list node */
+H5_DLLVAR hid_t H5E_CANTMODIFY_g;    /* Unable to modify record */
+H5_DLLVAR hid_t H5E_CANTREMOVE_g;    /* Unable to remove object */
+H5_DLLVAR hid_t H5E_CANTFIND_g;      /* Unable to check for record */
+
+/* File accessibility errors */
+#define H5E_FILEEXISTS       (H5OPEN H5E_FILEEXISTS_g)
+#define H5E_FILEOPEN         (H5OPEN H5E_FILEOPEN_g)
+#define H5E_CANTCREATE       (H5OPEN H5E_CANTCREATE_g)
+#define H5E_CANTOPENFILE     (H5OPEN H5E_CANTOPENFILE_g)
+#define H5E_CANTCLOSEFILE    (H5OPEN H5E_CANTCLOSEFILE_g)
+#define H5E_NOTHDF5          (H5OPEN H5E_NOTHDF5_g)
+#define H5E_BADFILE          (H5OPEN H5E_BADFILE_g)
+#define H5E_TRUNCATED        (H5OPEN H5E_TRUNCATED_g)
+#define H5E_MOUNT            (H5OPEN H5E_MOUNT_g)
+#define H5E_UNMOUNT          (H5OPEN H5E_UNMOUNT_g)
+#define H5E_CANTDELETEFILE   (H5OPEN H5E_CANTDELETEFILE_g)
+#define H5E_CANTLOCKFILE     (H5OPEN H5E_CANTLOCKFILE_g)
+#define H5E_CANTUNLOCKFILE   (H5OPEN H5E_CANTUNLOCKFILE_g)
+H5_DLLVAR hid_t H5E_FILEEXISTS_g;    /* File already exists */
+H5_DLLVAR hid_t H5E_FILEOPEN_g;      /* File already open */
+H5_DLLVAR hid_t H5E_CANTCREATE_g;    /* Unable to create file */
+H5_DLLVAR hid_t H5E_CANTOPENFILE_g;  /* Unable to open file */
+H5_DLLVAR hid_t H5E_CANTCLOSEFILE_g; /* Unable to close file */
+H5_DLLVAR hid_t H5E_NOTHDF5_g;       /* Not an HDF5 file */
+H5_DLLVAR hid_t H5E_BADFILE_g;       /* Bad file ID accessed */
+H5_DLLVAR hid_t H5E_TRUNCATED_g;     /* File has been truncated */
+H5_DLLVAR hid_t H5E_MOUNT_g;         /* File mount error */
+H5_DLLVAR hid_t H5E_UNMOUNT_g;       /* File unmount error */
+H5_DLLVAR hid_t H5E_CANTDELETEFILE_g; /* Unable to delete file */
+H5_DLLVAR hid_t H5E_CANTLOCKFILE_g;  /* Unable to lock file */
+H5_DLLVAR hid_t H5E_CANTUNLOCKFILE_g; /* Unable to unlock file */
+
+/* Object ID related errors */
+#define H5E_BADID            (H5OPEN H5E_BADID_g)
+#define H5E_BADGROUP         (H5OPEN H5E_BADGROUP_g)
+#define H5E_CANTREGISTER     (H5OPEN H5E_CANTREGISTER_g)
+#define H5E_CANTINC          (H5OPEN H5E_CANTINC_g)
+#define H5E_CANTDEC          (H5OPEN H5E_CANTDEC_g)
+#define H5E_NOIDS            (H5OPEN H5E_NOIDS_g)
+H5_DLLVAR hid_t H5E_BADID_g;         /* Unable to find ID information (already closed?) */
+H5_DLLVAR hid_t H5E_BADGROUP_g;      /* Unable to find ID group information */
+H5_DLLVAR hid_t H5E_CANTREGISTER_g;  /* Unable to register new ID */
+H5_DLLVAR hid_t H5E_CANTINC_g;       /* Unable to increment reference count */
+H5_DLLVAR hid_t H5E_CANTDEC_g;       /* Unable to decrement reference count */
+H5_DLLVAR hid_t H5E_NOIDS_g;         /* Out of IDs for group */
+
+/* Property list errors */
+#define H5E_CANTGET          (H5OPEN H5E_CANTGET_g)
+#define H5E_CANTSET          (H5OPEN H5E_CANTSET_g)
+#define H5E_DUPCLASS         (H5OPEN H5E_DUPCLASS_g)
+#define H5E_SETDISALLOWED    (H5OPEN H5E_SETDISALLOWED_g)
+H5_DLLVAR hid_t H5E_CANTGET_g;       /* Can't get value */
+H5_DLLVAR hid_t H5E_CANTSET_g;       /* Can't set value */
+H5_DLLVAR hid_t H5E_DUPCLASS_g;      /* Duplicate class name in parent class */
+H5_DLLVAR hid_t H5E_SETDISALLOWED_g; /* Disallowed operation */
+
+/* Function entry/exit interface errors */
+#define H5E_CANTINIT         (H5OPEN H5E_CANTINIT_g)
+#define H5E_ALREADYINIT      (H5OPEN H5E_ALREADYINIT_g)
+#define H5E_CANTRELEASE      (H5OPEN H5E_CANTRELEASE_g)
+H5_DLLVAR hid_t H5E_CANTINIT_g;      /* Unable to initialize object */
+H5_DLLVAR hid_t H5E_ALREADYINIT_g;   /* Object already initialized */
+H5_DLLVAR hid_t H5E_CANTRELEASE_g;   /* Unable to release object */
+
+/* Heap errors */
+#define H5E_CANTRESTORE      (H5OPEN H5E_CANTRESTORE_g)
+#define H5E_CANTCOMPUTE      (H5OPEN H5E_CANTCOMPUTE_g)
+#define H5E_CANTEXTEND       (H5OPEN H5E_CANTEXTEND_g)
+#define H5E_CANTATTACH       (H5OPEN H5E_CANTATTACH_g)
+#define H5E_CANTUPDATE       (H5OPEN H5E_CANTUPDATE_g)
+#define H5E_CANTOPERATE      (H5OPEN H5E_CANTOPERATE_g)
+H5_DLLVAR hid_t H5E_CANTRESTORE_g;   /* Can't restore condition */
+H5_DLLVAR hid_t H5E_CANTCOMPUTE_g;   /* Can't compute value */
+H5_DLLVAR hid_t H5E_CANTEXTEND_g;    /* Can't extend heap's space */
+H5_DLLVAR hid_t H5E_CANTATTACH_g;    /* Can't attach object */
+H5_DLLVAR hid_t H5E_CANTUPDATE_g;    /* Can't update object */
+H5_DLLVAR hid_t H5E_CANTOPERATE_g;   /* Can't operate on object */
+
+/* Datatype conversion errors */
+#define H5E_CANTCONVERT      (H5OPEN H5E_CANTCONVERT_g)
+#define H5E_BADSIZE          (H5OPEN H5E_BADSIZE_g)
+H5_DLLVAR hid_t H5E_CANTCONVERT_g;   /* Can't convert datatypes */
+H5_DLLVAR hid_t H5E_BADSIZE_g;       /* Bad size for object */
+
+/* System level errors */
+#define H5E_SYSERRSTR        (H5OPEN H5E_SYSERRSTR_g)
+H5_DLLVAR hid_t H5E_SYSERRSTR_g;     /* System error message */
+
+/* Group related errors */
+#define H5E_CANTOPENOBJ      (H5OPEN H5E_CANTOPENOBJ_g)
+#define H5E_CANTCLOSEOBJ     (H5OPEN H5E_CANTCLOSEOBJ_g)
+#define H5E_COMPLEN          (H5OPEN H5E_COMPLEN_g)
+#define H5E_PATH             (H5OPEN H5E_PATH_g)
+H5_DLLVAR hid_t H5E_CANTOPENOBJ_g;   /* Can't open object */
+H5_DLLVAR hid_t H5E_CANTCLOSEOBJ_g;  /* Can't close object */
+H5_DLLVAR hid_t H5E_COMPLEN_g;       /* Name component is too long */
+H5_DLLVAR hid_t H5E_PATH_g;          /* Problem with path to object */
+
+/* Free space errors */
+#define H5E_CANTMERGE        (H5OPEN H5E_CANTMERGE_g)
+#define H5E_CANTREVIVE       (H5OPEN H5E_CANTREVIVE_g)
+#define H5E_CANTSHRINK       (H5OPEN H5E_CANTSHRINK_g)
+H5_DLLVAR hid_t H5E_CANTMERGE_g;     /* Can't merge objects */
+H5_DLLVAR hid_t H5E_CANTREVIVE_g;    /* Can't revive object */
+H5_DLLVAR hid_t H5E_CANTSHRINK_g;    /* Can't shrink container */
+
+/* Argument errors */
+#define H5E_UNINITIALIZED    (H5OPEN H5E_UNINITIALIZED_g)
+#define H5E_UNSUPPORTED      (H5OPEN H5E_UNSUPPORTED_g)
+#define H5E_BADTYPE          (H5OPEN H5E_BADTYPE_g)
+#define H5E_BADRANGE         (H5OPEN H5E_BADRANGE_g)
+#define H5E_BADVALUE         (H5OPEN H5E_BADVALUE_g)
+H5_DLLVAR hid_t H5E_UNINITIALIZED_g; /* Information is uinitialized */
+H5_DLLVAR hid_t H5E_UNSUPPORTED_g;   /* Feature is unsupported */
+H5_DLLVAR hid_t H5E_BADTYPE_g;       /* Inappropriate type */
+H5_DLLVAR hid_t H5E_BADRANGE_g;      /* Out of range */
+H5_DLLVAR hid_t H5E_BADVALUE_g;      /* Bad value */
+
+/* No error */
+#define H5E_NONE_MINOR       (H5OPEN H5E_NONE_MINOR_g)
+H5_DLLVAR hid_t H5E_NONE_MINOR_g;    /* No error */
+
+/* Link related errors */
+#define H5E_TRAVERSE         (H5OPEN H5E_TRAVERSE_g)
+#define H5E_NLINKS           (H5OPEN H5E_NLINKS_g)
+#define H5E_NOTREGISTERED    (H5OPEN H5E_NOTREGISTERED_g)
+#define H5E_CANTMOVE         (H5OPEN H5E_CANTMOVE_g)
+#define H5E_CANTSORT         (H5OPEN H5E_CANTSORT_g)
+H5_DLLVAR hid_t H5E_TRAVERSE_g;      /* Link traversal failure */
+H5_DLLVAR hid_t H5E_NLINKS_g;        /* Too many soft links in path */
+H5_DLLVAR hid_t H5E_NOTREGISTERED_g; /* Link class not registered */
+H5_DLLVAR hid_t H5E_CANTMOVE_g;      /* Can't move object */
+H5_DLLVAR hid_t H5E_CANTSORT_g;      /* Can't sort objects */
+
+/* Generic low-level file I/O errors */
+#define H5E_SEEKERROR        (H5OPEN H5E_SEEKERROR_g)
+#define H5E_READERROR        (H5OPEN H5E_READERROR_g)
+#define H5E_WRITEERROR       (H5OPEN H5E_WRITEERROR_g)
+#define H5E_CLOSEERROR       (H5OPEN H5E_CLOSEERROR_g)
+#define H5E_OVERFLOW         (H5OPEN H5E_OVERFLOW_g)
+#define H5E_FCNTL            (H5OPEN H5E_FCNTL_g)
+H5_DLLVAR hid_t H5E_SEEKERROR_g;     /* Seek failed */
+H5_DLLVAR hid_t H5E_READERROR_g;     /* Read failed */
+H5_DLLVAR hid_t H5E_WRITEERROR_g;    /* Write failed */
+H5_DLLVAR hid_t H5E_CLOSEERROR_g;    /* Close failed */
+H5_DLLVAR hid_t H5E_OVERFLOW_g;      /* Address overflowed */
+H5_DLLVAR hid_t H5E_FCNTL_g;         /* File control (fcntl) failed */
+
+/* I/O pipeline errors */
+#define H5E_NOFILTER         (H5OPEN H5E_NOFILTER_g)
+#define H5E_CALLBACK         (H5OPEN H5E_CALLBACK_g)
+#define H5E_CANAPPLY         (H5OPEN H5E_CANAPPLY_g)
+#define H5E_SETLOCAL         (H5OPEN H5E_SETLOCAL_g)
+#define H5E_NOENCODER        (H5OPEN H5E_NOENCODER_g)
+#define H5E_CANTFILTER       (H5OPEN H5E_CANTFILTER_g)
+H5_DLLVAR hid_t H5E_NOFILTER_g;      /* Requested filter is not available */
+H5_DLLVAR hid_t H5E_CALLBACK_g;      /* Callback failed */
+H5_DLLVAR hid_t H5E_CANAPPLY_g;      /* Error from filter 'can apply' callback */
+H5_DLLVAR hid_t H5E_SETLOCAL_g;      /* Error from filter 'set local' callback */
+H5_DLLVAR hid_t H5E_NOENCODER_g;     /* Filter present but encoding disabled */
+H5_DLLVAR hid_t H5E_CANTFILTER_g;    /* Filter operation failed */
+
+/* Plugin errors */
+#define H5E_OPENERROR        (H5OPEN H5E_OPENERROR_g)
+H5_DLLVAR hid_t H5E_OPENERROR_g;     /* Can't open directory or file */
+
+/* Cache related errors */
+#define H5E_CANTFLUSH        (H5OPEN H5E_CANTFLUSH_g)
+#define H5E_CANTUNSERIALIZE  (H5OPEN H5E_CANTUNSERIALIZE_g)
+#define H5E_CANTSERIALIZE    (H5OPEN H5E_CANTSERIALIZE_g)
+#define H5E_CANTTAG          (H5OPEN H5E_CANTTAG_g)
+#define H5E_CANTLOAD         (H5OPEN H5E_CANTLOAD_g)
+#define H5E_PROTECT          (H5OPEN H5E_PROTECT_g)
+#define H5E_NOTCACHED        (H5OPEN H5E_NOTCACHED_g)
+#define H5E_SYSTEM           (H5OPEN H5E_SYSTEM_g)
+#define H5E_CANTINS          (H5OPEN H5E_CANTINS_g)
+#define H5E_CANTPROTECT      (H5OPEN H5E_CANTPROTECT_g)
+#define H5E_CANTUNPROTECT    (H5OPEN H5E_CANTUNPROTECT_g)
+#define H5E_CANTPIN          (H5OPEN H5E_CANTPIN_g)
+#define H5E_CANTUNPIN        (H5OPEN H5E_CANTUNPIN_g)
+#define H5E_CANTMARKDIRTY    (H5OPEN H5E_CANTMARKDIRTY_g)
+#define H5E_CANTMARKCLEAN    (H5OPEN H5E_CANTMARKCLEAN_g)
+#define H5E_CANTMARKUNSERIALIZED (H5OPEN H5E_CANTMARKUNSERIALIZED_g)
+#define H5E_CANTMARKSERIALIZED (H5OPEN H5E_CANTMARKSERIALIZED_g)
+#define H5E_CANTDIRTY        (H5OPEN H5E_CANTDIRTY_g)
+#define H5E_CANTCLEAN        (H5OPEN H5E_CANTCLEAN_g)
+#define H5E_CANTEXPUNGE      (H5OPEN H5E_CANTEXPUNGE_g)
+#define H5E_CANTRESIZE       (H5OPEN H5E_CANTRESIZE_g)
+#define H5E_CANTDEPEND       (H5OPEN H5E_CANTDEPEND_g)
+#define H5E_CANTUNDEPEND     (H5OPEN H5E_CANTUNDEPEND_g)
+#define H5E_CANTNOTIFY       (H5OPEN H5E_CANTNOTIFY_g)
+#define H5E_LOGGING          (H5OPEN H5E_LOGGING_g)
+#define H5E_CANTCORK         (H5OPEN H5E_CANTCORK_g)
+#define H5E_CANTUNCORK       (H5OPEN H5E_CANTUNCORK_g)
+H5_DLLVAR hid_t H5E_CANTFLUSH_g;     /* Unable to flush data from cache */
+H5_DLLVAR hid_t H5E_CANTUNSERIALIZE_g; /* Unable to mark metadata as unserialized */
+H5_DLLVAR hid_t H5E_CANTSERIALIZE_g; /* Unable to serialize data from cache */
+H5_DLLVAR hid_t H5E_CANTTAG_g;       /* Unable to tag metadata in the cache */
+H5_DLLVAR hid_t H5E_CANTLOAD_g;      /* Unable to load metadata into cache */
+H5_DLLVAR hid_t H5E_PROTECT_g;       /* Protected metadata error */
+H5_DLLVAR hid_t H5E_NOTCACHED_g;     /* Metadata not currently cached */
+H5_DLLVAR hid_t H5E_SYSTEM_g;        /* Internal error detected */
+H5_DLLVAR hid_t H5E_CANTINS_g;       /* Unable to insert metadata into cache */
+H5_DLLVAR hid_t H5E_CANTPROTECT_g;   /* Unable to protect metadata */
+H5_DLLVAR hid_t H5E_CANTUNPROTECT_g; /* Unable to unprotect metadata */
+H5_DLLVAR hid_t H5E_CANTPIN_g;       /* Unable to pin cache entry */
+H5_DLLVAR hid_t H5E_CANTUNPIN_g;     /* Unable to un-pin cache entry */
+H5_DLLVAR hid_t H5E_CANTMARKDIRTY_g; /* Unable to mark a pinned entry as dirty */
+H5_DLLVAR hid_t H5E_CANTMARKCLEAN_g; /* Unable to mark a pinned entry as clean */
+H5_DLLVAR hid_t H5E_CANTMARKUNSERIALIZED_g; /* Unable to mark an entry as unserialized */
+H5_DLLVAR hid_t H5E_CANTMARKSERIALIZED_g; /* Unable to mark an entry as serialized */
+H5_DLLVAR hid_t H5E_CANTDIRTY_g;     /* Unable to mark metadata as dirty */
+H5_DLLVAR hid_t H5E_CANTCLEAN_g;     /* Unable to mark metadata as clean */
+H5_DLLVAR hid_t H5E_CANTEXPUNGE_g;   /* Unable to expunge a metadata cache entry */
+H5_DLLVAR hid_t H5E_CANTRESIZE_g;    /* Unable to resize a metadata cache entry */
+H5_DLLVAR hid_t H5E_CANTDEPEND_g;    /* Unable to create a flush dependency */
+H5_DLLVAR hid_t H5E_CANTUNDEPEND_g;  /* Unable to destroy a flush dependency */
+H5_DLLVAR hid_t H5E_CANTNOTIFY_g;    /* Unable to notify object about action */
+H5_DLLVAR hid_t H5E_LOGGING_g;       /* Failure in the cache logging framework */
+H5_DLLVAR hid_t H5E_CANTCORK_g;      /* Unable to cork an object */
+H5_DLLVAR hid_t H5E_CANTUNCORK_g;    /* Unable to uncork an object */
+
+/* Map related errors */
+#define H5E_CANTPUT          (H5OPEN H5E_CANTPUT_g)
+H5_DLLVAR hid_t H5E_CANTPUT_g;       /* Can't put value */
+
+/* Dataspace errors */
+#define H5E_CANTCLIP         (H5OPEN H5E_CANTCLIP_g)
+#define H5E_CANTCOUNT        (H5OPEN H5E_CANTCOUNT_g)
+#define H5E_CANTSELECT       (H5OPEN H5E_CANTSELECT_g)
+#define H5E_CANTNEXT         (H5OPEN H5E_CANTNEXT_g)
+#define H5E_BADSELECT        (H5OPEN H5E_BADSELECT_g)
+#define H5E_CANTCOMPARE      (H5OPEN H5E_CANTCOMPARE_g)
+#define H5E_INCONSISTENTSTATE (H5OPEN H5E_INCONSISTENTSTATE_g)
+#define H5E_CANTAPPEND       (H5OPEN H5E_CANTAPPEND_g)
+H5_DLLVAR hid_t H5E_CANTCLIP_g;      /* Can't clip hyperslab region */
+H5_DLLVAR hid_t H5E_CANTCOUNT_g;     /* Can't count elements */
+H5_DLLVAR hid_t H5E_CANTSELECT_g;    /* Can't select hyperslab */
+H5_DLLVAR hid_t H5E_CANTNEXT_g;      /* Can't move to next iterator location */
+H5_DLLVAR hid_t H5E_BADSELECT_g;     /* Invalid selection */
+H5_DLLVAR hid_t H5E_CANTCOMPARE_g;   /* Can't compare objects */
+H5_DLLVAR hid_t H5E_INCONSISTENTSTATE_g; /* Internal states are inconsistent */
+H5_DLLVAR hid_t H5E_CANTAPPEND_g;    /* Can't append object */
+
+/* Resource errors */
+#define H5E_NOSPACE          (H5OPEN H5E_NOSPACE_g)
+#define H5E_CANTALLOC        (H5OPEN H5E_CANTALLOC_g)
+#define H5E_CANTCOPY         (H5OPEN H5E_CANTCOPY_g)
+#define H5E_CANTFREE         (H5OPEN H5E_CANTFREE_g)
+#define H5E_ALREADYEXISTS    (H5OPEN H5E_ALREADYEXISTS_g)
+#define H5E_CANTLOCK         (H5OPEN H5E_CANTLOCK_g)
+#define H5E_CANTUNLOCK       (H5OPEN H5E_CANTUNLOCK_g)
+#define H5E_CANTGC           (H5OPEN H5E_CANTGC_g)
+#define H5E_CANTGETSIZE      (H5OPEN H5E_CANTGETSIZE_g)
+#define H5E_OBJOPEN          (H5OPEN H5E_OBJOPEN_g)
+H5_DLLVAR hid_t H5E_NOSPACE_g;       /* No space available for allocation */
+H5_DLLVAR hid_t H5E_CANTALLOC_g;     /* Can't allocate space */
+H5_DLLVAR hid_t H5E_CANTCOPY_g;      /* Unable to copy object */
+H5_DLLVAR hid_t H5E_CANTFREE_g;      /* Unable to free object */
+H5_DLLVAR hid_t H5E_ALREADYEXISTS_g; /* Object already exists */
+H5_DLLVAR hid_t H5E_CANTLOCK_g;      /* Unable to lock object */
+H5_DLLVAR hid_t H5E_CANTUNLOCK_g;    /* Unable to unlock object */
+H5_DLLVAR hid_t H5E_CANTGC_g;        /* Unable to garbage collect */
+H5_DLLVAR hid_t H5E_CANTGETSIZE_g;   /* Unable to compute size */
+H5_DLLVAR hid_t H5E_OBJOPEN_g;       /* Object is already open */
+
+/* Parallel MPI errors */
+#define H5E_MPI              (H5OPEN H5E_MPI_g)
+#define H5E_MPIERRSTR        (H5OPEN H5E_MPIERRSTR_g)
+#define H5E_CANTRECV         (H5OPEN H5E_CANTRECV_g)
+#define H5E_CANTGATHER       (H5OPEN H5E_CANTGATHER_g)
+#define H5E_NO_INDEPENDENT   (H5OPEN H5E_NO_INDEPENDENT_g)
+H5_DLLVAR hid_t H5E_MPI_g;           /* Some MPI function failed */
+H5_DLLVAR hid_t H5E_MPIERRSTR_g;     /* MPI Error String */
+H5_DLLVAR hid_t H5E_CANTRECV_g;      /* Can't receive data */
+H5_DLLVAR hid_t H5E_CANTGATHER_g;    /* Can't gather data */
+H5_DLLVAR hid_t H5E_NO_INDEPENDENT_g; /* Can't perform independent IO */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5Epubgen_H */
diff --git a/install/include/H5Epublic.h b/install/include/H5Epublic.h
new file mode 100644
index 0000000000..b6cc1cb530
--- /dev/null
+++ b/install/include/H5Epublic.h
@@ -0,0 +1,945 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5E module.
+ */
+#ifndef H5Epublic_H
+#define H5Epublic_H
+
+#include <stdio.h> /* FILE arg of H5Eprint() */
+
+#include "H5public.h"  /* Generic Functions                        */
+#include "H5Ipublic.h" /* Identifiers                              */
+
+/* Value for the default error stack */
+#define H5E_DEFAULT 0 /* (hid_t) */
+
+/**
+ * Different kinds of error information
+ */
+typedef enum H5E_type_t { H5E_MAJOR, H5E_MINOR } H5E_type_t;
+
+/**
+ * Information about an error; element of error stack
+ */
+typedef struct H5E_error2_t {
+    hid_t cls_id;
+    /**< Class ID                           */
+    hid_t maj_num;
+    /**< Major error ID                        */
+    hid_t min_num;
+    /**< Minor error number                    */
+    unsigned line;
+    /**< Line in file where error occurs    */
+    const char *func_name;
+    /**< Function in which error occurred   */
+    const char *file_name;
+    /**< File in which error occurred       */
+    const char *desc;
+    /**< Optional supplied description      */
+} H5E_error2_t;
+
+/* When this header is included from a private header, don't make calls to H5open() */
+#undef H5OPEN
+#ifndef H5private_H
+#define H5OPEN H5open(),
+#else /* H5private_H */
+#define H5OPEN
+#endif /* H5private_H */
+
+/* HDF5 error class */
+/* Extern "C" block needed to compile C++ filter plugins with some compilers */
+#ifdef __cplusplus
+extern "C" {
+#endif
+#define H5E_ERR_CLS (H5OPEN H5E_ERR_CLS_g)
+H5_DLLVAR hid_t H5E_ERR_CLS_g;
+#ifdef __cplusplus
+}
+#endif
+
+/* Include the automatically generated public header information */
+/* (This includes the list of major and minor error codes for the library) */
+#include "H5Epubgen.h"
+
+/*
+ * One often needs to temporarily disable automatic error reporting when
+ * trying something that's likely or expected to fail.  The code to try can
+ * be nested between calls to H5Eget_auto() and H5Eset_auto(), but it's
+ * easier just to use this macro like:
+ *     H5E_BEGIN_TRY {
+ *        ...stuff here that's likely to fail...
+ *      } H5E_END_TRY
+ *
+ * Warning: don't break, return, or longjmp() from the body of the loop or
+ *        the error reporting won't be properly restored!
+ *
+ * These two macros still use the old API functions for backward compatibility
+ * purpose.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+#define H5E_BEGIN_TRY                                                                                        \
+    {                                                                                                        \
+        unsigned H5E_saved_is_v2;                                                                            \
+        union {                                                                                              \
+            H5E_auto1_t efunc1;                                                                              \
+            H5E_auto2_t efunc2;                                                                              \
+        } H5E_saved;                                                                                         \
+        void *H5E_saved_edata;                                                                               \
+                                                                                                             \
+        (void)H5Eauto_is_v2(H5E_DEFAULT, &H5E_saved_is_v2);                                                  \
+        if (H5E_saved_is_v2) {                                                                               \
+            (void)H5Eget_auto2(H5E_DEFAULT, &H5E_saved.efunc2, &H5E_saved_edata);                            \
+            (void)H5Eset_auto2(H5E_DEFAULT, NULL, NULL);                                                     \
+        }                                                                                                    \
+        else {                                                                                               \
+            (void)H5Eget_auto1(&H5E_saved.efunc1, &H5E_saved_edata);                                         \
+            (void)H5Eset_auto1(NULL, NULL);                                                                  \
+        }
+
+#define H5E_END_TRY                                                                                          \
+    if (H5E_saved_is_v2)                                                                                     \
+        (void)H5Eset_auto2(H5E_DEFAULT, H5E_saved.efunc2, H5E_saved_edata);                                  \
+    else                                                                                                     \
+        (void)H5Eset_auto1(H5E_saved.efunc1, H5E_saved_edata);                                               \
+    }
+#else /* H5_NO_DEPRECATED_SYMBOLS */
+#define H5E_BEGIN_TRY                                                                                        \
+    {                                                                                                        \
+        H5E_auto2_t saved_efunc;                                                                             \
+        void       *H5E_saved_edata;                                                                         \
+                                                                                                             \
+        (void)H5Eget_auto2(H5E_DEFAULT, &saved_efunc, &H5E_saved_edata);                                     \
+        (void)H5Eset_auto2(H5E_DEFAULT, NULL, NULL);
+
+#define H5E_END_TRY                                                                                          \
+    (void)H5Eset_auto2(H5E_DEFAULT, saved_efunc, H5E_saved_edata);                                           \
+    }
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+/*
+ * Public API Convenience Macros for Error reporting - Documented
+ */
+/* Use the Standard C __FILE__ & __LINE__ macros instead of typing them in */
+#define H5Epush_sim(func, cls, maj, min, str)                                                                \
+    H5Epush2(H5E_DEFAULT, __FILE__, func, __LINE__, cls, maj, min, str)
+
+/*
+ * Public API Convenience Macros for Error reporting - Undocumented
+ */
+/* Use the Standard C __FILE__ & __LINE__ macros instead of typing them in */
+/*  And return after pushing error onto stack */
+#define H5Epush_ret(func, cls, maj, min, str, ret)                                                           \
+    do {                                                                                                     \
+        H5Epush2(H5E_DEFAULT, __FILE__, func, __LINE__, cls, maj, min, str);                                 \
+        return (ret);                                                                                        \
+    } while (0)
+
+/* Use the Standard C __FILE__ & __LINE__ macros instead of typing them in
+ * And goto a label after pushing error onto stack.
+ */
+#define H5Epush_goto(func, cls, maj, min, str, label)                                                        \
+    do {                                                                                                     \
+        H5Epush2(H5E_DEFAULT, __FILE__, func, __LINE__, cls, maj, min, str);                                 \
+        goto label;                                                                                          \
+    } while (0)
+
+/**
+ * Error stack traversal direction
+ */
+typedef enum H5E_direction_t {
+    H5E_WALK_UPWARD   = 0, /**< begin w/ most specific error, end at API function */
+    H5E_WALK_DOWNWARD = 1  /**< begin at API function, end w/ most specific error */
+} H5E_direction_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Error stack traversal callback function pointers */
+//! <!-- [H5E_walk2_t_snip] -->
+/**
+ * \brief Callback function for H5Ewalk2()
+ *
+ * \param[in] n Indexed error position in the stack
+ * \param[in] err_desc Pointer to a data structure describing the error
+ * \param[in] client_data Pointer to client data in the format expected by the
+ *                        user-defined function
+ * \return \herr_t
+ */
+typedef herr_t (*H5E_walk2_t)(unsigned n, const H5E_error2_t *err_desc, void *client_data);
+//! <!-- [H5E_walk2_t_snip] -->
+
+//! <!-- [H5E_auto2_t_snip] -->
+/**
+ * \brief Callback function for H5Eset_auto2()
+ *
+ * \estack_id{estack}
+ * \param[in] client_data Pointer to client data in the format expected by the
+ *                        user-defined function
+ * \return \herr_t
+ */
+typedef herr_t (*H5E_auto2_t)(hid_t estack, void *client_data);
+//! <!-- [H5E_auto2_t_snip] -->
+
+/* Public API functions */
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Registers a client library or application program to the HDF5 error API
+ *
+ * \param[in] cls_name Name of the error class
+ * \param[in] lib_name Name of the client library or application to which the error class belongs
+ * \param[in] version Version of the client library or application to which the
+              error class belongs. It can be \c NULL.
+ * \return Returns a class identifier on success; otherwise returns H5I_INVALID_ID.
+ *
+ * \details H5Eregister_class() registers a client library or application
+ *          program to the HDF5 error API so that the client library or
+ *          application program can report errors together with the HDF5
+ *          library. It receives an identifier for this error class for further
+ *          error operations. The library name and version number will be
+ *          printed out in the error message as a preamble.
+ *
+ * \since 1.8.0
+ */
+H5_DLL hid_t H5Eregister_class(const char *cls_name, const char *lib_name, const char *version);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Removes an error class
+ *
+ * \param[in] class_id Error class identifier.
+ * \return \herr_t
+ *
+ * \details H5Eunregister_class() removes the error class specified by \p
+ *          class_id. All the major and minor errors in this class will also be
+ *          closed.
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Eunregister_class(hid_t class_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Closes an error message
+ *
+ * \param[in] err_id An error message identifier
+ * \return \herr_t
+ *
+ * \details H5Eclose_msg() closes an error message identifier, which can be
+ *          either a major or minor message.
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Eclose_msg(hid_t err_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Adds a major error message to an error class
+ *
+ * \param[in] cls An error class identifier
+ * \param[in] msg_type The type of the error message
+ * \param[in] msg Major error message
+ * \return \herr_t
+ *
+ * \details H5Ecreate_msg() adds an error message to an error class defined by
+ *          client library or application program. The error message can be
+ *          either major or minor as indicated by the parameter \p msg_type.
+ *
+ *          Use H5Eclose_msg() to close the message identifier returned by this
+ *          function.
+ *
+ * \since 1.8.0
+ */
+H5_DLL hid_t H5Ecreate_msg(hid_t cls, H5E_type_t msg_type, const char *msg);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Creates a new, empty error stack
+ *
+ * \return \hid_ti{error stack}
+ *
+ * \details H5Ecreate_stack() creates a new empty error stack and returns the
+ *          new stack's identifier. Use H5Eclose_stack() to close the error stack
+ *          identifier returned by this function.
+ *
+ * \since 1.8.0
+ */
+H5_DLL hid_t H5Ecreate_stack(void);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Returns a copy of the current error stack
+ *
+ * \return \hid_ti{error stack}
+ *
+ * \details H5Eget_current_stack() copies the current error stack and returns an
+ *          error stack identifier for the new copy.
+ *
+ * \since 1.8.0
+ */
+H5_DLL hid_t H5Eget_current_stack(void);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Appends one error stack to another, optionally closing the source
+ *        stack.
+ *
+ * \estack_id{dst_stack_id}
+ * \estack_id{src_stack_id}
+ * \param[in] close_source_stack Flag to indicate whether to close the source stack
+ * \return \herr_t
+ *
+ * \details H5Eappend_stack() appends the messages from error stack
+ *          \p src_stack_id to the error stack \p dst_stack_id.
+ *          If \p close_source_stack is \c true, the source error stack
+ *          will be closed.
+ *
+ * \since 1.14.0
+ */
+H5_DLL herr_t H5Eappend_stack(hid_t dst_stack_id, hid_t src_stack_id, hbool_t close_source_stack);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Closes an error stack handle
+ *
+ * \estack_id{stack_id}
+ *
+ * \return \herr_t
+ *
+ * \details H5Eclose_stack() closes the error stack handle \p stack_id
+ *          and releases its resources. #H5E_DEFAULT cannot be closed.
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Eclose_stack(hid_t stack_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Retrieves error class name
+ *
+ * \param[in] class_id Error class identifier
+ * \param[out] name Buffer for the error class name
+ * \param[in] size The maximum number of characters of the class name to be returned
+ *            by this function in \p name.
+ * \return Returns non-negative value as on success; otherwise returns negative value.
+ *
+ * \details H5Eget_class_name() retrieves the name of the error class specified
+ *          by the class identifier. If a non-NULL pointer is passed in for \p
+ *          name and \p size is greater than zero, the class name of \p size
+ *          long is returned. The length of the error class name is also
+ *          returned. If NULL is passed in as \p name, only the length of class
+ *          name is returned. If zero is returned, it means no name. The user is
+ *          responsible for allocating sufficient buffer space for the name.
+ *
+ * \since 1.8.0
+ */
+H5_DLL ssize_t H5Eget_class_name(hid_t class_id, char *name, size_t size);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Replaces the current error stack
+ *
+ * \estack_id{err_stack_id}
+ *
+ * \return \herr_t
+ *
+ * \details H5Eset_current_stack() replaces the content of the current error
+ *          stack with a copy of the content of the error stack specified by
+ *          \p err_stack_id, and it closes the error stack specified by
+ *          \p err_stack_id.
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Eset_current_stack(hid_t err_stack_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Pushes a new error record onto an error stack
+ *
+ * \estack_id{err_stack}. If the identifier is #H5E_DEFAULT, the error record
+ *                        will be pushed to the current stack.
+ * \param[in] file Name of the file in which the error was detected
+ * \param[in] func Name of the function in which the error was detected
+ * \param[in] line Line number in the file where the error was detected
+ * \param[in] cls_id Error class identifier
+ * \param[in] maj_id Major error identifier
+ * \param[in] min_id Minor error identifier
+ * \param[in] msg Error description string
+ * \return \herr_t
+ *
+ * \details H5Epush2() pushes a new error record onto the error stack specified
+ *          by \p err_stack.\n
+ *          The error record contains the error class identifier \p cls_id, the
+ *          major and minor message identifiers \p maj_id and \p min_id, the
+ *          function name \p func where the error was detected, the file name \p
+ *          file and line number \p line in the file where the error was
+ *          detected, and an error description \p msg.\n
+ *          The major and minor errors must be in the same error class.\n
+ *          The function name, filename, and error description strings must be
+ *          statically allocated.\n
+ *          \p msg can be a format control string with additional
+ *          arguments. This design of appending additional arguments is similar
+ *          to the system and C functions printf() and fprintf().
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Epush2(hid_t err_stack, const char *file, const char *func, unsigned line, hid_t cls_id,
+                       hid_t maj_id, hid_t min_id, const char *msg, ...);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Deletes specified number of error messages from the error stack
+ *
+ * \estack_id{err_stack}
+ * \param[in] count The number of error messages to be deleted from the top
+ *                  of error stack
+ * \return \herr_t
+ *
+ * \details H5Epop() deletes the number of error records specified in \p count
+ *          from the top of the error stack specified by \p err_stack (including
+ *          major, minor messages and description). The number of error messages
+ *          to be deleted is specified by \p count.
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Epop(hid_t err_stack, size_t count);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Prints the specified error stack in a default manner
+ *
+ * \estack_id{err_stack}
+ * \param[in] stream File pointer, or \c NULL for \c stderr
+ * \return \herr_t
+ *
+ * \details H5Eprint2() prints the error stack specified by \p err_stack on the
+ *          specified stream, \p stream. Even if the error stack is empty, a
+ *          one-line message of the following form will be printed:
+ *          \code{.unparsed}
+ *          HDF5-DIAG: Error detected in HDF5 library version: 1.5.62 thread 0.
+ *          \endcode
+ *
+ *          A similar line will appear before the error messages of each error
+ *          class stating the library name, library version number, and thread
+ *          identifier.
+ *
+ *          If \p err_stack is #H5E_DEFAULT, the current error stack will be
+ *          printed.
+ *
+ *          H5Eprint2() is a convenience function for H5Ewalk2() with a function
+ *          that prints error messages. Users are encouraged to write their own
+ *          more specific error handlers.
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Eprint2(hid_t err_stack, FILE *stream);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Walks the specified error stack, calling the specified function
+ *
+ * \estack_id{err_stack}
+ * \param[in] direction Direction in which the error stack is to be walked
+ * \param[in] func Function to be called for each error encountered
+ * \param[in] client_data Data to be passed to \p func
+ * \return \herr_t
+ *
+ * \details H5Ewalk2() walks the error stack specified by err_stack for the
+ *          current thread and calls the function specified in \p func for each
+ *          error along the way.
+ *
+ *          If the value of \p err_stack is #H5E_DEFAULT, then H5Ewalk2() walks
+ *          the current error stack.
+ *
+ *          \p direction specifies whether the stack is walked from the inside
+ *          out or the outside in. A value of #H5E_WALK_UPWARD means to begin
+ *          with the most specific error and end at the API; a value of
+ *          #H5E_WALK_DOWNWARD means to start at the API and end at the
+ *          innermost function where the error was first detected.
+ *
+ *          \p func, a function conforming to the #H5E_walk2_t prototype, will
+ *          be called for each error in the error stack. Its arguments will
+ *          include an index number \c n (beginning at zero regardless of stack
+ *          traversal direction), an error stack entry \c err_desc, and the \c
+ *          client_data pointer passed to H5Eprint(). The #H5E_walk2_t prototype
+ *          is as follows:
+ *          \snippet this H5E_walk2_t_snip
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Ewalk2(hid_t err_stack, H5E_direction_t direction, H5E_walk2_t func, void *client_data);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Returns the settings for the automatic error stack traversal
+ *        function and its data
+ *
+ * \estack_id
+ * \param[out] func The function currently set to be called upon an error condition
+ * \param[out] client_data Data currently set to be passed to the error function
+ * \return \herr_t
+ *
+ * \details H5Eget_auto2() returns the settings for the automatic error stack
+ *          traversal function, \p func, and its data, \p client_data, that are
+ *          associated with the error stack specified by \p estack_id.
+ *
+ *          Either or both of the \p func and \p client_data arguments may be
+ *          \c NULL, in which case the value is not returned.
+ *
+ *          The library initializes its default error stack traversal functions
+ *          to H5Eprint1() and H5Eprint2(). A call to H5Eget_auto2() returns
+ *          H5Eprint2() or the user-defined function passed in through
+ *          H5Eset_auto2(). A call to H5Eget_auto1() returns H5Eprint1() or the
+ *          user-defined function passed in through H5Eset_auto1(). However, if
+ *          the application passes in a user-defined function through
+ *          H5Eset_auto1(), it should call H5Eget_auto1() to query the traversal
+ *          function. If the application passes in a user-defined function
+ *          through H5Eset_auto2(), it should call H5Eget_auto2() to query the
+ *          traversal function.
+ *
+ *          Mixing the new style and the old style functions will cause a
+ *          failure. For example, if the application sets a user-defined
+ *          old-style traversal function through H5Eset_auto1(), a call to
+ *          H5Eget_auto2() will fail and will indicate that the application has
+ *          mixed H5Eset_auto1() and H5Eget_auto2(). On the other hand, mixing
+ *          H5Eset_auto2() and H5Eget_auto1() will also cause a failure. But if
+ *          the traversal functions are the library's default H5Eprint1() or
+ *          H5Eprint2(), mixing H5Eset_auto1() and H5Eget_auto2() or mixing
+ *          H5Eset_auto2() and H5Eget_auto1() does not fail.
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Eget_auto2(hid_t estack_id, H5E_auto2_t *func, void **client_data);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Turns automatic error printing on or off
+ *
+ * \estack_id
+ * \param[in] func Function to be called upon an error condition
+ * \param[in] client_data Data passed to the error function
+ * \return \herr_t
+ *
+ * \details H5Eset_auto2() turns on or off automatic printing of errors for the
+ *          error stack specified with \p estack_id. An \p estack_id value of
+ *          #H5E_DEFAULT indicates the current stack.
+ *
+ *          When automatic printing is turned on, by the use of a non-null \p func
+ *          pointer, any API function which returns an error indication will
+ *          first call \p func, passing it \p client_data as an argument.
+ *
+ *          \p func, a function compliant with the #H5E_auto2_t prototype, is
+ *          defined in the H5Epublic.h source code file as:
+ *          \snippet this H5E_auto2_t_snip
+ *
+ *          When the library is first initialized, the auto printing function is
+ *          set to H5Eprint2() (cast appropriately) and \p client_data is the
+ *          standard error stream pointer, \c stderr.
+ *
+ *          Automatic stack traversal is always in the #H5E_WALK_DOWNWARD
+ *          direction.
+ *
+ *          Automatic error printing is turned off with a H5Eset_auto2() call
+ *          with a \c NULL \p func pointer.
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Eset_auto2(hid_t estack_id, H5E_auto2_t func, void *client_data);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Clears the specified error stack or the error stack for the current thread
+ *
+ * \estack_id{err_stack}
+ * \return \herr_t
+ *
+ * \details H5Eclear2() clears the error stack specified by \p err_stack, or, if
+ *          \p err_stack is set to #H5E_DEFAULT, the error stack for the current
+ *          thread.
+ *
+ *          \p err_stack is an error stack identifier, such as that returned by
+ *          H5Eget_current_stack().
+ *
+ *          The current error stack is also cleared whenever an API function is
+ *          called, with certain exceptions (for instance, H5Eprint1() or
+ *          H5Eprint2()).
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Eclear2(hid_t err_stack);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Determines the type of error stack
+ *
+ * \estack_id{err_stack}
+ * \param[out] is_stack A flag indicating which error stack \c typedef the
+ *                      specified error stack conforms to
+ *
+ * \return \herr_t
+ *
+ * \details H5Eauto_is_v2() determines whether the error auto reporting function
+ *          for an error stack conforms to the #H5E_auto2_t \c typedef or the
+ *          #H5E_auto1_t \c typedef.
+ *
+ *          The \p is_stack parameter is set to 1 if the error stack conforms to
+ *          #H5E_auto2_t and 0 if it conforms to #H5E_auto1_t.
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Eauto_is_v2(hid_t err_stack, unsigned *is_stack);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Retrieves an error message
+ *
+ * \param[in] msg_id Error message identifier
+ * \param[out] type The type of the error message Valid values are #H5E_MAJOR
+ *                  and #H5E_MINOR.
+ * \param[out] msg Error message buffer
+ * \param[in] size The length of error message to be returned by this function
+ * \return Returns the size of the error message in bytes on success; otherwise
+ *         returns a negative value.
+ *
+ * \details H5Eget_msg() retrieves the error message including its length and
+ *          type. The error message is specified by \p msg_id. The user is
+ *          responsible for passing in sufficient buffer space for the
+ *          message. If \p msg is not NULL and \p size is greater than zero, the
+ *          error message of \p size long is returned. The length of the message
+ *          is also returned. If NULL is passed in as \p msg, only the length
+ *          and type of the message is returned. If the return value is zero, it
+ *          means there is no message.
+ *
+ * \since 1.8.0
+ */
+H5_DLL ssize_t H5Eget_msg(hid_t msg_id, H5E_type_t *type, char *msg, size_t size);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Retrieves the number of error messages in an error stack
+ *
+ * \estack_id{error_stack_id}
+ * \return Returns a non-negative value on success; otherwise returns a negative value.
+ *
+ * \details H5Eget_num() retrieves the number of error records in the error
+ *          stack specified by \p error_stack_id (including major, minor
+ *          messages and description).
+ *
+ * \since 1.8.0
+ */
+H5_DLL ssize_t H5Eget_num(hid_t error_stack_id);
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Typedefs */
+
+/* Alias major & minor error types to hid_t's, for compatibility with new
+ *      error API in v1.8
+ */
+typedef hid_t H5E_major_t;
+typedef hid_t H5E_minor_t;
+
+/**
+ * Information about an error element of error stack.
+ */
+typedef struct H5E_error1_t {
+    H5E_major_t maj_num;   /**< major error number                 */
+    H5E_minor_t min_num;   /**< minor error number                 */
+    const char *func_name; /**< function in which error occurred   */
+    const char *file_name; /**< file in which error occurred       */
+    unsigned    line;      /**< line in file where error occurs    */
+    const char *desc;      /**< optional supplied description      */
+} H5E_error1_t;
+
+/* Error stack traversal callback function pointers */
+//! <!-- [H5E_walk1_t_snip] -->
+/**
+ * \brief Callback function for H5Ewalk1()
+ *
+ * \param[in] n Indexed error position in the stack
+ * \param[in] err_desc Pointer to a data structure describing the error
+ * \param[in] client_data Pointer to client data in the format expected by the
+ *                        user-defined function
+ * \return \herr_t
+ */
+typedef herr_t (*H5E_walk1_t)(int n, H5E_error1_t *err_desc, void *client_data);
+//! <!-- [H5E_walk1_t_snip] -->
+
+//! <!-- [H5E_auto1_t_snip] -->
+/**
+ * \brief Callback function for H5Eset_auto1()
+ *
+ * \param[in] client_data Pointer to client data in the format expected by the
+ *                        user-defined function
+ * \return \herr_t
+ */
+typedef herr_t (*H5E_auto1_t)(void *client_data);
+//! <!-- [H5E_auto1_t_snip] -->
+
+/* Function prototypes */
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Clears the error stack for the current thread
+ *
+ * \return \herr_t
+ *
+ * \deprecated 1.8.0 Function H5Eclear() renamed to H5Eclear1() and deprecated
+ *                   in this release.
+ *
+ * \details H5Eclear1() clears the error stack for the current thread.\n
+ *          The stack is also cleared whenever an API function is called, with
+ *          certain exceptions (for instance, H5Eprint1()).
+ *
+ */
+H5_DLL herr_t H5Eclear1(void);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Returns the current settings for the automatic error stack traversal
+ *        function and its data
+ *
+ * \param[out] func Current setting for the function to be called upon an error
+ *                  condition
+ * \param[out] client_data Current setting for the data passed to the error
+ *                         function
+ * \return \herr_t
+ *
+ * \deprecated 1.8.0 Function H5Eget_auto() renamed to H5Eget_auto1() and
+ *                   deprecated in this release.
+ *
+ * \details H5Eget_auto1() returns the current settings for the automatic error
+ *          stack traversal function, \p func, and its data,
+ *          \p client_data. Either or both arguments may be \c NULL, in which case the
+ *          value is not returned.
+ *
+ *          The library initializes its default error stack traversal functions
+ *          to H5Eprint1() and H5Eprint2(). A call to H5Eget_auto2() returns
+ *          H5Eprint2() or the user-defined function passed in through
+ *          H5Eset_auto2(). A call to H5Eget_auto1() returns H5Eprint1() or the
+ *          user-defined function passed in through H5Eset_auto1(). However, if
+ *          the application passes in a user-defined function through
+ *          H5Eset_auto1(), it should call H5Eget_auto1() to query the traversal
+ *          function. If the application passes in a user-defined function
+ *          through H5Eset_auto2(), it should call H5Eget_auto2() to query the
+ *          traversal function.
+ *
+ *          Mixing the new style and the old style functions will cause a
+ *          failure. For example, if the application sets a user-defined
+ *          old-style traversal function through H5Eset_auto1(), a call to
+ *          H5Eget_auto2() will fail and will indicate that the application has
+ *          mixed H5Eset_auto1() and H5Eget_auto2(). On the other hand, mixing
+ *          H5Eset_auto2() and H5Eget_auto1() will also cause a failure. But if
+ *          the traversal functions are the library's default H5Eprint1() or
+ *          H5Eprint2(), mixing H5Eset_auto1() and H5Eget_auto2() or mixing
+ *          H5Eset_auto2() and H5Eget_auto1() does not fail.
+ *
+ */
+H5_DLL herr_t H5Eget_auto1(H5E_auto1_t *func, void **client_data);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Pushes a new error record onto the error stack
+ *
+ * \param[in] file Name of the file in which the error was detected
+ * \param[in] func Name of the function in which the error was detected
+ * \param[in] line Line number in the file where the error was detected
+ * \param[in] maj Major error identifier
+ * \param[in] min Minor error identifier
+ * \param[in] str Error description string
+ * \return \herr_t
+ *
+ * \deprecated 1.8.0 Function H5Epush() renamed to H5Epush1() and
+ *                   deprecated in this release.
+ *
+ * \details H5Epush1() pushes a new error record onto the error stack for the
+ *          current thread.\n
+ *          The error has major and minor numbers \p maj_num
+ *          and \p min_num, the function \p func where the error was detected, the
+ *          name of the file \p file where the error was detected, the line \p line
+ *          within that file, and an error description string \p str.\n
+ *          The function name, filename, and error description strings must be statically
+ *          allocated.
+ *
+ * \since 1.4.0
+ */
+H5_DLL herr_t H5Epush1(const char *file, const char *func, unsigned line, H5E_major_t maj, H5E_minor_t min,
+                       const char *str);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Prints the current error stack in a default manner
+ *
+ * \param[in] stream File pointer, or \c NULL for \c stderr
+ * \return \herr_t
+ *
+ * \deprecated 1.8.0 Function H5Eprint() renamed to H5Eprint1() and
+ *                   deprecated in this release.
+ *
+ * \details H5Eprint1() prints the error stack for the current thread
+ *          on the specified stream, \p stream. Even if the error stack is empty, a
+ *          one-line message of the following form will be printed:
+ *          \code{.unparsed}
+ *          HDF5-DIAG: Error detected in thread 0.
+ *          \endcode
+ *          H5Eprint1() is a convenience function for H5Ewalk1() with a function
+ *          that prints error messages. Users are encouraged to write their own
+ *          more specific error handlers.
+ *
+ */
+H5_DLL herr_t H5Eprint1(FILE *stream);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Turns automatic error printing on or off
+ *
+ * \param[in] func Function to be called upon an error condition
+ * \param[in] client_data Data passed to the error function
+ * \return \herr_t
+ *
+ * \deprecated 1.8.0 Function H5Eset_auto() renamed to H5Eset_auto1() and
+ *                   deprecated in this release.
+ *
+ * \details H5Eset_auto1() turns on or off automatic printing of errors. When
+ *          turned on (non-null \p func pointer), any API function which returns
+ *          an error indication will first call \p func, passing it \p
+ *          client_data as an argument.
+ *
+ *          \p func, a function conforming to the #H5E_auto1_t prototype, is
+ *          defined in the H5Epublic.h source code file as:
+ *          \snippet this H5E_auto1_t_snip
+ *
+ *          When the library is first initialized, the auto printing function is
+ *          set to H5Eprint1() (cast appropriately) and \p client_data is the
+ *          standard error stream pointer, \c stderr.
+ *
+ *          Automatic stack traversal is always in the #H5E_WALK_DOWNWARD
+ *          direction.
+ *
+ */
+H5_DLL herr_t H5Eset_auto1(H5E_auto1_t func, void *client_data);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Walks the current error stack, calling the specified function
+ *
+ * \param[in] direction Direction in which the error stack is to be walked
+ * \param[in] func Function to be called for each error encountered
+ * \param[in] client_data Data to be passed to \p func
+ * \return \herr_t
+ *
+ * \deprecated 1.8.0 Function H5Ewalk() renamed to H5Ewalk1() and
+ *                   deprecated in this release.
+ *
+ * \details H5Ewalk1() walks the error stack for the current thread and calls
+ *          the function specified in \p func for each error along the way.
+ *
+ *          \p direction specifies whether the stack is walked from the inside
+ *          out or the outside in. A value of #H5E_WALK_UPWARD means to begin
+ *          with the most specific error and end at the API; a value of
+ *          #H5E_WALK_DOWNWARD means to start at the API and end at the
+ *          innermost function where the error was first detected.
+ *
+ *          \p func, a function conforming to the #H5E_walk1_t prototype, will
+ *          be called for each error in the error stack. Its arguments will
+ *          include an index number \c n (beginning at zero regardless of stack
+ *          traversal direction), an error stack entry \c err_desc, and the \c
+ *          client_data pointer passed to H5Eprint(). The #H5E_walk1_t prototype
+ *          is as follows:
+ *          \snippet this H5E_walk1_t_snip
+ *
+ */
+H5_DLL herr_t H5Ewalk1(H5E_direction_t direction, H5E_walk1_t func, void *client_data);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Returns a character string describing an error specified by a major
+ *        error number
+ *
+ * \param[in] maj Major error number
+ * \return \herr_t
+ *
+ * \deprecated 1.8.0 Function deprecated in this release.
+ *
+ * \details H5Eget_major() returns a constant
+ *          character string that describes the error, given a major error number.
+ *
+ * \attention This function returns a dynamically allocated string (\c char
+ *            array). An application calling this function must free the memory
+ *            associated with the return value to prevent a memory leak.
+ *
+ */
+H5_DLL char *H5Eget_major(H5E_major_t maj);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5E
+ *
+ * \brief Returns a character string describing an error specified by a minor
+ *        error number
+ *
+ * \param[in] min Minor error number
+ * \return \herr_t
+ *
+ * \deprecated 1.8.0 Function deprecated and return type changed in this release.
+ *
+ * \details H5Eget_minor() returns a constant
+ *          character string that describes the error, given a minor error number.
+ *
+ * \attention In the Release 1.8.x series, H5Eget_minor() returns a string of
+ *            dynamic allocated \c char array. An application calling this
+ *            function from an HDF5 library of Release 1.8.0 or later must free
+ *            the memory associated with the return value to prevent a memory
+ *            leak. This is a change from the 1.6.x release series.
+ *
+ */
+H5_DLL char *H5Eget_minor(H5E_minor_t min);
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end H5Epublic_H */
diff --git a/install/include/H5FDcore.h b/install/include/H5FDcore.h
new file mode 100644
index 0000000000..cd45c8d606
--- /dev/null
+++ b/install/include/H5FDcore.h
@@ -0,0 +1,102 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the core virtual file driver (VFD)
+ */
+#ifndef H5FDcore_H
+#define H5FDcore_H
+
+/** Initializer for the core VFD */
+#define H5FD_CORE (H5FDperform_init(H5FD_core_init))
+
+/** Identifier for the core VFD */
+#define H5FD_CORE_VALUE H5_VFD_CORE
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @private
+ *
+ * \brief Private initializer for the core VFD
+ */
+H5_DLL hid_t H5FD_core_init(void);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Modifies the file access property list to use the #H5FD_CORE driver
+ *
+ * \fapl_id
+ * \param[in] increment Size, in bytes, of memory increments
+ * \param[in] backing_store Boolean flag indicating whether to write the file
+ *            contents to disk when the file is closed
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_core() modifies the file access property list to use the
+ *          #H5FD_CORE driver.
+ *
+ *          The #H5FD_CORE driver enables an application to work with a file in
+ *          memory, speeding reads and writes as no disk access is made. File
+ *          contents are stored only in memory until the file is closed. The \p
+ *          backing_store parameter determines whether file contents are ever
+ *          written to disk.
+ *
+ *          \p increment specifies the increment by which allocated memory is to
+ *          be increased each time more memory is required.
+ *
+ *          While using H5Fcreate() to create a core file, if the \p
+ *          backing_store is set to 1 (true), the file contents are flushed to a
+ *          file with the same name as this core file when the file is closed or
+ *          access to the file is terminated in memory.
+ *
+ *          The application is allowed to open an existing file with #H5FD_CORE
+ *          driver. While using H5Fopen() to open an existing file, if the \p
+ *          backing_store is set to 1 (true) and the \c flags for H5Fopen() is set to
+ *          #H5F_ACC_RDWR, any change to the file contents are saved to the file
+ *          when the file is closed. If \p backing_store is set to 0 (false) and the \c
+ *          flags for H5Fopen() is set to #H5F_ACC_RDWR, any change to the file
+ *          contents will be lost when the file is closed. If the flags for
+ *          H5Fopen() is set to #H5F_ACC_RDONLY, no change to the file is
+ *          allowed either in memory or on file.
+ *
+ * \note Currently this driver cannot create or open family or multi files.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pset_fapl_core(hid_t fapl_id, size_t increment, hbool_t backing_store);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Queries core file driver properties
+ *
+ * \fapl_id
+ * \param[out] increment Size, in bytes, of memory increments
+ * \param[out] backing_store Boolean flag indicating whether to write the file
+ *             contents to disk when the file is closed
+ * \returns \herr_t
+ *
+ * \details H5Pget_fapl_core() queries the #H5FD_CORE driver properties as set
+ *          by H5Pset_fapl_core().
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pget_fapl_core(hid_t fapl_id, size_t *increment /*out*/, hbool_t *backing_store /*out*/);
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5FDdevelop.h b/install/include/H5FDdevelop.h
new file mode 100644
index 0000000000..75e63b14c0
--- /dev/null
+++ b/install/include/H5FDdevelop.h
@@ -0,0 +1,307 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5FD (file drivers) developer
+ *      support routines.
+ */
+
+#ifndef H5FDdevelop_H
+#define H5FDdevelop_H
+
+/* Include package's public header */
+#include "H5FDpublic.h"
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* H5FD_class_t struct version */
+#define H5FD_CLASS_VERSION 0x01 /* File driver struct version */
+
+/* Map "fractal heap" header blocks to 'ohdr' type file memory, since its
+ * a fair amount of work to add a new kind of file memory and they are similar
+ * enough to object headers and probably too minor to deserve their own type.
+ *
+ * Map "fractal heap" indirect blocks to 'ohdr' type file memory, since they
+ * are similar to fractal heap header blocks.
+ *
+ * Map "fractal heap" direct blocks to 'lheap' type file memory, since they
+ * will be replacing local heaps.
+ *
+ * Map "fractal heap" 'huge' objects to 'draw' type file memory, since they
+ * represent large objects that are directly stored in the file.
+ *
+ *      -QAK
+ */
+#define H5FD_MEM_FHEAP_HDR      H5FD_MEM_OHDR
+#define H5FD_MEM_FHEAP_IBLOCK   H5FD_MEM_OHDR
+#define H5FD_MEM_FHEAP_DBLOCK   H5FD_MEM_LHEAP
+#define H5FD_MEM_FHEAP_HUGE_OBJ H5FD_MEM_DRAW
+
+/* Map "free space" header blocks to 'ohdr' type file memory, since its
+ * a fair amount of work to add a new kind of file memory and they are similar
+ * enough to object headers and probably too minor to deserve their own type.
+ *
+ * Map "free space" serialized sections to 'lheap' type file memory, since they
+ * are similar enough to local heap info.
+ *
+ *      -QAK
+ */
+#define H5FD_MEM_FSPACE_HDR   H5FD_MEM_OHDR
+#define H5FD_MEM_FSPACE_SINFO H5FD_MEM_LHEAP
+
+/* Map "shared object header message" master table to 'ohdr' type file memory,
+ * since its a fair amount of work to add a new kind of file memory and they are
+ * similar enough to object headers and probably too minor to deserve their own
+ * type.
+ *
+ * Map "shared object header message" indices to 'btree' type file memory,
+ * since they are similar enough to B-tree nodes.
+ *
+ *      -QAK
+ */
+#define H5FD_MEM_SOHM_TABLE H5FD_MEM_OHDR
+#define H5FD_MEM_SOHM_INDEX H5FD_MEM_BTREE
+
+/* Map "extensible array" header blocks to 'ohdr' type file memory, since its
+ * a fair amount of work to add a new kind of file memory and they are similar
+ * enough to object headers and probably too minor to deserve their own type.
+ *
+ * Map "extensible array" index blocks to 'ohdr' type file memory, since they
+ * are similar to extensible array header blocks.
+ *
+ * Map "extensible array" super blocks to 'btree' type file memory, since they
+ * are similar enough to B-tree nodes.
+ *
+ * Map "extensible array" data blocks & pages to 'lheap' type file memory, since
+ * they are similar enough to local heap info.
+ *
+ *      -QAK
+ */
+#define H5FD_MEM_EARRAY_HDR       H5FD_MEM_OHDR
+#define H5FD_MEM_EARRAY_IBLOCK    H5FD_MEM_OHDR
+#define H5FD_MEM_EARRAY_SBLOCK    H5FD_MEM_BTREE
+#define H5FD_MEM_EARRAY_DBLOCK    H5FD_MEM_LHEAP
+#define H5FD_MEM_EARRAY_DBLK_PAGE H5FD_MEM_LHEAP
+
+/* Map "fixed array" header blocks to 'ohdr' type file memory, since its
+ * a fair amount of work to add a new kind of file memory and they are similar
+ * enough to object headers and probably too minor to deserve their own type.
+ *
+ * Map "fixed array" data blocks & pages to 'lheap' type file memory, since
+ * they are similar enough to local heap info.
+ *
+ */
+#define H5FD_MEM_FARRAY_HDR       H5FD_MEM_OHDR
+#define H5FD_MEM_FARRAY_DBLOCK    H5FD_MEM_LHEAP
+#define H5FD_MEM_FARRAY_DBLK_PAGE H5FD_MEM_LHEAP
+
+/*
+ * A free-list map which maps all types of allocation requests to a single
+ * free list.  This is useful for drivers that don't really care about
+ * keeping different requests segregated in the underlying file and which
+ * want to make most efficient reuse of freed memory.  The use of the
+ * H5FD_MEM_SUPER free list is arbitrary.
+ */
+#define H5FD_FLMAP_SINGLE                                                                                    \
+    {                                                                                                        \
+        H5FD_MEM_SUPER,     /*default*/                                                                      \
+            H5FD_MEM_SUPER, /*super*/                                                                        \
+            H5FD_MEM_SUPER, /*btree*/                                                                        \
+            H5FD_MEM_SUPER, /*draw*/                                                                         \
+            H5FD_MEM_SUPER, /*gheap*/                                                                        \
+            H5FD_MEM_SUPER, /*lheap*/                                                                        \
+            H5FD_MEM_SUPER  /*ohdr*/                                                                         \
+    }
+
+/*
+ * A free-list map which segregates requests into `raw' or `meta' data
+ * pools.
+ */
+#define H5FD_FLMAP_DICHOTOMY                                                                                 \
+    {                                                                                                        \
+        H5FD_MEM_SUPER,     /*default*/                                                                      \
+            H5FD_MEM_SUPER, /*super*/                                                                        \
+            H5FD_MEM_SUPER, /*btree*/                                                                        \
+            H5FD_MEM_DRAW,  /*draw*/                                                                         \
+            H5FD_MEM_DRAW,  /*gheap*/                                                                        \
+            H5FD_MEM_SUPER, /*lheap*/                                                                        \
+            H5FD_MEM_SUPER  /*ohdr*/                                                                         \
+    }
+
+/*
+ * The default free list map which causes each request type to use it's own
+ * free-list.
+ */
+#define H5FD_FLMAP_DEFAULT                                                                                   \
+    {                                                                                                        \
+        H5FD_MEM_DEFAULT,     /*default*/                                                                    \
+            H5FD_MEM_DEFAULT, /*super*/                                                                      \
+            H5FD_MEM_DEFAULT, /*btree*/                                                                      \
+            H5FD_MEM_DEFAULT, /*draw*/                                                                       \
+            H5FD_MEM_DEFAULT, /*gheap*/                                                                      \
+            H5FD_MEM_DEFAULT, /*lheap*/                                                                      \
+            H5FD_MEM_DEFAULT  /*ohdr*/                                                                       \
+    }
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/* Forward declaration */
+typedef struct H5FD_t H5FD_t;
+
+/* Class information for each file driver */
+typedef struct H5FD_class_t {
+    unsigned           version; /**< File driver class struct version number */
+    H5FD_class_value_t value;
+    const char        *name;
+    haddr_t            maxaddr;
+    H5F_close_degree_t fc_degree;
+    herr_t (*terminate)(void);
+    hsize_t (*sb_size)(H5FD_t *file);
+    herr_t (*sb_encode)(H5FD_t *file, char *name /*out*/, unsigned char *p /*out*/);
+    herr_t (*sb_decode)(H5FD_t *f, const char *name, const unsigned char *p);
+    size_t fapl_size;
+    void *(*fapl_get)(H5FD_t *file);
+    void *(*fapl_copy)(const void *fapl);
+    herr_t (*fapl_free)(void *fapl);
+    size_t dxpl_size;
+    void *(*dxpl_copy)(const void *dxpl);
+    herr_t (*dxpl_free)(void *dxpl);
+    H5FD_t *(*open)(const char *name, unsigned flags, hid_t fapl, haddr_t maxaddr);
+    herr_t (*close)(H5FD_t *file);
+    int (*cmp)(const H5FD_t *f1, const H5FD_t *f2);
+    herr_t (*query)(const H5FD_t *f1, unsigned long *flags);
+    herr_t (*get_type_map)(const H5FD_t *file, H5FD_mem_t *type_map);
+    haddr_t (*alloc)(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, hsize_t size);
+    herr_t (*free)(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, haddr_t addr, hsize_t size);
+    haddr_t (*get_eoa)(const H5FD_t *file, H5FD_mem_t type);
+    herr_t (*set_eoa)(H5FD_t *file, H5FD_mem_t type, haddr_t addr);
+    haddr_t (*get_eof)(const H5FD_t *file, H5FD_mem_t type);
+    herr_t (*get_handle)(H5FD_t *file, hid_t fapl, void **file_handle);
+    herr_t (*read)(H5FD_t *file, H5FD_mem_t type, hid_t dxpl, haddr_t addr, size_t size, void *buffer);
+    herr_t (*write)(H5FD_t *file, H5FD_mem_t type, hid_t dxpl, haddr_t addr, size_t size, const void *buffer);
+    herr_t (*read_vector)(H5FD_t *file, hid_t dxpl, uint32_t count, H5FD_mem_t types[], haddr_t addrs[],
+                          size_t sizes[], void *bufs[]);
+    herr_t (*write_vector)(H5FD_t *file, hid_t dxpl, uint32_t count, H5FD_mem_t types[], haddr_t addrs[],
+                           size_t sizes[], const void *bufs[]);
+    herr_t (*read_selection)(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, size_t count, hid_t mem_spaces[],
+                             hid_t file_spaces[], haddr_t offsets[], size_t element_sizes[],
+                             void *bufs[] /*out*/);
+    herr_t (*write_selection)(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, size_t count, hid_t mem_spaces[],
+                              hid_t file_spaces[], haddr_t offsets[], size_t element_sizes[],
+                              const void *bufs[] /*in*/);
+    herr_t (*flush)(H5FD_t *file, hid_t dxpl_id, hbool_t closing);
+    herr_t (*truncate)(H5FD_t *file, hid_t dxpl_id, hbool_t closing);
+    herr_t (*lock)(H5FD_t *file, hbool_t rw);
+    herr_t (*unlock)(H5FD_t *file);
+    herr_t (*del)(const char *name, hid_t fapl);
+    herr_t (*ctl)(H5FD_t *file, uint64_t op_code, uint64_t flags, const void *input, void **output);
+    H5FD_mem_t fl_map[H5FD_MEM_NTYPES];
+} H5FD_class_t;
+
+/* A free list is a singly-linked list of address/size pairs. */
+typedef struct H5FD_free_t {
+    haddr_t             addr;
+    hsize_t             size;
+    struct H5FD_free_t *next;
+} H5FD_free_t;
+
+/*
+ * The main datatype for each driver. Public fields common to all drivers
+ * are declared here and the driver appends private fields in memory.
+ */
+struct H5FD_t {
+    hid_t               driver_id;     /*driver ID for this file   */
+    const H5FD_class_t *cls;           /*constant class info       */
+    unsigned long       fileno;        /* File 'serial' number     */
+    unsigned            access_flags;  /* File access flags (from create or open) */
+    unsigned long       feature_flags; /* VFL Driver feature Flags */
+    haddr_t             maxaddr;       /* For this file, overrides class */
+    haddr_t             base_addr;     /* Base address for HDF5 data w/in file */
+
+    /* Space allocation management fields */
+    hsize_t threshold;  /* Threshold for alignment  */
+    hsize_t alignment;  /* Allocation alignment     */
+    hbool_t paged_aggr; /* Paged aggregation for file space is enabled or not */
+};
+
+/* VFD initialization function */
+typedef hid_t (*H5FD_init_t)(void);
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5_DLL hid_t   H5FDperform_init(H5FD_init_t op);
+H5_DLL hid_t   H5FDregister(const H5FD_class_t *cls);
+H5_DLL htri_t  H5FDis_driver_registered_by_name(const char *driver_name);
+H5_DLL htri_t  H5FDis_driver_registered_by_value(H5FD_class_value_t driver_value);
+H5_DLL herr_t  H5FDunregister(hid_t driver_id);
+H5_DLL H5FD_t *H5FDopen(const char *name, unsigned flags, hid_t fapl_id, haddr_t maxaddr);
+H5_DLL herr_t  H5FDclose(H5FD_t *file);
+H5_DLL int     H5FDcmp(const H5FD_t *f1, const H5FD_t *f2);
+H5_DLL int     H5FDquery(const H5FD_t *f, unsigned long *flags);
+H5_DLL haddr_t H5FDalloc(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, hsize_t size);
+H5_DLL herr_t  H5FDfree(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, haddr_t addr, hsize_t size);
+H5_DLL haddr_t H5FDget_eoa(H5FD_t *file, H5FD_mem_t type);
+H5_DLL herr_t  H5FDset_eoa(H5FD_t *file, H5FD_mem_t type, haddr_t eoa);
+H5_DLL haddr_t H5FDget_eof(H5FD_t *file, H5FD_mem_t type);
+H5_DLL herr_t  H5FDget_vfd_handle(H5FD_t *file, hid_t fapl, void **file_handle);
+H5_DLL herr_t  H5FDread(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, haddr_t addr, size_t size,
+                        void *buf /*out*/);
+H5_DLL herr_t  H5FDwrite(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, haddr_t addr, size_t size,
+                         const void *buf);
+H5_DLL herr_t  H5FDread_vector(H5FD_t *file, hid_t dxpl_id, uint32_t count, H5FD_mem_t types[],
+                               haddr_t addrs[], size_t sizes[], void *bufs[] /* out */);
+H5_DLL herr_t  H5FDwrite_vector(H5FD_t *file, hid_t dxpl_id, uint32_t count, H5FD_mem_t types[],
+                                haddr_t addrs[], size_t sizes[], const void *bufs[] /* in */);
+H5_DLL herr_t  H5FDread_selection(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, uint32_t count,
+                                  hid_t mem_spaces[], hid_t file_spaces[], haddr_t offsets[],
+                                  size_t element_sizes[], void *bufs[] /* out */);
+H5_DLL herr_t  H5FDwrite_selection(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, uint32_t count,
+                                   hid_t mem_spaces[], hid_t file_spaces[], haddr_t offsets[],
+                                   size_t element_sizes[], const void *bufs[]);
+H5_DLL herr_t  H5FDread_vector_from_selection(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, uint32_t count,
+                                              hid_t mem_spaces[], hid_t file_spaces[], haddr_t offsets[],
+                                              size_t element_sizes[], void *bufs[] /* out */);
+H5_DLL herr_t  H5FDwrite_vector_from_selection(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, uint32_t count,
+                                               hid_t mem_spaces[], hid_t file_spaces[], haddr_t offsets[],
+                                               size_t element_sizes[], const void *bufs[] /* in */);
+H5_DLL herr_t  H5FDread_from_selection(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, uint32_t count,
+                                       hid_t mem_space_ids[], hid_t file_space_ids[], haddr_t offsets[],
+                                       size_t element_sizes[], void *bufs[] /* out */);
+H5_DLL herr_t  H5FDwrite_from_selection(H5FD_t *file, H5FD_mem_t type, hid_t dxpl_id, uint32_t count,
+                                        hid_t mem_space_ids[], hid_t file_space_ids[], haddr_t offsets[],
+                                        size_t element_sizes[], const void *bufs[] /* in */);
+H5_DLL herr_t  H5FDflush(H5FD_t *file, hid_t dxpl_id, hbool_t closing);
+H5_DLL herr_t  H5FDtruncate(H5FD_t *file, hid_t dxpl_id, hbool_t closing);
+H5_DLL herr_t  H5FDlock(H5FD_t *file, hbool_t rw);
+H5_DLL herr_t  H5FDunlock(H5FD_t *file);
+H5_DLL herr_t  H5FDdelete(const char *name, hid_t fapl_id);
+H5_DLL herr_t  H5FDctl(H5FD_t *file, uint64_t op_code, uint64_t flags, const void *input, void **output);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5FDdevelop_H */
diff --git a/install/include/H5FDdirect.h b/install/include/H5FDdirect.h
new file mode 100644
index 0000000000..1e60bb0811
--- /dev/null
+++ b/install/include/H5FDdirect.h
@@ -0,0 +1,127 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the direct virtual file driver (VFD)
+ */
+#ifndef H5FDdirect_H
+#define H5FDdirect_H
+
+#ifdef H5_HAVE_DIRECT
+
+/** Initializer for the direct VFD */
+#define H5FD_DIRECT (H5FDperform_init(H5FD_direct_init))
+
+/** Identifier for the direct VFD */
+#define H5FD_DIRECT_VALUE H5_VFD_DIRECT
+
+#else
+
+/** Initializer for the direct VFD (disabled) */
+#define H5FD_DIRECT       (H5I_INVALID_HID)
+
+/** Identifier for the direct VFD (disabled) */
+#define H5FD_DIRECT_VALUE H5_VFD_INVALID
+
+#endif /* H5_HAVE_DIRECT */
+
+/** Default value for memory boundary */
+#define MBOUNDARY_DEF 4096
+
+/** Default value for file block size */
+#define FBSIZE_DEF 4096
+
+/** Default value for maximum copy buffer size */
+#define CBSIZE_DEF (16 * 1024 * 1024)
+
+#ifdef H5_HAVE_DIRECT
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @private
+ *
+ * \brief Private initializer for the direct VFD
+ */
+H5_DLL hid_t H5FD_direct_init(void);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets up use of the direct I/O driver
+ *
+ * \fapl_id
+ * \param[in] alignment Required memory alignment boundary
+ * \param[in] block_size File system block size
+ * \param[in] cbuf_size Copy buffer size
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_direct() sets the file access property list, \p fapl_id,
+ *          to use the direct I/O driver, #H5FD_DIRECT. With this driver, data
+ *          is written to or read from the file synchronously without being
+ *          cached by the system.
+ *
+ *          File systems usually require the data address in memory, the file
+ *          address, and the size of the data to be aligned. The HDF5 library's
+ *          direct I/O driver is able to handle unaligned data, though that will
+ *          consume some additional memory resources and may slow
+ *          performance. To get better performance, use the system function \p
+ *          posix_memalign to align the data buffer in memory and the HDF5
+ *          function H5Pset_alignment() to align the data in the file. Be aware,
+ *          however, that aligned data I/O may cause the HDF5 file to be bigger
+ *          than the actual data size would otherwise require because the
+ *          alignment may leave some holes in the file.
+ *
+ *          \p alignment specifies the required alignment boundary in memory.
+ *
+ *          \p block_size specifies the file system block size. A value of 0
+ *          (zero) means to use HDF5 library's default value of 4KB.
+ *
+ *          \p cbuf_size specifies the copy buffer size.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_fapl_direct(hid_t fapl_id, size_t alignment, size_t block_size, size_t cbuf_size);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves direct I/O driver settings
+ *
+ * \fapl_id
+ * \param[out] boundary Required memory alignment boundary
+ * \param[out] block_size File system block size
+ * \param[out] cbuf_size Copy buffer size
+ * \returns \herr_t
+ *
+ * \details H5Pget_fapl_direct() retrieves the required memory alignment (\p
+ *          alignment), file system block size (\p block_size), and copy buffer
+ *          size (\p cbuf_size) settings for the direct I/O driver, #H5FD_DIRECT,
+ *          from the file access property list \p fapl_id.
+ *
+ *          See H5Pset_fapl_direct() for discussion of these values,
+ *          requirements, and important considerations.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_fapl_direct(hid_t fapl_id, size_t *boundary /*out*/, size_t *block_size /*out*/,
+                                 size_t *cbuf_size /*out*/);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5_HAVE_DIRECT */
+
+#endif
diff --git a/install/include/H5FDfamily.h b/install/include/H5FDfamily.h
new file mode 100644
index 0000000000..32e885c422
--- /dev/null
+++ b/install/include/H5FDfamily.h
@@ -0,0 +1,91 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the family virtual file driver (VFD)
+ */
+#ifndef H5FDfamily_H
+#define H5FDfamily_H
+
+/** Initializer for the family VFD */
+#define H5FD_FAMILY (H5FDperform_init(H5FD_family_init))
+
+/** Identifier for the family VFD */
+#define H5FD_FAMILY_VALUE H5_VFD_FAMILY
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @private
+ *
+ * \brief Private initializer for the family VFD
+ */
+H5_DLL hid_t H5FD_family_init(void);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the file access property list to use the family driver
+ *
+ * \fapl_id
+ * \param[in] memb_size Size in bytes of each file member
+ * \param[in] memb_fapl_id Identifier of file access property list for
+ *            each family member
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_family() sets the file access property list identifier,
+ *          \p fapl_id, to use the family driver.
+ *
+ *          \p memb_size is the size in bytes of each file member. This size
+ *          will be saved in file when the property list \p fapl_id is used to
+ *          create a new file. If \p fapl_id is used to open an existing file,
+ *          \p memb_size has to be equal to the original size saved in file. A
+ *          failure with an error message indicating the correct member size
+ *          will be returned if \p memb_size does not match the size saved. If
+ *          any user does not know the original size, #H5F_FAMILY_DEFAULT can be
+ *          passed in. The library will retrieve the saved size.
+ *
+ *          \p memb_fapl_id is the identifier of the file access property list
+ *          to be used for each family member.
+ *
+ * \version 1.8.0 Behavior of the \p memb_size parameter was changed.
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pset_fapl_family(hid_t fapl_id, hsize_t memb_size, hid_t memb_fapl_id);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Returns file access property list information
+ *
+ * \fapl_id
+ * \param[out] memb_size Size in bytes of each file member
+ * \param[out] memb_fapl_id Identifier of file access property list for
+ *             each family member
+ * \returns \herr_t
+ *
+ * \details H5Pget_fapl_family() returns file access property list for use with
+ *          the family driver. This information is returned through the output
+ *          parameters.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pget_fapl_family(hid_t fapl_id, hsize_t *memb_size /*out*/, hid_t *memb_fapl_id /*out*/);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5FDhdfs.h b/install/include/H5FDhdfs.h
new file mode 100644
index 0000000000..e5f7173fce
--- /dev/null
+++ b/install/include/H5FDhdfs.h
@@ -0,0 +1,143 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose: The public header file for the Hadoop Distributed File System
+ *          (hdfs) virtual file driver (VFD)
+ */
+
+#ifndef H5FDhdfs_H
+#define H5FDhdfs_H
+
+#ifdef H5_HAVE_LIBHDFS
+
+/** Initializer for the hdfs VFD */
+#define H5FD_HDFS (H5FDperform_init(H5FD_hdfs_init))
+
+/** Identifier for the hdfs VFD */
+#define H5FD_HDFS_VALUE H5_VFD_HDFS
+
+#else
+
+/** Initializer for the hdfs VFD (disabled) */
+#define H5FD_HDFS       (H5I_INVALID_HID)
+
+/** Identifier for the hdfs VFD (disabled) */
+#define H5FD_HDFS_VALUE H5_VFD_INVALID
+
+#endif /* H5_HAVE_LIBHDFS */
+
+#ifdef H5_HAVE_LIBHDFS
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/****************************************************************************
+ *
+ * Structure: H5FD_hdfs_fapl_t
+ *
+ * Purpose:
+ *
+ *     H5FD_hdfs_fapl_t is a public structure that is used to pass
+ *     configuration information to the appropriate HDFS VFD via the FAPL.
+ *     A pointer to an instance of this structure is a parameter to
+ *     H5Pset_fapl_hdfs() and H5Pget_fapl_hdfs().
+ *
+ *
+ *
+ * `version` (int32_t)
+ *
+ *     Version number of the `H5FD_hdfs_fapl_t` structure.  Any instance passed
+ *     to the above calls must have a recognized version number, or an error
+ *     will be flagged.
+ *
+ *     This field should be set to `H5FD__CURR_HDFS_FAPL_T_VERSION`.
+ *
+ * `namenode_name` (const char[])
+ *
+ *     Name of "Name Node" to access as the HDFS server.
+ *
+ *     Must not be longer than `H5FD__HDFS_NODE_NAME_SPACE`.
+ *
+ *     TBD: Can be NULL.
+ *
+ * `namenode_port` (int32_t) TBD
+ *
+ *     Port number to use to connect with Name Node.
+ *
+ *     TBD: If 0, uses a default port.
+ *
+ * `kerberos_ticket_cache` (const char[])
+ *
+ *     Path to the location of the Kerberos authentication cache.
+ *
+ *     Must not be longer than `H5FD__HDFS_KERB_CACHE_PATH_SPACE`.
+ *
+ *     TBD: Can be NULL.
+ *
+ * `user_name` (const char[])
+ *
+ *     Username to use when accessing file.
+ *
+ *     Must not be longer than `H5FD__HDFS_USER_NAME_SPACE`.
+ *
+ *     TBD: Can be NULL.
+ *
+ * `stream_buffer_size` (int32_t)
+ *
+ *     Size (in bytes) of the file read stream buffer.
+ *
+ *     TBD: If -1, relies on a default value.
+ *
+ ****************************************************************************/
+
+#define H5FD__CURR_HDFS_FAPL_T_VERSION 1
+
+#define H5FD__HDFS_NODE_NAME_SPACE       128
+#define H5FD__HDFS_USER_NAME_SPACE       128
+#define H5FD__HDFS_KERB_CACHE_PATH_SPACE 128
+
+typedef struct H5FD_hdfs_fapl_t {
+    int32_t version;
+    char    namenode_name[H5FD__HDFS_NODE_NAME_SPACE + 1];
+    int32_t namenode_port;
+    char    user_name[H5FD__HDFS_USER_NAME_SPACE + 1];
+    char    kerberos_ticket_cache[H5FD__HDFS_KERB_CACHE_PATH_SPACE + 1];
+    int32_t stream_buffer_size;
+} H5FD_hdfs_fapl_t;
+
+/** @private
+ *
+ * \brief Private initializer for the hdfs VFD
+ */
+H5_DLL hid_t H5FD_hdfs_init(void);
+
+/**
+ * \ingroup FAPL
+ *
+ * \todo Add missing documentation
+ */
+H5_DLL herr_t H5Pget_fapl_hdfs(hid_t fapl_id, H5FD_hdfs_fapl_t *fa_out);
+
+/**
+ * \ingroup FAPL
+ *
+ * \todo Add missing documentation
+ */
+H5_DLL herr_t H5Pset_fapl_hdfs(hid_t fapl_id, H5FD_hdfs_fapl_t *fa);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* H5_HAVE_LIBHDFS */
+
+#endif /* ifndef H5FDhdfs_H */
diff --git a/install/include/H5FDioc.h b/install/include/H5FDioc.h
new file mode 100644
index 0000000000..bcacd52252
--- /dev/null
+++ b/install/include/H5FDioc.h
@@ -0,0 +1,196 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the "I/O concentrator" driver.
+ * This provides a similar functionality to that of the subfiling driver
+ * but introduces the necessary file access functionality via a multi-
+ * threading MPI service
+ */
+
+#ifndef H5FDioc_H
+#define H5FDioc_H
+
+#include "H5FDsubfiling.h"
+
+#ifdef H5_HAVE_IOC_VFD
+/**
+ * \def H5FD_IOC
+ * Macro that returns the identifier for the #H5FD_IOC driver. \hid_t{file driver}
+ */
+#define H5FD_IOC (H5FDperform_init(H5FD_ioc_init))
+#else
+#define H5FD_IOC (H5I_INVALID_HID)
+#endif
+
+/**
+ * \def H5FD_IOC_NAME
+ * The canonical name for the #H5FD_IOC driver
+ */
+#define H5FD_IOC_NAME "ioc"
+
+#ifdef H5_HAVE_IOC_VFD
+
+#ifndef H5FD_IOC_FAPL_MAGIC
+/**
+ * \def H5FD_IOC_CURR_FAPL_VERSION
+ * The version number of the H5FD_ioc_config_t configuration
+ * structure for the #H5FD_IOC driver
+ */
+#define H5FD_IOC_CURR_FAPL_VERSION 1
+/**
+ * \def H5FD_IOC_FAPL_MAGIC
+ * Unique number used to distinguish the #H5FD_IOC driver from other HDF5 file drivers
+ */
+#define H5FD_IOC_FAPL_MAGIC 0xFED21331
+#endif
+
+/**
+ * \def H5FD_IOC_DEFAULT_THREAD_POOL_SIZE
+ * The default number of I/O concentrator worker threads
+ */
+#define H5FD_IOC_DEFAULT_THREAD_POOL_SIZE 4
+
+/*
+ * Environment variables interpreted by the IOC VFD
+ */
+
+/**
+ * \def H5FD_IOC_THREAD_POOL_SIZE
+ * Macro for name of the environment variable that controls/overrides
+ * the number of I/O concentrator worker threads
+ *
+ * The value set for this environment variable is interpreted as an
+ * int value and must be > 0.
+ */
+#define H5FD_IOC_THREAD_POOL_SIZE "H5FD_IOC_THREAD_POOL_SIZE"
+
+//! <!-- [H5FD_ioc_config_t_snip] -->
+/**
+ * \struct H5FD_ioc_config_t
+ * \brief Configuration structure for H5Pset_fapl_ioc() / H5Pget_fapl_ioc()
+ *
+ * \details H5FD_ioc_config_t is a public structure that is used to pass
+ *          configuration data to the #H5FD_IOC driver via a File Access
+ *          Property List. A pointer to an instance of this structure is
+ *          a parameter to H5Pset_fapl_ioc() and H5Pget_fapl_ioc().
+ *
+ * \var uint32_t H5FD_ioc_config_t::magic
+ *      A somewhat unique number which distinguishes the #H5FD_IOC driver
+ *      from other drivers. Used in combination with a version number, it
+ *      can help to validate a user-generated File Access Property List.
+ *      This field should be set to #H5FD_IOC_FAPL_MAGIC.
+ *
+ * \var uint32_t H5FD_ioc_config_t::version
+ *      Version number of the H5FD_ioc_config_t structure. Any instance passed
+ *      to H5Pset_fapl_ioc() / H5Pget_fapl_ioc() must have a recognized version
+ *      number or an error will be raised. Currently, this field should be set
+ *      to #H5FD_IOC_CURR_FAPL_VERSION.
+ *
+ * \var int32_t H5FD_ioc_config_t::thread_pool_size
+ *      The number of I/O concentrator worker threads to use.
+ *
+ *      This value can also be set or adjusted with the #H5FD_IOC_THREAD_POOL_SIZE
+ *      environment variable.
+ *
+ */
+typedef struct H5FD_ioc_config_t {
+    uint32_t magic;            /* Must be set to H5FD_IOC_FAPL_MAGIC */
+    uint32_t version;          /* Must be set to H5FD_IOC_CURR_FAPL_VERSION */
+    int32_t  thread_pool_size; /* Number of I/O concentrator worker threads to use */
+} H5FD_ioc_config_t;
+//! <!-- [H5FD_ioc_config_t_snip] -->
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief Internal routine to initialize #H5FD_IOC driver. Not meant to be
+ *        called directly by an HDF5 application
+ */
+H5_DLL hid_t H5FD_ioc_init(void);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Modifies the specified File Access Property List to use the #H5FD_IOC driver
+ *
+ * \fapl_id
+ * \param[in] vfd_config Pointer to #H5FD_IOC driver configuration structure. May be NULL.
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_ioc() modifies the File Access Property List to use the
+ *          #H5FD_IOC driver.
+ *
+ *          The #H5FD_IOC driver is a reference implementation of an "I/O concentrator"
+ *          file driver that works in conjunction with the #H5FD_SUBFILING driver and
+ *          provides the I/O backend for servicing I/O requests to subfiles.
+ *
+ *          Typically, an HDF5 application won't need to call this routine directly.
+ *          The #H5FD_IOC driver is usually set up as a side effect of an HDF5 application
+ *          using the #H5FD_SUBFILING driver, but this routine is provided in case the
+ *          application wishes to manually configure the #H5FD_IOC driver.
+ *
+ * \note The \p vfd_config parameter may be NULL. In this case, the driver will
+ *       be setup with default settings. Note that in this case, it is assumed
+ *       the parent #H5FD_SUBFILING driver was also setup with default settings.
+ *       If the two drivers differ in configuration settings, application behavior
+ *       may not be as expected.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5Pset_fapl_ioc(hid_t fapl_id, H5FD_ioc_config_t *vfd_config);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Queries a File Access Property List for #H5FD_IOC file driver properties
+ *
+ * \fapl_id
+ * \param[out] config_out Pointer to H5FD_ioc_config_t structure through which the
+ *                        #H5FD_IOC file driver properties will be returned.
+ *
+ * \returns \herr_t
+ *
+ * \details H5Pget_fapl_ioc() queries the specified File Access Property List for
+ *          #H5FD_IOC driver properties as set by H5Pset_fapl_ioc(). If the #H5FD_IOC
+ *          driver has not been set on the File Access Property List, a default
+ *          configuration is returned. An HDF5 application may use this functionality
+ *          to manually configure the #H5FD_IOC driver by calling H5Pget_fapl_ioc()
+ *          on a newly-created File Access Property List, adjusting the default
+ *          values and then calling H5Pset_fapl_ioc() with the configured
+ *          H5FD_ioc_config_t structure.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5Pget_fapl_ioc(hid_t fapl_id, H5FD_ioc_config_t *config_out);
+/**
+ * \brief Internal routine for managing exclusive access to critical sections
+ *        by the #H5FD_IOC driver's worker threads. Not meant to be called
+ *        directly by an HDF5 application
+ */
+H5_DLL void H5FD_ioc_begin_thread_exclusive(void);
+/**
+ * \brief Internal routine for managing exclusive access to critical sections
+ *        by the #H5FD_IOC driver's worker threads. Not meant to be called
+ *        directly by an HDF5 application
+ */
+H5_DLL void H5FD_ioc_end_thread_exclusive(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5_HAVE_IOC_VFD */
+
+#endif
diff --git a/install/include/H5FDlog.h b/install/include/H5FDlog.h
new file mode 100644
index 0000000000..b4af2050a6
--- /dev/null
+++ b/install/include/H5FDlog.h
@@ -0,0 +1,482 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the log virtual file driver (VFD)
+ */
+#ifndef H5FDlog_H
+#define H5FDlog_H
+
+/** Initializer for the log VFD */
+#define H5FD_LOG (H5FDperform_init(H5FD_log_init))
+
+/** Identifier for the log VFD */
+#define H5FD_LOG_VALUE H5_VFD_LOG
+
+/* Flags for H5Pset_fapl_log() */
+/* Flags for tracking 'meta' operations (truncate) */
+#define H5FD_LOG_TRUNCATE 0x00000001
+#define H5FD_LOG_META_IO  (H5FD_LOG_TRUNCATE)
+/* Flags for tracking where reads/writes/seeks occur */
+#define H5FD_LOG_LOC_READ  0x00000002
+#define H5FD_LOG_LOC_WRITE 0x00000004
+#define H5FD_LOG_LOC_SEEK  0x00000008
+#define H5FD_LOG_LOC_IO    (H5FD_LOG_LOC_READ | H5FD_LOG_LOC_WRITE | H5FD_LOG_LOC_SEEK)
+/* Flags for tracking number of times each byte is read/written */
+#define H5FD_LOG_FILE_READ  0x00000010
+#define H5FD_LOG_FILE_WRITE 0x00000020
+#define H5FD_LOG_FILE_IO    (H5FD_LOG_FILE_READ | H5FD_LOG_FILE_WRITE)
+/* Flag for tracking "flavor" (type) of information stored at each byte */
+#define H5FD_LOG_FLAVOR 0x00000040
+/* Flags for tracking total number of reads/writes/seeks/truncates */
+#define H5FD_LOG_NUM_READ     0x00000080
+#define H5FD_LOG_NUM_WRITE    0x00000100
+#define H5FD_LOG_NUM_SEEK     0x00000200
+#define H5FD_LOG_NUM_TRUNCATE 0x00000400
+#define H5FD_LOG_NUM_IO       (H5FD_LOG_NUM_READ | H5FD_LOG_NUM_WRITE | H5FD_LOG_NUM_SEEK | H5FD_LOG_NUM_TRUNCATE)
+/* Flags for tracking time spent in open/stat/read/write/seek/truncate/close */
+#define H5FD_LOG_TIME_OPEN     0x00000800
+#define H5FD_LOG_TIME_STAT     0x00001000
+#define H5FD_LOG_TIME_READ     0x00002000
+#define H5FD_LOG_TIME_WRITE    0x00004000
+#define H5FD_LOG_TIME_SEEK     0x00008000
+#define H5FD_LOG_TIME_TRUNCATE 0x00010000
+#define H5FD_LOG_TIME_CLOSE    0x00020000
+#define H5FD_LOG_TIME_IO                                                                                     \
+    (H5FD_LOG_TIME_OPEN | H5FD_LOG_TIME_STAT | H5FD_LOG_TIME_READ | H5FD_LOG_TIME_WRITE |                    \
+     H5FD_LOG_TIME_SEEK | H5FD_LOG_TIME_TRUNCATE | H5FD_LOG_TIME_CLOSE)
+/* Flags for tracking allocation/release of space in file */
+#define H5FD_LOG_ALLOC 0x00040000
+#define H5FD_LOG_FREE  0x00080000
+#define H5FD_LOG_ALL                                                                                         \
+    (H5FD_LOG_FREE | H5FD_LOG_ALLOC | H5FD_LOG_TIME_IO | H5FD_LOG_NUM_IO | H5FD_LOG_FLAVOR |                 \
+     H5FD_LOG_FILE_IO | H5FD_LOG_LOC_IO | H5FD_LOG_META_IO)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @private
+ *
+ * \brief Private initializer for the log VFD
+ */
+H5_DLL hid_t H5FD_log_init(void);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets up the logging virtual file driver (#H5FD_LOG) for use
+ *
+ * \fapl_id
+ * \param[in] logfile Name of the log file
+ * \param[in] flags Flags specifying the types of logging activity
+ * \param[in] buf_size The size of the logging buffers, in bytes (see description)
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_log() modifies the file access property list to use the
+ *          logging driver, #H5FD_LOG. The logging virtual file driver (VFD) is
+ *          a clone of the standard SEC2 (#H5FD_SEC2) driver with additional
+ *          facilities for logging VFD metrics and activity to a file.
+ *
+ *          \p logfile is the name of the file in which the logging entries are
+ *          to be recorded.
+ *
+ *          The actions to be logged are specified in the parameter \p flags
+ *          using the pre-defined constants described in the following
+ *          table. Multiple flags can be set through the use of a logical \c OR
+ *          contained in parentheses. For example, logging read and write
+ *          locations would be specified as
+ *          \Code{(H5FD_LOG_LOC_READ|H5FD_LOG_LOC_WRITE)}.
+ *
+ * <table>
+ * <caption>Table1: Logging Flags</caption>
+ * <tr>
+ * <td>
+ * #H5FD_LOG_LOC_READ
+ * </td>
+ * <td rowspan="3">
+ * Track the location and length of every read, write, or seek operation.
+ * </td>
+ * </tr>
+ * <tr><td>#H5FD_LOG_LOC_WRITE</td></tr>
+ * <tr><td>#H5FD_LOG_LOC_SEEK</td></tr>
+ * <tr>
+ * <td>
+ * #H5FD_LOG_LOC_IO
+ * </td>
+ * <td>
+ * Track all I/O locations and lengths. The logical equivalent of the following:
+ * \Code{(#H5FD_LOG_LOC_READ | #H5FD_LOG_LOC_WRITE | #H5FD_LOG_LOC_SEEK)}
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>
+ * #H5FD_LOG_FILE_READ
+ * </td>
+ * <td rowspan="2">
+ * Track the number of times each byte is read or written.
+ * </td>
+ * </tr>
+ * <tr><td>#H5FD_LOG_FILE_WRITE</td></tr>
+ * <tr>
+ * <td>
+ * #H5FD_LOG_FILE_IO
+ * </td>
+ * <td>
+ * Track the number of times each byte is read and written. The logical
+ * equivalent of the following:
+ * \Code{(#H5FD_LOG_FILE_READ | #H5FD_LOG_FILE_WRITE)}
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>
+ * #H5FD_LOG_FLAVOR
+ * </td>
+ * <td>
+ * Track the type, or flavor, of information stored at each byte.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>
+ * #H5FD_LOG_NUM_READ
+ * </td>
+ * <td rowspan="4">
+ * Track the total number of read, write, seek, or truncate operations that occur.
+ * </td>
+ * </tr>
+ * <tr><td>#H5FD_LOG_NUM_WRITE</td></tr>
+ * <tr><td>#H5FD_LOG_NUM_SEEK</td></tr>
+ * <tr><td>#H5FD_LOG_NUM_TRUNCATE</td></tr>
+ * <tr>
+ * <td>
+ * #H5FD_LOG_NUM_IO
+ * </td>
+ * <td>
+ * Track the total number of all types of I/O operations. The logical equivalent
+ * of the following:
+ * \Code{(#H5FD_LOG_NUM_READ | #H5FD_LOG_NUM_WRITE | #H5FD_LOG_NUM_SEEK | #H5FD_LOG_NUM_TRUNCATE)}
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>
+ * #H5FD_LOG_TIME_OPEN
+ * </td>
+ * <td rowspan="6">
+ * Track the time spent in open, stat, read, write, seek, or close operations.
+ * </td>
+ * </tr>
+ * <tr><td>#H5FD_LOG_TIME_STAT</td></tr>
+ * <tr><td>#H5FD_LOG_TIME_READ</td></tr>
+ * <tr><td>#H5FD_LOG_TIME_WRITE</td></tr>
+ * <tr><td>#H5FD_LOG_TIME_SEEK</td></tr>
+ * <tr><td>#H5FD_LOG_TIME_CLOSE</td></tr>
+ * <tr>
+ * <td>
+ * #H5FD_LOG_TIME_IO
+ * </td>
+ * <td>
+ * Track the time spent in each of the above operations. The logical equivalent
+ * of the following:
+ * \Code{(#H5FD_LOG_TIME_OPEN | #H5FD_LOG_TIME_STAT | #H5FD_LOG_TIME_READ | #H5FD_LOG_TIME_WRITE |
+ *        #H5FD_LOG_TIME_SEEK | #H5FD_LOG_TIME_CLOSE)}
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>
+ * #H5FD_LOG_ALLOC
+ * </td>
+ * <td>
+ * Track the allocation of space in the file.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>
+ * #H5FD_LOG_ALL
+ * </td>
+ * <td>
+ * Track everything. The logical equivalent of the following:
+ * \Code{(#H5FD_LOG_ALLOC | #H5FD_LOG_TIME_IO | #H5FD_LOG_NUM_IO | #H5FD_LOG_FLAVOR | #H5FD_LOG_FILE_IO |
+ *        #H5FD_LOG_LOC_IO)}
+ * </td>
+ * </tr>
+ * </table>
+ * The logging driver can track the number of times each byte in the file is
+ * read from or written to (using #H5FD_LOG_FILE_READ and #H5FD_LOG_FILE_WRITE)
+ * and what kind of data is at that location (e.g., metadata, raw data; using
+ * #H5FD_LOG_FLAVOR). This information is tracked in internal buffers of size
+ * buf_size, which must be at least the maximum size in bytes of the file to be
+ * logged while the log driver is in use.\n
+ * One buffer of size buf_size will be created for each of #H5FD_LOG_FILE_READ,
+ * #H5FD_LOG_FILE_WRITE and #H5FD_LOG_FLAVOR when those flags are set; these
+ * buffers will not grow as the file increases in size.
+ *
+ * \par Output:
+ * This section describes the logging driver (LOG VFD) output.\n
+ * The table, immediately below, describes output of the various logging driver
+ * flags and function calls. A list of valid flavor values, describing the type
+ * of data stored, follows the table.
+ * <table>
+ * <caption>Table2: Logging Output</caption>
+ * <tr>
+ * <th>Flag</th><th>VFD Call</th><th>Output and Comments</th>
+ * </th>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_LOC_READ</td>
+ * <td>Read</td>
+ * <td>
+ * \Code{%10a-%10a (%10Zu bytes) (%s) Read}\n\n
+ * Start position\n
+ * End position\n
+ * Number of bytes\n
+ * Flavor of read\n\n
+ * Adds \Code{(\%f s)} and seek time if #H5FD_LOG_TIME_SEEK is also set.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_LOC_READ</td>
+ * <td>Read Error</td>
+ * <td>
+ * \Code{Error! Reading: %10a-%10a (%10Zu bytes)}\n\n
+ * Same parameters as non-error entry.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_LOC_WRITE</td>
+ * <td>Write</td>
+ * <td>
+ * \Code{%10a-%10a (%10Zu bytes) (%s) Written}\n\n
+ * Start position\n
+ * End position\n
+ * Number of bytes\n
+ * Flavor of write\n\n
+ * Adds \Code{(\%f s)} and seek time if #H5FD_LOG_TIME_SEEK is also set.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_LOC_WRITE</td>
+ * <td>Write Error</td>
+ * <td>
+ * \Code{Error! Writing: %10a-%10a (%10Zu bytes)}\n\n
+ * Same parameters as non-error entry.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_LOC_SEEK</td>
+ * <td>Read, Write</td>
+ * <td>
+ * \Code{Seek: From %10a-%10a}\n\n
+ * Start position\n
+ * End position\n\n
+ * Adds \Code{(\%f s)} and seek time if #H5FD_LOG_TIME_SEEK is also set.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_FILE_READ</td>
+ * <td>Close</td>
+ * <td>
+ * Begins with:\n
+ * Dumping read I/O information\n\n
+ * Then, for each range of identical values, there is this line:\n
+ * \Code{Addr %10-%10 (%10lu bytes) read from %3d times}\n\n
+ * Start address\n
+ * End address\n
+ * Number of bytes\n
+ * Number of times read\n\n
+ * Note: The data buffer is scanned and each range of identical values
+ * gets one entry in the log file to save space and make it easier to read.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_FILE_WRITE</td>
+ * <td>Close</td>
+ * <td>
+ * Begins with:\n
+ * Dumping read I/O information\n\n
+ * Then, for each range of identical values, there is this line:\n
+ * \Code{Addr %10-%10 (%10lu bytes) written to %3d times}\n\n
+ * Start address\n
+ * End address\n
+ * Number of bytes\n
+ * Number of times written\n\n
+ * Note: The data buffer is scanned and each range of identical values
+ * gets one entry in the log file to save space and make it easier to read.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_FLAVOR</td>
+ * <td>Close</td>
+ * <td>
+ * Begins with:\n
+ * Dumping I/O flavor information\n\n
+ * Then, for each range of identical values, there is this line:\n
+ * \Code{Addr %10-%10 (%10lu bytes) flavor is %s}\n\n
+ * Start address\n
+ * End address\n
+ * Number of bytes\n
+ * Flavor\n\n
+ * Note: The data buffer is scanned and each range of identical values
+ * gets one entry in the log file to save space and make it easier to read.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_NUM_READ</td>
+ * <td>Close</td>
+ * <td>
+ * Total number of read operations: \Code{%11u}
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_NUM_WRITE</td>
+ * <td>Close</td>
+ * <td>
+ * Total number of write operations: \Code{%11u}
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_NUM_SEEK</td>
+ * <td>Close</td>
+ * <td>
+ * Total number of seek operations: \Code{%11u}
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_NUM_TRUNCATE</td>
+ * <td>Close</td>
+ * <td>
+ * Total number of truncate operations: \Code{%11u}
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_TIME_OPEN</td>
+ * <td>Open</td>
+ * <td>
+ * Open took: \Code{(\%f s)}
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_TIME_READ</td>
+ * <td>Close, Read</td>
+ * <td>
+ * Total time in read operations: \Code{\%f s}\n\n
+ * See also: #H5FD_LOG_LOC_READ
+ * </td>
+ * </tr>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_TIME_WRITE</td>
+ * <td>Close, Write</td>
+ * <td>
+ * Total time in write operations: \Code{\%f s}\n\n
+ * See also: #H5FD_LOG_LOC_WRITE
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_TIME_SEEK</td>
+ * <td>Close, Read, Write</td>
+ * <td>
+ * Total time in write operations: \Code{\%f s}\n\n
+ * See also: #H5FD_LOG_LOC_SEEK or #H5FD_LOG_LOC_WRITE
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_TIME_CLOSE</td>
+ * <td>Close</td>
+ * <td>
+ * Close took: \Code{(\%f s)}
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_TIME_STAT</td>
+ * <td>Open</td>
+ * <td>
+ * Stat took: \Code{(\%f s)}
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_LOG_ALLOC</td>
+ * <td>Alloc</td>
+ * <td>
+ * \Code{%10-%10 (%10Hu bytes) (\%s) Allocated}\n\n
+ * Start of address space\n
+ * End of address space\n
+ * Total size allocation\n
+ * Flavor of allocation
+ * </td>
+ * </tr>
+ * </table>
+ *
+ * \par Flavors:
+ * The \Emph{flavor} describes the type of stored information. The following
+ * table lists the flavors that appear in log output and briefly describes each.
+ * These terms are provided here to aid in the construction of log message
+ * parsers; a full description is beyond the scope of this document.
+ * <table>
+ * <caption>Table3: Flavors of logged data</caption>
+ * <tr>
+ * <th>Flavor</th><th>Description</th>
+ * </th>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_MEM_NOLIST</td>
+ * <td>Error value</td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_MEM_DEFAULT</td>
+ * <td>Value not yet set.\n
+ *     May also be a datatype set in a larger allocation that will be
+ *     suballocated by the library.</td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_MEM_SUPER</td>
+ * <td>Superblock data</td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_MEM_BTREE</td>
+ * <td>B-tree data</td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_MEM_DRAW</td>
+ * <td>Raw data (for example, contents of a dataset)</td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_MEM_GHEAP</td>
+ * <td>Global heap data</td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_MEM_LHEAP</td>
+ * <td>Local heap data</td>
+ * </tr>
+ * <tr>
+ * <td>#H5FD_MEM_OHDR</td>
+ * <td>Object header data</td>
+ * </tr>
+ * </table>
+ *
+ * \version 1.8.7 The flags parameter has been changed from \Code{unsigned int}
+ *          to \Code{unsigned long long}.
+ *          The implementation of the #H5FD_LOG_TIME_OPEN, #H5FD_LOG_TIME_READ,
+ *          #H5FD_LOG_TIME_WRITE, and #H5FD_LOG_TIME_SEEK flags has been finished.
+ *          New flags were added: #H5FD_LOG_NUM_TRUNCATE and #H5FD_LOG_TIME_STAT.
+ * \version 1.6.0 The \c verbosity parameter has been removed.
+ *          Two new parameters have been added: \p flags of type \Code{unsigned} and
+ *          \p buf_size of type \Code{size_t}.
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pset_fapl_log(hid_t fapl_id, const char *logfile, unsigned long long flags, size_t buf_size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5FDmirror.h b/install/include/H5FDmirror.h
new file mode 100644
index 0000000000..6c98e1a8a6
--- /dev/null
+++ b/install/include/H5FDmirror.h
@@ -0,0 +1,98 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the mirror virtual file driver (VFD)
+ */
+
+#ifndef H5FDmirror_H
+#define H5FDmirror_H
+
+#ifdef H5_HAVE_MIRROR_VFD
+
+/** Initializer for the mirror VFD */
+#define H5FD_MIRROR (H5FDperform_init(H5FD_mirror_init))
+
+/** Identifier for the mirror VFD */
+#define H5FD_MIRROR_VALUE H5_VFD_MIRROR
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ============================================================================
+ * Mirror VFD use and operation.
+ * ============================================================================
+ */
+
+/* ---------------------------------------------------------------------------
+ * Structure:   H5FD_mirror_fapl_t
+ *
+ * Used to pass configuration information to the Mirror VFD.
+ * Populate components as appropriate and pass structure pointer to
+ * `H5Pset_fapl_mirror()`.
+ *
+ * `magic` (uint32_t)
+ *      Semi-unique number to sanity-check pointers to this structure type.
+ *      MUST equal H5FD_MIRROR_FAPL_MAGIC to be considered valid.
+ *
+ * `version` (uint32_t)
+ *      Indicates expected components of the structure.
+ *
+ * `handshake_port (int)
+ *      Port number to expect to reach the "Mirror Server" on the remote host.
+ *
+ * `remote_ip` (char[])
+ *      IP address string of "Mirror Server" remote host.
+ * ---------------------------------------------------------------------------
+ */
+#define H5FD_MIRROR_FAPL_MAGIC          0xF8DD514C
+#define H5FD_MIRROR_CURR_FAPL_T_VERSION 1
+#define H5FD_MIRROR_MAX_IP_LEN          32
+typedef struct H5FD_mirror_fapl_t {
+    uint32_t magic;
+    uint32_t version;
+    int      handshake_port;
+    char     remote_ip[H5FD_MIRROR_MAX_IP_LEN + 1];
+} H5FD_mirror_fapl_t;
+
+/** @private
+ *
+ * \brief Private initializer for the mirror VFD
+ */
+H5_DLL hid_t H5FD_mirror_init(void);
+
+/**
+ * \ingroup FAPL
+ *
+ * \todo Add missing documentation
+ */
+H5_DLL herr_t H5Pget_fapl_mirror(hid_t fapl_id, H5FD_mirror_fapl_t *fa_out);
+
+/**
+ * \ingroup FAPL
+ *
+ * \todo Add missing documentation
+ */
+H5_DLL herr_t H5Pset_fapl_mirror(hid_t fapl_id, H5FD_mirror_fapl_t *fa);
+
+#ifdef __cplusplus
+}
+#endif
+
+#else /* H5_HAVE_MIRROR_VFD */
+
+#define H5FD_MIRROR (H5I_INAVLID_HID)
+
+#endif /* H5_HAVE_MIRROR_VFD */
+
+#endif /* H5FDmirror_H */
diff --git a/install/include/H5FDmpi.h b/install/include/H5FDmpi.h
new file mode 100644
index 0000000000..9cee0e69b7
--- /dev/null
+++ b/install/include/H5FDmpi.h
@@ -0,0 +1,57 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for common items for all MPI VFL drivers
+ */
+#ifndef H5FDmpi_H
+#define H5FDmpi_H
+
+/***** Macros for One linked collective IO case. *****/
+/* The default value to do one linked collective IO for all chunks.
+   If the average number of chunks per process is greater than this value,
+      the library will create an MPI derived datatype to link all chunks to do collective IO.
+      The user can set this value through an API. */
+
+#define H5D_ONE_LINK_CHUNK_IO_THRESHOLD 0
+/***** Macros for multi-chunk collective IO case. *****/
+/* The default value of the threshold to do collective IO for this chunk.
+   If the average percentage of processes per chunk is greater than the default value,
+   collective IO is done for this chunk.
+*/
+
+#define H5D_MULTI_CHUNK_IO_COL_THRESHOLD 60
+/**
+ * Type of I/O for data transfer properties
+ */
+typedef enum H5FD_mpio_xfer_t {
+    H5FD_MPIO_INDEPENDENT = 0, /**< Use independent I/O access */
+    H5FD_MPIO_COLLECTIVE       /**< Use collective I/O access */
+} H5FD_mpio_xfer_t;
+
+/* Type of chunked dataset I/O */
+typedef enum H5FD_mpio_chunk_opt_t {
+    H5FD_MPIO_CHUNK_DEFAULT = 0,
+    H5FD_MPIO_CHUNK_ONE_IO, /*zero is the default*/
+    H5FD_MPIO_CHUNK_MULTI_IO
+} H5FD_mpio_chunk_opt_t;
+
+/* Type of collective I/O */
+typedef enum H5FD_mpio_collective_opt_t {
+    H5FD_MPIO_COLLECTIVE_IO = 0,
+    H5FD_MPIO_INDIVIDUAL_IO /*zero is the default*/
+} H5FD_mpio_collective_opt_t;
+
+/* Include all the MPI VFL headers */
+#include "H5FDmpio.h" /* MPI I/O file driver			*/
+
+#endif /* H5FDmpi_H */
diff --git a/install/include/H5FDmpio.h b/install/include/H5FDmpio.h
new file mode 100644
index 0000000000..5e7ecf3035
--- /dev/null
+++ b/install/include/H5FDmpio.h
@@ -0,0 +1,294 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the MPI-I/O (mpio) virtual file driver (VFD)
+ */
+#ifndef H5FDmpio_H
+#define H5FDmpio_H
+
+#ifdef H5_HAVE_PARALLEL
+
+/** Initializer for the mpio VFD */
+#define H5FD_MPIO (H5FDperform_init(H5FD_mpio_init))
+
+#else
+
+/** Initializer for the mpio VFD (disabled) */
+#define H5FD_MPIO (H5I_INVALID_HID)
+
+#endif
+
+#ifdef H5_HAVE_PARALLEL
+
+#if defined(H5F_DEBUG) && !defined(H5FDmpio_DEBUG)
+/** Turn mpio VFD debugging on (requires H5F_DEBUG) */
+#define H5FDmpio_DEBUG
+#endif
+
+/* Global var whose value comes from environment variable */
+/* (Defined in H5FDmpio.c) */
+H5_DLLVAR hbool_t H5FD_mpi_opt_types_g;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @private
+ *
+ * \brief Private initializer for the mpio VFD
+ */
+H5_DLL hid_t H5FD_mpio_init(void);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Stores MPI IO communicator information to the file access property list
+ *
+ * \fapl_id
+ * \param[in] comm MPI communicator
+ * \param[in] info MPI info object
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_mpio() stores the user-supplied MPI IO parameters \p
+ *          comm, for communicator, and \p info, for information, in the file
+ *          access property list \p fapl_id. That property list can then be used
+ *          to create and/or open a file.
+ *
+ *          H5Pset_fapl_mpio() is available only in the parallel HDF5 library
+ *          and is not a collective function.
+ *
+ *          \p comm is the MPI communicator to be used for file open, as defined
+ *          in \c MPI_File_open of MPI. This function makes a duplicate of the
+ *          communicator, so modifications to \p comm after this function call
+ *          returns have no effect on the file access property list.
+ *
+ *          \p info is the MPI Info object to be used for file open, as defined
+ *          in MPI_File_open() of MPI. This function makes a duplicate copy of
+ *          the Info object, so modifications to the Info object after this
+ *          function call returns will have no effect on the file access
+ *          property list.
+ *
+ *          If the file access property list already contains previously-set
+ *          communicator and Info values, those values will be replaced and the
+ *          old communicator and Info object will be freed.
+ *
+ * \note Raw dataset chunk caching is not currently supported when using this
+ *       file driver in read/write mode. All calls to H5Dread() and H5Dwrite()
+ *       will access the disk directly, and H5Pset_cache() and
+ *       H5Pset_chunk_cache() will have no effect on performance.\n
+ *       Raw dataset chunk caching is supported when this driver is used in
+ *       read-only mode.
+ *
+ * \version 1.4.5 Handling of the MPI Communicator and Info object changed at
+ *          this release. A duplicate of each of these is now stored in the property
+ *          list instead of pointers to each.
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pset_fapl_mpio(hid_t fapl_id, MPI_Comm comm, MPI_Info info);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Returns MPI IO communicator information
+ *
+ * \fapl_id
+ * \param[out] comm MPI communicator
+ * \param[out] info MPI info object
+ * \returns \herr_t
+ *
+ * \details If the file access property list is set to the #H5FD_MPIO driver,
+ *          H5Pget_fapl_mpio() returns duplicates of the stored MPI communicator
+ *          and Info object through the \p comm and \p info pointers, if those
+ *          values are non-null.
+ *
+ *          Since the MPI communicator and Info object are duplicates of the
+ *          stored information, future modifications to the access property list
+ *          will not affect them. It is the responsibility of the application to
+ *          free these objects.
+ *
+ * \version 1.4.5 Handling of the MPI Communicator and Info object changed at
+ *          this release. A duplicate of each of these is now stored in the
+ *          property list instead of pointers to each.
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pget_fapl_mpio(hid_t fapl_id, MPI_Comm *comm /*out*/, MPI_Info *info /*out*/);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Sets data transfer mode
+ *
+ * \dxpl_id
+ * \param[in] xfer_mode Transfer mode
+ * \returns \herr_t
+ *
+ * \details H5Pset_dxpl_mpio() sets the data transfer property list \p dxpl_id
+ *          to use transfer mode \p xfer_mode. The property list can then be
+ *          used to control the I/O transfer mode during data I/O operations.
+ *
+ *          Valid transfer modes are #H5FD_MPIO_INDEPENDENT (default) and
+ *          #H5FD_MPIO_COLLECTIVE.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pset_dxpl_mpio(hid_t dxpl_id, H5FD_mpio_xfer_t xfer_mode);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Returns the data transfer mode
+ *
+ * \dxpl_id
+ * \param[out] xfer_mode Transfer mode
+ * \returns \herr_t
+ *
+ * \details H5Pget_dxpl_mpio() queries the data transfer mode currently set in
+ *          the data transfer property list \p dxpl_id.
+ *
+ *          Upon return, \p xfer_mode contains the data transfer mode, if it is
+ *          non-null.
+ *
+ *          H5Pget_dxpl_mpio() is not a collective function.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pget_dxpl_mpio(hid_t dxpl_id, H5FD_mpio_xfer_t *xfer_mode /*out*/);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Sets low-level data transfer mode
+ *
+ * \dxpl_id
+ * \param[in] opt_mode Transfer mode
+ * \returns \herr_t
+ *
+ * \details H5Pset_dxpl_mpio_collective_opt() sets the data transfer property
+ *          list \p dxpl_id to use transfer mode \p opt_mode when performing
+ *          I/O. This allows the application to specify collective I/O at the
+ *          HDF5 interface level (with the H5Pset_dxpl_mpio() API routine),
+ *          while controlling whether the actual I/O is performed collectively
+ *          (e.g., via MPI_File_write_at_all) or independently (e.g., via
+ *          MPI_File_write_at). If the collectivity setting at the HDF5
+ *          interface level (set via H5Pset_dxpl_mpio()) is not set to
+ *          H5FD_MPIO_COLLECTIVE, this setting will be ignored.
+ *
+ *          Valid transfer modes are #H5FD_MPIO_COLLECTIVE_IO (default) and
+ *          #H5FD_MPIO_INDIVIDUAL_IO.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pset_dxpl_mpio_collective_opt(hid_t dxpl_id, H5FD_mpio_collective_opt_t opt_mode);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Sets a flag specifying linked-chunk I/O or multi-chunk I/O
+ *
+ * \dxpl_id
+ * \param[in] opt_mode Transfer mode
+ * \returns \herr_t
+ *
+ * \details H5Pset_dxpl_mpio_chunk_opt() specifies whether I/O is to be
+ *          performed as linked-chunk I/O or as multi-chunk I/O. This function
+ *          overrides the HDF5 library's internal algorithm for determining
+ *          which mechanism to use.
+ *
+ *          When an application uses collective I/O with chunked storage, the
+ *          HDF5 library normally uses an internal algorithm to determine
+ *          whether that I/O activity should be conducted as one linked-chunk
+ *          I/O or as multi-chunk I/O. H5Pset_dxpl_mpio_chunk_opt() is provided
+ *          so that an application can override the library's algorithm in
+ *          circumstances where the library might lack the information needed to
+ *          make an optimal decision.
+ *
+ *          H5Pset_dxpl_mpio_chunk_opt() works by setting one of the following
+ *          flags in the parameter \p opt_mode:
+ *          - #H5FD_MPIO_CHUNK_ONE_IO -	Do one-link chunked I/O
+ *          - #H5FD_MPIO_CHUNK_MULTI_IO - Do multi-chunked I/O
+ *
+ *          This function works by setting a corresponding property in the
+ *          dataset transfer property list \p dxpl_id.
+ *
+ *          The library performs I/O in the specified manner unless it
+ *          determines that the low-level MPI IO package does not support the
+ *          requested behavior; in such cases, the HDF5 library will internally
+ *          use independent I/O.
+ *
+ *          Use of this function is optional.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_dxpl_mpio_chunk_opt(hid_t dxpl_id, H5FD_mpio_chunk_opt_t opt_mode);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Sets a numeric threshold for linked-chunk I/O
+ *
+ * \dxpl_id
+ * \param[in] num_chunk_per_proc
+ * \returns \herr_t
+ *
+ * \details H5Pset_dxpl_mpio_chunk_opt_num() sets a numeric threshold for the
+ *          use of linked-chunk I/O.
+ *
+ *          The library will calculate the average number of chunks selected by
+ *          each process when doing collective access with chunked storage. If
+ *          the number is greater than the threshold set in \p
+ *          num_chunk_per_proc, the library will use linked-chunk I/O;
+ *          otherwise, a separate I/O process will be invoked for each chunk
+ *          (multi-chunk I/O).
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_dxpl_mpio_chunk_opt_num(hid_t dxpl_id, unsigned num_chunk_per_proc);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Sets a ratio threshold for collective I/O
+ *
+ * \dxpl_id
+ * \param[in] percent_num_proc_per_chunk
+ * \returns \herr_t
+ *
+ * \details H5Pset_dxpl_mpio_chunk_opt_ratio() sets a threshold for the use of
+ *          collective I/O based on the ratio of processes with collective
+ *          access to a dataset with chunked storage. The decision whether to
+ *          use collective I/O is made on a per-chunk basis.
+ *
+ *          The library will calculate the percentage of the total number of
+ *          processes, the ratio, that hold selections in each chunk. If that
+ *          percentage is greater than the threshold set in \p
+ *          percent_proc_per_chunk, the library will do collective I/O for this
+ *          chunk; otherwise, independent I/O will be done for the chunk.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_dxpl_mpio_chunk_opt_ratio(hid_t dxpl_id, unsigned percent_num_proc_per_chunk);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5_HAVE_PARALLEL */
+
+#endif
diff --git a/install/include/H5FDmulti.h b/install/include/H5FDmulti.h
new file mode 100644
index 0000000000..d89a3e27cc
--- /dev/null
+++ b/install/include/H5FDmulti.h
@@ -0,0 +1,258 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the multi virtual file driver (VFD)
+ */
+#ifndef H5FDmulti_H
+#define H5FDmulti_H
+
+/** Initializer for the multi VFD */
+#define H5FD_MULTI (H5FDperform_init(H5FD_multi_init))
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @private
+ *
+ * \brief Private initializer for the multi VFD
+ */
+H5_DLL hid_t H5FD_multi_init(void);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets up use of the multi-file driver
+ *
+ * \fapl_id
+ * \param[in] memb_map Maps memory usage types to other memory usage types
+ * \param[in] memb_fapl Property list for each memory usage type
+ * \param[in] memb_name Name generator for names of member files
+ * \param[in] memb_addr The offsets within the virtual address space, from 0
+ *           (zero) to #HADDR_MAX, at which each type of data storage begins
+ * \param[in] relax Allows read-only access to incomplete file sets when \c true
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_multi() sets the file access property list \p fapl_id to
+ *          use the multi-file driver.
+ *
+ *          The multi-file driver enables different types of HDF5 data and
+ *          metadata to be written to separate files. These files are viewed by
+ *          the HDF5 library and the application as a single virtual HDF5 file
+ *          with a single HDF5 file address space. The types of data that can be
+ *          broken out into separate files include raw data, the superblock,
+ *          B-tree data, global heap data, local heap data, and object
+ *          headers. At the programmer's discretion, two or more types of data
+ *          can be written to the same file while other types of data are
+ *          written to separate files.
+ *
+ *          The array \p memb_map maps memory usage types to other memory usage
+ *          types and is the mechanism that allows the caller to specify how
+ *          many files are created. The array contains #H5FD_MEM_NTYPES entries,
+ *          which are either the value #H5FD_MEM_DEFAULT or a memory usage
+ *          type. The number of unique values determines the number of files
+ *          that are opened.
+ *
+ *          The array \p memb_fapl contains a property list for each memory
+ *          usage type that will be associated with a file.
+ *
+ *          The array \p memb_name should be a name generator (a
+ *          \Code{printf}-style format with a \Code{%s} which will be replaced
+ *          with the name passed to H5FDopen(), usually from H5Fcreate() or
+ *          H5Fopen()).
+ *
+ *          The array \p memb_addr specifies the offsets within the virtual
+ *          address space, from 0 (zero) to #HADDR_MAX, at which each type of
+ *          data storage begins.
+ *
+ *          If \p relax is set to 1 (true), then opening an existing file for
+ *          read-only access will not fail if some file members are
+ *          missing. This allows a file to be accessed in a limited sense if
+ *          just the meta data is available.
+ *
+ *          Default values for each of the optional arguments are as follows:
+ *          <table>
+ *          <tr>
+ *          <td>\p memb_map</td>
+ *          <td>The default member map contains the value #H5FD_MEM_DEFAULT for each element.</td>
+ *          </tr>
+ *          <tr>
+ *          <td>
+ *          \p memb_fapl
+ *          </td>
+ *          <td>
+ *          The default value is #H5P_DEFAULT for each element.
+ *          </td>
+ *          </tr>
+ *          <tr>
+ *          <td>
+ *          \p memb_name
+ *          </td>
+ *          <td>
+ *          The default string is \Code{%s-X.h5} where \c X is one of the following letters:
+ *          - \c s for #H5FD_MEM_SUPER
+ *          - \c b for #H5FD_MEM_BTREE
+ *          - \c r for #H5FD_MEM_DRAW
+ *          - \c g for #H5FD_MEM_GHEAP
+ *          - \c l for #H5FD_MEM_LHEAP
+ *          - \c o for #H5FD_MEM_OHDR
+ *          </td>
+ *          </tr>
+ *          <tr>
+ *          <td>
+ *          \p memb_addr
+ *          </td>
+ *          <td>
+ *          The default setting is that the address space is equally divided
+ *          among all of the elements:
+ *          - #H5FD_MEM_SUPER \Code{-> 0 * (HADDR_MAX/6)}
+ *          - #H5FD_MEM_BTREE \Code{-> 1 * (HADDR_MAX/6)}
+ *          - #H5FD_MEM_DRAW \Code{-> 2 * (HADDR_MAX/6)}
+ *          - #H5FD_MEM_GHEAP \Code{-> 3 * (HADDR_MAX/6)}
+ *          - #H5FD_MEM_LHEAP \Code{-> 4 * (HADDR_MAX/6)}
+ *          - #H5FD_MEM_OHDR \Code{-> 5 * (HADDR_MAX/6)}
+ *          </td>
+ *          </tr>
+ *          </table>
+ *
+ * \par Example:
+ * The following code sample sets up a multi-file access property list that
+ * partitions data into meta and raw files, each being one-half of the address:\n
+ * \code
+ * H5FD_mem_t mt, memb_map[H5FD_MEM_NTYPES];
+ * hid_t memb_fapl[H5FD_MEM_NTYPES];
+ * const char *memb[H5FD_MEM_NTYPES];
+ * haddr_t memb_addr[H5FD_MEM_NTYPES];
+ *
+ * // The mapping...
+ * for (mt=0; mt<H5FD_MEM_NTYPES; mt++) {
+ *   memb_map[mt] = H5FD_MEM_SUPER;
+ * }
+ * memb_map[H5FD_MEM_DRAW] = H5FD_MEM_DRAW;
+ *
+ * // Member information
+ * memb_fapl[H5FD_MEM_SUPER] = H5P_DEFAULT;
+ * memb_name[H5FD_MEM_SUPER] = "%s.meta";
+ * memb_addr[H5FD_MEM_SUPER] = 0;
+ *
+ * memb_fapl[H5FD_MEM_DRAW] = H5P_DEFAULT;
+ * memb_name[H5FD_MEM_DRAW] = "%s.raw";
+ * memb_addr[H5FD_MEM_DRAW] = HADDR_MAX/2;
+ *
+ * hid_t fapl = H5Pcreate(H5P_FILE_ACCESS);
+ * H5Pset_fapl_multi(fapl, memb_map, memb_fapl,
+ *                   memb_name, memb_addr, true);
+ * \endcode
+ *
+ * \version 1.6.3 \p memb_name parameter type changed to \Code{const char* const*}.
+ * \since 1.4.0
+ */
+H5_DLL herr_t H5Pset_fapl_multi(hid_t fapl_id, const H5FD_mem_t *memb_map, const hid_t *memb_fapl,
+                                const char *const *memb_name, const haddr_t *memb_addr, hbool_t relax);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Returns information about the multi-file access property list
+ *
+ * \fapl_id
+ * \param[out] memb_map Maps memory usage types to other memory usage types
+ * \param[out] memb_fapl Property list for each memory usage type
+ * \param[out] memb_name Name generator for names of member files
+ * \param[out] memb_addr The offsets within the virtual address space, from 0
+ *           (zero) to #HADDR_MAX, at which each type of data storage begins
+ * \param[out] relax Allows read-only access to incomplete file sets when \c true
+ * \returns \herr_t
+ *
+ * \details H5Pget_fapl_multi() returns information about the multi-file access
+ *          property list.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pget_fapl_multi(hid_t fapl_id, H5FD_mem_t *memb_map /*out*/, hid_t *memb_fapl /*out*/,
+                                char **memb_name /*out*/, haddr_t *memb_addr /*out*/, hbool_t *relax /*out*/);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Emulates the old split file driver
+ *
+ * \fapl_id{fapl}
+ * \param[in] meta_ext Metadata filename extension
+ * \param[in] meta_plist_id File access property list identifier for the metadata file
+ * \param[in] raw_ext Raw data filename extension
+ * \param[in] raw_plist_id
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_split() is a compatibility function that enables the
+ *          multi-file driver to emulate the split driver from HDF5 Releases 1.0
+ *          and 1.2. The split file driver stored metadata and raw data in
+ *          separate files but provided no mechanism for separating types of
+ *          metadata.
+ *
+ *          \p fapl is a file access property list identifier.
+ *
+ *          \p meta_ext is the filename extension for the metadata file. The
+ *          extension is appended to the name passed to H5FDopen(), usually from
+ *          H5Fcreate() or H5Fopen(), to form the name of the metadata file. If
+ *          the string \Code{%s} is used in the extension, it works like the
+ *          name generator as in H5Pset_fapl_multi().
+ *
+ *          \p meta_plist_id is the file access property list identifier for the
+ *          metadata file.
+ *
+ *          \p raw_ext is the filename extension for the raw data file. The
+ *          extension is appended to the name passed to H5FDopen(), usually from
+ *          H5Fcreate() or H5Fopen(), to form the name of the raw data file. If
+ *          the string \Code{%s} is used in the extension, it works like the
+ *          name generator as in H5Pset_fapl_multi().
+ *
+ *          \p raw_plist_id is the file access property list identifier for the
+ *          raw data file.
+ *
+ *          If a user wishes to check to see whether this driver is in use, the
+ *          user must call H5Pget_driver() and compare the returned value to the
+ *          string #H5FD_MULTI. A positive match will confirm that the multi
+ *          driver is in use; HDF5 provides no mechanism to determine whether it
+ *          was called as the special case invoked by H5Pset_fapl_split().
+ *
+ * \par Example:
+ * \code
+ * // Example 1: Both metadata and raw data files are in the same
+ * //            directory. Use Station1-m.h5 and Station1-r.h5 as
+ * //            the metadata and raw data files.
+ * hid_t fapl, fid;
+ * fapl = H5Pcreate(H5P_FILE_ACCESS);
+ * H5Pset_fapl_split(fapl, "-m.h5", H5P_DEFAULT, "-r.h5", H5P_DEFAULT);
+ * fid=H5Fcreate("Station1",H5F_ACC_TRUNC,H5P_DEFAULT,fapl);
+ *
+ * // Example 2: metadata and raw data files are in different
+ * //            directories.  Use PointA-m.h5 and /pfs/PointA-r.h5 as
+ * //            the metadata and raw data files.
+ * hid_t fapl, fid;
+ * fapl = H5Pcreate(H5P_FILE_ACCESS);
+ * H5Pset_fapl_split(fapl, "-m.h5", H5P_DEFAULT, "/pfs/%s-r.h5", H5P_DEFAULT);
+ * fid=H5Fcreate("PointA",H5F_ACC_TRUNC,H5P_DEFAULT,fapl);
+ * \endcode
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pset_fapl_split(hid_t fapl, const char *meta_ext, hid_t meta_plist_id, const char *raw_ext,
+                                hid_t raw_plist_id);
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5FDonion.h b/install/include/H5FDonion.h
new file mode 100644
index 0000000000..4aaab6d3c3
--- /dev/null
+++ b/install/include/H5FDonion.h
@@ -0,0 +1,185 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the onion virtual file driver (VFD)
+ */
+#ifndef H5FDonion_H
+#define H5FDonion_H
+
+/** Initializer for the onion VFD */
+#define H5FD_ONION (H5FDperform_init(H5FD_onion_init))
+
+/** Identifier for the onion VFD */
+#define H5FD_ONION_VALUE H5_VFD_ONION
+
+/** Current version of the onion VFD fapl info struct */
+#define H5FD_ONION_FAPL_INFO_VERSION_CURR 1
+
+#define H5FD_ONION_FAPL_INFO_CREATE_FLAG_ENABLE_PAGE_ALIGNMENT                                               \
+    (0x0001u) /**<                                                                                           \
+               * Onion history metadata will align to page_size.                                             \
+               * Partial pages of unused space will occur in the file,                                       \
+               * but may improve read performance from the backing store                                     \
+               * on some systems.                                                                            \
+               * If disabled (0), padding will not be inserted to align                                      \
+               * to page boundaries.                                                                         \
+               */
+
+/**
+ * Max length of a comment.
+ * The buffer is defined to be this size + 1 to handle the NUL.
+ */
+#define H5FD_ONION_FAPL_INFO_COMMENT_MAX_LEN 255
+
+/**
+ * Indicates that you want the latest revision.
+ */
+#define H5FD_ONION_FAPL_INFO_REVISION_ID_LATEST UINT64_MAX
+
+/**
+ * Indicates how the new onion data will be stored.
+ */
+typedef enum H5FD_onion_target_file_constant_t {
+    H5FD_ONION_STORE_TARGET_ONION, /**<
+                                    * Onion history is stored in a single, separate "onion
+                                    * file". Shares filename and path as hdf5 file (if any),
+                                    * with only a different filename extension.
+                                    */
+} H5FD_onion_target_file_constant_t;
+
+/**
+ * Stores fapl information for creating onion VFD files.
+ */
+typedef struct H5FD_onion_fapl_info_t {
+    uint8_t version;                                /**<
+                                                     * Future-proofing identifier. Informs struct membership.
+                                                     * Must equal H5FD_ONION_FAPL_VERSION_CURR to be considered valid.
+                                                     */
+    hid_t backing_fapl_id;                          /**<
+                                                     * Backing or 'child' FAPL ID to handle I/O with the
+                                                     * underlying backing store. It must use the same backing driver as the
+                                                     * original file.
+                                                     */
+    uint32_t page_size;                             /**<
+                                                     * page_size:   Size of the amended data pages. If opening an existing file,
+                                                     *              must equal the existing page size or zero. If creating a new
+                                                     *              file or an initial revision of an existing file, must be a
+                                                     *              power of 2.
+                                                     *
+                                                     */
+    H5FD_onion_target_file_constant_t store_target; /**<
+                                                     * Identifies where the history data is stored.
+                                                     */
+    uint64_t revision_num;                          /**<
+                                                     * Which revision to open. Valid values are 0 (the original file) or the
+                                                     *              revision number of an existing revision.
+                                                     *              H5FD_ONION_FAPL_INFO_REVISION_ID_LATEST refers to the most
+                                                     *              recently-created revision in the history.
+                                                     */
+    uint8_t force_write_open;                       /**<
+                                                     *              Flag to ignore the write-lock flag in the onion data
+                                                     *              and attempt to open the file write-only anyway.
+                                                     *              This may be relevant if, for example, the library crashed
+                                                     *              while the file was open in write mode and the write-lock
+                                                     *              flag was not cleared.
+                                                     *              Must equal H5FD_ONION_FAPL_FLAG_FORCE_OPEN to enable.
+                                                     *
+                                                     */
+    uint8_t creation_flags;                         /**<
+                                                     * Flag used only when instantiating an onion file.
+                                                     * If the relevant bit is set to a nonzero value, its feature
+                                                     * will be enabled.
+                                                     */
+    char comment[H5FD_ONION_FAPL_INFO_COMMENT_MAX_LEN +
+                 1]; /**<
+                      * User-supplied NULL-terminated comment for a revision to be
+                      * written.
+                      * Cannot be longer than H5FD_ONION_FAPL_COMMENT_MAX_LEN.
+                      * Ignored if part of a FAPL used to open in read mode.
+                      */
+} H5FD_onion_fapl_info_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @private
+ *
+ * \brief Private initializer for the onion VFD
+ */
+H5_DLL hid_t H5FD_onion_init(void);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup FAPL
+ *
+ * \brief get the onion info from the file access property list
+ *
+ * \fapl_id
+ * \param[out] fa_out The pointer to the structure H5FD_onion_fapl_info_t
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_fapl_onion() retrieves the structure H5FD_onion_fapl_info_t
+ *          from the file access property list that is set for the onion VFD
+ *          driver.
+ *
+ * \since 1.14.0
+ */
+H5_DLL herr_t H5Pget_fapl_onion(hid_t fapl_id, H5FD_onion_fapl_info_t *fa_out);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup FAPL
+ *
+ * \brief set the onion info for the file access property list
+ *
+ * \fapl_id
+ * \param[in] fa The pointer to the structure H5FD_onion_fapl_info_t
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_fapl_onion() sets the structure H5FD_onion_fapl_info_t
+ *          for the file access property list that is set for the onion VFD
+ *          driver.
+ *
+ * \since 1.14.0
+ */
+H5_DLL herr_t H5Pset_fapl_onion(hid_t fapl_id, const H5FD_onion_fapl_info_t *fa);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5FD
+ *
+ * \brief get the number of revisions
+ *
+ * \param[in] filename The name of the onion file
+ * \param[in] fapl_id The ID of the file access property list
+ * \param[out] revision_count The number of revisions
+ *
+ * \return \herr_t
+ *
+ * \details H5FDonion_get_revision_count() returns the number of revisions
+ *          for an onion file. It takes the file name and file access property
+ *          list that is set for the onion VFD driver.
+ *
+ *
+ * \since 1.14.0
+ */
+H5_DLL herr_t H5FDonion_get_revision_count(const char *filename, hid_t fapl_id, uint64_t *revision_count);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5FDonion_H */
diff --git a/install/include/H5FDpublic.h b/install/include/H5FDpublic.h
new file mode 100644
index 0000000000..d8d77d6534
--- /dev/null
+++ b/install/include/H5FDpublic.h
@@ -0,0 +1,429 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef H5FDpublic_H
+#define H5FDpublic_H
+
+#include "H5public.h"  /* Generic Functions                        */
+#include "H5Fpublic.h" /* Files                                    */
+#include "H5Ipublic.h" /* Identifiers                              */
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+#define H5FD_VFD_DEFAULT 0 /* Default VFL driver value */
+
+/* VFD identifier values
+ * These are H5FD_class_value_t values, NOT hid_t values!
+ */
+#define H5_VFD_INVALID   ((H5FD_class_value_t)(-1))
+#define H5_VFD_SEC2      ((H5FD_class_value_t)(0))
+#define H5_VFD_CORE      ((H5FD_class_value_t)(1))
+#define H5_VFD_LOG       ((H5FD_class_value_t)(2))
+#define H5_VFD_FAMILY    ((H5FD_class_value_t)(3))
+#define H5_VFD_MULTI     ((H5FD_class_value_t)(4))
+#define H5_VFD_STDIO     ((H5FD_class_value_t)(5))
+#define H5_VFD_SPLITTER  ((H5FD_class_value_t)(6))
+#define H5_VFD_MPIO      ((H5FD_class_value_t)(7))
+#define H5_VFD_DIRECT    ((H5FD_class_value_t)(8))
+#define H5_VFD_MIRROR    ((H5FD_class_value_t)(9))
+#define H5_VFD_HDFS      ((H5FD_class_value_t)(10))
+#define H5_VFD_ROS3      ((H5FD_class_value_t)(11))
+#define H5_VFD_SUBFILING ((H5FD_class_value_t)(12))
+#define H5_VFD_IOC       ((H5FD_class_value_t)(13))
+#define H5_VFD_ONION     ((H5FD_class_value_t)(14))
+
+/* VFD IDs below this value are reserved for library use. */
+#define H5_VFD_RESERVED 256
+
+/* Maximum VFD ID */
+#define H5_VFD_MAX 65535
+
+/* Define VFL driver features that can be enabled on a per-driver basis */
+/* These are returned with the 'query' function pointer in H5FD_class_t */
+/*
+ * Defining H5FD_FEAT_AGGREGATE_METADATA for a VFL driver means that
+ * the library will attempt to allocate a larger block for metadata and
+ * then sub-allocate each metadata request from that larger block.
+ */
+#define H5FD_FEAT_AGGREGATE_METADATA 0x00000001
+/*
+ * Defining H5FD_FEAT_ACCUMULATE_METADATA for a VFL driver means that
+ * the library will attempt to cache metadata as it is written to the file
+ * and build up a larger block of metadata to eventually pass to the VFL
+ * 'write' routine.
+ *
+ * Distinguish between updating the metadata accumulator on writes and
+ * reads.  This is particularly (perhaps only, even) important for MPI-I/O
+ * where we guarantee that writes are collective, but reads may not be.
+ * If we were to allow the metadata accumulator to be written during a
+ * read operation, the application would hang.
+ */
+#define H5FD_FEAT_ACCUMULATE_METADATA_WRITE 0x00000002
+#define H5FD_FEAT_ACCUMULATE_METADATA_READ  0x00000004
+#define H5FD_FEAT_ACCUMULATE_METADATA                                                                        \
+    (H5FD_FEAT_ACCUMULATE_METADATA_WRITE | H5FD_FEAT_ACCUMULATE_METADATA_READ)
+/*
+ * Defining H5FD_FEAT_DATA_SIEVE for a VFL driver means that
+ * the library will attempt to cache raw data as it is read from/written to
+ * a file in a "data sieve" buffer.  See Rajeev Thakur's papers:
+ *  http://www.mcs.anl.gov/~thakur/papers/romio-coll.ps.gz
+ *  http://www.mcs.anl.gov/~thakur/papers/mpio-high-perf.ps.gz
+ */
+#define H5FD_FEAT_DATA_SIEVE 0x00000008
+/*
+ * Defining H5FD_FEAT_AGGREGATE_SMALLDATA for a VFL driver means that
+ * the library will attempt to allocate a larger block for "small" raw data
+ * and then sub-allocate "small" raw data requests from that larger block.
+ */
+#define H5FD_FEAT_AGGREGATE_SMALLDATA 0x00000010
+/*
+ * Defining H5FD_FEAT_IGNORE_DRVRINFO for a VFL driver means that
+ * the library will ignore the driver info that is encoded in the file
+ * for the VFL driver.  (This will cause the driver info to be eliminated
+ * from the file when it is flushed/closed, if the file is opened R/W).
+ */
+#define H5FD_FEAT_IGNORE_DRVRINFO 0x00000020
+/*
+ * Defining the H5FD_FEAT_DIRTY_DRVRINFO_LOAD for a VFL driver means that
+ * the library will mark the driver info dirty when the file is opened
+ * R/W.  This will cause the driver info to be re-encoded when the file
+ * is flushed/closed.
+ */
+#define H5FD_FEAT_DIRTY_DRVRINFO_LOAD 0x00000040
+/*
+ * Defining H5FD_FEAT_POSIX_COMPAT_HANDLE for a VFL driver means that
+ * the handle for the VFD (returned with the 'get_handle' callback) is
+ * of type 'int' and is compatible with POSIX I/O calls.
+ */
+#define H5FD_FEAT_POSIX_COMPAT_HANDLE 0x00000080
+/*
+ * Defining H5FD_FEAT_HAS_MPI for a VFL driver means that
+ * the driver makes use of MPI communication and code may retrieve
+ * communicator/rank information from it
+ */
+#define H5FD_FEAT_HAS_MPI 0x00000100
+/*
+ * Defining the H5FD_FEAT_ALLOCATE_EARLY for a VFL driver will force
+ * the library to use the H5D_ALLOC_TIME_EARLY on dataset create
+ * instead of the default H5D_ALLOC_TIME_LATE
+ */
+#define H5FD_FEAT_ALLOCATE_EARLY 0x00000200
+/*
+ * Defining H5FD_FEAT_ALLOW_FILE_IMAGE for a VFL driver means that
+ * the driver is able to use a file image in the fapl as the initial
+ * contents of a file.
+ */
+#define H5FD_FEAT_ALLOW_FILE_IMAGE 0x00000400
+/*
+ * Defining H5FD_FEAT_CAN_USE_FILE_IMAGE_CALLBACKS for a VFL driver
+ * means that the driver is able to use callbacks to make a copy of the
+ * image to store in memory.
+ */
+#define H5FD_FEAT_CAN_USE_FILE_IMAGE_CALLBACKS 0x00000800
+/*
+ * Defining H5FD_FEAT_SUPPORTS_SWMR_IO for a VFL driver means that the
+ * driver supports the single-writer/multiple-readers I/O pattern.
+ */
+#define H5FD_FEAT_SUPPORTS_SWMR_IO 0x00001000
+/*
+ * Defining H5FD_FEAT_USE_ALLOC_SIZE for a VFL driver
+ * means that the library will just pass the allocation size to the
+ * the driver's allocation callback which will eventually handle alignment.
+ * This is specifically used for the multi/split driver.
+ */
+#define H5FD_FEAT_USE_ALLOC_SIZE 0x00002000
+/*
+ * Defining H5FD_FEAT_PAGED_AGGR for a VFL driver
+ * means that the driver needs special file space mapping for paged aggregation.
+ * This is specifically used for the multi/split driver.
+ */
+#define H5FD_FEAT_PAGED_AGGR 0x00004000
+/*
+ * Defining H5FD_FEAT_DEFAULT_VFD_COMPATIBLE for a VFL driver
+ * that creates a file which is compatible with the default VFD.
+ * Generally, this means that the VFD creates a single file that follows
+ * the canonical HDF5 file format.
+ * Regarding the Splitter VFD specifically, only drivers with this flag
+ * enabled may be used as the Write-Only (W/O) channel driver.
+ */
+#define H5FD_FEAT_DEFAULT_VFD_COMPATIBLE 0x00008000
+/*
+ * Defining H5FD_FEAT_MEMMANAGE for a VFL driver means that
+ * the driver uses special memory management routines or wishes
+ * to do memory management in a specific manner. Therefore, HDF5
+ * should request that the driver handle any memory management
+ * operations when appropriate.
+ */
+#define H5FD_FEAT_MEMMANAGE 0x00010000
+
+/* ctl function definitions: */
+#define H5FD_CTL_OPC_RESERVED 512 /* Opcodes below this value are reserved for library use */
+#define H5FD_CTL_OPC_EXPER_MIN                                                                               \
+    H5FD_CTL_OPC_RESERVED /* Minimum opcode value available for experimental use                             \
+                           */
+#define H5FD_CTL_OPC_EXPER_MAX                                                                               \
+    (H5FD_CTL_OPC_RESERVED + 511) /* Maximum opcode value available for experimental use */
+
+/* ctl function op codes: */
+#define H5FD_CTL_INVALID_OPCODE              0
+#define H5FD_CTL_TEST_OPCODE                 1
+#define H5FD_CTL_GET_MPI_COMMUNICATOR_OPCODE 2
+#define H5FD_CTL_GET_MPI_INFO_OPCODE         9
+#define H5FD_CTL_GET_MPI_RANK_OPCODE         3
+#define H5FD_CTL_GET_MPI_SIZE_OPCODE         4
+#define H5FD_CTL_MEM_ALLOC                   5
+#define H5FD_CTL_MEM_FREE                    6
+#define H5FD_CTL_MEM_COPY                    7
+#define H5FD_CTL_GET_MPI_FILE_SYNC_OPCODE    8
+
+/* ctl function flags: */
+
+/* Definitions:
+ *
+ * WARNING: While the following definitions of Terminal
+ * and Passthrough VFDs should be workable for now, they
+ * have to be adjusted as our use cases for VFDs expand.
+ *
+ *                                   JRM -- 8/4/21
+ *
+ *
+ * Terminal VFD: Lowest VFD in the VFD stack through
+ * which all VFD calls pass.  Note that this definition
+ * is situational.  For example, the sec2 VFD is typically
+ * terminal.  However, in the context of the family file
+ * driver, it is not -- the family file driver is the
+ * bottom VFD through which all VFD calls pass, and thus
+ * it is terminal.
+ *
+ * Similarly, on the splitter VFD, a sec2 VFD on the
+ * R/W channel is terminal, but a sec2 VFD on the W/O
+ * channel is not.
+ *
+ *
+ * Pass through VFD:  Any VFD that relays all VFD calls
+ * (with the possible exception of some non-I/O related
+ * calls) to underlying VFD(s).
+ */
+
+/* Unknown op codes should be ignored silently unless the
+ * H5FD_CTL_FAIL_IF_UNKNOWN_FLAG is set.
+ *
+ * On terminal VFDs, unknown op codes should generate an
+ * error unconditionally if this flag is set.
+ *
+ * On pass through VFDs, unknown op codes should be routed
+ * to the underlying VFD(s) as indicated by any routing
+ * flags.  In the absence of such flags, the VFD should
+ * generate an error.
+ */
+#define H5FD_CTL_FAIL_IF_UNKNOWN_FLAG 0x0001
+
+/* The H5FD_CTL_ROUTE_TO_TERMINAL_VFD_FLAG is used only
+ * by non-ternminal VFDs, and only applies to unknown
+ * opcodes. (known op codes should be handled as
+ * appropriate.)
+ *
+ * If this flag is set for an unknown op code, that
+ * op code should be passed to the next VFD down
+ * the VFD stack en-route to the terminal VFD.
+ * If that VFD does not support the ctl call, the
+ * pass through VFD should fail or succeed as directed
+ * by the  H5FD_CTL_FAIL_IF_UNKNOWN_FLAG.
+ */
+#define H5FD_CTL_ROUTE_TO_TERMINAL_VFD_FLAG 0x0002
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/*
+ * File driver identifiers.
+ *
+ * Values 0 through 255 are for drivers defined by the HDF5 library.
+ * Values 256 through 511 are available for testing new drivers.
+ * Subsequent values should be obtained from the HDF5 development
+ * team at mailto:help@hdfgroup.org.
+ */
+typedef int H5FD_class_value_t;
+
+/* Types of allocation requests: see H5Fpublic.h  */
+typedef enum H5F_mem_t H5FD_mem_t;
+
+/**
+ * Define enum for the source of file image callbacks
+ */
+//! <!-- [H5FD_file_image_op_t_snip] -->
+typedef enum {
+    H5FD_FILE_IMAGE_OP_NO_OP,
+    H5FD_FILE_IMAGE_OP_PROPERTY_LIST_SET,
+    /**< Passed to the \p image_malloc and \p image_memcpy callbacks when a
+     * file image buffer is to be copied while being set in a file access
+     * property list (FAPL)*/
+    H5FD_FILE_IMAGE_OP_PROPERTY_LIST_COPY,
+    /**< Passed to the \p image_malloc and \p image_memcpy callbacks
+     * when a file image buffer is to be copied when a FAPL is copied*/
+    H5FD_FILE_IMAGE_OP_PROPERTY_LIST_GET,
+    /**<Passed to the \p image_malloc and \p image_memcpy callbacks when
+     * a file image buffer is to be copied while being retrieved from a FAPL*/
+    H5FD_FILE_IMAGE_OP_PROPERTY_LIST_CLOSE,
+    /**<Passed to the \p image_free callback when a file image
+     * buffer is to be released during a FAPL close operation*/
+    H5FD_FILE_IMAGE_OP_FILE_OPEN,
+    /**<Passed to the \p image_malloc and
+     * \p image_memcpy callbackswhen a
+     * file image buffer is to be copied during a file open operation \n
+     * While the file image being opened will typically be copied from a
+     * FAPL, this need not always be the case. For example, the core file
+     * driver, also known as the memory file driver, takes its initial
+     * image from a file.*/
+    H5FD_FILE_IMAGE_OP_FILE_RESIZE,
+    /**<Passed to the \p image_realloc callback when a file driver needs
+     * to resize an image buffer*/
+    H5FD_FILE_IMAGE_OP_FILE_CLOSE
+    /**<Passed to the \p image_free callback when an image buffer is to
+     * be released during a file close operation*/
+} H5FD_file_image_op_t;
+//! <!-- [H5FD_file_image_op_t_snip] -->
+
+/**
+ * Define structure to hold file image callbacks
+ */
+//! <!-- [H5FD_file_image_callbacks_t_snip] -->
+typedef struct {
+    /**
+     * \param[in] size Size in bytes of the file image buffer to allocate
+     * \param[in] file_image_op A value from H5FD_file_image_op_t indicating
+     *                          the operation being performed on the file image
+     *                          when this callback is invoked
+     * \param[in] udata Value passed in in the H5Pset_file_image_callbacks
+     *            parameter \p udata
+     */
+    //! <!-- [image_malloc_snip] -->
+    void *(*image_malloc)(size_t size, H5FD_file_image_op_t file_image_op, void *udata);
+    //! <!-- [image_malloc_snip] -->
+    /**
+     * \param[in] dest Address of the destination buffer
+     * \param[in] src Address of the source buffer
+     * \param[in] size Size in bytes of the file image buffer to allocate
+     * \param[in] file_image_op A value from #H5FD_file_image_op_t indicating
+     *                          the operation being performed on the file image
+     *                          when this callback is invoked
+     * \param[in] udata Value passed in in the H5Pset_file_image_callbacks
+     *            parameter \p udata
+     */
+    //! <!-- [image_memcpy_snip] -->
+    void *(*image_memcpy)(void *dest, const void *src, size_t size, H5FD_file_image_op_t file_image_op,
+                          void *udata);
+    //! <!-- [image_memcpy_snip] -->
+    /**
+     * \param[in] ptr Pointer to the buffer being reallocated
+     * \param[in] size Size in bytes of the file image buffer to allocate
+     * \param[in] file_image_op A value from #H5FD_file_image_op_t indicating
+     *                          the operation being performed on the file image
+     *                          when this callback is invoked
+     * \param[in] udata Value passed in in the H5Pset_file_image_callbacks
+     *            parameter \p udata
+     */
+    //! <!-- [image_realloc_snip] -->
+    void *(*image_realloc)(void *ptr, size_t size, H5FD_file_image_op_t file_image_op, void *udata);
+    //! <!-- [image_realloc_snip] -->
+    /**
+     * \param[in] ptr Pointer to the buffer being reallocated
+     * \param[in] file_image_op A value from #H5FD_file_image_op_t indicating
+     *                          the operation being performed on the file image
+     *                          when this callback is invoked
+     * \param[in] udata Value passed in in the H5Pset_file_image_callbacks
+     *            parameter \p udata
+     */
+    //! <!-- [image_free_snip] -->
+    herr_t (*image_free)(void *ptr, H5FD_file_image_op_t file_image_op, void *udata);
+    //! <!-- [image_free_snip] -->
+    /**
+     * \param[in] udata Value passed in in the H5Pset_file_image_callbacks
+     *            parameter \p udata
+     */
+    //! <!-- [udata_copy_snip] -->
+    void *(*udata_copy)(void *udata);
+    //! <!-- [udata_copy_snip] -->
+    /**
+     * \param[in] udata Value passed in in the H5Pset_file_image_callbacks
+     *            parameter \p udata
+     */
+    //! <!-- [udata_free_snip] -->
+    herr_t (*udata_free)(void *udata);
+    //! <!-- [udata_free_snip] -->
+    /**
+     * \brief The final field in the #H5FD_file_image_callbacks_t struct,
+     *        provides a pointer to user-defined data. This pointer will be
+     *        passed to the image_malloc, image_memcpy, image_realloc, and
+     *        image_free callbacks. Define udata as NULL if no user-defined
+     *        data is provided.
+     */
+    void *udata;
+} H5FD_file_image_callbacks_t;
+//! <!-- [H5FD_file_image_callbacks_t_snip] -->
+
+/**
+ * Define structure to hold "ctl memory copy" parameters
+ */
+//! <!-- [H5FD_ctl_memcpy_args_t_snip] -->
+typedef struct H5FD_ctl_memcpy_args_t {
+    void       *dstbuf;  /**< Destination buffer */
+    hsize_t     dst_off; /**< Offset within destination buffer */
+    const void *srcbuf;  /**< Source buffer */
+    hsize_t     src_off; /**< Offset within source buffer */
+    size_t      len;     /**< Length of data to copy from source buffer */
+} H5FD_ctl_memcpy_args_t;
+//! <!-- [H5FD_ctl_memcpy_args_t_snip] -->
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Function prototypes */
+
+/**
+ * \ingroup H5FD
+ *
+ * \brief Allows querying a VFD ID for features before the file is opened
+ *
+ * \param[in] driver_id Virtual File Driver (VFD) ID
+ * \param[out] flags VFD flags supported
+ *
+ * \return \herr_t
+ *
+ * \details Queries a virtual file driver (VFD) for feature flags. Takes a
+ *          VFD hid_t so it can be used before the file is opened. For example,
+ *          this could be used to check if a VFD supports SWMR.
+ *
+ * \note The flags obtained here are just those of the base driver and
+ *       do not take any configuration options (e.g., set via a fapl
+ *       call) into consideration.
+ *
+ * \since 1.10.2
+ */
+H5_DLL herr_t H5FDdriver_query(hid_t driver_id, unsigned long *flags /*out*/);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/install/include/H5FDros3.h b/install/include/H5FDros3.h
new file mode 100644
index 0000000000..217af2d01b
--- /dev/null
+++ b/install/include/H5FDros3.h
@@ -0,0 +1,218 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the read-only S3 (ros3) virtual file driver (VFD)
+ */
+#ifndef H5FDros3_H
+#define H5FDros3_H
+
+#ifdef H5_HAVE_ROS3_VFD
+/** Initializer for the ros3 VFD */
+#define H5FD_ROS3 (H5FDperform_init(H5FD_ros3_init))
+
+/** Identifier for the ros3 VFD */
+#define H5FD_ROS3_VALUE H5_VFD_ROS3
+#else
+/** Initializer for the ros3 VFD (disabled) */
+#define H5FD_ROS3       (H5I_INVALID_HID)
+
+/** Identifier for the ros3 VFD (disabled) */
+#define H5FD_ROS3_VALUE H5_VFD_INVALID
+#endif
+
+#ifdef H5_HAVE_ROS3_VFD
+
+/****************************************************************************
+ *
+ * Structure: H5FD_ros3_fapl_t
+ *
+ * Purpose:
+ *
+ *     H5FD_ros3_fapl_t is a public structure that is used to pass S3
+ *     authentication data to the appropriate S3 VFD via the FAPL.  A pointer
+ *     to an instance of this structure is a parameter to H5Pset_fapl_ros3()
+ *     and H5Pget_fapl_ros3().
+ *
+ *
+ *
+ * `version` (int32_t)
+ *
+ *     Version number of the H5FD_ros3_fapl_t structure.  Any instance passed
+ *     to the above calls must have a recognized version number, or an error
+ *     will be flagged.
+ *
+ *     This field should be set to H5FD_CURR_ROS3_FAPL_T_VERSION.
+ *
+ * `authenticate` (hbool_t)
+ *
+ *     Flag true or false whether or not requests are to be authenticated
+ *     with the AWS4 algorithm.
+ *     If true, `aws_region`, `secret_id`, and `secret_key` must be populated.
+ *     If false, those three components are unused.
+ *
+ * `aws_region` (char[])
+ *
+ *     String: name of the AWS "region" of the host, e.g. "us-east-1".
+ *
+ * `secret_id` (char[])
+ *
+ *     String: "Access ID" for the resource.
+ *
+ * `secret_key` (char[])
+ *
+ *     String: "Secret Access Key" associated with the ID and resource.
+ *
+ ****************************************************************************/
+
+/**
+ * \def H5FD_CURR_ROS3_FAPL_T_VERSION
+ * The version number of the H5FD_ros3_fapl_t configuration
+ * structure for the $H5FD_ROS3 driver.
+ */
+#define H5FD_CURR_ROS3_FAPL_T_VERSION 1
+
+/**
+ * \def H5FD_ROS3_MAX_REGION_LEN
+ * Maximum string length for specifying the region of the S3 bucket.
+ */
+#define H5FD_ROS3_MAX_REGION_LEN 32
+/**
+ * \def H5FD_ROS3_MAX_SECRET_ID_LEN
+ * Maximum string length for specifying the security ID.
+ */
+#define H5FD_ROS3_MAX_SECRET_ID_LEN 128
+/**
+ * \def H5FD_ROS3_MAX_SECRET_KEY_LEN
+ * Maximum string length for specifying the security key.
+ */
+#define H5FD_ROS3_MAX_SECRET_KEY_LEN 128
+/**
+ * \def H5FD_ROS3_MAX_SECRET_TOK_LEN
+ * Maximum string length for specifying the session/security token.
+ */
+#define H5FD_ROS3_MAX_SECRET_TOK_LEN 1024
+
+/**
+ *\struct H5FD_ros3_fapl_t
+ * \brief Configuration structure for H5Pset_fapl_ros3() / H5Pget_fapl_ros3().
+ *
+ * \details H5FD_ros_fapl_t is a public structure that is used to pass
+ *          configuration data to the #H5FD_ROS3 driver via a File Access
+ *          Property List. A pointer to an instance of this structure is
+ *          a parameter to H5Pset_fapl_ros3() and H5Pget_fapl_ros3().
+ *
+ * \var int32_t H5FD_ros3_fapl_t::version
+ *      Version number of the H5FD_ros3_fapl_t structure. Any instance passed
+ *      to H5Pset_fapl_ros3() / H5Pget_fapl_ros3() must have a recognized version
+ *      number or an error will be raised. Currently, this field should be set
+ *      to #H5FD_CURR_ROS3_FAPL_T_VERSION.
+ *
+ * \var hbool_t H5FD_ros3_fapl_t::authenticate
+ *      A Boolean which specifies if security credentials should be used for
+ *      accessing a S3 bucket.
+ *
+ * \var char H5FD_ros3_fapl_t::aws_region[H5FD_ROS3_MAX_REGION_LEN + 1]
+ *      A string which specifies the AWS region of the S3 bucket.
+ *
+ * \var char H5FD_ros3_fapl_t::secret_id[H5FD_ROS3_MAX_SECRET_ID_LEN + 1]
+ *      A string which specifies the security ID.
+ *
+ * \var char H5FD_ros3_fapl_t::secret_key[H5FD_ROS3_MAX_SECRET_KEY_LEN + 1]
+ *      A string which specifies the security key.
+ *
+ */
+typedef struct H5FD_ros3_fapl_t {
+    int32_t version;
+    hbool_t authenticate;
+    char    aws_region[H5FD_ROS3_MAX_REGION_LEN + 1];
+    char    secret_id[H5FD_ROS3_MAX_SECRET_ID_LEN + 1];
+    char    secret_key[H5FD_ROS3_MAX_SECRET_KEY_LEN + 1];
+} H5FD_ros3_fapl_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @private
+ *
+ * \brief Private initializer for the ros3 VFD
+ */
+H5_DLL hid_t H5FD_ros3_init(void);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Queries a File Access Property List for #H5FD_ROS3 file driver properties.
+ *
+ * \fapl_id
+ * \param[out] fa_out Pointer to #H5FD_ROS3 driver configuration structure.
+ * \returns \herr_t
+ */
+H5_DLL herr_t H5Pget_fapl_ros3(hid_t fapl_id, H5FD_ros3_fapl_t *fa_out);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Modifies the specified File Access Property List to use the #H5FD_ROS3 driver.
+ *
+ * \fapl_id
+ * \param[in] fa Pointer to #H5FD_ROS3 driver configuration structure.
+ * \returns \herr_t
+ */
+H5_DLL herr_t H5Pset_fapl_ros3(hid_t fapl_id, const H5FD_ros3_fapl_t *fa);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Queries a File Access Property List for #H5FD_ROS3 file driver session/security
+ *        token.
+ *
+ * \fapl_id
+ * \param[in] size Size of the provided char array for storing the session/security token.
+ * \param[out] token Session/security token.
+ * \returns \herr_t
+ *
+ * \since 1.14.2
+ */
+H5_DLL herr_t H5Pget_fapl_ros3_token(hid_t fapl_id, size_t size, char *token);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Modifies the specified File Access Property List to use the #H5FD_ROS3 driver
+ *        by adding the specified session/security token.
+ *
+ * \fapl_id
+ * \param[in] token Session/security token.
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_ros3_token() modifies an existing File Access Property List which
+ *          is used by #H5FD_ROS3 driver by adding or updating the session/security token
+ *          of the property list. Be aware, to set the token first you need to create
+ *          a proper File Access Property List using H5Pset_fapl_ros() and use this list
+ *          as input argument of the function H5Pset_fapl_ros3_token().
+ *
+ *          Note, the session token is only needed when you want to access a S3 bucket
+ *          using temporary security credentials.
+ *
+ * \since 1.14.2
+ */
+H5_DLL herr_t H5Pset_fapl_ros3_token(hid_t fapl_id, const char *token);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5_HAVE_ROS3_VFD */
+
+#endif /* ifndef H5FDros3_H */
diff --git a/install/include/H5FDs3comms.h b/install/include/H5FDs3comms.h
new file mode 100644
index 0000000000..120a71a9c8
--- /dev/null
+++ b/install/include/H5FDs3comms.h
@@ -0,0 +1,557 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*****************************************************************************
+ * Read-Only S3 Virtual File Driver (VFD)
+ *
+ * This is the header for the S3 Communications module
+ *
+ * ***NOT A FILE DRIVER***
+ *
+ * Purpose:
+ *
+ *     - Provide structures and functions related to communicating with
+ *       Amazon S3 (Simple Storage Service).
+ *     - Abstract away the REST API (HTTP,
+ *       networked communications) behind a series of uniform function calls.
+ *     - Handle AWS4 authentication, if appropriate.
+ *     - Fail predictably in event of errors.
+ *     - Eventually, support more S3 operations, such as creating, writing to,
+ *       and removing Objects remotely.
+ *
+ *     translates:
+ *     `read(some_file, bytes_offset, bytes_length, &dest_buffer);`
+ *     to:
+ *     ```
+ *     GET myfile HTTP/1.1
+ *     Host: somewhere.me
+ *     Range: bytes=4096-5115
+ *     ```
+ *     and places received bytes from HTTP response...
+ *     ```
+ *     HTTP/1.1 206 Partial-Content
+ *     Content-Range: 4096-5115/63239
+ *
+ *     <bytes>
+ *     ```
+ *     ...in destination buffer.
+ *
+ *****************************************************************************/
+
+#include "H5private.h" /* Generic Functions        */
+
+#ifdef H5_HAVE_ROS3_VFD
+
+/* Necessary S3 headers */
+#include <curl/curl.h>
+#include <openssl/evp.h>
+#include <openssl/hmac.h>
+#include <openssl/sha.h>
+
+/*****************
+ * PUBLIC MACROS *
+ *****************/
+
+/* hexadecimal string of pre-computed sha256 checksum of the empty string
+ * hex(sha256sum(""))
+ */
+#define EMPTY_SHA256 "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
+
+/* string length (plus null terminator)
+ * example ISO8601-format string: "20170713T145903Z" (YYYYmmdd'T'HHMMSS'_')
+ */
+#define ISO8601_SIZE 17
+
+/* string length (plus null terminator)
+ * example RFC7231-format string: "Fri, 30 Jun 2017 20:41:55 GMT"
+ */
+#define RFC7231_SIZE 30
+
+/*---------------------------------------------------------------------------
+ *
+ * Macro: ISO8601NOW()
+ *
+ * Purpose:
+ *
+ *     write "YYYYmmdd'T'HHMMSS'Z'" (less single-quotes) to dest
+ *     e.g., "20170630T204155Z"
+ *
+ *     wrapper for strftime()
+ *
+ *     It is left to the programmer to check return value of
+ *     ISO8601NOW (should equal ISO8601_SIZE - 1).
+ *
+ *---------------------------------------------------------------------------
+ */
+#define ISO8601NOW(dest, now_gm) strftime((dest), ISO8601_SIZE, "%Y%m%dT%H%M%SZ", (now_gm))
+
+/*---------------------------------------------------------------------------
+ *
+ * Macro: RFC7231NOW()
+ *
+ * Purpose:
+ *
+ *     write "Day, dd Mmm YYYY HH:MM:SS GMT" to dest
+ *     e.g., "Fri, 30 Jun 2017 20:41:55 GMT"
+ *
+ *     wrapper for strftime()
+ *
+ *     It is left to the programmer to check return value of
+ *     RFC7231NOW (should equal RFC7231_SIZE - 1).
+ *
+ *---------------------------------------------------------------------------
+ */
+#define RFC7231NOW(dest, now_gm) strftime((dest), RFC7231_SIZE, "%a, %d %b %Y %H:%M:%S GMT", (now_gm))
+
+/* Reasonable maximum length of a credential string.
+ * Provided for error-checking S3COMMS_FORMAT_CREDENTIAL (below).
+ *  17 <- "////aws4_request\0"
+ *   2 < "s3" (service)
+ *   8 <- "YYYYmmdd" (date)
+ * 128 <- (access_id)
+ * 155 :: sum
+ */
+#define S3COMMS_MAX_CREDENTIAL_SIZE 155
+
+/*---------------------------------------------------------------------------
+ *
+ * Macro: H5FD_S3COMMS_FORMAT_CREDENTIAL()
+ *
+ * Purpose:
+ *
+ *     Format "S3 Credential" string from inputs, for AWS4.
+ *
+ *     Wrapper for snprintf().
+ *
+ *     _HAS NO ERROR-CHECKING FACILITIES_
+ *     It is left to programmer to ensure that return value confers success.
+ *     e.g.,
+ *     ```
+ *     assert( S3COMMS_MAX_CREDENTIAL_SIZE >=
+ *             S3COMMS_FORMAT_CREDENTIAL(...) );
+ *     ```
+ *
+ *     "<access-id>/<date>/<aws-region>/<aws-service>/aws4_request"
+ *     assuming that `dest` has adequate space.
+ *
+ *     ALL inputs must be null-terminated strings.
+ *
+ *     `access` should be the user's access key ID.
+ *     `date` must be of format "YYYYmmdd".
+ *     `region` should be relevant AWS region, i.e. "us-east-1".
+ *     `service` should be "s3".
+ *
+ *---------------------------------------------------------------------------
+ */
+#define S3COMMS_FORMAT_CREDENTIAL(dest, access, iso8601_date, region, service)                               \
+    snprintf((dest), S3COMMS_MAX_CREDENTIAL_SIZE, "%s/%s/%s/%s/aws4_request", (access), (iso8601_date),      \
+             (region), (service))
+
+/*********************
+ * PUBLIC STRUCTURES *
+ *********************/
+
+/*----------------------------------------------------------------------------
+ *
+ * Structure: hrb_node_t
+ *
+ * HTTP Header Field Node
+ *
+ *
+ *
+ * Maintain a ordered (linked) list of HTTP Header fields.
+ *
+ * Provides efficient access and manipulation of a logical sequence of
+ * HTTP header fields, of particular use when composing an
+ * "S3 Canonical Request" for authentication.
+ *
+ * - The creation of a Canonical Request involves:
+ *     - convert field names to lower case
+ *     - sort by this lower-case name
+ *     - convert ": " name-value separator in HTTP string to ":"
+ *     - get sorted lowercase names without field or separator
+ *
+ * As HTTP headers allow headers in any order (excepting the case of multiple
+ * headers with the same name), the list ordering can be optimized for Canonical
+ * Request creation, suggesting alphabtical order. For more expedient insertion
+ * and removal of elements in the list, linked list seems preferable to a
+ * dynamically-expanding array. The usually-smaller number of entries (5 or
+ * fewer) makes performance overhead of traversing the list trivial.
+ *
+ * The above requirements of creating at Canonical Request suggests a reasonable
+ * trade-off of speed for space with the option to compute elements as needed
+ * or to have the various elements prepared and stored in the structure
+ * (e.g. name, value, lowername, concatenated name:value)
+ * The structure currently is implemented to pre-compute.
+ *
+ * At all times, the "first" node of the list should be the least,
+ * alphabetically. For all nodes, the `next` node should be either NULL or
+ * of greater alphabetical value.
+ *
+ * Each node contains its own header field information, plus a pointer to the
+ * next node.
+ *
+ * It is not allowed to have multiple nodes with the same _lowercase_ `name`s
+ * in the same list
+ * (i.e., name is case-insensitive for access and modification.)
+ *
+ * All data (`name`, `value`, `lowername`, and `cat`) are null-terminated
+ * strings allocated specifically for their node.
+ *
+ *
+ *
+ * `magic` (unsigned long)
+ *
+ *     "unique" identifier number for the structure type
+ *
+ * `name` (char *)
+ *
+ *     Case-meaningful name of the HTTP field.
+ *     Given case is how it is supplied to networking code.
+ *     e.g., "Range"
+ *
+ * `lowername` (char *)
+ *
+ *     Lowercase copy of name.
+ *     e.g., "range"
+ *
+ * `value` (char *)
+ *
+ *     Case-meaningful value of HTTP field.
+ *     e.g., "bytes=0-9"
+ *
+ * `cat` (char *)
+ *
+ *     Concatenated, null-terminated string of HTTP header line,
+ *     as the field would appear in an HTTP request.
+ *     e.g., "Range: bytes=0-9"
+ *
+ * `next` (hrb_node_t *)
+ *
+ *     Pointers to next node in the list, or NULL sentinel as end of list.
+ *     Next node must have a greater `lowername` as determined by strcmp().
+ *
+ *----------------------------------------------------------------------------
+ */
+typedef struct hrb_node_t {
+    unsigned long      magic;
+    char              *name;
+    char              *value;
+    char              *cat;
+    char              *lowername;
+    struct hrb_node_t *next;
+} hrb_node_t;
+#define S3COMMS_HRB_NODE_MAGIC 0x7F5757UL
+
+/*----------------------------------------------------------------------------
+ *
+ * Structure: hrb_t
+ *
+ * HTTP Request Buffer structure
+ *
+ *
+ *
+ * Logically represent an HTTP request
+ *
+ *     GET /myplace/myfile.h5 HTTP/1.1
+ *     Host: over.rainbow.oz
+ *     Date: Fri, 01 Dec 2017 12:35:04 CST
+ *
+ *     <body>
+ *
+ * ...with fast, efficient access to and modification of primary and field
+ * elements.
+ *
+ * Structure for building HTTP requests while hiding much of the string
+ * processing required "under the hood."
+ *
+ * Information about the request target -- the first line -- and the body text,
+ * if any, are managed directly with this structure. All header fields, e.g.,
+ * "Host" and "Date" above, are created with a linked list of `hrb_node_t` and
+ * included in the request by a pointer to the head of the list.
+ *
+ *
+ *
+ * `magic` (unsigned long)
+ *
+ *     "Magic" number confirming that this is an hrb_t structure and
+ *     what operations are valid for it.
+ *
+ *     Must be S3COMMS_HRB_MAGIC to be valid.
+ *
+ * `body` (char *) :
+ *
+ *     Pointer to start of HTTP body.
+ *
+ *     Can be NULL, in which case it is treated as the empty string, "".
+ *
+ * `body_len` (size_t) :
+ *
+ *     Number of bytes (characters) in `body`. 0 if empty or NULL `body`.
+ *
+ * `first_header` (hrb_node_t *) :
+ *
+ *     Pointer to first SORTED header node, if any.
+ *     It is left to the programmer to ensure that this node and associated
+ *     list is destroyed when done.
+ *
+ * `resource` (char *) :
+ *
+ *     Pointer to resource URL string, e.g., "/folder/page.xhtml".
+ *
+ * `verb` (char *) :
+ *
+ *     Pointer to HTTP verb string, e.g., "GET".
+ *
+ * `version` (char *) :
+ *
+ *     Pointer to HTTP version string, e.g., "HTTP/1.1".
+ *
+ *----------------------------------------------------------------------------
+ */
+typedef struct {
+    unsigned long magic;
+    char         *body;
+    size_t        body_len;
+    hrb_node_t   *first_header;
+    char         *resource;
+    char         *verb;
+    char         *version;
+} hrb_t;
+#define S3COMMS_HRB_MAGIC 0x6DCC84UL
+
+/*----------------------------------------------------------------------------
+ *
+ * Structure: parsed_url_t
+ *
+ *
+ * Represent a URL with easily-accessed pointers to logical elements within.
+ * These elements (components) are stored as null-terminated strings (or just
+ * NULLs). These components should be allocated for the structure, making the
+ * data as safe as possible from modification. If a component is NULL, it is
+ * either implicit in or absent from the URL.
+ *
+ * "http://mybucket.s3.amazonaws.com:8080/somefile.h5?param=value&arg=value"
+ *  ^--^   ^-----------------------^ ^--^ ^---------^ ^-------------------^
+ * Scheme             Host           Port  Resource        Query/-ies
+ *
+ *
+ *
+ * `magic` (unsigned long)
+ *
+ *     Structure identification and validation identifier.
+ *     Identifies as `parsed_url_t` type.
+ *
+ * `scheme` (char *)
+ *
+ *     String representing which protocol is to be expected.
+ *     _Must_ be present.
+ *     "http", "https", "ftp", e.g.
+ *
+ * `host` (char *)
+ *
+ *     String of host, either domain name, IPv4, or IPv6 format.
+ *     _Must_ be present.
+ *     "over.rainbow.oz", "192.168.0.1", "[0000:0000:0000:0001]"
+ *
+ * `port` (char *)
+ *
+ *     String representation of specified port. Must resolve to a valid unsigned
+ *     integer.
+ *     "9000", "80"
+ *
+ * `path` (char *)
+ *
+ *     Path to resource on host. If not specified, assumes root "/".
+ *     "lollipop_guild.wav", "characters/witches/white.dat"
+ *
+ * `query` (char *)
+ *
+ *     Single string of all query parameters in url (if any).
+ *     "arg1=value1&arg2=value2"
+ *
+ *----------------------------------------------------------------------------
+ */
+typedef struct {
+    unsigned long magic;
+    char         *scheme; /* required */
+    char         *host;   /* required */
+    char         *port;
+    char         *path;
+    char         *query;
+} parsed_url_t;
+#define S3COMMS_PARSED_URL_MAGIC 0x21D0DFUL
+
+/*----------------------------------------------------------------------------
+ *
+ * Structure: s3r_t
+ *
+ *
+ *
+ * S3 request structure "handle".
+ *
+ * Holds persistent information for Amazon S3 requests.
+ *
+ * Instantiated through `H5FD_s3comms_s3r_open()`, copies data into self.
+ *
+ * Intended to be re-used for operations on a remote object.
+ *
+ * Cleaned up through `H5FD_s3comms_s3r_close()`.
+ *
+ * _DO NOT_ share handle between threads: curl easy handle `curlhandle` has
+ * undefined behavior if called to perform in multiple threads.
+ *
+ *
+ *
+ * `magic` (unsigned long)
+ *
+ *     "magic" number identifying this structure as unique type.
+ *     MUST equal `S3R_MAGIC` to be valid.
+ *
+ * `curlhandle` (CURL)
+ *
+ *     Pointer to the curl_easy handle generated for the request.
+ *
+ * `httpverb` (char *)
+ *
+ *     Pointer to NULL-terminated string. HTTP verb,
+ *     e.g. "GET", "HEAD", "PUT", etc.
+ *
+ *     Default is NULL, resulting in a "GET" request.
+ *
+ * `purl` (parsed_url_t *)
+ *
+ *     Pointer to structure holding the elements of URL for file open.
+ *
+ *     e.g., "http://bucket.aws.com:8080/myfile.dat?q1=v1&q2=v2"
+ *     parsed into...
+ *     {   scheme: "http"
+ *         host:   "bucket.aws.com"
+ *         port:   "8080"
+ *         path:   "myfile.dat"
+ *         query:  "q1=v1&q2=v2"
+ *     }
+ *
+ *     Cannot be NULL.
+ *
+ * `region` (char *)
+ *
+ *     Pointer to NULL-terminated string, specifying S3 "region",
+ *     e.g., "us-east-1".
+ *
+ *     Required to authenticate.
+ *
+ * `secret_id` (char *)
+ *
+ *     Pointer to NULL-terminated string for "secret" access id to S3 resource.
+ *
+ *     Required to authenticate.
+ *
+ * `signing_key` (unsigned char *)
+ *
+ *     Pointer to `SHA256_DIGEST_LENGTH`-long string for "reusable" signing
+ *     key, generated via
+ *     `HMAC-SHA256(HMAC-SHA256(HMAC-SHA256(HMAC-SHA256("AWS4<secret_key>",
+ *         "<yyyyMMDD"), "<aws-region>"), "<aws-service>"), "aws4_request")`
+ *     which may be re-used for several (up to seven (7)) days from creation?
+ *     Computed once upon file open.
+ *
+ *     Required to authenticate.
+ *
+ *----------------------------------------------------------------------------
+ */
+typedef struct {
+    unsigned long  magic;
+    CURL          *curlhandle;
+    size_t         filesize;
+    char          *httpverb;
+    parsed_url_t  *purl;
+    char          *region;
+    char          *secret_id;
+    unsigned char *signing_key;
+    char          *token;
+} s3r_t;
+
+#define S3COMMS_S3R_MAGIC 0x44d8d79
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************
+ * DECLARATION OF HTTP FIELD LIST ROUTINES *
+ *******************************************/
+
+H5_DLL herr_t H5FD_s3comms_hrb_node_set(hrb_node_t **L, const char *name, const char *value);
+
+/***********************************************
+ * DECLARATION OF HTTP REQUEST BUFFER ROUTINES *
+ ***********************************************/
+
+H5_DLL herr_t H5FD_s3comms_hrb_destroy(hrb_t **buf);
+
+H5_DLL hrb_t *H5FD_s3comms_hrb_init_request(const char *verb, const char *resource, const char *host);
+
+/*************************************
+ * DECLARATION OF S3REQUEST ROUTINES *
+ *************************************/
+
+H5_DLL herr_t H5FD_s3comms_s3r_close(s3r_t *handle);
+
+H5_DLL size_t H5FD_s3comms_s3r_get_filesize(s3r_t *handle);
+
+H5_DLL s3r_t *H5FD_s3comms_s3r_open(const char url[], const char region[], const char id[],
+                                    const unsigned char signing_key[], const char token[]);
+
+H5_DLL herr_t H5FD_s3comms_s3r_read(s3r_t *handle, haddr_t offset, size_t len, void *dest);
+
+/*********************************
+ * DECLARATION OF OTHER ROUTINES *
+ *********************************/
+
+H5_DLL struct tm *gmnow(void);
+
+H5_DLL herr_t H5FD_s3comms_aws_canonical_request(char *canonical_request_dest, int cr_size,
+                                                 char *signed_headers_dest, int sh_size, hrb_t *http_request);
+
+H5_DLL herr_t H5FD_s3comms_bytes_to_hex(char *dest, const unsigned char *msg, size_t msg_len, bool lowercase);
+
+H5_DLL herr_t H5FD_s3comms_free_purl(parsed_url_t *purl);
+
+H5_DLL herr_t H5FD_s3comms_HMAC_SHA256(const unsigned char *key, size_t key_len, const char *msg,
+                                       size_t msg_len, char *dest);
+
+H5_DLL herr_t H5FD_s3comms_load_aws_profile(const char *name, char *key_id_out, char *secret_access_key_out,
+                                            char *aws_region_out);
+
+H5_DLL herr_t H5FD_s3comms_nlowercase(char *dest, const char *s, size_t len);
+
+H5_DLL herr_t H5FD_s3comms_parse_url(const char *str, parsed_url_t **purl);
+
+H5_DLL herr_t H5FD_s3comms_percent_encode_char(char *repr, const unsigned char c, size_t *repr_len);
+
+H5_DLL herr_t H5FD_s3comms_signing_key(unsigned char *md, const char *secret, const char *region,
+                                       const char *iso8601now);
+
+H5_DLL herr_t H5FD_s3comms_tostringtosign(char *dest, const char *req_str, const char *now,
+                                          const char *region);
+
+H5_DLL herr_t H5FD_s3comms_trim(char *dest, char *s, size_t s_len, size_t *n_written);
+
+H5_DLL herr_t H5FD_s3comms_uriencode(char *dest, const char *s, size_t s_len, bool encode_slash,
+                                     size_t *n_written);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5_HAVE_ROS3_VFD */
diff --git a/install/include/H5FDsec2.h b/install/include/H5FDsec2.h
new file mode 100644
index 0000000000..dd0a4d8918
--- /dev/null
+++ b/install/include/H5FDsec2.h
@@ -0,0 +1,56 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the POSOX I/O (sec2 - "POSIX section 2")
+ *          virtual file driver (VFD)
+ */
+#ifndef H5FDsec2_H
+#define H5FDsec2_H
+
+/** Initializer for the sec2 VFD */
+#define H5FD_SEC2 (H5FDperform_init(H5FD_sec2_init))
+
+/** Identifier for the sec2 VFD */
+#define H5FD_SEC2_VALUE H5_VFD_SEC2
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @private
+ *
+ * \brief Private initializer for the sec2 VFD
+ */
+H5_DLL hid_t H5FD_sec2_init(void);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Modifies the file access property list to use the #H5FD_SEC2 driver
+ *
+ * \fapl_id
+ *
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_sec2() modifies the file access property list to use the
+ *          #H5FD_SEC2 driver.
+ *
+ * \since 1.4.0
+ */
+H5_DLL herr_t H5Pset_fapl_sec2(hid_t fapl_id);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5FDsplitter.h b/install/include/H5FDsplitter.h
new file mode 100644
index 0000000000..99a471e5ce
--- /dev/null
+++ b/install/include/H5FDsplitter.h
@@ -0,0 +1,118 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the splitter virtual file driver (VFD)
+ */
+
+#ifndef H5FDsplitter_H
+#define H5FDsplitter_H
+
+/** Initializer for the splitter VFD */
+#define H5FD_SPLITTER (H5FDperform_init(H5FD_splitter_init))
+
+/** Identifier for the splitter VFD */
+#define H5FD_SPLITTER_VALUE H5_VFD_SPLITTER
+
+/** The version of the H5FD_splitter_vfd_config_t structure used */
+#define H5FD_CURR_SPLITTER_VFD_CONFIG_VERSION 1
+
+/**
+ * Maximum length of a filename/path string in the Write-Only channel,
+ * including the NULL-terminator.
+ */
+#define H5FD_SPLITTER_PATH_MAX 4096
+
+/** Semi-unique constant used to help identify structure pointers */
+#define H5FD_SPLITTER_MAGIC 0x2B916880
+
+//! <!-- [H5FD_splitter_vfd_config_t_snip] -->
+/**
+ * Configuration options for setting up the Splitter VFD
+ */
+typedef struct H5FD_splitter_vfd_config_t {
+    int32_t      magic;   /**< Magic number to identify this struct. Must be \p H5FD_SPLITTER_MAGIC. */
+    unsigned int version; /**< Version number of this struct. Currently must be \p
+                             H5FD_CURR_SPLITTER_VFD_CONFIG_VERSION. */
+    hid_t rw_fapl_id;     /**< File-access property list for setting up the read/write channel. Can be \p
+                             H5P_DEFAULT. */
+    hid_t wo_fapl_id; /**< File-access property list for setting up the read-only channel. The selected VFD
+                         must support the \p H5FD_FEAT_DEFAULT_VFD_COMPATIBLE flag. Can be \p H5P_DEFAULT. */
+    char wo_path[H5FD_SPLITTER_PATH_MAX + 1];       /**< Path to the write-only file */
+    char log_file_path[H5FD_SPLITTER_PATH_MAX + 1]; /**< Path to the log file, which will be created on HDF5
+                                                       file open (existing files will be clobbered). Can be
+                                                       NULL, in which case no logging output is generated. */
+    hbool_t ignore_wo_errs;                         /**< Whether to ignore errors on the write-only channel */
+} H5FD_splitter_vfd_config_t;
+//! <!-- [H5FD_splitter_vfd_config_t_snip] -->
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @private
+ *
+ * \brief Private initializer for the splitter VFD
+ */
+H5_DLL hid_t H5FD_splitter_init(void);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the file access property list to use the splitter driver
+ *
+ * \fapl_id
+ * \param[in] config_ptr Configuration options for the VFD
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_splitter() sets the file access property list identifier,
+ *          \p fapl_id, to use the splitter driver.
+ *
+ *          The splitter VFD echoes file manipulation (e.g. create, truncate)
+ *          and write calls to a second, write-only file.
+ *
+ *          \note The splitter VFD should not be confused with the split VFD,
+ *          which is a simplification of the multi VFD and creates separate
+ *          files for metadata and data.
+ *
+ * \since 1.10.7, 1.12.1
+ */
+H5_DLL herr_t H5Pset_fapl_splitter(hid_t fapl_id, H5FD_splitter_vfd_config_t *config_ptr);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Gets splitter driver properties from the the file access property list
+ *
+ * \fapl_id
+ * \param[out] config_ptr Configuration options for the VFD
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_splitter() sets the file access property list identifier,
+ *          \p fapl_id, to use the splitter driver.
+ *
+ *          The splitter VFD echoes file manipulation (e.g. create, truncate)
+ *          and write calls to a second file.
+ *
+ *          \note The splitter VFD should not be confused with the split VFD,
+ *          which is a simplification of the multi VFD and creates separate
+ *          files for metadata and data.
+ *
+ * \since 1.10.7, 1.12.1
+ */
+H5_DLL herr_t H5Pget_fapl_splitter(hid_t fapl_id, H5FD_splitter_vfd_config_t *config_ptr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5FDstdio.h b/install/include/H5FDstdio.h
new file mode 100644
index 0000000000..794fe31bf6
--- /dev/null
+++ b/install/include/H5FDstdio.h
@@ -0,0 +1,58 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the C stdio virtual file driver (VFD)
+ */
+#ifndef H5FDstdio_H
+#define H5FDstdio_H
+
+#include "H5Ipublic.h"
+
+/** Initializer for the stdio VFD */
+#define H5FD_STDIO (H5FDperform_init(H5FD_stdio_init))
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @private
+ *
+ * \brief Private initializer for the stdio VFD
+ */
+H5_DLL hid_t H5FD_stdio_init(void);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the standard I/O driver
+ *
+ * \fapl_id
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_stdio() modifies the file access property list to use
+ *          the stdio VFD, which uses I/O calls from stdio.h.
+ *
+ * \note This VFD was designed to be a "demo" VFD that shows how to write
+ * your own VFD. Most applications should not use this VFD and should instead
+ * use the POSIX I/O VFD (sec2).
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pset_fapl_stdio(hid_t fapl_id);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5FDsubfiling.h b/install/include/H5FDsubfiling.h
new file mode 100644
index 0000000000..d6d2ffd16d
--- /dev/null
+++ b/install/include/H5FDsubfiling.h
@@ -0,0 +1,415 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Purpose: The public header file for the subfiling driver. */
+#ifndef H5FDsubfiling_H
+#define H5FDsubfiling_H
+
+#ifdef H5_HAVE_SUBFILING_VFD
+/**
+ * \def H5FD_SUBFILING
+ * Macro that returns the identifier for the #H5FD_SUBFILING driver. \hid_t{file driver}
+ */
+#define H5FD_SUBFILING (H5FDperform_init(H5FD_subfiling_init))
+#else
+#define H5FD_SUBFILING (H5I_INVALID_HID)
+#endif
+
+/**
+ * \def H5FD_SUBFILING_NAME
+ * The canonical name for the #H5FD_SUBFILING driver
+ */
+#define H5FD_SUBFILING_NAME "subfiling"
+
+#ifdef H5_HAVE_SUBFILING_VFD
+
+#ifndef H5FD_SUBFILING_FAPL_MAGIC
+/**
+ * \def H5FD_SUBFILING_CURR_FAPL_VERSION
+ * The version number of the H5FD_subfiling_config_t configuration
+ * structure for the #H5FD_SUBFILING driver
+ */
+#define H5FD_SUBFILING_CURR_FAPL_VERSION 1
+/**
+ * \def H5FD_SUBFILING_FAPL_MAGIC
+ * Unique number used to distinguish the #H5FD_SUBFILING driver from other HDF5 file drivers
+ */
+#define H5FD_SUBFILING_FAPL_MAGIC 0xFED01331
+#endif
+
+/**
+ * \def H5FD_SUBFILING_DEFAULT_STRIPE_SIZE
+ * The default stripe size (in bytes) for data stripes in subfiles
+ */
+#define H5FD_SUBFILING_DEFAULT_STRIPE_SIZE (32 * 1024 * 1024)
+
+/**
+ * \def H5FD_SUBFILING_DEFAULT_STRIPE_COUNT
+ * Macro for the default Subfiling stripe count value. The default
+ * is currently to use one subfile per node.
+ */
+#define H5FD_SUBFILING_DEFAULT_STRIPE_COUNT -1
+
+/**
+ * \def H5FD_SUBFILING_FILENAME_TEMPLATE
+ * The basic printf-style template for a #H5FD_SUBFILING driver
+ * subfile filename. The format specifiers correspond to:
+ *
+ * \par \%s
+ *   base filename, e.g. "file.h5"
+ *
+ * \par \%PRIu64
+ *   file inode, e.g. 11273556
+ *
+ * \par \%0*d
+ *   number (starting at 1) signifying the Nth (out of
+ *   total number of subfiles) subfile. Zero-padded
+ *   according to the number of digits in the number of
+ *   subfiles (calculated by <tt>log10(num_subfiles) + 1)</tt>
+ *
+ * \par \%d
+ *   number of subfiles
+ *
+ * yielding filenames such as:
+ *
+ * file.h5.subfile_11273556_01_of_10 \n
+ * file.h5.subfile_11273556_02_of_10 \n
+ * file.h5.subfile_11273556_10_of_10 \n
+ */
+#define H5FD_SUBFILING_FILENAME_TEMPLATE "%s.subfile_%" PRIu64 "_%0*d_of_%d"
+
+/**
+ * \def H5FD_SUBFILING_CONFIG_FILENAME_TEMPLATE
+ * The basic printf-style template for a #H5FD_SUBFILING driver
+ * configuration filename. The format specifiers correspond to:
+ *
+ * \par \%s
+ *   base filename, e.g. "file.h5"
+ *
+ * \par \%PRIu64
+ *   file inode, e.g. 11273556
+ *
+ * yielding a filename such as:
+ *
+ * file.h5.subfile_11273556.config
+ */
+#define H5FD_SUBFILING_CONFIG_FILENAME_TEMPLATE "%s.subfile_%" PRIu64 ".config"
+
+/*
+ * Environment variables interpreted by the HDF5 Subfiling feature
+ */
+
+/**
+ * \def H5FD_SUBFILING_STRIPE_SIZE
+ * Macro for name of the environment variable that specifies the size
+ * (in bytes) for data stripes in subfiles
+ *
+ * The value set for this environment variable is interpreted as a
+ * long long value and must be > 0.
+ */
+#define H5FD_SUBFILING_STRIPE_SIZE "H5FD_SUBFILING_STRIPE_SIZE"
+/**
+ * \def H5FD_SUBFILING_IOC_PER_NODE
+ * Macro for name of the environment variable that specifies the number
+ * of MPI ranks per node to use as I/O concentrators
+ *
+ * The value set for this environment variable is interpreted as a
+ * long value and must be > 0.
+ */
+#define H5FD_SUBFILING_IOC_PER_NODE "H5FD_SUBFILING_IOC_PER_NODE"
+/**
+ * \def H5FD_SUBFILING_IOC_SELECTION_CRITERIA
+ * Macro for name of the environment variable that provides information
+ * for selection MPI ranks as I/O concentrators
+ *
+ * The value set for this environment variable is interpreted differently,
+ * depending on the IOC selection method chosen.
+ *
+ * For #SELECT_IOC_ONE_PER_NODE, this value is ignored.
+ *
+ * For #SELECT_IOC_EVERY_NTH_RANK, this value is interpreted as a
+ *     long value and must be > 0. The value will correspond to the
+ *     `N` value when selecting every `N`-th MPI rank as an I/O
+ *     concentrator.
+ *
+ * For #SELECT_IOC_WITH_CONFIG, this value is ignored as that particular
+ *     IOC selection method is not currently supported.
+ *
+ * For #SELECT_IOC_TOTAL, this value is interpreted as a long value
+ *     and must be > 0. The value will correspond to the total number
+ *     of I/O concentrators to be used.
+ */
+#define H5FD_SUBFILING_IOC_SELECTION_CRITERIA "H5FD_SUBFILING_IOC_SELECTION_CRITERIA"
+/**
+ * \def H5FD_SUBFILING_SUBFILE_PREFIX
+ * Macro for name of the environment variable that specifies a prefix
+ * to apply to the filenames generated for subfiles
+ *
+ * The value set for this environment variable is interpreted as a
+ * pathname.
+ */
+#define H5FD_SUBFILING_SUBFILE_PREFIX "H5FD_SUBFILING_SUBFILE_PREFIX"
+/**
+ * \def H5FD_SUBFILING_CONFIG_FILE_PREFIX
+ * Macro for name of the environment variable that specifies a prefix
+ * to apply to the subfiling configuration filename. Useful for cases
+ * where the application wants to place the configuration file in a
+ * different directory than the default of putting it alongside the
+ * generated subfiles. For example, when writing to node-local storage
+ * one may wish to place the configuration file on a scratch file
+ * system readable by all nodes, while the subfiles are initially
+ * written to the node-local storage.
+ *
+ * The value set for this environment variable is interpreted as a
+ * pathname that must already exist.
+ *
+ * NOTE: As this prefix string will be encoded in the driver info
+ *       message that gets written to the file, there is an upper
+ *       limit of about ~900 single-byte characters for this string,
+ *       though possibly less due to other information the driver
+ *       may encode. Avoid long prefix names where possible.
+ */
+#define H5FD_SUBFILING_CONFIG_FILE_PREFIX "H5FD_SUBFILING_CONFIG_FILE_PREFIX"
+
+/**
+ * \enum H5FD_subfiling_ioc_select_t
+ * This enum defines the various constants to allow different
+ * allocations of MPI ranks as I/O concentrators.
+ *
+ * \var SELECT_IOC_ONE_PER_NODE
+ *      Default selection method. One MPI rank per node is used as an
+ *      I/O concentrator. If this selection method is used, the number
+ *      of I/O concentrators per node can be adjusted with the
+ *      #H5FD_SUBFILING_IOC_PER_NODE environment variable.
+ *
+ * \var SELECT_IOC_EVERY_NTH_RANK
+ *      Starting with MPI rank 0, a stride of 'N' is applied to the MPI
+ *      rank values to determine the next I/O concentrator. The
+ *      #H5FD_SUBFILING_IOC_SELECTION_CRITERIA environment variable must
+ *      be set to the value desired for 'N'.
+ *
+ * \var SELECT_IOC_WITH_CONFIG
+ *      Currently unsupported. Use a configuration file to determine
+ *      the mapping from MPI ranks to I/O concentrators. The
+ *      #H5FD_SUBFILING_IOC_SELECTION_CRITERIA environment variable must
+ *      be set to the path to the configuration file.
+ *
+ * \var SELECT_IOC_TOTAL
+ *      Specifies that a total of 'N' I/O concentrators should be used.
+ *      Starting with MPI rank 0, a stride of 'MPI comm size' / 'N' is
+ *      applied to the MPI rank values to determine the next I/O
+ *      concentrator. The #H5FD_SUBFILING_IOC_SELECTION_CRITERIA
+ *      environment variable must be set to the value desired for 'N'.
+ *
+ * \var ioc_selection_options
+ *      Unused. Sentinel value
+ */
+typedef enum {
+    SELECT_IOC_ONE_PER_NODE = 0, /* Default                              */
+    SELECT_IOC_EVERY_NTH_RANK,   /* Starting at rank 0, select-next += N */
+    SELECT_IOC_WITH_CONFIG,      /* NOT IMPLEMENTED: Read-from-file      */
+    SELECT_IOC_TOTAL,            /* Starting at rank 0, mpi_size / total */
+    ioc_selection_options        /* Sentinel value                       */
+    /* NOTE: Add to the Fortran constants (H5f90global.F90)  when adding new entries */
+} H5FD_subfiling_ioc_select_t;
+
+/**
+ * \struct H5FD_subfiling_params_t
+ * \brief Subfiling parameter structure that is shared between the #H5FD_SUBFILING
+ *        and #H5FD_IOC drivers
+ *
+ * \var H5FD_subfiling_ioc_select_t H5FD_subfiling_params_t::ioc_selection
+ *      The method to use for selecting MPI ranks to be I/O concentrators. The
+ *      current default is to select one MPI rank per node to be an I/O concentrator.
+ *      Refer to #H5FD_subfiling_ioc_select_t for a description of the algorithms
+ *      available for use.
+ *
+ * \var int64_t H5FD_subfiling_params_t::stripe_size
+ *      The stripe size defines the size (in bytes) of the data stripes in the
+ *      subfiles for the logical HDF5 file. Data is striped across the subfiles
+ *      in a round-robin wrap-around fashion in segments equal to the stripe size.
+ *
+ *      For example, in an HDF5 file consisting of four subfiles with a 1MiB stripe
+ *      size, the first and fifth 1MiB of data would reside in the first subfile,
+ *      the second and sixth 1MiB of data would reside in the second subfile and so
+ *      on.
+ *
+ *      This value can also be set or adjusted with the #H5FD_SUBFILING_STRIPE_SIZE
+ *      environment variable.
+ *
+ * \var int32_t H5FD_subfiling_params_t::stripe_count
+ *      The target number of subfiles to use for the logical HDF5 file. The current
+ *      default is to use one subfile per node, but it can be useful to set a
+ *      different target number of subfiles, especially if the HDF5 application will
+ *      pre-create the HDF5 file on a single MPI rank. In that particular case, the
+ *      single rank will need to know how many subfiles the logical HDF5 file will
+ *      consist of in order to properly pre-create the file.
+ *
+ *      This value is used in conjunction with the IOC selection method to determine
+ *      which MPI ranks will be assigned as I/O concentrators. Alternatively, the
+ *      mapping between MPI ranks and I/O concentrators can be set or adjusted with a
+ *      combination of the #ioc_selection field and the #H5FD_SUBFILING_IOC_PER_NODE
+ *      and #H5FD_SUBFILING_IOC_SELECTION_CRITERIA environment variables.
+ */
+typedef struct H5FD_subfiling_params_t {
+    H5FD_subfiling_ioc_select_t ioc_selection; /* Method to select I/O concentrators          */
+    int64_t                     stripe_size;   /* Size (in bytes) of data stripes in subfiles */
+    int32_t                     stripe_count;  /* Target number of subfiles to use            */
+} H5FD_subfiling_params_t;
+
+//! <!-- [H5FD_subfiling_config_t_snip] -->
+/**
+ * \struct H5FD_subfiling_config_t
+ * \brief Configuration structure for H5Pset_fapl_subfiling() / H5Pget_fapl_subfiling()
+ *
+ * \details H5FD_subfiling_config_t is a public structure that is used to pass
+ *          subfiling configuration data to the #H5FD_SUBFILING driver via
+ *          a File Access Property List. A pointer to an instance of this structure
+ *          is a parameter to H5Pset_fapl_subfiling() and H5Pget_fapl_subfiling().
+ *
+ * \var uint32_t H5FD_subfiling_config_t::magic
+ *      A somewhat unique number which distinguishes the #H5FD_SUBFILING driver
+ *      from other drivers. Used in combination with a version number, it can
+ *      help to validate a user-generated File Access Property List. This field
+ *      should be set to #H5FD_SUBFILING_FAPL_MAGIC.
+ *
+ * \var uint32_t H5FD_subfiling_config_t::version
+ *      Version number of the H5FD_subfiling_config_t structure. Any instance
+ *      passed to H5Pset_fapl_subfiling() / H5Pget_fapl_subfiling() must have
+ *      a recognized version number or an error will be raised. Currently, this
+ *      field should be set to #H5FD_SUBFILING_CURR_FAPL_VERSION.
+ *
+ * \var hid_t H5FD_subfiling_config_t::ioc_fapl_id
+ *      The File Access Property List which is setup with the file driver that
+ *      the #H5FD_SUBFILING driver will use for servicing I/O requests to the
+ *      subfiles. Currently, the File Access Property List must be setup with
+ *      the #H5FD_IOC driver by calling H5Pset_fapl_ioc(), but future development
+ *      may allow other file drivers to be used.
+ *
+ * \var bool H5FD_subfiling_config_t::require_ioc
+ *      A boolean flag which indicates whether the #H5FD_SUBFILING driver should
+ *      use the #H5FD_IOC driver for its I/O operations. This field should currently
+ *      always be set to true.
+ *
+ * \var H5FD_subfiling_params_t H5FD_subfiling_config_t::shared_cfg
+ *      A structure which contains the subfiling parameters that are shared between
+ *      the #H5FD_SUBFILING and #H5FD_IOC drivers. This includes the subfile stripe
+ *      size, stripe count, IOC selection method, etc.
+ *
+ */
+typedef struct H5FD_subfiling_config_t {
+    uint32_t magic;                     /* Must be set to H5FD_SUBFILING_FAPL_MAGIC                         */
+    uint32_t version;                   /* Must be set to H5FD_SUBFILING_CURR_FAPL_VERSION                  */
+    hid_t    ioc_fapl_id;               /* The FAPL setup with the stacked VFD to use for I/O concentrators */
+    bool     require_ioc;               /* Whether to use the IOC VFD (currently must always be true)       */
+    H5FD_subfiling_params_t shared_cfg; /* Subfiling/IOC parameters (stripe size, stripe count, etc.)       */
+} H5FD_subfiling_config_t;
+//! <!-- [H5FD_subfiling_config_t_snip] -->
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief Internal routine to initialize #H5FD_SUBFILING driver. Not meant to be
+ *        called directly by an HDF5 application
+ */
+H5_DLL hid_t H5FD_subfiling_init(void);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Modifies the specified File Access Property List to use the #H5FD_SUBFILING driver
+ *
+ * \fapl_id
+ * \param[in] vfd_config Pointer to #H5FD_SUBFILING driver configuration structure. May be NULL.
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_subfiling() modifies the File Access Property List to use the
+ *          #H5FD_SUBFILING driver.
+ *
+ *          The #H5FD_SUBFILING driver is an MPI-based file driver that allows an
+ *          HDF5 application to distribute a logical HDF5 file across a collection
+ *          of "subfiles" in equal-sized data segment "stripes". I/O to the logical
+ *          HDF5 file is then directed to the appropriate "subfile" according to the
+ *          #H5FD_SUBFILING configuration and a system of I/O concentrators, which
+ *          are MPI ranks operating worker threads.
+ *
+ *          By allowing a configurable stripe size, number of I/O concentrators and
+ *          method for selecting MPI ranks as I/O concentrators, the #H5FD_SUBFILING
+ *          driver aims to enable an HDF5 application to find a middle ground between
+ *          the single shared file and file-per-process approaches to parallel file I/O
+ *          for the particular machine the application is running on. In general, the
+ *          goal is to avoid some of the complexity of the file-per-process approach
+ *          while also minimizing the locking issues of the single shared file approach
+ *          on a parallel file system.
+ *
+ * \note Since the #H5FD_SUBFILING driver is an MPI-based file driver, the HDF5
+ *       application should ensure that H5Pset_mpi_params() is called before this
+ *       routine so that the appropriate MPI communicator and info objects will be
+ *       setup for use by the #H5FD_SUBFILING and #H5FD_IOC drivers.
+ *
+ * \note The current architecture of the #H5FD_SUBFILING driver requires that the
+ *       HDF5 application must have been initialized with MPI_Init_thread() using
+ *       a value of MPI_THREAD_MULTIPLE for the thread support level.
+ *
+ * \note The \p vfd_config parameter may be NULL. In this case, the reference
+ *       implementation I/O concentrator VFD will be used with the default settings
+ *       of one I/O concentrator per node and a stripe size of 32MiB. Refer to the
+ *       H5FD_subfiling_config_t documentation for information about configuration
+ *       for the #H5FD_SUBFILING driver.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5Pset_fapl_subfiling(hid_t fapl_id, const H5FD_subfiling_config_t *vfd_config);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Queries a File Access Property List for #H5FD_SUBFILING file driver properties
+ *
+ * \fapl_id
+ * \param[out] config_out Pointer to H5FD_subfiling_config_t structure through which the
+ *                        #H5FD_SUBFILING file driver properties will be returned.
+ *
+ * \returns \herr_t
+ *
+ * \details H5Pget_fapl_subfiling() queries the specified File Access Property List for
+ *          #H5FD_SUBFILING driver properties as set by H5Pset_fapl_subfiling(). If the
+ *          #H5FD_SUBFILING driver has not been set on the File Access Property List, a
+ *          default configuration is returned. An HDF5 application may use this
+ *          functionality to manually configure the #H5FD_SUBFILING driver by calling
+ *          H5Pget_fapl_subfiling() on a newly-created File Access Property List, adjusting
+ *          the default values and then calling H5Pset_fapl_subfiling() with the configured
+ *          H5FD_subfiling_config_t structure.
+ *
+ * \note H5Pget_fapl_subfiling() returns the #H5FD_SUBFILING driver properties as they
+ *       were initially set for the File Access Property List using H5Pset_fapl_subfiling().
+ *       Alternatively, the driver properties can be modified at runtime according to values
+ *       set for the #H5FD_SUBFILING_STRIPE_SIZE, #H5FD_SUBFILING_IOC_PER_NODE and
+ *       #H5FD_SUBFILING_IOC_SELECTION_CRITERIA environment variables. However, driver
+ *       properties set through environment variables will not be reflected in what is
+ *       returned by H5Pget_fapl_subfiling(), so an application may need to check those
+ *       environment variables to get accurate values for the #H5FD_SUBFILING driver
+ *       properties.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5Pget_fapl_subfiling(hid_t fapl_id, H5FD_subfiling_config_t *config_out);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5_HAVE_SUBFILING_VFD */
+
+#endif /* H5FDsubfiling_H */
diff --git a/install/include/H5FDwindows.h b/install/include/H5FDwindows.h
new file mode 100644
index 0000000000..673d1c93b5
--- /dev/null
+++ b/install/include/H5FDwindows.h
@@ -0,0 +1,66 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the Windows virtual file driver (VFD)
+ *
+ *          This VFD uses no Win32 API calls directly (though it may be
+ *          rewritten to do so in the future). It is currently defined to
+ *          be the sec2 VFD.
+ */
+#ifndef H5FDwindows_H
+#define H5FDwindows_H
+
+/** Initializer for the Windows VFD */
+#define H5FD_WINDOWS (H5FD_sec2_init())
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the Windows I/O driver
+ *
+ * \fapl_id
+ * \returns \herr_t
+ *
+ * \details H5Pset_fapl_windows() sets the default HDF5 Windows I/O driver on
+ *          Windows systems.
+ *
+ *          Since the HDF5 library uses this driver, #H5FD_WINDOWS, by default
+ *          on Windows systems, it is not normally necessary for a user
+ *          application to call H5Pset_fapl_windows(). While it is not
+ *          recommended, there may be times when a user chooses to set a
+ *          different HDF5 driver, such as the standard I/O driver (#H5FD_STDIO)
+ *          or the sec2 driver (#H5FD_SEC2), in a Windows
+ *          application. H5Pset_fapl_windows() is provided so that the
+ *          application can return to the Windows I/O driver when the time
+ *          comes.
+ *
+ *          Only the Windows driver is tested on Windows systems; other drivers
+ *          are used at the application's and the user's risk.
+ *
+ *          Furthermore, the Windows driver is tested and available only on
+ *          Windows systems; it is not available on non-Windows systems.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_fapl_windows(hid_t fapl_id);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* H5FDwindows_H */
diff --git a/install/include/H5Fpublic.h b/install/include/H5Fpublic.h
new file mode 100644
index 0000000000..34a92ac517
--- /dev/null
+++ b/install/include/H5Fpublic.h
@@ -0,0 +1,1928 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5F module.
+ */
+#ifndef H5Fpublic_H
+#define H5Fpublic_H
+
+#include "H5public.h"   /* Generic Functions                        */
+#include "H5ACpublic.h" /* Metadata Cache                           */
+#include "H5Ipublic.h"  /* Identifiers                              */
+
+/* When this header is included from a private header, don't make calls to H5check() */
+#undef H5CHECK
+#ifndef H5private_H
+#define H5CHECK H5check(),
+#else /* H5private_H */
+#define H5CHECK
+#endif /* H5private_H */
+
+/* When this header is included from a private HDF5 header, don't make calls to H5open() */
+#undef H5OPEN
+#ifndef H5private_H
+#define H5OPEN H5open(),
+#else /* H5private_H */
+#define H5OPEN
+#endif /* H5private_H */
+
+/*
+ * These are the bits that can be passed to the `flags' argument of
+ * H5Fcreate() and H5Fopen(). Use the bit-wise OR operator (|) to combine
+ * them as needed.  As a side effect, they call H5check_version() to make sure
+ * that the application is compiled with a version of the hdf5 header files
+ * which are compatible with the library to which the application is linked.
+ * We're assuming that these constants are used rather early in the hdf5
+ * session.
+ */
+#define H5F_ACC_RDONLY (H5CHECK H5OPEN 0x0000u) /**< Absence of RDWR: read-only */
+#define H5F_ACC_RDWR   (H5CHECK H5OPEN 0x0001u) /**< Open for read and write    */
+#define H5F_ACC_TRUNC  (H5CHECK H5OPEN 0x0002u) /**< Overwrite existing files   */
+#define H5F_ACC_EXCL   (H5CHECK H5OPEN 0x0004u) /**< Fail if file already exists*/
+/* NOTE: 0x0008u was H5F_ACC_DEBUG, now deprecated */
+#define H5F_ACC_CREAT (H5CHECK H5OPEN 0x0010u) /**< Create non-existing files  */
+#define H5F_ACC_SWMR_WRITE                                                                                   \
+    (H5CHECK 0x0020u) /**< Indicate that this file is open for writing in a                                  \
+                       *   single-writer/multi-reader (SWMR)  scenario.                                      \
+                       *   Note that the process(es) opening the file for reading                            \
+                       *   must open the file with #H5F_ACC_RDONLY and use the                               \
+                       *   #H5F_ACC_SWMR_READ access flag. */
+#define H5F_ACC_SWMR_READ                                                                                    \
+    (H5CHECK 0x0040u) /**< Indicate that this file is open for reading in a                                  \
+                       * single-writer/multi-reader (SWMR) scenario. Note that                               \
+                       * the process(es) opening the file for SWMR reading must                              \
+                       * also open the file with the #H5F_ACC_RDONLY flag.  */
+
+/**
+ * Default property list identifier
+ *
+ * \internal Value passed to H5Pset_elink_acc_flags to cause flags to be taken from the parent file.
+ * \internal ignore setting on lapl
+ */
+#define H5F_ACC_DEFAULT (H5CHECK H5OPEN 0xffffu)
+
+/* Flags for H5Fget_obj_count() & H5Fget_obj_ids() calls */
+#define H5F_OBJ_FILE     (0x0001u) /**< File objects */
+#define H5F_OBJ_DATASET  (0x0002u) /**< Dataset objects */
+#define H5F_OBJ_GROUP    (0x0004u) /**< Group objects */
+#define H5F_OBJ_DATATYPE (0x0008u) /**< Named datatype objects */
+#define H5F_OBJ_ATTR     (0x0010u) /**< Attribute objects */
+#define H5F_OBJ_ALL      (H5F_OBJ_FILE | H5F_OBJ_DATASET | H5F_OBJ_GROUP | H5F_OBJ_DATATYPE | H5F_OBJ_ATTR)
+#define H5F_OBJ_LOCAL                                                                                        \
+    (0x0020u) /**< Restrict search to objects opened through current file ID                                 \
+                   (as opposed to objects opened through any file ID accessing this file) */
+
+#define H5F_FAMILY_DEFAULT 0 /* (hsize_t) */
+
+#ifdef H5_HAVE_PARALLEL
+/**
+ * Use this constant string as the MPI_Info key to set H5Fmpio debug flags.
+ * To turn on H5Fmpio debug flags, set the MPI_Info value with this key to
+ * have the value of a string consisting of the characters that turn on the
+ * desired flags.
+ */
+#define H5F_MPIO_DEBUG_KEY "H5F_mpio_debug_key"
+#endif /* H5_HAVE_PARALLEL */
+
+/**
+ * The scope of an operation such as H5Fflush(), e.g.,
+ * a single file vs. a set of mounted files
+ */
+typedef enum H5F_scope_t {
+    H5F_SCOPE_LOCAL  = 0, /**< The specified file handle only */
+    H5F_SCOPE_GLOBAL = 1  /**< The entire virtual file        */
+} H5F_scope_t;
+
+/**
+ * Unlimited file size for H5Pset_external()
+ */
+#define H5F_UNLIMITED HSIZE_UNDEF
+
+/**
+ * How does file close behave?
+ */
+typedef enum H5F_close_degree_t {
+    H5F_CLOSE_DEFAULT = 0, /**< Use the degree pre-defined by underlying VFD */
+    H5F_CLOSE_WEAK    = 1, /**< File closes only after all opened objects are closed */
+    H5F_CLOSE_SEMI    = 2, /**< If no opened objects, file is closed; otherwise, file close fails */
+    H5F_CLOSE_STRONG  = 3  /**< If there are opened objects, close them first, then close file */
+} H5F_close_degree_t;
+
+/**
+ * Current "global" information about file
+ */
+//! <!-- [H5F_info2_t_snip] -->
+typedef struct H5F_info2_t {
+    struct {
+        unsigned version;        /**< Superblock version number */
+        hsize_t  super_size;     /**< Superblock size */
+        hsize_t  super_ext_size; /**< Superblock extension size */
+    } super;
+    struct {
+        unsigned version;   /**< Version number of file free space management */
+        hsize_t  meta_size; /**< Free space manager metadata size */
+        hsize_t  tot_space; /**< Amount of free space in the file */
+    } free;
+    struct {
+        unsigned     version;   /**< Version number of shared object header info */
+        hsize_t      hdr_size;  /**< Shared object header message header size */
+        H5_ih_info_t msgs_info; /**< Shared object header message index & heap size */
+    } sohm;
+} H5F_info2_t;
+//! <!-- [H5F_info2_t_snip] -->
+
+/**
+ * Types of allocation requests. The values larger than #H5FD_MEM_DEFAULT
+ * should not change other than adding new types to the end. These numbers
+ * might appear in files.
+ *
+ * \internal Please change the log VFD flavors array if you change this
+ *           enumeration.
+ */
+typedef enum H5F_mem_t {
+    H5FD_MEM_NOLIST = -1, /**< Data should not appear in the free list.
+                           * Must be negative.
+                           */
+    H5FD_MEM_DEFAULT = 0, /**< Value not yet set.  Can also be the
+                           * datatype set in a larger allocation
+                           * that will be suballocated by the library.
+                           * Must be zero.
+                           */
+    H5FD_MEM_SUPER = 1,   /**< Superblock data */
+    H5FD_MEM_BTREE = 2,   /**< B-tree data */
+    H5FD_MEM_DRAW  = 3,   /**< Raw data (content of datasets, etc.) */
+    H5FD_MEM_GHEAP = 4,   /**< Global heap data */
+    H5FD_MEM_LHEAP = 5,   /**< Local heap data */
+    H5FD_MEM_OHDR  = 6,   /**< Object header data */
+
+    H5FD_MEM_NTYPES /**< Sentinel value - must be last */
+} H5F_mem_t;
+
+/**
+ * Free space section information
+ */
+//! <!-- [H5F_sect_info_t_snip] -->
+typedef struct H5F_sect_info_t {
+    haddr_t addr; /**< Address of free space section */
+    hsize_t size; /**< Size of free space section */
+} H5F_sect_info_t;
+//! <!-- [H5F_sect_info_t_snip] -->
+
+/**
+ * Library's format versions
+ */
+typedef enum H5F_libver_t {
+    H5F_LIBVER_ERROR    = -1,
+    H5F_LIBVER_EARLIEST = 0, /**< Use the earliest possible format for storing objects */
+    H5F_LIBVER_V18      = 1, /**< Use the latest v18 format for storing objects */
+    H5F_LIBVER_V110     = 2, /**< Use the latest v110 format for storing objects */
+    H5F_LIBVER_V112     = 3, /**< Use the latest v112 format for storing objects */
+    H5F_LIBVER_V114     = 4, /**< Use the latest v114 format for storing objects */
+    H5F_LIBVER_V116     = 5, /**< Use the latest v116 format for storing objects */
+    H5F_LIBVER_NBOUNDS       /**< Sentinel */
+} H5F_libver_t;
+
+#define H5F_LIBVER_LATEST H5F_LIBVER_V116
+
+/**
+ * File space handling strategy
+ */
+//! <!-- [H5F_fspace_strategy_t_snip] -->
+typedef enum H5F_fspace_strategy_t {
+    H5F_FSPACE_STRATEGY_FSM_AGGR = 0, /**< Mechanisms: free-space managers, aggregators, and virtual file
+                                         drivers This is the library default when not set */
+    H5F_FSPACE_STRATEGY_PAGE =
+        1, /**< Mechanisms: free-space managers with embedded paged aggregation and virtual file drivers */
+    H5F_FSPACE_STRATEGY_AGGR = 2, /**< Mechanisms: aggregators and virtual file drivers */
+    H5F_FSPACE_STRATEGY_NONE = 3, /**< Mechanisms: virtual file drivers */
+    H5F_FSPACE_STRATEGY_NTYPES    /**< Sentinel */
+} H5F_fspace_strategy_t;
+//! <!-- [H5F_fspace_strategy_t_snip] -->
+
+/**
+ * File space handling strategy for release 1.10.0
+ *
+ * \deprecated 1.10.1
+ */
+typedef enum H5F_file_space_type_t {
+    H5F_FILE_SPACE_DEFAULT     = 0, /**< Default (or current) free space strategy setting */
+    H5F_FILE_SPACE_ALL_PERSIST = 1, /**< Persistent free space managers, aggregators, virtual file driver */
+    H5F_FILE_SPACE_ALL         = 2, /**< Non-persistent free space managers, aggregators, virtual file driver
+                                         This is the library default */
+    H5F_FILE_SPACE_AGGR_VFD = 3,    /**< Aggregators, Virtual file driver */
+    H5F_FILE_SPACE_VFD      = 4,    /**< Virtual file driver */
+    H5F_FILE_SPACE_NTYPES           /**< Sentinel */
+} H5F_file_space_type_t;
+
+//! <!-- [H5F_retry_info_t_snip] -->
+#define H5F_NUM_METADATA_READ_RETRY_TYPES 21
+
+/**
+ * Data structure to report the collection of read retries for metadata items with checksum as
+ * used by H5Fget_metadata_read_retry_info()
+ */
+typedef struct H5F_retry_info_t {
+    unsigned  nbins;
+    uint32_t *retries[H5F_NUM_METADATA_READ_RETRY_TYPES];
+} H5F_retry_info_t;
+//! <!-- [H5F_retry_info_t_snip] -->
+
+/**
+ * Callback for H5Pset_object_flush_cb() in a file access property list
+ */
+typedef herr_t (*H5F_flush_cb_t)(hid_t object_id, void *udata);
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \ingroup H5F
+ *
+ * \brief Checks if a file can be opened with a given file access property
+ *        list
+ *
+ * \param[in] container_name Name of a file
+ * \fapl_id
+ *
+ * \return \htri_t
+ *
+ * \details H5Fis_accessible() checks if the file specified by \p
+ *          container_name can be opened with the file access property list
+ *          \p fapl_id.
+ *
+ * \note The H5Fis_accessible() function enables files to be checked with a
+ *       given file access property list, unlike H5Fis_hdf5(), which only uses
+ *       the default file driver when opening a file.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL htri_t H5Fis_accessible(const char *container_name, hid_t fapl_id);
+/**
+ * \ingroup H5F
+ *
+ * \brief Creates an HDF5 file
+ *
+ * \param[in] filename Name of the file to create
+ * \param[in] flags    File access flags. Allowable values are:
+ *                     - #H5F_ACC_TRUNC: Truncate file, if it already exists,
+ *                       erasing all data previously stored in the file
+ *                     - #H5F_ACC_EXCL: Fail if file already exists
+ * \fcpl_id
+ * \fapl_id
+ * \return \hid_t{file}
+ *
+ * \details H5Fcreate() is the primary function for creating HDF5 files; it
+ *          creates a new HDF5 file with the specified name and property lists.
+ *
+ *          The \p filename parameter specifies the name of the new file.
+ *
+ *          The \p flags parameter specifies whether an existing file is to be
+ *          overwritten. It should be set to either #H5F_ACC_TRUNC to overwrite
+ *          an existing file or #H5F_ACC_EXCL, instructing the function to fail
+ *          if the file already exists.
+ *
+ *          New files are always created in read-write mode, so the read-write
+ *          and read-only flags, #H5F_ACC_RDWR and #H5F_ACC_RDONLY,
+ *          respectively, are not relevant in this function. Further note that
+ *          a specification of #H5F_ACC_RDONLY will be ignored; the file will
+ *          be created in read-write mode, regardless.
+ *
+ *          More complex behaviors of file creation and access are controlled
+ *          through the file creation and file access property lists,
+ *          \p fcpl_id and \p fapl_id, respectively. The value of #H5P_DEFAULT
+ *          for any property list value indicates that the library should use
+ *          the default values for that appropriate property list.
+ *
+ *          The return value is a file identifier for the newly-created file;
+ *          this file identifier should be closed by calling H5Fclose() when
+ *          it is no longer needed.
+ *
+ * \par Example
+ * \snippet H5F_examples.c minimal
+ *
+ * \note  #H5F_ACC_TRUNC and #H5F_ACC_EXCL are mutually exclusive; use
+ *        exactly one.
+ *
+ * \note An additional flag, #H5F_ACC_DEBUG, prints debug information. This
+ *       flag can be combined with one of the above values using the bit-wise
+ *       OR operator (\c |), but it is used only by HDF5 library developers;
+ *       \Emph{it is neither tested nor supported for use in applications}.
+ *
+ * \attention \Bold{Special case  File creation in the case of an already-open file:}
+ *            If a file being created is already opened, by either a previous
+ *            H5Fopen() or H5Fcreate() call, the HDF5 library may or may not
+ *            detect that the open file and the new file are the same physical
+ *            file. (See H5Fopen() regarding the limitations in detecting the
+ *            re-opening of an already-open file.)\n
+ *            If the library detects that the file is already opened,
+ *            H5Fcreate() will return a failure, regardless of the use of
+ *            #H5F_ACC_TRUNC.\n
+ *            If the library does not detect that the file is already opened
+ *            and #H5F_ACC_TRUNC is not used, H5Fcreate() will return a failure
+ *            because the file already exists. Note that this is correct
+ *            behavior.\n
+ *            But if the library does not detect that the file is already
+ *            opened and #H5F_ACC_TRUNC is used, H5Fcreate() will truncate the
+ *            existing file and return a valid file identifier. Such a
+ *            truncation of a currently-opened file will almost certainly
+ *            result in errors. While unlikely, the HDF5 library may not be
+ *            able to detect, and thus report, such errors.\n
+ *            Applications should avoid calling H5Fcreate() with an already
+ *            opened file.
+ *
+ * \since 1.0.0
+ *
+ * \see H5Fopen(), H5Fclose()
+ *
+ */
+H5_DLL hid_t H5Fcreate(const char *filename, unsigned flags, hid_t fcpl_id, hid_t fapl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Fcreate}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Fcreate_async(const char *app_file, const char *app_func, unsigned app_line,
+                             const char *filename, unsigned flags, hid_t fcpl_id, hid_t fapl_id, hid_t es_id);
+#else
+H5_DLL hid_t H5Fcreate_async(const char *filename, unsigned flags, hid_t fcpl_id, hid_t fapl_id, hid_t es_id);
+#endif
+/**
+ * \ingroup H5F
+ *
+ * \brief Opens an existing HDF5 file
+ *
+ * \param[in] filename Name of the file to be opened
+ * \param[in] flags    File access flags. Allowable values are:
+ *                     - #H5F_ACC_RDWR: Allows read and write access to file
+ *                     - #H5F_ACC_RDONLY: Allows read-only access to file
+ *                     - #H5F_ACC_RDWR \c | #H5F_ACC_SWMR_WRITE: Indicates that
+ *                       the file is open for writing in a
+ *                       single-writer/multi-writer (SWMR) scenario.
+ *                     - #H5F_ACC_RDONLY \c | #H5F_ACC_SWMR_READ:  Indicates
+ *                       that the file is open for reading in a
+ *                       single-writer/multi-reader (SWMR) scenario.
+ *                     - An additional flag, #H5F_ACC_DEBUG, prints debug
+ *                       information. This flag can be combined with one of the
+ *                       above values using the bit-wise OR operator (\c |), but
+ *                       it is used only by HDF5 library developers;
+ *                       \Emph{it is neither tested nor supported} for use in
+ *                       applications.
+ * \fapl_id
+ * \return \hid_t{file}
+ *
+ * \details H5Fopen() is the primary function for accessing existing HDF5 files.
+ *          This function opens the named file in the specified access mode and
+ *          with the specified access property list.
+ *
+ *          Note that H5Fopen() does not create a file if it does not already
+ *          exist; see H5Fcreate().
+ *
+ *          The \p filename parameter specifies the name of the file to be
+ *          opened.
+ *
+ *          The \p fapl_id parameter specifies the file access property list.
+ *          The use of #H5P_DEFAULT specifies that default I/O access properties
+ *          are to be used.
+ *
+ *          The \p flags parameter specifies whether the file will be opened in
+ *          read-write or read-only mode, #H5F_ACC_RDWR or #H5F_ACC_RDONLY,
+ *          respectively. More complex behaviors of file access are controlled
+ *          through the file-access property list.
+ *
+ *          The return value is a file identifier for the open file; this file
+ *          identifier should be closed by calling H5Fclose() when it is no
+ *          longer needed.
+ *
+ * \par Example
+ * \snippet H5F_examples.c open
+ *
+ * \note  #H5F_ACC_RDWR and #H5F_ACC_RDONLY are mutually exclusive; use
+ *        exactly one.
+ *
+ * \attention \Bold{Special cases  Multiple opens:} A file can often be opened
+ *            with a new H5Fopen() call without closing an already-open
+ *            identifier established in a previous H5Fopen() or H5Fcreate()
+ *            call. Each such H5Fopen() call will return a unique identifier
+ *            and the file can be accessed through any of these identifiers as
+ *            long as the identifier remains valid. In such multiply-opened
+ *            cases, the open calls must use the same flags argument and the
+ *            file access property lists must use the same file close degree
+ *            property setting (see the external link discussion below and
+ *            H5Pset_fclose_degree()).\n
+ *            In some cases, such as files on a local Unix file system, the
+ *            HDF5 library can detect that a file is multiply opened and will
+ *            maintain coherent access among the file identifiers.\n
+ *            But in many other cases, such as parallel file systems or
+ *            networked file systems, it is not always possible to detect
+ *            multiple opens of the same physical file. In such cases, HDF5
+ *            will treat the file identifiers as though they are accessing
+ *            different files and will be unable to maintain coherent access.
+ *            Errors are likely to result in these cases. While unlikely, the
+ *            HDF5 library may not be able to detect, and thus report,
+ *            such errors.\n
+ *            It is generally recommended that applications avoid multiple
+ *            opens of the same file.
+ *
+ * \attention \Bold{Special restriction on multiple opens of a file first
+ *            opened by means of an external link:} When an external link is
+ *            followed, the external file is always opened with the weak file
+ *            close degree property setting, #H5F_CLOSE_WEAK (see
+ *            H5Lcreate_external() and H5Pset_fclose_degree()). If the file is
+ *            reopened with H5Fopen while it remains held open from such an
+ *            external link call, the file access property list used in the
+ *            open call must include the file close degree setting
+ *            #H5F_CLOSE_WEAK or the open will fail.
+ *
+ * \version 1.10.0 The #H5F_ACC_SWMR_WRITE and #H5F_ACC_SWMR_READ flags were added.
+ *
+ * \see H5Fclose()
+ *
+ */
+H5_DLL hid_t H5Fopen(const char *filename, unsigned flags, hid_t fapl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Fopen}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Fopen_async(const char *app_file, const char *app_func, unsigned app_line,
+                           const char *filename, unsigned flags, hid_t access_plist, hid_t es_id);
+#else
+H5_DLL hid_t H5Fopen_async(const char *filename, unsigned flags, hid_t access_plist, hid_t es_id);
+#endif
+/**
+ * \ingroup H5F
+ *
+ * \brief Returns a new identifier for a previously-opened HDF5 file
+ *
+ * \param[in] file_id Identifier of a file for which an additional identifier
+ *                    is required
+ *
+ * \return \hid_t{file}
+ *
+ * \details H5Freopen() returns a new file identifier for an already-open HDF5
+ *          file, as specified by \p file_id. Both identifiers share caches and
+ *          other information. The only difference between the identifiers is
+ *          that the new identifier is not mounted anywhere and no files are
+ *          mounted on it.
+ *
+ *          The new file identifier should be closed by calling H5Fclose() when
+ *          it is no longer needed.
+ *
+ * \note Note that there is no circumstance under which H5Freopen() can
+ *       actually open a closed file; the file must already be open and have an
+ *       active \p file_id. E.g., one cannot close a file with H5Fclose() on
+ *       \p file_id then use H5Freopen() on \p file_id to reopen it.
+ *
+ */
+H5_DLL hid_t H5Freopen(hid_t file_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Freopen}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Freopen_async(const char *app_file, const char *app_func, unsigned app_line, hid_t file_id,
+                             hid_t es_id);
+#else
+H5_DLL hid_t H5Freopen_async(hid_t file_id, hid_t es_id);
+#endif
+/**
+ * \ingroup H5F
+ *
+ * \brief Flushes all buffers associated with a file to storage
+ *
+ * \loc_id{object_id}
+ * \param[in] scope The scope of the flush action
+ *
+ * \return \herr_t
+ *
+ * \details H5Fflush() causes all buffers associated with a file to be
+ *          immediately flushed to storage without removing the data from the
+ *          cache.
+ *
+ *          \p object_id can be any object associated with the file, including
+ *          the file itself, a dataset, a group, an attribute, or a named
+ *          datatype.
+ *
+ *          \p scope specifies whether the scope of the flush action is
+ *          global or local. Valid values are as follows:
+ *          \scopes
+ *
+ * \par Example
+ * \snippet H5F_examples.c flush
+ *
+ * \attention HDF5 does not possess full control over buffering. H5Fflush()
+ *            flushes the internal HDF5 buffers and then asks the operating system
+ *            (the OS) to flush the system buffers for the open files. After
+ *            that, the OS is responsible for ensuring that the data is
+ *            actually flushed to disk.
+ *
+ */
+H5_DLL herr_t H5Fflush(hid_t object_id, H5F_scope_t scope);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Fflush}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Fflush_async(const char *app_file, const char *app_func, unsigned app_line, hid_t object_id,
+                             H5F_scope_t scope, hid_t es_id);
+#else
+H5_DLL herr_t H5Fflush_async(hid_t object_id, H5F_scope_t scope, hid_t es_id);
+#endif
+/**
+ * \ingroup H5F
+ *
+ * \brief Terminates access to an HDF5 file
+ *
+ * \file_id
+ * \return \herr_t
+ *
+ * \details H5Fclose() terminates access to an HDF5 file (specified by
+ *          \p file_id) by flushing all data to storage.
+ *
+ *          If this is the last file identifier open for the file and no other
+ *          access identifier is open (e.g., a dataset identifier, group
+ *          identifier, or shared datatype identifier), the file will be fully
+ *          closed and access will end.
+ *
+ * \par Example
+ * \snippet H5F_examples.c minimal
+ *
+ * \note \Bold{Delayed close:} Note the following deviation from the
+ *       above-described behavior. If H5Fclose() is called for a file, but one
+ *       or more objects within the file remain open, those objects will remain
+ *       accessible until they are individually closed. Thus, if the dataset
+ *       \c data_sample is open when H5Fclose() is called for the file
+ *       containing it, \c data_sample will remain open and accessible
+ *       (including writable) until it is explicitly closed. The file will be
+ *       automatically closed once all objects in the file have been closed.\n
+ *       Be warned, however, that there are circumstances where it is not
+ *       possible to delay closing a file. For example, an MPI-IO file close is
+ *       a collective call; all of the processes that open the file must
+ *       close it collectively. The file cannot be closed at some time in the
+ *       future by each process in an independent fashion. Another example is
+ *       that an application using an AFS token-based file access privilege may
+ *       destroy its AFS token after H5Fclose() has returned successfully. This
+ *       would make any future access to the file, or any object within it,
+ *       illegal.\n
+ *       In such situations, applications must close all open objects in a file
+ *       before calling H5Fclose. It is generally recommended to do so in all
+ *       cases.
+ *
+ * \see H5Fopen()
+ *
+ */
+H5_DLL herr_t H5Fclose(hid_t file_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Fclose}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Fclose_async(const char *app_file, const char *app_func, unsigned app_line, hid_t file_id,
+                             hid_t es_id);
+#else
+H5_DLL herr_t H5Fclose_async(hid_t file_id, hid_t es_id);
+#endif
+/**
+ * \ingroup H5F
+ *
+ * \brief Deletes an HDF5 file
+ *
+ * \param[in] filename Name of the file to delete
+ * \fapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Fdelete() deletes an HDF5 file \p filename with a file access
+ *          property list \p fapl_id. The \p fapl_id should be configured with
+ *          the same VOL connector or VFD that was used to open the file.
+ *
+ *          This API was introduced for use with the Virtual Object Layer
+ *          (VOL). With the VOL, HDF5 "files" can map to arbitrary storage
+ *          schemes such as object stores and relational database tables. The
+ *          data created by these implementations may be inconvenient for a
+ *          user to remove without a detailed knowledge of the storage scheme.
+ *          H5Fdelete() gives VOL connector authors the ability to add
+ *          connector-specific delete code to their connectors so that users
+ *          can remove these "files" without detailed knowledge of the storage
+ *          scheme.
+ *
+ *          For a VOL connector, H5Fdelete() deletes the file in a way that
+ *          makes sense for the specified VOL connector.
+ *
+ *          For the native HDF5 connector, HDF5 files will be deleted via the
+ *          VFDs, each of which will have to be modified to delete the files it
+ *          creates.
+ *
+ *          For all implementations, H5Fdelete() will first check if the file
+ *          is an HDF5 file via H5Fis_accessible(). This is done to ensure that
+ *          H5Fdelete() cannot be used as an arbitrary file deletion call.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Fdelete(const char *filename, hid_t fapl_id);
+/**
+ * \ingroup H5F
+ *
+ * \brief Returns a file creation property list identifier
+ *
+ * \file_id
+ * \return \hid_t{file creation property list}
+ *
+ * \details H5Fget_create_plist() returns the file creation property list
+ *          identifier identifying the creation properties used to create this
+ *          file. This function is useful for duplicating properties when
+ *          creating another file.
+ *
+ *          The creation property list identifier should be released with
+ *          H5Pclose().
+ *
+ */
+H5_DLL hid_t H5Fget_create_plist(hid_t file_id);
+/**
+ * \ingroup H5F
+ *
+ * \brief Returns a file access property list identifier
+ *
+ * \file_id
+ * \return \hid_t{file access property list}
+ *
+ * \details H5Fget_access_plist() returns the file access property list
+ *          identifier of the specified file.
+ *
+ */
+H5_DLL hid_t H5Fget_access_plist(hid_t file_id);
+/**
+ * \ingroup H5F
+ *
+ * \brief Determines the read/write or read-only status of a file
+ *
+ * \file_id
+ * \param[out] intent Access mode flag as originally passed with H5Fopen()
+ *
+ * \return \herr_t
+ *
+ * \details Given the identifier of an open file, \p file_id, H5Fget_intent()
+ *          retrieves the intended access mode" flag passed with H5Fopen() when
+ *          the file was opened.
+ *
+ *          The value of the flag is returned in \p intent. Valid values are as
+ *          follows:
+ *          \file_access
+ *
+ * \note The function will not return an error if intent is NULL; it will
+ *       simply do nothing.
+ *
+ * \version 1.10.0 Function enhanced to work with SWMR functionality.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Fget_intent(hid_t file_id, unsigned *intent);
+/**
+ * \ingroup H5F
+ *
+ * \brief Retrieves a file's file number that uniquely identifies an open file
+ *
+ * \file_id
+ * \param[out] fileno A buffer to hold the file number
+ *
+ * \return \herr_t
+ *
+ * \details H5Fget_fileno() retrieves a file number for a file specified by the
+ *          file identifier \p file_id and the pointer \p fnumber to the file
+ *          number.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Fget_fileno(hid_t file_id, unsigned long *fileno);
+/**
+ * \ingroup H5F
+ *
+ * \brief Returns the number of open object identifiers for an open file
+ *
+ * \file_id or #H5F_OBJ_ALL for all currently-open HDF5 files
+ * \param[in] types Type of object for which identifiers are to be returned
+ *
+ * \return Returns the number of open objects if successful; otherwise returns
+ *         a negative value.
+ *
+ * \details Given the identifier of an open file, file_id, and the desired
+ *          object types, types, H5Fget_obj_count() returns the number of open
+ *          object identifiers for the file.
+ *
+ *          To retrieve a count of open identifiers for open objects in all
+ *          HDF5 application files that are currently open, pass the value
+ *          #H5F_OBJ_ALL in \p file_id.
+ *
+ *          The types of objects to be counted are specified in types as
+ *          follows:
+ *          \obj_types
+ *
+ *          Multiple object types can be combined with the
+ *          logical \c OR operator (|). For example, the expression
+ *          \c (#H5F_OBJ_DATASET|#H5F_OBJ_GROUP) would call for datasets and
+ *          groups.
+ *
+ * \version 1.6.8, 1.8.2 Function return type changed to \c ssize_t.
+ * \version 1.6.5 #H5F_OBJ_LOCAL has been added as a qualifier on the types
+ *                of objects to be counted. #H5F_OBJ_LOCAL restricts the
+ *                search to objects opened through current file identifier.
+ *
+ */
+H5_DLL ssize_t H5Fget_obj_count(hid_t file_id, unsigned types);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5F
+ *
+ * \brief Returns a list of open object identifiers
+ *
+ * \file_id or #H5F_OBJ_ALL for all currently-open HDF5 files
+ * \param[in] types Type of object for which identifiers are to be returned
+ * \param[in] max_objs Maximum number of object identifiers to place into
+ *                     \p obj_id_list
+ * \param[out] obj_id_list Pointer to the returned buffer of open object
+ *                         identifiers
+ *
+ * \return Returns number of objects placed into \p obj_id_list if successful;
+ *         otherwise returns a negative value.
+ *
+ * \details Given the file identifier \p file_id and the type of objects to be
+ *          identified, types, H5Fget_obj_ids() returns the list of identifiers
+ *          for all open HDF5 objects fitting the specified criteria.
+ *
+ *          To retrieve identifiers for open objects in all HDF5 application
+ *          files that are currently open, pass the value #H5F_OBJ_ALL in
+ *          \p file_id.
+ *
+ *          The types of object identifiers to be retrieved are specified in
+ *          types using the codes listed for the same parameter in
+ *          H5Fget_obj_count().
+ *
+ *          To retrieve a count of open objects, use the H5Fget_obj_count()
+ *          function. This count can be used to set the \p max_objs parameter.
+ *
+ * \version 1.8.2 Function return type changed to \c ssize_t and \p
+ *                max_objs parameter datatype changed to \c size_t.
+ * \version 1.6.8 Function return type changed to \c ssize_t and \p
+ *                max_objs parameter datatype changed to \c size_t.
+ * \since 1.6.0
+ *
+ */
+H5_DLL ssize_t H5Fget_obj_ids(hid_t file_id, unsigned types, size_t max_objs, hid_t *obj_id_list);
+/**
+ * \ingroup H5F
+ *
+ * \brief Returns pointer to the file handle from the virtual file driver
+ *
+ * \file_id
+ * \fapl_id{fapl}
+ * \param[out] file_handle Pointer to the file handle being used by the
+ *                         low-level virtual file driver
+ *
+ * \return \herr_t
+ *
+ * \details Given the file identifier \p file_id and the file access property
+ *          list \p fapl_id, H5Fget_vfd_handle() returns a pointer to the file
+ *          handle from the low-level file driver currently being used by the
+ *          HDF5 library for file I/O.
+ *
+ * \note For most drivers, the value of \p fapl_id will be #H5P_DEFAULT. For
+ *       the \c FAMILY or \c MULTI drivers, this value should be defined
+ *       through the property list functions: H5Pset_family_offset() for the
+ *       \c FAMILY driver and H5Pset_multi_type() for the \c MULTI driver
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Fget_vfd_handle(hid_t file_id, hid_t fapl, void **file_handle);
+/**
+ * \ingroup H5F
+ *
+ * \brief Mounts an HDF5 file
+ *
+ * \loc_id{loc}
+ * \param[in] name Name of the group onto which the file specified by \p child
+ *                 is to be mounted
+ * \file_id{child}
+ * \param[in] plist File mount property list identifier. Pass #H5P_DEFAULT!
+ *
+ * \return \herr_t
+ *
+ * \details H5Fmount() mounts the file specified by \p child onto the object
+ *          specified by \p loc and \p name using the mount properties \p plist
+ *          If the object specified by \p loc is a dataset, named datatype or
+ *          attribute, then the file will be mounted at the location where the
+ *          attribute, dataset, or named datatype is attached.
+ *
+ * \par Example
+ * \snippet H5F_examples.c mount
+ *
+ * \note To date, no file mount properties have been defined in HDF5. The
+ *       proper value to pass for \p plist is #H5P_DEFAULT, indicating the
+ *       default file mount property list.
+ *
+ */
+H5_DLL herr_t H5Fmount(hid_t loc, const char *name, hid_t child, hid_t plist);
+/**
+ * \ingroup H5F
+ *
+ * \brief Unounts an HDF5 file
+ *
+ * \loc_id{loc}
+ * \param[in] name Name of the mount point
+ *
+ * \return \herr_t
+ *
+ * \details Given a mount point, H5Funmount() dissociates the mount point's
+ *          file from the file mounted there. This function does not close
+ *          either file.
+ *
+ *          The mount point can be either the group in the parent or the root
+ *          group of the mounted file (both groups have the same name). If the
+ *          mount point was opened before the mount then it is the group in the
+ *          parent; if it was opened after the mount then it is the root group
+ *          of the child.
+ *
+ */
+H5_DLL herr_t H5Funmount(hid_t loc, const char *name);
+/**
+ * \ingroup H5F
+ *
+ * \brief Returns the amount of free space in a file (in bytes)
+ *
+ * \file_id
+ *
+ * \return Returns the amount of free space in the file if successful;
+ *         otherwise returns a negative value.
+ *
+ * \details Given the identifier of an open file, \p file_id,
+ *          H5Fget_freespace() returns the amount of space that is unused by
+ *          any objects in the file.
+ *
+ *          The interpretation of this number depends on the configured free space
+ *          management strategy. For example, if the HDF5 library only tracks free
+ *          space in a file from a file open or create until that file is closed,
+ *          then this routine will report the free space that has been created
+ *          during that interval.
+ *
+ * \since 1.6.1
+ *
+ */
+H5_DLL hssize_t H5Fget_freespace(hid_t file_id);
+/**
+ * \ingroup H5F
+ *
+ * \brief Returns the size of an HDF5 file (in bytes)
+ *
+ * \file_id
+ * \param[out] size Size of the file, in bytes
+ *
+ * \return \herr_t
+ *
+ * \details H5Fget_filesize() returns the size of the HDF5 file specified by
+ *          \p file_id.
+ *
+ *          The returned size is that of the entire file, as opposed to only
+ *          the HDF5 portion of the file. I.e., size includes the user block,
+ *          if any, the HDF5 portion of the file, and any data that may have
+ *          been appended beyond the data written through the HDF5 library.
+ *
+ * \since 1.6.3
+ *
+ */
+H5_DLL herr_t H5Fget_filesize(hid_t file_id, hsize_t *size);
+/**
+ * \ingroup H5F
+ *
+ * \brief Retrieves the file's end-of-allocation (EOA)
+ *
+ * \file_id
+ * \param[out] eoa The file's EOA
+ *
+ * \return \herr_t
+ *
+ * \details H5Fget_eoa() retrieves the file's EOA and returns it in the
+ *          parameter eoa.
+ *
+ * \since 1.10.2
+ *
+ */
+H5_DLL herr_t H5Fget_eoa(hid_t file_id, haddr_t *eoa);
+/**
+ * \ingroup H5F
+ *
+ * \brief Sets the file' EOA to the maximum of (EOA, EOF) + increment
+ *
+ * \file_id
+ * \param[in] increment The number of bytes to be added to the maximum of
+ *                      (EOA, EOF)
+ *
+ * \return \herr_t
+ *
+ * \details H5Fincrement_filesize() sets the file's EOA to the maximum of (EOA,
+ *          EOF) + \p increment. The EOA is the end-of-file address stored in
+ *          the file's superblock while EOF is the file's actual end-of-file.
+ *
+ * \since 1.10.2
+ *
+ */
+H5_DLL herr_t H5Fincrement_filesize(hid_t file_id, hsize_t increment);
+/**
+ * \ingroup H5F
+ *
+ * \brief Retrieves a copy of the image of an existing, open file
+ *
+ * \file_id
+ * \param[out] buf_ptr Pointer to the buffer into which the image of the
+ *                     HDF5 file is to be copied. If \p buf_ptr is NULL,
+ *                     no data will be copied but the function's return value
+ *                     will still indicate the buffer size required (or a
+ *                     negative value on error).
+ * \param[out] buf_len Size of the supplied buffer
+ *
+ * \return ssize_t
+ *
+ * \details H5Fget_file_image() retrieves a copy of the image of an existing,
+ *          open file. This routine can be used with files opened using the
+ *          SEC2 (or POSIX), STDIO, and Core (or Memory) virtual file drivers
+ *          (VFDs).
+ *
+ *          If the return value of H5Fget_file_image() is a positive value, it
+ *          will be the length in bytes of the buffer required to store the
+ *          file image. So if the file size is unknown, it can be safely
+ *          determined with an initial H5Fget_file_image() call with buf_ptr
+ *          set to NULL. The file image can then be retrieved with a second
+ *          H5Fget_file_image() call with \p buf_len set to the initial call's
+ *          return value.
+ *
+ *          While the current file size can also be retrieved with
+ *          H5Fget_filesize(), that call may produce a larger value than is
+ *          needed. The value returned by H5Fget_filesize() includes the user
+ *          block, if it exists, and any unallocated space at the end of the
+ *          file. It is safe in all situations to get the file size with
+ *          H5Fget_file_image() and it often produces a value that is more
+ *          appropriate for the size of a file image buffer.
+ *
+ * \note \Bold{Recommended Reading:} This function is part of the file image
+ *       operations feature set. It is highly recommended to study the guide
+ *       \ref_file_image_ops before using this feature set.
+ *
+ * \attention H5Pget_file_image() will fail, returning a negative value, if the
+ *            file is too large for the supplied buffer.
+ *
+ * \see H5LTopen_file_image(), H5Pset_file_image(), H5Pget_file_image(),
+ *      H5Pset_file_image_callbacks(), H5Pget_file_image_callbacks()
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL ssize_t H5Fget_file_image(hid_t file_id, void *buf_ptr, size_t buf_len);
+/**
+ * \ingroup MDC
+ *
+ * \brief Obtains current metadata cache configuration for target file
+ *
+ * \file_id
+ * \param[in,out] config_ptr Pointer to the H5AC_cache_config_t instance in which
+ *                        the current metadata cache configuration is to be
+ *                        reported. The fields of this structure are discussed
+ *                        \ref H5AC-cache-config-t "here".
+ * \return \herr_t
+ *
+ * \note The \c in direction applies only to the H5AC_cache_config_t::version
+ *       field. All other fields are out parameters.
+ *
+ * \details H5Fget_mdc_config() loads the current metadata cache configuration
+ *          into the instance of H5AC_cache_config_t pointed to by the \p config_ptr
+ *          parameter.\n
+ *          The fields of the H5AC_cache_config_t structure are shown below:
+ *          \snippet H5ACpublic.h H5AC_cache_config_t_snip
+ *          \click4more
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Fget_mdc_config(hid_t file_id, H5AC_cache_config_t *config_ptr);
+/**
+ * \ingroup MDC
+ *
+ * \brief Attempts to configure metadata cache of target file
+ *
+ * \file_id
+ * \param[in,out] config_ptr Pointer to the H5AC_cache_config_t instance
+ *                           containing the desired configuration.
+ *                           The fields of this structure are discussed
+ *                           \ref H5AC-cache-config-t "here".
+ * \return \herr_t
+ *
+ * \details H5Fset_mdc_config() attempts to configure the file's metadata cache
+ *          according configuration supplied in \p config_ptr.
+ *          \snippet H5ACpublic.h H5AC_cache_config_t_snip
+ *          \click4more
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Fset_mdc_config(hid_t file_id, const H5AC_cache_config_t *config_ptr);
+/**
+ * \ingroup MDC
+ *
+ * \brief Obtains target file's metadata cache hit rate
+ *
+ * \file_id
+ * \param[out] hit_rate_ptr Pointer to the double in which the hit rate is returned. Note that
+ *                          \p hit_rate_ptr is undefined if the API call fails
+ * \return \herr_t
+ *
+ * \details H5Fget_mdc_hit_rate() queries the metadata cache of the target file to obtain its hit rate
+ *          \Code{(cache hits / (cache hits + cache misses))} since the last time hit rate statistics
+ *          were reset. If the cache has not been accessed since the last time the hit rate stats were
+ *          reset, the hit rate is defined to be 0.0.
+ *
+ *          The hit rate stats can be reset either manually (via H5Freset_mdc_hit_rate_stats()), or
+ *          automatically. If the cache's adaptive resize code is enabled, the hit rate stats will be
+ *          reset once per epoch. If they are reset manually as well, the cache may behave oddly.
+ *
+ *          See the overview of the metadata cache in the special topics section of the user manual for
+ *          details on the metadata cache and its adaptive resize algorithms.
+ *
+ */
+H5_DLL herr_t H5Fget_mdc_hit_rate(hid_t file_id, double *hit_rate_ptr);
+/**
+ * \ingroup MDC
+ *
+ * \brief Obtains current metadata cache size data for specified file
+ *
+ * \file_id
+ * \param[out] max_size_ptr Pointer to the location in which the current cache maximum size is to be
+ *                          returned, or NULL if this datum is not desired
+ * \param[out] min_clean_size_ptr Pointer to the location in which the current cache minimum clean
+ *                                size is to be returned, or NULL if that datum is not desired
+ * \param[out] cur_size_ptr Pointer to the location in which the current cache size is to be returned,
+ *                          or NULL if that datum is not desired
+ * \param[out] cur_num_entries_ptr Pointer to the location in which the current number of entries in
+ *                                 the cache is to be returned, or NULL if that datum is not desired
+ * \returns \herr_t
+ *
+ * \details H5Fget_mdc_size()  queries the metadata cache of the target file for the desired size
+ *          information, and returns this information in the locations indicated by the pointer
+ *          parameters. If any pointer parameter is NULL, the associated data is not returned.
+ *
+ *          If the API call fails, the values returned via the pointer parameters are undefined.
+ *
+ *          If adaptive cache resizing is enabled, the cache maximum size and minimum clean size
+ *          may change at the end of each epoch. Current size and current number of entries can
+ *          change on each cache access.
+ *
+ *          Current size can exceed maximum size under certain conditions. See the overview of the
+ *          metadata cache in the special topics section of the user manual for a discussion of this.
+ *
+ */
+H5_DLL herr_t H5Fget_mdc_size(hid_t file_id, size_t *max_size_ptr, size_t *min_clean_size_ptr,
+                              size_t *cur_size_ptr, int *cur_num_entries_ptr);
+/**
+ * \ingroup MDC
+ *
+ * \brief Resets hit rate statistics counters for the target file
+ *
+ * \file_id
+ * \returns \herr_t
+ *
+ * \details
+ * \parblock
+ * H5Freset_mdc_hit_rate_stats() resets the hit rate statistics counters in the metadata cache
+ * associated with the specified file.
+ *
+ * If the adaptive cache resizing code is enabled, the hit rate statistics are reset at the beginning
+ * of each epoch. This API call allows you to do the same thing from your program.
+ *
+ * The adaptive cache resizing code may behave oddly if you use this call when adaptive cache resizing
+ * is enabled. However, the call should be useful if you choose to control metadata cache size from your
+ * program.
+ *
+ * See \ref_mdc_in_hdf5 for details about the metadata cache and the adaptive cache resizing
+ * algorithms. If you have not read, understood, and thought about the material covered in that
+ * documentation,
+ * you should not be using this API call.
+ * \endparblock
+ *
+ */
+H5_DLL herr_t H5Freset_mdc_hit_rate_stats(hid_t file_id);
+/**
+ * \ingroup H5F
+ *
+ * \brief Retrieves name of file to which object belongs
+ *
+ * \obj_id
+ * \param[out] name Buffer for the file name
+ * \param[in] size Size, in bytes, of the \p name buffer
+ *
+ * \return Returns the length of the file name if successful; otherwise returns
+ *         a negative value.
+ *
+ * \details H5Fget_name() retrieves the name of the file to which the object \p
+ *          obj_id belongs. The object can be a file, group, dataset,
+ *          attribute, or named datatype.
+ *
+ *          Up to \p size characters of the file name are returned in \p name;
+ *          additional characters, if any, are not returned to the user
+ *          application.
+ *
+ *          If the length of the name, which determines the required value of
+ *          size, is unknown, a preliminary H5Fget_name() call can be made by
+ *          setting \p name to NULL. The return value of this call will be the
+ *          size of the file name; that value plus one (1) can then be assigned
+ *          to size for a second H5Fget_name() call, which will retrieve the
+ *          actual name. (The value passed in with the parameter \p size must
+ *          be one greater than size in bytes of the actual name in order to
+ *          accommodate the null terminator; if \p size is set to the exact
+ *          size of the name, the last byte passed back will contain the null
+ *          terminator and the last character will be missing from the name
+ *          passed back to the calling application.)
+ *
+ *          If an error occurs, the buffer pointed to by \p name is unchanged
+ *          and the function returns a negative value.
+ *
+ * \since 1.6.3
+ *
+ */
+H5_DLL ssize_t H5Fget_name(hid_t obj_id, char *name, size_t size);
+/**
+ * \ingroup H5F
+ *
+ * \brief Retrieves global file information
+ *
+ * \fgdta_obj_id
+ * \param[out] file_info Buffer for global file information
+ *
+ * \return \herr_t
+ *
+ * \details H5Fget_info2() returns global information for the file associated
+ *          with the object identifier \p obj_id in the H5F_info2_t \c struct
+ *          named \p file_info.
+ *
+ *          \p obj_id is an identifier for any object in the file of interest.
+ *
+ *          H5F_info2_t struct is defined in H5Fpublic.h as follows:
+ *          \snippet this H5F_info2_t_snip
+ *
+ *          The \c super sub-struct contains the following information:
+ *          \li \c vers is the version number of the superblock.
+ *          \li \c  super_size is the size of the superblock.
+ *          \li \c super_ext_size is the size of the superblock extension.
+ *
+ *          The \c free sub-struct contains the following information:
+ *          \li vers is the version number of the free-space manager.
+ *          \li \c hdr_size is the size of the free-space manager header.
+ *          \li \c tot_space is the total amount of free space in the file.
+ *
+ *          The \c sohm sub-struct contains shared object header message
+ *          information as follows:
+ *          \li \c vers is the version number of the shared object header information.
+ *          \li \c hdr_size is the size of the shared object header message.
+ *          \li \c msgs_info is an H5_ih_info_t struct defined in H5public.h as
+ *              follows: \snippet H5public.h H5_ih_info_t_snip
+ *          \li \p index_size is the summed size of all the shared object
+ *              header indexes. Each index might be either a B-tree or
+ *              a list.
+ *          \li \p heap_size is the size of the heap.
+ *
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Fget_info2(hid_t obj_id, H5F_info2_t *file_info);
+/**
+ * \ingroup SWMR
+ *
+ * \brief Retrieves the collection of read retries for metadata entries with checksum
+ *
+ * \file_id
+ * \param[out] info Struct containing the collection of read retries for metadata
+ *                  entries with checksum
+ * \return \herr_t\n
+ *
+ * \details \Bold{Failure Modes:}
+ *       \li When the input identifier is not a file identifier.
+ *       \li When the pointer to the output structure is NULL.
+ *       \li When the memory allocation for \p retries failed.
+ *
+ * \details H5Fget_metadata_read_retry_info() retrieves information regarding the number
+ *          of read retries for metadata entries with checksum for the file \p file_id.
+ *          This information is reported in the H5F_retry_info_t struct defined in
+ *          H5Fpublic.h as follows:
+ *          \snippet this H5F_retry_info_t_snip
+ *          \c nbins is the number of bins for each \c retries[i] of metadata entry \c i.
+ *          It is calculated based on the current number of read attempts used in the
+ *          library and logarithmic base 10.
+ *
+ *          If read retries are incurred for a metadata entry \c i, the library will
+ *          allocate memory for \Code{retries[i] (nbins * sizeof(uint32_t)} and store
+ *          the collection of retries there. If there are no retries for a metadata entry
+ *          \c i, \Code{retries[i]} will be NULL. After a call to this routine, users should
+ *          free each \Code{retries[i]} that is non-NULL, otherwise resource leak will occur.
+ *
+ *          For the library default read attempts of 100 for SWMR access, nbins will be 2
+ *          as depicted below:
+ *          \li \Code{retries[i][0]} is the number of 1 to 9 read retries.
+ *          \li \Code{retries[i][1]} is the number of 10 to 99 read retries.
+ *          For the library default read attempts of 1 for non-SWMR access, \c nbins will
+ *          be 0 and each \Code{retries[i]} will be NULL.
+ *
+ *          The following table lists the 21 metadata entries of \Code{retries[]}:
+ *          <table>
+ *          <tr>
+ *          <th>Index for \Code{retries[]}</th>
+ *          <th>Metadata entries<sup>*</sup></th>
+ *          </tr>
+ *          <tr><td>0</td><td>Object header (version 2)</td></tr>
+ *          <tr><td>1</td><td>Object header chunk (version 2)</td></tr>
+ *          <tr><td>2</td><td>B-tree header (version 2)</td></tr>
+ *          <tr><td>3</td><td>B-tree internal node (version 2)</td></tr>
+ *          <tr><td>4</td><td>B-tree leaf node (version 2)</td></tr>
+ *          <tr><td>5</td><td>Fractal heap header</td></tr>
+ *          <tr><td>6</td><td>Fractal heap direct block (optional checksum)</td></tr>
+ *          <tr><td>7</td><td>Fractal heap indirect block</td></tr>
+ *          <tr><td>8</td><td>Free-space header</td></tr>
+ *          <tr><td>9</td><td>Free-space sections</td></tr>
+ *          <tr><td>10</td><td>Shared object header message table</td></tr>
+ *          <tr><td>11</td><td>Shared message record list</td></tr>
+ *          <tr><td>12</td><td>Extensive array header</td></tr>
+ *          <tr><td>13</td><td>Extensive array index block</td></tr>
+ *          <tr><td>14</td><td>Extensive array super block</td></tr>
+ *          <tr><td>15</td><td>Extensive array data block</td></tr>
+ *          <tr><td>16</td><td>Extensive array data block page</td></tr>
+ *          <tr><td>17</td><td>Fixed array super block</td></tr>
+ *          <tr><td>18</td><td>Fixed array data block</td></tr>
+ *          <tr><td>19</td><td>Fixed array data block page</td></tr>
+ *          <tr><td>20</td><td>File's superblock (version 2)</td></tr>
+ *          <tr><td colspan=2><sup>*</sup> All entries are of version 0 (zero) unless indicated
+ *          otherwise.</td></tr>
+ *          </table>
+ *
+ * \note   On a system that is not atomic, the library might possibly read inconsistent
+ *         metadata with checksum when performing single-writer/multiple-reader (SWMR)
+ *         operations for an HDF5 file. Upon encountering such situations, the library
+ *         will try reading the metadata again for a set number of times to attempt to
+ *         obtain consistent data. The maximum number of read attempts used by the library
+ *         will be either the value set via H5Pset_metadata_read_attempts() or the library
+ *         default value when a value is not set.\n
+ *         When the current number of metadata read attempts used in the library is unable
+ *         to remedy the reading of inconsistent metadata on a system, the user can assess
+ *         the information obtained via this routine to derive a different maximum value.
+ *         The information can also be helpful for debugging purposes to identify potential
+ *         issues with metadata flush dependencies and SWMR implementation in general.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Fget_metadata_read_retry_info(hid_t file_id, H5F_retry_info_t *info);
+/**
+ * \ingroup SWMR
+ *
+ * \brief Retrieves free-space section information for a file
+ *
+ * \file_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Fstart_swmr_write() will activate SWMR writing mode for a file
+ *          associated with \p file_id. This routine will prepare and ensure
+ *          the file is safe for SWMR writing as follows:
+ *          \li Check that the file is opened with write access (#H5F_ACC_RDWR).
+ *          \li Check that the file is opened with the latest library format to
+ *              ensure data structures with check-summed metadata are used.
+ *          \li Check that the file is not already marked in SWMR writing mode.
+ *          \li Enable reading retries for check-summed metadata to remedy
+ *              possible checksum failures from reading inconsistent metadata
+ *              on a system that is not atomic.
+ *          \li Turn off usage of the library's accumulator to avoid possible
+ *              ordering problem on a system that is not atomic.
+ *          \li Perform a flush of the file's data buffers and metadata to set
+ *              a consistent state for starting SWMR write operations.
+ *
+ *          Library objects are groups, datasets, and committed datatypes. For
+ *          the current implementation, groups and datasets can remain open when
+ *          activating SWMR writing mode, but not committed datatypes. Attributes
+ *          attached to objects cannot remain open either.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Fstart_swmr_write(hid_t file_id);
+/**
+ * \ingroup H5F
+ *
+ * \brief Retrieves free-space section information for a file
+ *
+ * \file_id
+ * \param[in] type The file memory allocation type
+ * \param[in] nsects The number of free-space sections
+ * \param[out] sect_info Array of instances of H5F_sect_info_t in which
+ *                       the free-space section information is to be returned
+ *
+ * \return Returns the number of free-space sections for the specified
+ *         free-space manager in the file; otherwise returns a negative value.
+ *
+ * \details H5Fget_free_sections() retrieves free-space section information for
+ *          the free-space manager with type that is associated with file
+ *          \p file_id. If type is #H5FD_MEM_DEFAULT, this routine retrieves
+ *          free-space section information for all the free-space managers in
+ *          the file.
+ *
+ *          Valid values for \p type are the following:
+ *          \mem_types
+ *
+ *          H5F_sect_info_t is defined as follows (in H5Fpublic.h):
+ *          \snippet this H5F_sect_info_t_snip
+ *
+ *          This routine retrieves free-space section information for \p nsects
+ *          sections or, at most, the maximum number of sections in the specified
+ *          free-space manager. If the number of sections is not known, a
+ *          preliminary H5Fget_free_sections() call can be made by setting \p
+ *          sect_info to NULL and the total number of free-space sections for
+ *          the specified free-space manager will be returned. Users can then
+ *          allocate space for entries in \p sect_info, each of which is
+ *          defined as an H5F_sect_info_t \c struct.
+ *
+ * \attention \Bold{Failure Modes:} This routine will fail when the following
+ *            is true:
+ *            \li The library fails to retrieve the file creation property list
+ *                associated with \p file_id.
+ *            \li If the parameter \p sect_info is non-null, but the parameter
+ *                \p nsects is equal to 0.
+ *            \li The library fails to retrieve free-space section information
+ *                for the file.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL ssize_t H5Fget_free_sections(hid_t file_id, H5F_mem_t type, size_t nsects,
+                                    H5F_sect_info_t *sect_info /*out*/);
+/**
+ * \ingroup H5F
+ *
+ * \brief Clears the external link open file cache
+ *
+ * \file_id
+ * \return \herr_t
+ *
+ * \details H5Fclear_elink_file_cache() evicts all the cached child files in
+ *          the specified file's external file cache, causing them to be closed
+ *          if there is nothing else holding them open.
+ *
+ *          H5Fclear_elink_file_cache() does not close the cache itself;
+ *          subsequent external link traversals from the parent file will again
+ *          cache the target file. See H5Pset_elink_file_cache_size() for
+ *          information on closing the file cache.
+ *
+ * \see H5Pset_elink_file_cache_size(), H5Pget_elink_file_cache_size()
+ *
+ * \since 1.8.7
+ *
+ */
+H5_DLL herr_t H5Fclear_elink_file_cache(hid_t file_id);
+/**
+ * \ingroup H5F
+ *
+ * \brief Enables the switch of version bounds setting for a file
+ *
+ * \file_id
+ * \param[in] low The earliest version of the library that will be used for
+ *                writing objects
+ * \param[in] high The latest version of the library that will be used for
+ *                 writing objects
+ *
+ * \return \herr_t
+ *
+ * \details H5Fset_libver_bounds() enables the switch of version bounds setting
+ *          for an open file associated with \p file_id.
+ *
+ *          For the parameters \p low and \p high, see the description for
+ *          H5Pset_libver_bounds().
+ *
+ * \par Example
+ * \snippet H5F_examples.c libver_bounds
+ *
+ * \since 1.10.2
+ *
+ */
+H5_DLL herr_t H5Fset_libver_bounds(hid_t file_id, H5F_libver_t low, H5F_libver_t high);
+/**
+ * \ingroup MDC
+ *
+ * \brief Starts logging metadata cache events if logging was previously enabled
+ *
+ * \file_id
+ *
+ * \return \herr_t
+ *
+ * \details The metadata cache is a central part of the HDF5 library through
+ *          which all \Emph{file metadata} reads and writes take place. File
+ *          metadata is normally invisible to the user and is used by the
+ *          library for purposes such as locating and indexing data. File
+ *          metadata should not be confused with user metadata, which consists
+ *          of attributes created by users and attached to HDF5 objects such
+ *          as datasets via H5A API calls.
+ *
+ *          Due to the complexity of the cache, a trace/logging feature has been
+ *          created that can be used by HDF5 developers for debugging and performance
+ *          analysis. The functions that control this functionality will normally be
+ *          of use to a very limited number of developers outside of The HDF Group.
+ *          The functions have been documented to help users create logs that can
+ *          be sent with bug reports.
+ *
+ *          Control of the log functionality is straightforward. Logging is enabled
+ *          via the H5Pset_mdc_log_options() function, which will modify the file
+ *          access property list used to open or create a file. This function has
+ *          a flag that determines whether logging begins at file open or starts
+ *          in a paused state. Log messages can then be controlled via the
+ *          H5Fstart_mdc_logging() and H5Fstop_mdc_logging() functions.
+ *          H5Pget_mdc_log_options() can be used to examine a file access property
+ *          list, and H5Fget_mdc_logging_status() will return the current state of
+ *          the logging flags.
+ *
+ *          The log format is described in the \ref_mdc_logging document.
+ *
+ * \note Logging can only be started or stopped if metadata cache logging was enabled
+ *       via H5Pset_mdc_log_options().\n
+ *       When enabled and currently logging, the overhead of the logging feature will
+ *       almost certainly be significant.\n
+ *       The log file is opened when the HDF5 file is opened or created and not when
+ *       this function is called for the first time.\n
+ *       This function opens the log file and starts logging metadata cache operations
+ *       for a particular file. Calling this function when logging has already been
+ *       enabled will be considered an error.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Fstart_mdc_logging(hid_t file_id);
+/**
+ * \ingroup MDC
+ *
+ * \brief Stops logging metadata cache events if logging was previously enabled and is currently ongoing
+ *
+ * \file_id
+ *
+ * \return \herr_t
+ *
+ * \details The metadata cache is a central part of the HDF5 library through
+ *          which all \Emph{file metadata} reads and writes take place. File
+ *          metadata is normally invisible to the user and is used by the
+ *          library for purposes such as locating and indexing data. File
+ *          metadata should not be confused with user metadata, which consists
+ *          of attributes created by users and attached to HDF5 objects such
+ *          as datasets via H5A API calls.
+ *
+ *          Due to the complexity of the cache, a trace/logging feature has been
+ *          created that can be used by HDF5 developers for debugging and performance
+ *          analysis. The functions that control this functionality will normally be
+ *          of use to a very limited number of developers outside of The HDF Group.
+ *          The functions have been documented to help users create logs that can
+ *          be sent with bug reports.
+ *
+ *          Control of the log functionality is straightforward. Logging is enabled
+ *          via the H5Pset_mdc_log_options() function, which will modify the file
+ *          access property list used to open or create a file. This function has
+ *          a flag that determines whether logging begins at file open or starts
+ *          in a paused state. Log messages can then be controlled via the
+ *          H5Fstart_mdc_logging() and H5Fstop_mdc_logging() functions.
+ *          H5Pget_mdc_log_options() can be used to examine a file access property
+ *          list, and H5Fget_mdc_logging_status() will return the current state of
+ *          the logging flags.
+ *
+ *          The log format is described in the \ref_mdc_logging document.
+ *
+ * \note Logging can only be started or stopped if metadata cache logging was enabled
+ *       via H5Pset_mdc_log_options().\n
+ *       This function only suspends the logging operations. The log file will remain
+ *       open and will not be closed until the HDF5 file is closed.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Fstop_mdc_logging(hid_t file_id);
+/**
+ * \ingroup MDC
+ *
+ * \brief Gets the current metadata cache logging status
+ *
+ * \file_id
+ * \param[out] is_enabled Whether logging is enabled
+ * \param[out] is_currently_logging Whether events are currently being logged
+ * \return \herr_t
+ *
+ * \details The metadata cache is a central part of the HDF5 library through
+ *          which all \Emph{file metadata} reads and writes take place. File
+ *          metadata is normally invisible to the user and is used by the
+ *          library for purposes such as locating and indexing data. File
+ *          metadata should not be confused with user metadata, which consists
+ *          of attributes created by users and attached to HDF5 objects such
+ *          as datasets via H5A API calls.
+ *
+ *          Due to the complexity of the cache, a trace/logging feature has been
+ *          created that can be used by HDF5 developers for debugging and performance
+ *          analysis. The functions that control this functionality will normally be
+ *          of use to a very limited number of developers outside of The HDF Group.
+ *          The functions have been documented to help users create logs that can
+ *          be sent with bug reports.
+ *
+ *          Control of the log functionality is straightforward. Logging is enabled
+ *          via the H5Pset_mdc_log_options() function, which will modify the file
+ *          access property list used to open or create a file. This function has
+ *          a flag that determines whether logging begins at file open or starts
+ *          in a paused state. Log messages can then be controlled via the
+ *          H5Fstart_mdc_logging() and H5Fstop_mdc_logging() functions.
+ *          H5Pget_mdc_log_options() can be used to examine a file access property
+ *          list, and H5Fget_mdc_logging_status() will return the current state of
+ *          the logging flags.
+ *
+ *          The log format is described in the \ref_mdc_logging document.
+ *
+ * \note Unlike H5Fstart_mdc_logging() and H5Fstop_mdc_logging(), this function can
+ *       be called on any open file identifier.
+ *
+ * \since 1.10.0
+ */
+H5_DLL herr_t H5Fget_mdc_logging_status(hid_t file_id, hbool_t *is_enabled, hbool_t *is_currently_logging);
+/**
+ * \ingroup H5F
+ *
+ * \brief Resets the page buffer statistics
+ *
+ * \file_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Freset_page_buffering_stats() resets the page buffer statistics
+ *          for a specified file identifier \p file_id.
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5Freset_page_buffering_stats(hid_t file_id);
+/**
+ * \ingroup H5F
+ *
+ * \brief Retrieves statistics about page access when it is enabled
+ *
+ * \file_id
+ * \param[out] accesses Two integer array for the number of metadata and raw
+ *                      data accesses to the page buffer
+ * \param[out] hits Two integer array for the number of metadata and raw data
+ *                  hits in the page buffer
+ * \param[out] misses Two integer array for the number of metadata and raw data
+ *                    misses in the page buffer
+ * \param[out] evictions Two integer array for the number of metadata and raw
+ *                       data evictions from the page buffer
+ * \param[out] bypasses Two integer array for the number of metadata and raw
+ *                      data accesses that bypass the page buffer
+ *
+ * \return \herr_t
+ *
+ * \details H5Fget_page_buffering_stats() retrieves page buffering statistics
+ *          such as the number of metadata and raw data accesses (\p accesses),
+ *          hits (\p hits), misses (\p misses), evictions (\p evictions), and
+ *          accesses that bypass the page buffer (\p bypasses).
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5Fget_page_buffering_stats(hid_t file_id, unsigned accesses[2], unsigned hits[2],
+                                          unsigned misses[2], unsigned evictions[2], unsigned bypasses[2]);
+/**
+ * \ingroup MDC
+ *
+ * \brief Obtains information about a cache image if it exists
+ *
+ * \file_id
+ * \param[out] image_addr Offset of the cache image if it exists, or #HADDR_UNDEF if it does not
+ * \param[out] image_size Length of the cache image if it exists, or 0 if it does not
+ * \returns \herr_t
+ *
+ * \details
+ * \parblock
+ * H5Fget_mdc_image_info() returns information about a cache image if it exists.
+ *
+ * When an HDF5 file is opened in Read/Write mode, any metadata cache image will
+ * be read and deleted from the file on the first metadata cache access (or, if
+ * persistent free space managers are enabled, on the first file space
+ * allocation / deallocation, or read of free space manager status, whichever
+ * comes first).
+ *
+ * Thus, if the file is opened Read/Write, H5Fget_mdc_image_info() should be called
+ * immediately after file open and before any other operation. If H5Fget_mdc_image_info()
+ * is called after the cache image is loaded, it will correctly report that no cache image
+ * exists, as the image will have already been read and deleted from the file. In the Read Only
+ * case, the function may be called at any time, as any cache image will not be deleted
+ * from the file.
+ * \endparblock
+ *
+ * \since 1.10.1
+ */
+H5_DLL herr_t H5Fget_mdc_image_info(hid_t file_id, haddr_t *image_addr, hsize_t *image_size);
+/**
+ * \ingroup H5F
+ *
+ * \brief Retrieves the setting for whether or not a file will create minimized
+ *        dataset object headers
+ *
+ * \file_id
+ * \param[out] minimize Flag indicating whether the library will or will not
+ *                      create minimized dataset object headers
+ *
+ * \return \herr_t
+ *
+ * \details H5Fget_dset_no_attrs_hint() retrieves the no dataset attributes
+ *          hint setting for the file specified by the file identifier \p
+ *          file_id. This setting is used to inform the library to create
+ *          minimized dataset object headers when \c true.
+ *
+ *          The setting's value is returned in the boolean pointer minimized.
+ *
+ * \since 1.10.5
+ *
+ */
+H5_DLL herr_t H5Fget_dset_no_attrs_hint(hid_t file_id, hbool_t *minimize);
+/**
+ * \ingroup H5F
+ *
+ * \brief Sets the flag to create minimized dataset object headers
+ *
+ * \file_id
+ * \param[in] minimize Flag indicating whether the library will or will not
+ *                     create minimized dataset object headers
+ *
+ * \return \herr_t
+ *
+ * \details H5Fset_dset_no_attrs_hint() sets the no dataset attributes hint
+ *          setting for the file specified by the file identifier \p file_id.
+ *          If the boolean flag \p minimize is set to \c true, then the library
+ *          will create minimized dataset object headers in the file.
+ *          \Bold{All} files that refer to the same file-on-disk will be
+ *          affected by the most recent setting, regardless of the file
+ *          identifier/handle (e.g., as returned by H5Fopen()). By setting the
+ *          \p minimize flag to \c true, the library expects that no attributes
+ *          will be added to the dataset - attributes can be added, but they
+ *          are appended with a continuation message, which can reduce
+ *          performance.
+ *
+ * \attention This setting interacts with H5Pset_dset_no_attrs_hint(): if
+ *            either is set to \c true, then the created dataset's object header
+ *            will be minimized.
+ *
+ * \since 1.10.5
+ *
+ */
+H5_DLL herr_t H5Fset_dset_no_attrs_hint(hid_t file_id, hbool_t minimize);
+
+#ifdef H5_HAVE_PARALLEL
+/**
+ * \ingroup PH5F
+ *
+ * \brief Sets the MPI atomicity mode
+ *
+ * \file_id
+ * \param[in] flag Logical flag for atomicity setting. Valid values are:
+ *                 \li \c 1 -- Sets MPI file access to atomic mode.
+ *                 \li \c 0 -- Sets MPI file access to nonatomic mode.
+ * \returns \herr_t
+ *
+ * \par Motivation
+ * H5Fset_mpi_atomicity() is applicable only in parallel environments using MPI I/O.
+ * The function is one of the tools used to ensure sequential consistency. This means
+ * that a set of operations will behave as though they were performed in a serial
+ * order consistent with the program order.
+ *
+ * \details
+ * \parblock
+ * H5Fset_mpi_atomicity() sets MPI consistency semantics for data access to the file,
+ * \p file_id.
+ *
+ * If \p flag is set to \c 1, all file access operations will appear atomic, guaranteeing
+ * sequential consistency. If \p flag is set to \c 0, enforcement of atomic file access
+ * will be turned off.
+ *
+ * H5Fset_mpi_atomicity() is a collective function and all participating processes must
+ * pass the same values for \p file_id and \p flag.
+ *
+ * This function is available only when the HDF5 library is configured with parallel support
+ * (\Code{--enable-parallel | HDF5_ENABLE_PARALLEL}). It is useful only when used with the #H5FD_MPIO driver
+ * (see H5Pset_fapl_mpio()).
+ * \endparblock
+ *
+ * \attention
+ * \parblock
+ * H5Fset_mpi_atomicity() calls \Code{MPI_File_set_atomicity} underneath and is not supported
+ * if the execution platform does not support \Code{MPI_File_set_atomicity}. When it is
+ * supported and used, the performance of data access operations may drop significantly.
+ *
+ * In certain scenarios, even when \Code{MPI_File_set_atomicity} is supported, setting
+ * atomicity with H5Fset_mpi_atomicity() and \p flag set to 1 does not always yield
+ * strictly atomic updates. For example, some H5Dwrite() calls translate to multiple
+ * \Code{MPI_File_write_at} calls. This happens in all cases where the high-level file
+ * access routine translates to multiple lower level file access routines.
+ * The following scenarios will raise this issue:
+ * \li Non-contiguous file access using independent I/O
+ * \li Partial collective I/O using chunked access
+ * \li Collective I/O using filters or when data conversion is required
+ *
+ * This issue arises because MPI atomicity is a matter of MPI file access operations rather
+ * than HDF5 access operations. But the user is normally seeking atomicity at the HDF5 level.
+ * To accomplish this, the application must set a barrier after a write, H5Dwrite(), but before
+ * the next read, H5Dread(), in addition to calling H5Fset_mpi_atomicity().The barrier will
+ * guarantee that all underlying write operations execute atomically before the read
+ * operations starts. This ensures additional ordering semantics and will normally produce
+ * the desired behavior.
+ * \endparblock
+ *
+ * \see \ref_cons_semantics
+ *
+ * \since 1.8.9
+ *
+ */
+H5_DLL herr_t H5Fset_mpi_atomicity(hid_t file_id, hbool_t flag);
+/**
+ * \ingroup PH5F
+ *
+ * \brief Retrieves the atomicity mode in use
+ *
+ * \file_id
+ * \param[out] flag Logical flag for atomicity setting. Valid values are:
+ *                  \li 1 -- MPI file access is set to atomic mode.
+ *                  \li 0 -- MPI file access is set to nonatomic mode.
+ * \returns \herr_t
+ *
+ * \details H5Fget_mpi_atomicity() retrieves the current consistency semantics mode for
+ *          data access for the file \p file_id.
+ *
+ *          Upon successful return, \p flag will be set to \c 1 if file access is set
+ *          to atomic mode and \c 0 if file access is set to nonatomic mode.
+ *
+ * \see \ref_cons_semantics
+ *
+ * \since 1.8.9
+ *
+ */
+H5_DLL herr_t H5Fget_mpi_atomicity(hid_t file_id, hbool_t *flag);
+#endif /* H5_HAVE_PARALLEL */
+
+/// \cond DEV
+/* Internal API routines */
+H5_DLL herr_t H5Fformat_convert(hid_t fid);
+/// \endcond
+
+/// \cond DEV
+/* API Wrappers for async routines */
+/* (Must be defined _after_ the function prototype) */
+/* (And must only defined when included in application code, not the library) */
+#ifndef H5F_MODULE
+#define H5Fcreate_async(...) H5Fcreate_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Fopen_async(...)   H5Fopen_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Freopen_async(...) H5Freopen_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Fflush_async(...)  H5Fflush_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Fclose_async(...)  H5Fclose_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+
+/* Define "wrapper" versions of function calls, to allow compile-time values to
+ *      be passed in by language wrapper or library layer on top of HDF5.
+ */
+#define H5Fcreate_async_wrap H5_NO_EXPAND(H5Fcreate_async)
+#define H5Fopen_async_wrap   H5_NO_EXPAND(H5Fopen_async)
+#define H5Freopen_async_wrap H5_NO_EXPAND(H5Freopen_async)
+#define H5Fflush_async_wrap  H5_NO_EXPAND(H5Fflush_async)
+#define H5Fclose_async_wrap  H5_NO_EXPAND(H5Fclose_async)
+#endif /* H5F_MODULE */
+/// \endcond
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+#define H5F_ACC_DEBUG (H5CHECK H5OPEN 0x0000u) /**< Print debug info \deprecated In which version? */
+
+/* Typedefs */
+
+/**
+ * Current "global" information about file
+ */
+//! <!-- [H5F_info1_t_snip] -->
+typedef struct H5F_info1_t {
+    hsize_t super_ext_size; /**< Superblock extension size */
+    struct {
+        hsize_t      hdr_size;  /**< Shared object header message header size */
+        H5_ih_info_t msgs_info; /**< Shared object header message index & heap size */
+    } sohm;
+} H5F_info1_t;
+//! <!-- [H5F_info1_t_snip] -->
+
+/* Function prototypes */
+/**
+ * \ingroup H5F
+ *
+ * \brief Retrieves global file information
+ *
+ * \fgdta_obj_id
+ * \param[out] file_info Buffer for global file information
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function has been renamed from H5Fget_info() and is
+ *             deprecated in favor of the macro #H5Fget_info or the function
+ *             H5Fget_info2().
+ *
+ * \details H5Fget_info1() returns global information for the file associated
+ *          with the object identifier \p obj_id in the H5F_info1_t \c struct
+ *          named \p file_info.
+ *
+ *          \p obj_id is an identifier for any object in the file of interest.
+ *
+ *          H5F_info1_t struct is defined in H5Fpublic.h as follows:
+ *          \snippet this H5F_info1_t_snip
+ *
+ *          \c super_ext_size is the size of the superblock extension.
+ *
+ *          The \c sohm sub-struct contains shared object header message
+ *          information as follows:
+ *          \li \c hdr_size is the size of the shared object header message.
+ *          \li \c msgs_info is an H5_ih_info_t struct defined in H5public.h as
+ *              follows: \snippet H5public.h H5_ih_info_t_snip
+ *
+ *          \li \p index_size is the summed size of all the shared object
+ *              header indexes. Each index might be either a B-tree or
+ *              a list.
+ *
+ * \version 1.10.0 Function H5Fget_info() renamed to H5Fget_info1() and
+ *                 deprecated in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Fget_info1(hid_t obj_id, H5F_info1_t *file_info);
+/**
+ * \ingroup H5F
+ *
+ * \brief Sets the latest version of the library to be used for writing objects
+ *
+ * \file_id
+ * \param[in] latest_format Latest format flag
+ *
+ * \return \herr_t
+ *
+ * \deprecated When?
+ *
+ * \todo In which version was this function introduced?
+ * \todo In which version was this function deprecated?
+ *
+ */
+H5_DLL herr_t H5Fset_latest_format(hid_t file_id, hbool_t latest_format);
+/**
+ * \ingroup H5F
+ *
+ * \brief Determines whether a file is in the HDF5 format
+ *
+ * \param[in] file_name File name
+ *
+ * \return \htri_t
+ *
+ * \deprecated When?
+ *
+ * \details H5Fis_hdf5() determines whether a file is in the HDF5 format.
+ *
+ * \todo In which version was this function deprecated?
+ * \todo In which version was this function introduced?
+ *
+ */
+H5_DLL htri_t H5Fis_hdf5(const char *file_name);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* H5Fpublic_H */
diff --git a/install/include/H5Gpublic.h b/install/include/H5Gpublic.h
new file mode 100644
index 0000000000..cc04680316
--- /dev/null
+++ b/install/include/H5Gpublic.h
@@ -0,0 +1,1177 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5Gpublic.h
+ *
+ * Purpose:             Public declarations for the H5G package
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef H5Gpublic_H
+#define H5Gpublic_H
+
+#include "H5public.h"  /* Generic Functions                        */
+#include "H5Ipublic.h" /* Identifiers                              */
+#include "H5Lpublic.h" /* Links                                    */
+#include "H5Opublic.h" /* Object Headers                           */
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+//! <!-- [H5G_storage_t_snip] -->
+/**
+ * Types of link storage for groups
+ */
+typedef enum H5G_storage_type_t {
+    H5G_STORAGE_TYPE_UNKNOWN = -1, /**< Unknown link storage type	*/
+    H5G_STORAGE_TYPE_SYMBOL_TABLE, /**< Links in group are stored with a "symbol table" */
+                                   /**< (this is sometimes called "old-style" groups) */
+    H5G_STORAGE_TYPE_COMPACT,      /**< Links are stored in object header */
+    H5G_STORAGE_TYPE_DENSE         /**< Links are stored in fractal heap & indexed with v2 B-tree */
+} H5G_storage_type_t;
+//! <!-- [H5G_storage_t_snip] -->
+
+//! <!-- [H5G_info_t_snip] -->
+/**
+ * Information struct for group for
+ * H5Gget_info(), H5Gget_info_by_name(), and H5Gget_info_by_idx()
+ */
+typedef struct H5G_info_t {
+    H5G_storage_type_t storage_type; /**< Type of storage for links in group */
+    hsize_t            nlinks;       /**< Number of links in group */
+    int64_t            max_corder;   /**< Current max. creation order value for group */
+    hbool_t            mounted;      /**< Whether group has a file mounted on it */
+} H5G_info_t;
+//! <!-- [H5G_info_t_snip] -->
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Creates a new group and links it into the file
+ *
+ * \fgdta_loc_id
+ * \param[in] name      Name of the group to create
+ * \lcpl_id
+ * \gcpl_id
+ * \gapl_id
+ *
+ * \return \hid_t{group}
+ *
+ * \details H5Gcreate2() creates a new group in a file. After a
+ *          group has been created, links to datasets and to other groups
+ *          can be added.
+ *
+ *          The \p loc_id and \p name parameters specify where the group
+ *          is located. \p loc_id may be a file, group, dataset, named
+ *          datatype or attribute in the file. If an attribute, dataset,
+ *          or named datatype is specified for \p loc_id then the group
+ *          will be created at the location where the attribute, dataset,
+ *          or named datatype is attached. \p name is the link to the group;
+ *          \p name may be either an absolute path in the file (the links
+ *          from the root group to the new group) or a relative path from
+ *          \p loc_id (the link(s) from the group specified by \p loc_id
+ *          to the new group).
+ *
+ *          \p lcpl_id, \p gcpl_id, and \p gapl_id are property list
+ *          identifiers. These property lists govern how the link to the
+ *          group is created, how the group is created, and how the group
+ *          can be accessed in the future, respectively. #H5P_DEFAULT can
+ *          be passed in if the default properties are appropriate for
+ *          these property lists. Currently, there are no APIs for the
+ *          group access property list; use #H5P_DEFAULT.
+ *
+ *          The group identifier should be closed by H5Gclose() when access
+ *          is no longer required to prevent resource leaks.
+ *
+ * \since 1.8.0
+ *
+ * \see H5Gopen2()
+ *
+ */
+H5_DLL hid_t H5Gcreate2(hid_t loc_id, const char *name, hid_t lcpl_id, hid_t gcpl_id, hid_t gapl_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Gcreate}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Gcreate_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                             const char *name, hid_t lcpl_id, hid_t gcpl_id, hid_t gapl_id, hid_t es_id);
+#else
+H5_DLL hid_t  H5Gcreate_async(hid_t loc_id, const char *name, hid_t lcpl_id, hid_t gcpl_id, hid_t gapl_id,
+                              hid_t es_id);
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Creates a new empty group without linking it into the file structure
+ *
+ * \fgdta_loc_id
+ * \gcpl_id
+ * \gapl_id
+ *
+ * \return \hid_t{group}
+ *
+ * \details H5Gcreate_anon() creates a new empty group in the file
+ *          specified by \p loc_id. With default settings, H5Gcreate_anon()
+ *          provides similar functionality to that provided by
+ *          H5Gcreate1(), with the differences described in the list below.
+ *
+ *          The new group's creation and access properties are specified
+ *          in \p gcpl_id and \p gapl_id, respectively.
+ *
+ *          H5Gcreate_anon() returns a new group identifier. This identifier
+ *          must be linked into the HDF5 file structure with H5Olink()
+ *          or it will be deleted from the file when the file is closed.
+ *
+ *          The differences between this function and H5Gcreate1() are
+ *          as follows:
+ *
+ *          \li H5Gcreate1() does not provide for the use of custom property
+ *              lists; H5Gcreate1() always uses default properties.
+ *          \li H5Gcreate_anon() neither provides the new group's name
+ *              nor links it into the HDF5 file structure; those actions
+ *              must be performed separately through a call to H5Olink(),
+ *              which offers greater control over linking.
+ *          \li H5Gcreate_anon() does not directly provide a hint mechanism
+ *              for the group's heap size. Comparable information can be
+ *              included in the group creation property list \p gcpl_id through
+ *              a H5Pset_local_heap_size_hint() call.
+ *
+ *          A group created with this function should be closed with
+ *          H5Gclose() when the group is no longer needed so that resource
+ *          leaks will not develop.
+ *
+ * \see H5Olink(), H5Gcreate()
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Gcreate_anon(hid_t loc_id, hid_t gcpl_id, hid_t gapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Opens an existing group in a file
+ *
+ * \fgdta_loc_id
+ * \param[in] name      Name of the group to open
+ * \gapl_id
+ *
+ * \return \hid_t{group}
+ *
+ * \details H5Gopen2() opens an existing group, \p name, at the location
+ *          specified by \p loc_id.
+ *
+ *          With default settings, H5Gopen2() provides similar functionality
+ *          to that provided by H5Gopen(). The only difference is that
+ *          H5Gopen2() can provide a group access property list, \p gapl_id.
+ *
+ *          H5Gopen2() returns a group identifier for the group that was
+ *          opened. This group identifier should be released by H5Gclose()
+ *          when it is no longer needed to prevent resource leaks.
+ *
+ * \since 1.8.0
+ *
+ * \see H5Gcreate2()
+ *
+ */
+H5_DLL hid_t H5Gopen2(hid_t loc_id, const char *name, hid_t gapl_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Gopen}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Gopen_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                           const char *name, hid_t gapl_id, hid_t es_id);
+#else
+H5_DLL hid_t  H5Gopen_async(hid_t loc_id, const char *name, hid_t gapl_id, hid_t es_id);
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Gets a group creation property list identifier
+ *
+ * \group_id
+ *
+ * \return \hid_t{creation property list}
+ *
+ * \details H5Gget_create_plist() returns an identifier for the group creation
+ *          property list associated with the group specified by \p group_id.
+ *
+ *          The creation property list identifier should be released with
+ *          H5Pclose() to prevent resource leaks.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Gget_create_plist(hid_t group_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Retrieves information about a group
+ *
+ * \fgdta_loc_id
+ * \param[out] ginfo Struct in which group information is returned
+ *
+ * \return \hid_t{group}
+ *
+ * \details H5Gget_info() retrieves information about the group at location
+ *          specified by \p loc_id. The information is returned in the \p ginfo.
+ *
+ *          \p ginfo is an H5G_info_t struct and is defined (in H5Gpublic.h)
+ *          as follows:
+ *
+ * \snippet this H5G_info_t_snip
+ * Possible values of \p storage_type are:
+ * \storage_type
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Gget_info(hid_t loc_id, H5G_info_t *ginfo);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Gget_info}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Gget_info_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                                H5G_info_t *ginfo /*out*/, hid_t es_id);
+#else
+H5_DLL herr_t H5Gget_info_async(hid_t loc_id, H5G_info_t *ginfo /*out*/, hid_t es_id);
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Retrieves information about a group by its name
+ *
+ * \fgdta_loc_id
+ * \param[in] name      Name of the group to query
+ * \param[out] ginfo Struct in which group information is returned
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Gget_info_by_name() retrieves information about the group \p name
+ *          at location specified by \p loc_id. The information is returned in
+ *          the \p ginfo struct.
+ *
+ *          If \p loc_id specifies the group for which information is queried,
+ *          then the group's \p name can be a dot (.).
+ *
+ *          \p ginfo is an H5G_info_t struct and is defined (in H5Gpublic.h)
+ *          as follows:
+ *
+ * \snippet this H5G_info_t_snip
+ * Possible values of \p storage_type are:
+ * \storage_type
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Gget_info_by_name(hid_t loc_id, const char *name, H5G_info_t *ginfo, hid_t lapl_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Gget_info_by_name}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Gget_info_by_name_async(const char *app_file, const char *app_func, unsigned app_line,
+                                        hid_t loc_id, const char *name, H5G_info_t *ginfo /*out*/,
+                                        hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL herr_t H5Gget_info_by_name_async(hid_t loc_id, const char *name, H5G_info_t *ginfo /*out*/,
+                                        hid_t lapl_id, hid_t es_id);
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Retrieves information about a group, according to the group's
+ *        position within an index
+ *
+ * \fgdta_loc_id
+ * \param[in] group_name Name of the group to query
+ * \param[in] idx_type   Transient index identifying object
+ * \param[in] order      Transient index identifying object
+ * \param[in] n          Position in the index of the group to query
+ * \param[out] ginfo     Struct in which group information is returned
+ * \lapl_id
+ *
+ * \return Returns
+ *      \li The size of the object name if successful, or
+ *      \li 0 if no name is associated with the group identifier, or
+ *      \li negative value, if failure occurred
+ *
+ * \details H5Gget_info_by_idx() retrieves the same information
+ *          about a group as retrieved by the function H5Gget_info(),
+ *          but the means of identifying the group differs; the group is
+ *          identified by position in an index rather than by name.
+ *
+ *          \p loc_id and \p group_name specify the group containing
+ *          the group for which information is sought. The groups in \p
+ *          group_name are indexed by \p idx_type; the group for which
+ *          information is retrieved is identified in that index by index
+ *          order, \p order, and index position, \p n.
+ *
+ *          If \p loc_id specifies the group containing the group for
+ *          which information is queried, \p group_name can be a dot (.).
+ *
+ *          Valid values for \p index_type are as follows:
+ * \indexes
+ *          The order in which the index is to be examined, as specified
+ *          by \p order, can be one of the following:
+ * \orders
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Gget_info_by_idx(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                 H5_iter_order_t order, hsize_t n, H5G_info_t *ginfo, hid_t lapl_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Gget_info_by_idx}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Gget_info_by_idx_async(const char *app_file, const char *app_func, unsigned app_line,
+                                       hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                       H5_iter_order_t order, hsize_t n, H5G_info_t *ginfo /*out*/,
+                                       hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL herr_t H5Gget_info_by_idx_async(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                       H5_iter_order_t order, hsize_t n, H5G_info_t *ginfo /*out*/,
+                                       hid_t lapl_id, hid_t es_id);
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Flushes all buffers associated with a group to disk
+ *
+ * \group_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Gflush() causes all buffers associated with a group to be
+ *          immediately flushed to the disk without removing the data from
+ *          the cache.
+ *
+ * \attention
+ *          HDF5 does not possess full control over buffering. H5G_FLUSH
+ *          flushes the internal HDF5 buffers and then asks the operating
+ *          system (the OS) to flush the system buffers for the open
+ *          files. After that, the OS is responsible for ensuring that
+ *          the data is actually flushed to the disk.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Gflush(hid_t group_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Refreshes all buffers associated with a group
+ *
+ * \group_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Grefresh() causes all buffers associated with a group to be
+ *          cleared and immediately re-loaded with updated contents from disk.
+ *
+ *          This function essentially closes the group, evicts all
+ *          metadata associated with it from the cache, and then reopens
+ *          the group. The reopened group is automatically re-registered
+ *          with the same identifier.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Grefresh(hid_t group_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Closes the specified group
+ *
+ * \group_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Gclose() releases resources used by a group that was
+ *          opened by H5Gcreate() or H5Gopen().  After closing a group,
+ *          \p group_id cannot be used again until another H5Gcreate()
+ *          or H5Gopen() is called on it.
+ *
+ *          Failure to release a group with this call will result in
+ *          resource leaks.
+ *
+ * \par Example
+ * \snippet H5F_examples.c mount
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Gclose(hid_t group_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Gclose}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Gclose_async(const char *app_file, const char *app_func, unsigned app_line, hid_t group_id,
+                             hid_t es_id);
+#else
+H5_DLL herr_t H5Gclose_async(hid_t group_id, hid_t es_id);
+#endif
+
+/// \cond DEV
+/* API Wrappers for async routines */
+/* (Must be defined _after_ the function prototype) */
+/* (And must only defined when included in application code, not the library) */
+#ifndef H5G_MODULE
+#define H5Gcreate_async(...)           H5Gcreate_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Gopen_async(...)             H5Gopen_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Gget_info_async(...)         H5Gget_info_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Gget_info_by_name_async(...) H5Gget_info_by_name_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Gget_info_by_idx_async(...)  H5Gget_info_by_idx_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Gclose_async(...)            H5Gclose_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+
+/* Define "wrapper" versions of function calls, to allow compile-time values to
+ *      be passed in by language wrapper or library layer on top of HDF5.
+ */
+#define H5Gcreate_async_wrap           H5_NO_EXPAND(H5Gcreate_async)
+#define H5Gopen_async_wrap             H5_NO_EXPAND(H5Gopen_async)
+#define H5Gget_info_async_wrap         H5_NO_EXPAND(H5Gget_info_async)
+#define H5Gget_info_by_name_async_wrap H5_NO_EXPAND(H5Gget_info_by_name_async)
+#define H5Gget_info_by_idx_async_wrap  H5_NO_EXPAND(H5Gget_info_by_idx_async)
+#define H5Gclose_async_wrap            H5_NO_EXPAND(H5Gclose_async)
+#endif /* H5G_MODULE */
+/// \endcond
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+
+/* Link definitions */
+#define H5G_SAME_LOC   H5L_SAME_LOC
+#define H5G_LINK_ERROR H5L_TYPE_ERROR
+#define H5G_LINK_HARD  H5L_TYPE_HARD
+#define H5G_LINK_SOFT  H5L_TYPE_SOFT
+#define H5G_link_t     H5L_type_t
+
+/* Macros for types of objects in a group (see H5G_obj_t definition) */
+#define H5G_NTYPES      256 /* Max possible number of types	*/
+#define H5G_NLIBTYPES   8   /* Number of internal types	*/
+#define H5G_NUSERTYPES  (H5G_NTYPES - H5G_NLIBTYPES)
+#define H5G_USERTYPE(X) (8 + (X)) /* User defined types		*/
+
+/* Typedefs */
+
+//! <!-- [H5G_obj_t_snip] -->
+/**
+ * An object has a certain type. The first few numbers are reserved for use
+ * internally by HDF5. Users may add their own types with higher values.  The
+ * values are never stored in the file -- they only exist while an application
+ * is running.  An object may satisfy the `isa' function for more than one type.
+ *
+ * \deprecated
+ */
+typedef enum H5G_obj_t {
+    H5G_UNKNOWN = -1, /**< Unknown object type		*/
+    H5G_GROUP,        /**< Object is a group		*/
+    H5G_DATASET,      /**< Object is a dataset		*/
+    H5G_TYPE,         /**< Object is a named data type	*/
+    H5G_LINK,         /**< Object is a symbolic link	*/
+    H5G_UDLINK,       /**< Object is a user-defined link */
+    H5G_RESERVED_5,   /**< Reserved for future use	*/
+    H5G_RESERVED_6,   /**< Reserved for future use	*/
+    H5G_RESERVED_7    /**< Reserved for future use	*/
+} H5G_obj_t;
+//! <!-- [H5G_obj_t_snip] -->
+
+//! <!-- [H5G_iterate_t_snip] -->
+/**
+ * Callback for H5Giterate()
+ *
+ * \deprecated
+ */
+typedef herr_t (*H5G_iterate_t)(hid_t group, const char *name, void *op_data);
+//! <!-- [H5G_iterate_t_snip] -->
+
+//! <!-- [H5G_stat_t_snip] -->
+/**
+ * Information about an object
+ *
+ * \deprecated
+ */
+typedef struct H5G_stat_t {
+    unsigned long fileno[2]; /**< file number			*/
+    unsigned long objno[2];  /**< object number			*/
+    unsigned      nlink;     /**< number of hard links to object*/
+    H5G_obj_t     type;      /**< basic object type		*/
+    time_t        mtime;     /**< modification time		*/
+    size_t        linklen;   /**< symbolic link value length	*/
+    H5O_stat_t    ohdr;      /**< Object header information    */
+} H5G_stat_t;
+//! <!-- [H5G_stat_t_snip] -->
+
+/* Function prototypes */
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Creates a new group and links it into the file
+ *
+ * \fgdta_loc_id
+ * \param[in] name      Name of the group to create
+ * \param[in] size_hint The number of bytes to reserve for the names
+ *                      that will appear in the group
+ *
+ * \return \hid_t{group}
+ *
+ * \deprecated This function is deprecated in favor of H5Gcreate2().
+ *
+ * \details H5Gcreate1() creates a new group with the specified name at the
+ *          specified location, \p loc_id.  \p loc_id may be a file, group,
+ *          dataset, named datatype or attribute.  If an attribute, dataset, or
+ *          named datatype is specified for \p loc_id then the group will be
+ *          created at the location where the attribute, dataset, or named
+ *          datatype is attached. The name, name, must not already be taken by
+ *          some other object and all parent groups must already exist.
+ *
+ *          \p name can be a relative path based at \p loc_id or an absolute
+ *          path from the root of the file. Use of this function requires that
+ *          any intermediate groups specified in the path already exist.
+ *
+ *          The length of a group name, or of the name of any object within a
+ *          group, is not limited.
+ *
+ *          \p size_hint is a hint for the number of bytes to reserve to store
+ *          the names which will be eventually added to the new group. This
+ *          value must be between 0 and UINT32_MAX (inclusive). If this
+ *          parameter is zero, a default value will be used.
+ *
+ *          The return value is a group identifier for the open group. This
+ *          group identifier should be closed by calling H5Gclose() when it is
+ *          no longer needed.
+ *
+ *          See H5Gcreate_anon() for a discussion of the differences between
+ *          H5Gcreate1() and H5Gcreate_anon().
+ *
+ * \par Example
+ * \snippet H5F_examples.c mount
+ *
+ * \version 1.8.0 Function H5Gcreate() renamed to H5Gcreate1() and deprecated
+ *                in this release.
+ * \since 1.0.0
+ *
+ */
+H5_DLL hid_t H5Gcreate1(hid_t loc_id, const char *name, size_t size_hint);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Opens an existing group for modification and returns a group
+ *        identifier for that group
+ *
+ * \fgdta_loc_id
+ * \param[in] name      Name of the group to open
+ *
+ * \return \hid_t{group}
+ *
+ * \deprecated This function is deprecated in favor of H5Gopen2().
+ *
+ * \details H5Gopen1() opens an existing group, \p name, at the location
+ *          specified by \p loc_id.
+ *
+ *          H5Gopen1() returns a group identifier for the group that was
+ *          opened. This group identifier should be released by calling
+ *          H5Gclose() when it is no longer needed.
+ *
+ * \version 1.8.0 The function H5Gopen() was renamed to H5Gopen1()
+ *                and deprecated in this release.
+ * \since 1.0.0
+ *
+ */
+H5_DLL hid_t H5Gopen1(hid_t loc_id, const char *name);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Creates a link of the specified type from \p new_name to \p
+ *        cur_name
+ *
+ * \fg_loc_id{cur_loc_id}
+ * \param[in] type Link type
+ * \param[in] cur_name Name of the existing object
+ * \param[in] new_name New name for the object
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function is deprecated.
+ *
+ * \details H5Glink() creates a new name for an object that has some current
+ *          name, possibly one of many names it currently has.
+ *
+ *          If \p link_type is #H5G_LINK_HARD, then \p cur_name must specify
+ *          the name of an existing object and both names are interpreted
+ *          relative to \p cur_loc_id, which is either a file identifier or a
+ *          group identifier.
+ *
+ *          If \p link_type is #H5G_LINK_SOFT, then \p cur_name can be anything
+ *          and is interpreted at lookup time relative to the group which
+ *          contains the final component of \p new_name. For instance, if \p
+ *          cur_name is \Code{./foo}, \p new_name is \Code{./x/y/bar}, and a
+ *          request is made for \Code{./x/y/bar}, then the actual object looked
+ *          up is \Code{./x/y/./foo}.
+
+ * \version 1.8.0 Function deprecated in this release.
+ *
+ */
+H5_DLL herr_t H5Glink(hid_t cur_loc_id, H5G_link_t type, const char *cur_name, const char *new_name);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Creates a link of the specified type from \p cur_name to \p
+ *        new_name
+ *
+ * \fg_loc_id{cur_loc_id}
+ * \param[in] cur_name Name of the existing object
+ * \param[in] type Link type
+ * \fg_loc_id{new_loc_id}
+ * \param[in] new_name New name for the object
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function is deprecated.
+ *
+ * \details H5Glink2() creates a new name for an object that has some current
+ *          name, possibly one of many names it currently has.
+ *
+ *          If \p link_type is #H5G_LINK_HARD, then \p cur_name must specify the
+ *          name of an existing object and both names are interpreted relative
+ *          to \p cur_loc_id and \p new_loc_id, respectively, which are either
+ *          file identifiers or group identifiers.
+ *
+ *          If \p link_type is #H5G_LINK_SOFT, then \p cur_name can be anything
+ *          and is interpreted at lookup time relative to the group which
+ *          contains the final component of \p new_name. For instance, if \p
+ *          current_name is \Code{./foo}, \p new_name is \Code{./x/y/bar}, and a
+ *          request is made for \Code{./x/y/bar}, then the actual object looked
+ *          up is \Code{./x/y/./foo}.
+
+ * \version 1.8.0 Function deprecated in this release.
+ *
+ */
+H5_DLL herr_t H5Glink2(hid_t cur_loc_id, const char *cur_name, H5G_link_t type, hid_t new_loc_id,
+                       const char *new_name);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Renames an object within an HDF5 file
+ *
+ * \fg_loc_id{src_loc_id}
+ * \param[in] src_name Object's original name
+ * \param[in] dst_name Object's new name
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function is deprecated.
+ *
+ * \details H5Gmove() renames an object within an HDF5 file. The original name,
+ *          \p src_name, is unlinked from the group graph and the new name, \p
+ *          dst_name, is inserted as an atomic operation. Both names are
+ *          interpreted relative to \p loc_id, which is either a file or a group
+ *          identifier.
+ *
+ * \attention Exercise care in moving groups as it is possible to render data in
+ *            a file inaccessible with H5Gmove(). See The Group Interface in the
+ *            \ref UG.
+ *
+ * \version 1.8.0 Function deprecated in this release.
+ *
+ */
+H5_DLL herr_t H5Gmove(hid_t src_loc_id, const char *src_name, const char *dst_name);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Renames an object within an HDF5 file
+ *
+ * \fg_loc_id{src_loc_id}
+ * \param[in] src_name Object's original name
+ * \fg_loc_id{dst_loc_id}
+ * \param[in] dst_name Object's new name
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function is deprecated.
+ *
+ * \details H5Gmove2() renames an object within an HDF5 file. The original name,
+ *          \p src_name, is unlinked from the group graph and the new name, \p
+ *          dst_name, is inserted as an atomic operation.
+ *
+ *          \p src_name and \p dst_name are interpreted relative to \p
+ *          src_loc_id and \p dst_loc_id, respectively, which are either file or
+ *          group identifiers.
+ *
+ * \attention Exercise care in moving groups as it is possible to render data in
+ *            a file inaccessible with H5Gmove2(). See The Group Interface in the
+ *            \ref UG.
+ *
+ * \version 1.8.0 Function deprecated in this release.
+ *
+ */
+H5_DLL herr_t H5Gmove2(hid_t src_loc_id, const char *src_name, hid_t dst_loc_id, const char *dst_name);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Removes the link to an object from a group
+ *
+ * \fg_loc_id{loc_id}
+ * \param[in] name Name of the object to unlink
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function is deprecated in favor of the function H5Ldelete().
+ *
+ * \details H5Gunlink() removes the object specified by \p name from the group
+ *          graph and decrements the link count for the object to which \p name
+ *          points. This action eliminates any association between name and the
+ *          object to which name pointed.
+ *
+ *          Object headers keep track of how many hard links refer to an object;
+ *          when the link count reaches zero, the object can be removed from the
+ *          file. Objects which are open are not removed until all identifiers
+ *          to the object are closed.
+ *
+ *          If the link count reaches zero, all file space associated with the
+ *          object will be released, i.e., identified in memory as freespace. If
+ *          any object identifier is open for the object, the space will not be
+ *          released until after the object identifier is closed.
+ *
+ *          Note that space identified as freespace is available for reuse only
+ *          as long as the file remains open; once a file has been closed, the
+ *          HDF5 library loses track of freespace. See Freespace Management in
+ *          the \ref UG for further details.
+ *
+ * \attention Exercise care in moving groups as it is possible to render data in
+ *            a file inaccessible with H5Gunlink(). See The Group Interface in the
+ *            \ref UG.
+ *
+ * \version 1.8.0 Function deprecated in this release.
+ *
+ */
+H5_DLL herr_t H5Gunlink(hid_t loc_id, const char *name);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Returns the name of the object that the symbolic link points to
+ *
+ * \fg_loc_id{loc_id}
+ * \param[in] name Symbolic link to the object whose name is to be returned
+ * \param[in] size Maximum number of characters of value to be returned
+ * \param[out] buf A buffer to hold the name of the object being sought
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function is deprecated in favor of the function H5Lget_val().
+ *
+ * \details H5Gget_linkval() returns up to size characters of the name of the
+ *          object that the symbolic link name points to.
+ *
+ *          The parameter \p loc_id is a file or group identifier.
+ *
+ *          The parameter \p name must be a symbolic link pointing to the
+ *          desired object and must be defined relative to \p loc_id.
+ *
+ *          If size is smaller than the size of the returned object name, then
+ *          the name stored in the buffer value will not be \c NULL terminated.
+ *
+ *          This function fails if \p name is not a symbolic link. The presence
+ *          of a symbolic link can be tested by passing zero for \p size and \p
+ *          NULL for value.
+ *
+ *          This function should be used only after H5Lget_info1() (or the
+ *          deprecated function H5Gget_objinfo()) has been called to verify that
+ *          name is a symbolic link.
+ *
+ * \version 1.8.0 Function deprecated in this release.
+ *
+ */
+H5_DLL herr_t H5Gget_linkval(hid_t loc_id, const char *name, size_t size, char *buf /*out*/);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Sets comment for specified object
+ *
+ * \fgdt_loc_id
+ * \param[in] name Name of the object whose comment is to be set or reset
+ *                 name must be \Code{'.'} (dot) if \p loc_id fully specifies
+ *                 the object for which the comment is to be set.
+ * \param[in] comment The new comment
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function is deprecated in favor of the function
+ *             H5Oset_comment().
+ *
+ * \details H5Gset_comment() sets the comment for the object specified by \p
+ *          loc_id and name to comment. Any previously existing comment is
+ *          overwritten.
+ *
+ *          \p loc_id can specify any object in the file. name can be one of the
+ *          following:
+ *          \li The name of the object relative to \p loc_id
+ *          \li An absolute name of the object, starting from \c /, the file's
+ *              root group
+ *          \li A dot (\c .), if \p loc_id fully specifies the object
+ *
+ *          If \p comment is the empty string or a null pointer, the comment
+ *          message is removed from the object.
+ *
+ *          Comments should be relatively short, null-terminated, ASCII strings.
+ *
+ *          Comments can be attached to any object that has an object header,
+ *          e.g., datasets, groups, and named datatypes, but not symbolic links.
+ *
+ * \version 1.8.0 Function deprecated in this release.
+ *
+ */
+H5_DLL herr_t H5Gset_comment(hid_t loc_id, const char *name, const char *comment);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Retrieves comment for specified object
+ *
+ * \fgdt_loc_id
+ * \param[in] name Name of the object whose comment is to be set or reset
+ *                 name must be \Code{'.'} (dot) if \p loc_id fully specifies
+ *                 the object for which the comment is to be set.
+ * \param[in] bufsize Maximum number of comment characters to be returned in \p buf.
+ * \param[in] buf The comment
+ *
+ * \return Returns the number of characters in the comment, counting the \c NULL
+ *         terminator, if successful; the value returned may be larger than
+ *         \p bufsize. Otherwise returns a negative value.
+ *
+ * \deprecated This function is deprecated in favor of the function
+ *             H5Oget_comment().
+ *
+ * \details H5Gget_comment() retrieves the comment for the object specified
+ *          by \p loc_id and \p name. The comment is returned in the buffer \p
+ *          buf.
+ *
+ *          \p loc_id can specify any object in the file. name can be one of the
+ *          following:
+ *          \li The name of the object relative to \p loc_id
+ *          \li An absolute name of the object, starting from \c /, the file's
+ *              root group
+ *          \li A dot (\c .), if \p loc_id fully specifies the object
+ *
+ *          At most bufsize characters, including a null-terminator, are
+ *          returned in \p buf. The returned value is not null-terminated if the
+ *          comment is longer than the supplied buffer. If the size of the
+ *          comment is unknown, a preliminary \p H5Gget_comment() call will
+ *          return the size of the comment, including space for the
+ *          null-terminator.
+ *
+ *          If an object does not have a comment, the empty string is returned
+ *          in comment.
+ *
+ * \version 1.8.0 Function deprecated in this release.
+ *
+ */
+H5_DLL int H5Gget_comment(hid_t loc_id, const char *name, size_t bufsize, char *buf);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Iterates over the entries of a group invoking a callback for each
+ *        entry encountered
+ *
+ * \fg_loc_id
+ * \param[in] name Group over which the iteration is performed
+ * \param[in,out] idx Location at which to begin the iteration
+ * \param[in] op Operation to be performed on an object at each step of the
+ *               iteration
+ * \param[in,out] op_data Data associated with the operation
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function is deprecated in favor of the function
+ *             H5Literate1().
+ *
+ * \details H5Giterate() iterates over the members of name in the file or group
+ *          specified with \p loc_id. For each object in the group, the \p
+ *          op_data and some additional information, specified below, are passed
+ *          to the operator function. The iteration begins with the \p idx
+ *          object in the group and the next element to be processed by the
+ *          operator is returned in \p idx. If \p idx is NULL, then the iterator
+ *          starts at the first group member; since no stopping point is
+ *          returned in this case, the iterator cannot be restarted if one of
+ *          the calls to its operator returns non-zero. H5Giterate() does not
+ *          recursively follow links into subgroups of the specified group.
+ *
+ *          The prototype for \ref H5G_iterate_t is:
+ *          \snippet this H5G_iterate_t_snip
+ *
+ *          The operation receives the group identifier for the group being
+ *          iterated over, \p group, the name of the current object within
+ *          the group, \p name, and the pointer to the operator data
+ *          passed into H5Giterate(), \p op_data.
+ *
+ *          The return values from an operator are:
+ *          \li Zero causes the iterator to continue, returning zero when all
+ *              group members have been processed.
+ *          \li Positive causes the iterator to immediately return that positive
+ *              value, indicating short-circuit success. The iterator can be
+ *              restarted at the next group member.
+ *          \li Negative causes the iterator to immediately return that value,
+ *              indicating failure. The iterator can be restarted at the next
+ *              group member.
+ *
+ *          H5Giterate() assumes that the membership of the group identified by
+ *          \p name remains unchanged through the iteration. If the membership
+ *          changes during the iteration, the function's behavior is undefined.
+ *
+ *          H5Giterate() is not recursive. In particular, if a member of \p name
+ *          is found to be a group, call it \c subgroup_a, H5Giterate() does not
+ *          examine the members of \c subgroup_a. When recursive iteration is
+ *          required, the application must handle the recursion, explicitly
+ *          calling H5Giterate() on discovered subgroups.
+ *
+ * \warning  Adding or removing members to the group during iteration
+ *           will lead to undefined behavior.
+ *
+ * \version 1.8.0 Function deprecated in this release.
+ *
+ */
+H5_DLL herr_t H5Giterate(hid_t loc_id, const char *name, int *idx, H5G_iterate_t op, void *op_data);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Returns number of objects in the group specified by its identifier
+ *
+ * \fg_loc_id
+ * \param[out] num_objs Number of objects in the group
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function is deprecated in favor of the function H5Gget_info().
+ *
+ * \details H5Gget_num_objs() returns number of objects in a group. Group is
+ *          specified by its identifier \p loc_id. If a file identifier is
+ *          passed in, then the number of objects in the root group is returned.
+ *
+ * \version 1.8.0 Function deprecated in this release.
+ *
+ */
+H5_DLL herr_t H5Gget_num_objs(hid_t loc_id, hsize_t *num_objs);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Returns information about an object.
+ *
+ * \fgdt_loc_id
+ * \param[in] name Name of the object for which status is being sought
+ * \param[in] follow_link Link flag
+ * \param[out] statbuf Buffer in which to return information about the object
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function is deprecated in favor of the functions H5Oget_info()
+ *             and H5Lget_info1().
+ *
+ * \details H5Gget_objinfo() returns information about the specified object
+ *          through the \p statbuf argument.
+ *
+ *          A file or group identifier, \p loc_id, and an object name, \p name,
+ *          relative to \p loc_id, are commonly used to specify the
+ *          object. However, if the object identifier is already known to the
+ *          application, an alternative approach is to use that identifier, \c
+ *          obj_id, in place of \p loc_id, and a dot (\c .) in place of \p
+ *          name. Thus, the alternative versions of the first portion of an
+ *          H5Gget_objinfo() call would be as follows:
+ *          \code
+ *          H5Gget_objinfo (loc_id name  ...)
+ *          H5Gget_objinfo (obj_id .     ...)
+ *          \endcode
+ *
+ *          If the object is a symbolic link and follow_link is zero (0), then
+ *          the information returned describes the link itself; otherwise the
+ *          link is followed and the information returned describes the object
+ *          to which the link points. If \p follow_link is non-zero but the
+ *          final symbolic link is dangling (does not point to anything), then
+ *          an error is returned. The \p statbuf fields are undefined for an
+ *          error. The existence of an object can be tested by calling this
+ *          function with a \c NULL \p statbuf.
+ *
+ *          H5Gget_objinfo() fills in the following data structure (defined in
+ *          H5Gpublic.h):
+ *          \snippet this H5G_stat_t_snip
+ *
+ *          where \ref H5O_stat_t (defined in H5Opublic.h) is:
+ *          \snippet H5Opublic.h H5O_stat_t_snip
+ *
+ * \attention Some systems will be able to record the time accurately but unable
+ *            to retrieve the correct time; such systems (e.g., Irix64) will
+ *            report an \c mtime value of 0 (zero).
+ *
+ * \version 1.8.0 Function deprecated in this release.
+ * \version 1.6.1 Two new fields were added to the \ref H5G_stat_t struct in
+ *                this release.
+ *
+ */
+H5_DLL herr_t H5Gget_objinfo(hid_t loc_id, const char *name, hbool_t follow_link,
+                             H5G_stat_t *statbuf /*out*/);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Returns the name of an object specified by an index
+ *
+ * \fg_loc_id
+ * \param[in] idx Transient index identifying object
+ * \param[in,out] name Pointer to user-provided buffer the object name
+ * \param[in] size Name length
+ *
+ * \return Returns the size of the object name if successful, or 0 if no name is
+ *         associated with the group identifier. Otherwise returns a negative
+ *         value.
+ *
+ * \deprecated This function is deprecated in favor of the function H5Lget_name_by_idx().
+ *
+ * \details H5Gget_objname_by_idx() returns the name of the object specified by
+ *          the index \p idx in the group \p loc_id.
+ *
+ *          The group is specified by a group identifier \p loc_id. If
+ *          preferred, a file identifier may be passed in \p loc_id; that file's
+ *          root group will be assumed.
+ *
+ *          \p idx is the transient index used to iterate through the objects in
+ *          the group. The value of \p idx is any nonnegative number less than
+ *          the total number of objects in the group, which is returned by the
+ *          function H5Gget_num_objs(). Note that this is a transient index; an
+ *          object may have a different index each time a group is opened.
+ *
+ *          The object name is returned in the user-specified buffer \p name.
+ *
+ *          If the size of the provided buffer \p name is less or equal the
+ *          actual object name length, the object name is truncated to
+ *          \Code{max_size - 1} characters.
+ *
+ *          Note that if the size of the object's name is unknown, a preliminary
+ *          call to H5Gget_objname_by_idx() with \p name set to \c NULL will
+ *          return the length of the object's name. A second call to
+ *          H5Gget_objname_by_idx() can then be used to retrieve the actual
+ *          name.
+ *
+ * \version 1.8.0 Function deprecated in this release.
+ * \since 1.6.0
+ *
+ */
+H5_DLL ssize_t H5Gget_objname_by_idx(hid_t loc_id, hsize_t idx, char *name, size_t size);
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5G
+ *
+ * \brief Returns the type of an object specified by an index
+ *
+ * \fg_loc_id
+ * \param[in] idx Transient index identifying object
+ *
+ * \return Returns the type of the object if successful. Otherwise returns a
+ *         negative value.
+ *
+ * \deprecated This function is deprecated in favor of the function H5Oget_info().
+ *
+ * \details H5Gget_objtype_by_idx() returns the type of the object specified by
+ *          the index \p idx in the group \p loc_id.
+ *
+ *          The group is specified by a group identifier \p loc_id. If
+ *          preferred, a file identifier may be passed in \p loc_id; that file's
+ *          root group will be assumed.
+ *
+ *          \p idx is the transient index used to iterate through the objects in
+ *          the group. This parameter is described in more detail in the
+ *          discussion of H5Gget_objname_by_idx().
+ *
+ * \version 1.8.0 Function deprecated in this release.
+ * \version 1.6.0 The function return type changed from \c int to the enumerated
+ *                type \ref H5G_obj_t.
+ * \since 1.6.0
+ *
+ */
+H5_DLL H5G_obj_t H5Gget_objtype_by_idx(hid_t loc_id, hsize_t idx);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* H5Gpublic_H */
diff --git a/install/include/H5IMpublic.h b/install/include/H5IMpublic.h
new file mode 100644
index 0000000000..0ba9d648cf
--- /dev/null
+++ b/install/include/H5IMpublic.h
@@ -0,0 +1,349 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef H5IMpublic_H
+#define H5IMpublic_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** \page H5IM_UG The HDF5 High Level Images
+ * @todo Under Construction
+ */
+
+/**\defgroup H5IM HDF5 Images API (H5IM)
+ *
+ * <em>Creating and manipulating HDF5 datasets intended to be
+ * interpreted as images (H5IM)</em>
+ *
+ * The specification for the Images API is presented in another
+ * document: \ref IMG
+ * This version of the API is primarily concerned with two dimensional raster
+ * data similar to HDF4 Raster Images.
+ * The HDF5 Images API uses the \ref H5LT.
+ *
+ * \note \Bold{Programming hints:}
+ * \note To use any of these functions or subroutines,
+ *       you must first include the relevant include file (C) or
+ *       module (Fortran) in your application.
+ * \note The following line includes the HDF5 Images package, H5IM,
+ *       in C applications:
+ *       \code #include "hdf5_hl.h" \endcode
+ * \note This line includes the H5IM module in Fortran applications:
+ *       \code use h5im \endcode
+ *
+ * - \ref H5IMget_image_info
+ *    \n Gets information about an image dataset (dimensions,
+ *       interlace mode and number of associated palettes).
+ * - \ref H5IMget_npalettes
+ *   \n Gets the number of palettes associated to an image.
+ * - \ref H5IMget_palette
+ *   \n Gets the palette dataset.
+ * - \ref H5IMget_palette_info
+ *   \n Gets information about a palette dataset (dimensions).
+ * - \ref H5IMis_image
+ *   \n Inquires if a dataset is an image
+ * - \ref H5IMis_palette
+ *   \n Inquires if a dataset is a palette.
+ * - \ref H5IMlink_palette
+ *   \n Attaches a palette to an image.
+ * - \ref H5IMmake_image_8bit
+ *   \n Creates and writes an image.
+ * - \ref H5IMmake_image_24bit
+ *   \n Creates and writes a true color image.
+ * - \ref H5IMmake_palette
+ *   \n Creates and writes a palette.
+ * - \ref H5IMread_image
+ *   \n Reads image data from disk.
+ * - \ref H5IMunlink_palette
+ *   \n Detaches a palette from an image.
+ *
+ */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5IM
+ *
+ * \brief Creates and writes an image.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The name of the dataset to create
+ * \param[in] width     The width of the image
+ * \param[in] height    The height of the image
+ * \param[in] buffer    Buffer with data to be written to the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5IMmake_image_8bit() creates and writes a dataset named
+ *          \p dset_name attached to the file or group specified by the
+ *          identifier \p loc_id. Attributes conforming to the HDF5 Image
+ *          and Palette specification for an indexed image are attached to
+ *          the dataset, thus identifying it as an image. The image data is
+ *          of the type #H5T_NATIVE_UCHAR. An indexed image is an image in
+ *          which each each pixel information storage is an index to a
+ *          table palette.
+ *
+ */
+H5_HLDLL herr_t H5IMmake_image_8bit(hid_t loc_id, const char *dset_name, hsize_t width, hsize_t height,
+                                    const unsigned char *buffer);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5IM
+ *
+ * \brief Creates and writes a true color image.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The name of the dataset to create
+ * \param[in] width     The width of the image
+ * \param[in] height    The height of the image
+ * \param[in] interlace String defining the interlace mode
+ * \param[in] buffer    Buffer with data to be written to the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5IMmake_image_24bit() creates and writes a dataset named
+ *          \p dset_name attached to the file or group specified by the
+ *          identifier \p loc_id. This function defines a true color image
+ *          conforming to the HDF5 Image and Palette specification.
+ *          The function assumes that the image data is of the type
+ *          #H5T_NATIVE_UCHAR.
+ *
+ *          A true color image is an image where the pixel storage contains
+ *          several color planes. In a 24 bit RGB color model, these planes
+ *          are red, green and blue. In a true color image the stream of bytes
+ *          can be stored in several different ways, thus defining the
+ *          interlace (or interleaving) mode. The 2 most used types of interlace mode
+ *          are interlace by pixel and interlace by plane. In the 24 bit RGB color
+ *          model example, interlace by plane means all the red components for the
+ *          entire dataset are stored first, followed by all the green components,
+ *          and then by all the blue components. Interlace by pixel in this example
+ *          means that for each pixel the sequence red, green, blue is defined.
+ *          In this function, the interlace mode is defined in the parameter
+ *          \p interlace, a string that can have the values INTERLACE_PIXEL
+ *          or INTERLACE_PLANE.
+ *
+ */
+H5_HLDLL herr_t H5IMmake_image_24bit(hid_t loc_id, const char *dset_name, hsize_t width, hsize_t height,
+                                     const char *interlace, const unsigned char *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5IM
+ *
+ * \brief Gets information about an image dataset
+ *        (dimensions, interlace mode and number of associated palettes).
+ *
+ * \fg_loc_id
+ * \param[in] dset_name     The name of the dataset
+ * \param[out] width        The width of the image
+ * \param[out] height       The height of the image
+ * \param[out] planes       The number of color planes of the image
+ * \param[out] interlace    The interlace mode of the image
+ * \param[out] npals        The number of palettes associated to the image
+ *
+ * \return \herr_t
+ *
+ * \details H5IMget_image_info() gets information about an image
+ *          named \p dset_name attached to the file or group specified
+ *          by the identifier \p loc_id.
+ *
+ */
+H5_HLDLL herr_t H5IMget_image_info(hid_t loc_id, const char *dset_name, hsize_t *width, hsize_t *height,
+                                   hsize_t *planes, char *interlace, hssize_t *npals);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5IM
+ *
+ * \brief Reads image data from disk.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The name of the dataset to create
+ * \param[out] buffer   Buffer with data to store the image
+ *
+ * \return \herr_t
+ *
+ * \details H5IMread_image() reads a dataset named \p dset_name
+ *          attached to the file or group specified by the
+ *          identifier \p loc_id.
+ *
+ */
+H5_HLDLL herr_t H5IMread_image(hid_t loc_id, const char *dset_name, unsigned char *buffer);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5IM
+ *
+ * \brief Creates and writes a palette.
+ *
+ * \fg_loc_id
+ * \param[in] pal_name  The name of the palette
+ * \param[in] pal_dims  An array of the size of the palette dimensions
+ * \param[in] pal_data  Buffer with data to be written to the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5IMmake_palette() creates and writes a dataset
+ *          named \p pal_name. Attributes conforming to the HDF5 Image and
+ *          Palette specification are attached to the dataset, thus
+ *          identifying it as a palette. The palette data is of the
+ *          type #H5T_NATIVE_UCHAR.
+ *
+ */
+H5_HLDLL herr_t H5IMmake_palette(hid_t loc_id, const char *pal_name, const hsize_t *pal_dims,
+                                 const unsigned char *pal_data);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5IM
+ *
+ * \brief Attaches a palette to an image.
+ *
+ * \fg_loc_id
+ * \param[in] image_name    The name of the dataset to attach the palette to
+ * \param[in] pal_name      The name of the palette
+ *
+ * \return \herr_t
+ *
+ * \details H5IMlink_palette() attaches a palette named \p pal_name
+ *          to an image specified by \p image_name. The image dataset
+ *          may or not already have an attached palette. If it has,
+ *          the array of palette references is extended to hold the reference
+ *          to the new palette.
+ *
+ */
+H5_HLDLL herr_t H5IMlink_palette(hid_t loc_id, const char *image_name, const char *pal_name);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5IM
+ *
+ * \brief Detaches a palette from an image.
+ *
+ * \fg_loc_id
+ * \param[in] image_name    The name of the image dataset
+ * \param[in] pal_name      The name of the palette
+ *
+ * \return \herr_t
+ *
+ * \details H5IMunlink_palette() detaches a palette from an image
+ *          specified by \p image_name.
+ *
+ */
+H5_HLDLL herr_t H5IMunlink_palette(hid_t loc_id, const char *image_name, const char *pal_name);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5IM
+ *
+ * \brief Gets the number of palettes associated to an image.
+ *
+ * \fg_loc_id
+ * \param[in] image_name    The name of the image dataset
+ * \param[out] npals        The number of palettes
+ *
+ * \return \herr_t
+ *
+ * \details H5IMget_npalettes() gets the number of palettes associated to
+ *          an image specified by \p image_name.
+ *
+ */
+H5_HLDLL herr_t H5IMget_npalettes(hid_t loc_id, const char *image_name, hssize_t *npals);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5IM
+ *
+ * \brief Gets information about a palette dataset (dimensions).
+ *
+ * \fg_loc_id
+ * \param[in] image_name    The name of the image dataset
+ * \param[in] pal_number    The zero based index that identifies
+ *                          the palette
+ * \param[out] pal_dims     The dimensions of the palette dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5IMget_palette_info() gets the dimensions of the palette
+ *          dataset identified by \p pal_number (a zero based index)
+ *          associated to an image specified by \p image_name.
+ *
+ */
+H5_HLDLL herr_t H5IMget_palette_info(hid_t loc_id, const char *image_name, int pal_number, hsize_t *pal_dims);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5IM
+ *
+ * \brief Gets the palette dataset.
+ *
+ * \fg_loc_id
+ * \param[in] image_name    The name of the image dataset
+ * \param[in] pal_number    The zero based index that identifies
+ *                          the palette
+ * \param[out] pal_data     The palette dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5IMget_palette() gets the palette dataset identified
+ *          by \p pal_number (a zero based index) associated to an
+ *          image specified by \p image_name.
+ *
+ */
+H5_HLDLL herr_t H5IMget_palette(hid_t loc_id, const char *image_name, int pal_number,
+                                unsigned char *pal_data);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5IM
+ *
+ * \brief Inquires if a dataset is an image.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name    The name of the dataset
+ *
+ * \return \htri_t
+ *
+ * \details H5IMis_image() inquires if a dataset named \p dset_name,
+ *          attached to the file or group specified by the identifier
+ *          \p loc_id, is an image based on the HDF5 Image and Palette
+ *          Specification.
+ *
+ */
+H5_HLDLL herr_t H5IMis_image(hid_t loc_id, const char *dset_name);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5IM
+ *
+ * \brief Inquires if a dataset is a palette
+ *
+ * \fg_loc_id
+ * \param[in] dset_name    The name of the dataset
+ *
+ * \return \htri_t
+ *
+ * \details H5IMis_palette() inquires if a dataset named \p dset_name,
+ *          attached to the file or group specified by the
+ *          identifier \p loc_id, is a palette based on the HDF5
+ *          Image and Palette Specification.
+ *
+ */
+H5_HLDLL herr_t H5IMis_palette(hid_t loc_id, const char *dset_name);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5Idevelop.h b/install/include/H5Idevelop.h
new file mode 100644
index 0000000000..d0ff200ee6
--- /dev/null
+++ b/install/include/H5Idevelop.h
@@ -0,0 +1,139 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5I (ID management) developer
+ *      support routines.
+ */
+
+#ifndef H5Idevelop_H
+#define H5Idevelop_H
+
+/* Include package's public header */
+#include "H5Ipublic.h" /* ID management */
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/**
+ * The type of the realize_cb callback for H5Iregister_future
+ */
+//! <!-- [H5I_future_realize_func_t_snip] -->
+typedef herr_t (*H5I_future_realize_func_t)(void *future_object, hid_t *actual_object_id);
+//! <!-- [H5I_future_realize_func_t_snip] -->
+
+/**
+ * The type of the discard_cb callback for H5Iregister_future
+ */
+//! <!-- [H5I_future_discard_func_t_snip] -->
+typedef herr_t (*H5I_future_discard_func_t)(void *future_object);
+//! <!-- [H5I_future_discard_func_t_snip] -->
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \ingroup H5I
+ *
+ * \brief Registers a "future" object under a type and returns an ID for it
+ *
+ * \param[in] type The identifier of the type of the new ID
+ * \param[in] object Pointer to "future" object for which a new ID is created
+ * \param[in] realize_cb Function pointer to realize a future object
+ * \param[in] discard_cb Function pointer to destroy a future object
+ *
+ * \return \hid_t{object}
+ *
+ * \details H5Iregister_future() creates and returns a new ID for a "future" object.
+ *          Future objects are a special kind of object and represent a
+ *          placeholder for an object that has not yet been created or opened.
+ *          The \p realize_cb will be invoked by the HDF5 library to 'realize'
+ *          the future object as an actual object.  A call to H5Iobject_verify()
+ *          will invoke the \p realize_cb callback and if it successfully
+ *          returns, will return the actual object, not the future object.
+ *
+ * \details The \p type parameter is the identifier for the ID type to which
+ *          this new future ID will belong. This identifier may have been created
+ *          by a call to H5Iregister_type() or may be one of the HDF5 pre-defined
+ *          ID classes (e.g. H5I_FILE, H5I_GROUP, H5I_DATASPACE, etc).
+ *
+ * \details The \p object parameter is a pointer to the memory which the new ID
+ *          will be a reference to. This pointer will be stored by the library,
+ *          but will not be returned to a call to H5Iobject_verify() until the
+ *          \p realize_cb callback has returned the actual pointer for the object.
+ *
+ *          A  NULL value for \p object is allowed.
+ *
+ * \details The \p realize_cb parameter is a function pointer that will be
+ *          invoked by the HDF5 library to convert a future object into an
+ *          actual object.   The \p realize_cb function may be invoked by
+ *          H5Iobject_verify() to return the actual object for a user-defined
+ *          ID class (i.e. an ID class registered with H5Iregister_type()) or
+ *          internally by the HDF5 library in order to use or get information
+ *          from an HDF5 pre-defined ID type.  For example, the \p realize_cb
+ *          for a future dataspace object will be called during the process
+ *          of returning information from H5Sget_simple_extent_dims().
+ *
+ *          Note that although the \p realize_cb routine returns
+ *          an ID (as a parameter) for the actual object, the HDF5 library
+ *          will swap the actual object in that ID for the future object in
+ *          the future ID.  This ensures that the ID value for the object
+ *          doesn't change for the user when the object is realized.
+ *
+ *          Note that the \p realize_cb callback could receive a NULL value
+ *          for a future object pointer, if one was used when H5Iregister_future()
+ *          was initially called.  This is permitted as a means of allowing
+ *          the \p realize_cb to act as a generator of new objects, without
+ *          requiring creation of unnecessary future objects.
+ *
+ *          It is an error to pass NULL for \p realize_cb.
+ *
+ * \details The \p discard_cb parameter is a function pointer that will be
+ *          invoked by the HDF5 library to destroy a future object.  This
+ *          callback will always be invoked for _every_ future object, whether
+ *          the \p realize_cb is invoked on it or not.  It's possible that
+ *          the \p discard_cb is invoked on a future object without the
+ *          \p realize_cb being invoked, e.g. when a future ID is closed without
+ *          requiring the future object to be realized into an actual one.
+ *
+ *          Note that the \p discard_cb callback could receive a NULL value
+ *          for a future object pointer, if one was used when H5Iregister_future()
+ *          was initially called.
+ *
+ *          It is an error to pass NULL for \p discard_cb.
+ *
+ * \note The H5Iregister_future() function is primarily targeted at VOL connector
+ *          authors and is _not_ designed for general-purpose application use.
+ *
+ */
+H5_DLL hid_t H5Iregister_future(H5I_type_t type, const void *object, H5I_future_realize_func_t realize_cb,
+                                H5I_future_discard_func_t discard_cb);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5Idevelop_H */
diff --git a/install/include/H5Ipublic.h b/install/include/H5Ipublic.h
new file mode 100644
index 0000000000..ce78ae3c0f
--- /dev/null
+++ b/install/include/H5Ipublic.h
@@ -0,0 +1,666 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains function prototypes for each exported function in
+ * the H5I module.
+ */
+#ifndef H5Ipublic_H
+#define H5Ipublic_H
+
+#include "H5public.h" /* Generic Functions                        */
+
+/**
+ * Library type values.
+ * \internal Library type values.  Start with `1' instead of `0' because it
+ *           makes the tracing output look better when hid_t values are large
+ *           numbers. Change the TYPE_BITS in H5I.c if the MAXID gets larger
+ *           than 32 (an assertion will fail otherwise).
+ *
+ *           When adding types here, add a section to the 'misc19' test in
+ *           test/tmisc.c to verify that the H5I{inc|dec|get}_ref() routines
+ *           work correctly with it. \endinternal
+ */
+//! <!-- [H5I_type_t_snip] -->
+typedef enum H5I_type_t {
+    H5I_UNINIT = (-2),  /**< uninitialized type                        */
+    H5I_BADID  = (-1),  /**< invalid Type                              */
+    H5I_FILE   = 1,     /**< type ID for File objects                  */
+    H5I_GROUP,          /**< type ID for Group objects                 */
+    H5I_DATATYPE,       /**< type ID for Datatype objects              */
+    H5I_DATASPACE,      /**< type ID for Dataspace objects             */
+    H5I_DATASET,        /**< type ID for Dataset objects               */
+    H5I_MAP,            /**< type ID for Map objects                   */
+    H5I_ATTR,           /**< type ID for Attribute objects             */
+    H5I_VFL,            /**< type ID for virtual file layer            */
+    H5I_VOL,            /**< type ID for virtual object layer          */
+    H5I_GENPROP_CLS,    /**< type ID for generic property list classes */
+    H5I_GENPROP_LST,    /**< type ID for generic property lists        */
+    H5I_ERROR_CLASS,    /**< type ID for error classes                 */
+    H5I_ERROR_MSG,      /**< type ID for error messages                */
+    H5I_ERROR_STACK,    /**< type ID for error stacks                  */
+    H5I_SPACE_SEL_ITER, /**< type ID for dataspace selection iterator  */
+    H5I_EVENTSET,       /**< type ID for event sets                    */
+    H5I_NTYPES          /**< number of library types, MUST BE LAST!    */
+} H5I_type_t;
+//! <!-- [H5I_type_t_snip] -->
+
+/**
+ * Type of IDs to return to users
+ */
+typedef int64_t hid_t;
+
+#define PRIdHID PRId64
+#define PRIxHID PRIx64
+#define PRIXHID PRIX64
+#define PRIoHID PRIo64
+
+/**
+ * The size of identifiers
+ */
+#define H5_SIZEOF_HID_T H5_SIZEOF_INT64_T
+
+/**
+ * An invalid object ID. This is also negative for error return.
+ */
+#define H5I_INVALID_HID (-1)
+
+/**
+ * A function for freeing objects. This function will be called with a pointer
+ * to the object and a pointer to a pointer to the asynchronous request object.
+ * The function should free the object and return non-negative to indicate that
+ * the object can be removed from the ID type. If the function returns negative
+ * (failure) then the object will remain in the ID type. For asynchronous
+ * operations and handling the request parameter, see the HDF5 user guide and
+ * VOL connector author guide.
+ */
+typedef herr_t (*H5I_free_t)(void *obj, void **request);
+
+/**
+ * The type of a function to compare objects & keys
+ */
+//! <!-- [H5I_search_func_t_snip] -->
+typedef int (*H5I_search_func_t)(void *obj, hid_t id, void *key);
+//! <!-- [H5I_search_func_t_snip] -->
+
+/**
+ * The type of H5Iiterate() callback functions
+ */
+//! <!-- [H5I_iterate_func_t_snip] -->
+typedef herr_t (*H5I_iterate_func_t)(hid_t id, void *udata);
+//! <!-- [H5I_iterate_func_t_snip] -->
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Public API functions */
+
+/**
+ * \ingroup H5IUD
+ *
+ * \brief Registers an object under a type and returns an ID for it
+ *
+ * \param[in] type The identifier of the type of the new ID
+ * \param[in] object Pointer to object for which a new ID is created
+ *
+ * \return \hid_t{object}
+ *
+ * \details H5Iregister() creates and returns a new ID for an object.
+ *
+ * \details The \p type parameter is the identifier for the ID type to which
+ *          this new ID will belong. This identifier must have been created by
+ *          a call to H5Iregister_type().
+ *
+ * \details The \p object parameter is a pointer to the memory which the new ID
+ *          will be a reference to. This pointer will be stored by the library
+ *          and returned via a call to H5Iobject_verify().
+ *
+ */
+H5_DLL hid_t H5Iregister(H5I_type_t type, const void *object);
+/**
+ * \ingroup H5IUD
+ *
+ * \brief Returns the object referenced by an ID
+ *
+ * \param[in] id ID to be dereferenced
+ * \param[in] type The identifier type
+
+ *
+ * \return Pointer to the object referenced by \p id on success, NULL on failure.
+ *
+ * \details H5Iobject_verify() returns a pointer to the memory referenced by id
+ *          after verifying that \p id is of type \p type. This function is
+ *          analogous to dereferencing a pointer in C with type checking.
+ *
+ * \note H5Iobject_verify() does not change the ID it is called on in any way
+ *       (as opposed to H5Iremove_verify(), which removes the ID from its
+ *       type's hash table).
+ *
+ * \see H5Iregister()
+ *
+ */
+H5_DLL void *H5Iobject_verify(hid_t id, H5I_type_t type);
+/**
+ * \ingroup H5IUD
+ *
+ * \brief Removes an ID from its type
+ *
+ * \param[in] id The ID to be removed from its type
+ * \param[in] type The identifier type
+
+ *
+ * \return Returns a pointer to the memory referred to by \p id on success,
+ *         NULL on failure.
+ *
+ * \details H5Iremove_verify() first ensures that \p id belongs to \p type.
+ *          If so, it removes \p id from its type and returns the pointer
+ *          to the memory it referred to. This pointer is the same pointer that
+ *          was placed in storage by H5Iregister(). If id does not belong to
+ *          \p type, then NULL is returned.
+ *
+ *          The \p id parameter is the ID which is to be removed from its type.
+ *
+ *          The \p type parameter is the identifier for the ID type which \p id
+ *          is supposed to belong to. This identifier must have been created by
+ *          a call to H5Iregister_type().
+ *
+ * \note This function does NOT deallocate the memory that \p id refers to.
+ *       The pointer returned by H5Iregister() must be deallocated by the user
+ *       to avoid memory leaks.
+ *
+ */
+H5_DLL void *H5Iremove_verify(hid_t id, H5I_type_t type);
+/**
+ * \ingroup H5I
+ *
+ * \brief Retrieves the type of an object
+ *
+ * \obj_id{id}
+ *
+ * \return Returns the object type if successful; otherwise #H5I_BADID.
+ *
+ * \details H5Iget_type() retrieves the type of the object identified by
+ *          \p id. If no valid type can be determined or the identifier submitted is
+ *          invalid, the function returns #H5I_BADID.
+ *
+ *          This function is of particular use in determining the type of
+ *          object closing function (H5Dclose(), H5Gclose(), etc.) to call
+ *          after a call to H5Rdereference().
+ *
+ * \note Note that this function returns only the type of object that \p id
+ *       would identify if it were valid; it does not determine whether \p id
+ *       is valid identifier. Validity can be determined with a call to
+ *       H5Iis_valid().
+ *
+ */
+H5_DLL H5I_type_t H5Iget_type(hid_t id);
+/**
+ * \ingroup H5I
+ *
+ * \brief Retrieves an identifier for the file containing the specified object
+ *
+ * \obj_id{id}
+ *
+ * \return \hid_t{file}
+ *
+ * \details H5Iget_file_id() returns the identifier of the file associated with
+ *          the object referenced by \p id.
+ *
+ * \note Note that the HDF5 library permits an application to close a file
+ *       while objects within the file remain open. If the file containing the
+ *       object \p id is still open, H5Iget_file_id() will retrieve the
+ *       existing file identifier. If there is no existing file identifier for
+ *       the file, i.e., the file has been closed, H5Iget_file_id() will reopen
+ *       the file and return a new file identifier. In either case, the file
+ *       identifier must eventually be released using H5Fclose().
+ *
+ * \since 1.6.3
+ *
+ */
+H5_DLL hid_t H5Iget_file_id(hid_t id);
+/**
+ * \ingroup H5I
+ *
+ * \brief Retrieves a name of an object based on the object identifier
+ *
+ * \obj_id{id}
+ * \param[out] name A buffer for the name associated with the identifier
+ * \param[in] size The size of the \p name buffer; usually the size of
+ *                 the name in bytes plus 1 for a NULL terminator
+ *
+ * \return ssize_t
+ *
+ * \details H5Iget_name() retrieves a name for the object identified by \p id.
+ *
+ * \details Up to size characters of the name are returned in \p name;
+ *          additional characters, if any, are not returned to the user
+ *          application.
+ *
+ *          If the length of the name, which determines the required value of
+ *          \p size, is unknown, a preliminary H5Iget_name() call can be made.
+ *          The return value of this call will be the size in bytes of the
+ *          object name. That value, plus 1 for a NULL terminator, is then
+ *          assigned to size for a second H5Iget_name() call, which will
+ *          retrieve the actual name.
+ *
+ *          If the object identified by \p id is an attribute, as determined
+ *          via H5Iget_type(), H5Iget_name() retrieves the name of the object
+ *          to which that attribute is attached. To retrieve the name of the
+ *          attribute itself, use H5Aget_name().
+ *
+ *          If there is no name associated with the object identifier or if the
+ *          name is NULL, H5Iget_name() returns 0 (zero).
+ *
+ * \note Note that an object in an HDF5 file may have multiple paths if there
+ *       are multiple links pointing to it. This function may return any one of
+ *       these paths. When possible, H5Iget_name() returns the path with which
+ *       the object was opened.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL ssize_t H5Iget_name(hid_t id, char *name /*out*/, size_t size);
+/**
+ * \ingroup H5I
+ *
+ * \brief Increments the reference count for an object
+ *
+ * \obj_id{id}
+ *
+ * \return Returns a non-negative reference count of the object ID after
+ *         incrementing it if successful; otherwise a negative value is
+ *         returned.
+ *
+ * \details H5Iinc_ref() increments the reference count of the object
+ *          identified by \p id.
+ *
+ *          The reference count for an object ID is attached to the information
+ *          about an object in memory and has no relation to the number of
+ *          links to an object on disk.
+ *
+ *          The reference count for a newly created object will be 1. Reference
+ *          counts for objects may be explicitly modified with this function or
+ *          with H5Idec_ref(). When an object ID's reference count reaches
+ *          zero, the object will be closed. Calling an object ID's \c close
+ *          function decrements the reference count for the ID which normally
+ *          closes the object, but if the reference count for the ID has been
+ *          incremented with this function, the object will only be closed when
+ *          the reference count reaches zero with further calls to H5Idec_ref()
+ *          or the object ID's \c close function.
+ *
+ *          If the object ID was created by a collective parallel call (such as
+ *          H5Dcreate(), H5Gopen(), etc.), the reference count should be
+ *          modified by all the processes which have copies of the ID.
+ *          Generally this means that group, dataset, attribute, file and named
+ *          datatype IDs should be modified by all the processes and that all
+ *          other types of IDs are safe to modify by individual processes.
+ *
+ *          This function is of particular value when an application is
+ *          maintaining multiple copies of an object ID. The object ID can be
+ *          incremented when a copy is made. Each copy of the ID can then be
+ *          safely closed or decremented and the HDF5 object will be closed
+ *          when the reference count for that that object drops to zero.
+ *
+ * \since 1.6.2
+ *
+ */
+H5_DLL int H5Iinc_ref(hid_t id);
+/**
+ * \ingroup H5I
+ *
+ * \brief Decrements the reference count for an object
+ *
+ * \obj_id{id}
+ *
+ * \return Returns a non-negative reference count of the object ID after
+ *         decrementing it, if successful; otherwise a negative value is
+ *         returned.
+ *
+ * \details H5Idec_ref() decrements the reference count of the object
+ *          identified by \p id.
+ *
+ *          The reference count for an object ID is attached to the information
+ *          about an object in memory and has no relation to the number of
+ *          links to an object on disk.
+ *
+ *          The reference count for a newly created object will be 1. Reference
+ *          counts for objects may be explicitly modified with this function or
+ *          with H5Iinc_ref(). When an object identifier's reference count
+ *          reaches zero, the object will be closed. Calling an object
+ *          identifier's \c close function decrements the reference count for
+ *          the identifier, which normally closes the object, but if the
+ *          reference count for the identifier has been incremented with
+ *          H5Iinc_ref(), the object will only be closed when the reference
+ *          count reaches zero with further calls to this function or the
+ *          object identifier's \c close function.
+ *
+ *          If the object ID was created by a collective parallel call (such as
+ *          H5Dcreate(), H5Gopen(), etc.), the reference count should be
+ *          modified by all the processes which have copies of the ID.
+ *          Generally, this means that group, dataset, attribute, file and named
+ *          datatype IDs should be modified by all the processes and that all
+ *          other types of IDs are safe to modify by individual processes.
+ *
+ *          This function is of particular value when an application
+ *          maintains multiple copies of an object ID. The object ID can be
+ *          incremented when a copy is made. Each copy of the ID can then be
+ *          safely closed or decremented and the HDF5 object will be closed
+ *          when the reference count for that object drops to zero.
+ *
+ * \since 1.6.2
+ *
+ */
+H5_DLL int H5Idec_ref(hid_t id);
+/**
+ * \ingroup H5I
+ *
+ * \brief Retrieves the reference count for an object
+ *
+ * \obj_id{id}
+ *
+ * \return Returns a non-negative current reference count of the object
+ *         identifier if successful; otherwise a negative value is returned.
+ *
+ * \details H5Iget_ref() retrieves the reference count of the object identified
+ *          by \p id.
+ *
+ *          The reference count for an object identifier is attached to the
+ *          information about an object in memory and has no relation to the
+ *          number of links to an object on disk.
+ *
+ *          The function H5Iis_valid() is used to determine whether a specific
+ *          object identifier is valid.
+ *
+ * \since 1.6.2
+ *
+ */
+H5_DLL int H5Iget_ref(hid_t id);
+/**
+ * \ingroup H5IUD
+ *
+ * \brief Creates and returns a new ID type
+ *
+ * \param[in] hash_size Minimum hash table size (in entries) used to store IDs
+ *                      for the new type
+ * \param[in] reserved Number of reserved IDs for the new type
+ * \param[in] free_func Function used to deallocate space for a single ID
+ *
+ * \return Returns the type identifier on success, negative on failure.
+ *
+ * \details H5Iregister_type() allocates space for a new ID type and returns an
+ *          identifier for it.
+ *
+ *          The \p hash_size parameter indicates the minimum size of the hash
+ *          table used to store IDs in the new type.
+ *
+ *          The \p reserved parameter indicates the number of IDs in this new
+ *          type to be reserved. Reserved IDs are valid IDs which are not
+ *          associated with any storage within the library.
+ *
+ *          The \p free_func parameter is a function pointer to a function
+ *          which returns an herr_t and accepts a \c void*. The purpose of this
+ *          function is to deallocate memory for a single ID. It will be called
+ *          by H5Iclear_type() and H5Idestroy_type() on each ID. This function
+ *          is NOT called by H5Iremove_verify(). The \c void* will be the same
+ *          pointer which was passed in to the H5Iregister() function. The \p
+ *          free_func function should return 0 on success and -1 on failure.
+ *
+ */
+H5_DLL H5I_type_t H5Iregister_type(size_t hash_size, unsigned reserved, H5I_free_t free_func);
+/**
+ * \ingroup H5IUD
+ *
+ * \brief Deletes all identifiers of the given type
+ *
+ * \param[in] type Identifier of identifier type which is to be cleared of identifiers
+ * \param[in] force Whether or not to force deletion of all identifiers
+ *
+ * \return \herr_t
+ *
+ * \details H5Iclear_type() deletes all identifiers of the type identified by
+ *          the argument \p type.
+ *
+ *          The identifier type's free function is first called on all of these
+ *          identifiers to free their memory, then they are removed from the
+ *          type.
+ *
+ *          If the \p force flag is set to false, only those identifiers whose
+ *          reference counts are equal to 1 will be deleted, and all other
+ *          identifiers will be entirely unchanged. If the force flag is true,
+ *          all identifiers of this type will be deleted.
+ *
+ */
+H5_DLL herr_t H5Iclear_type(H5I_type_t type, hbool_t force);
+/**
+ * \ingroup H5IUD
+ *
+ * \brief Removes an identifier type and all identifiers within that type
+ *
+ * \param[in] type Identifier of identifier type which is to be destroyed
+ *
+ * \return \herr_t
+ *
+ * \details H5Idestroy_type deletes an entire identifier type \p type. All
+ *          identifiers of this type are destroyed and no new identifiers of
+ *          this type can be registered.
+ *
+ *          The type's free function is called on all of the identifiers which
+ *          are deleted by this function, freeing their memory. In addition,
+ *          all memory used by this type's hash table is freed.
+ *
+ *          Since the H5I_type_t values of destroyed identifier types are
+ *          reused when new types are registered, it is a good idea to set the
+ *          variable holding the value of the destroyed type to #H5I_UNINIT.
+ *
+ */
+H5_DLL herr_t H5Idestroy_type(H5I_type_t type);
+/**
+ * \ingroup H5IUD
+ *
+ * \brief Increments the reference count on an ID type
+ *
+ * \param[in] type The identifier of the type whose reference count is to be incremented
+ *
+ * \return Returns the current reference count on success, negative on failure.
+ *
+ * \details H5Iinc_type_ref() increments the reference count on an ID type. The
+ *          reference count is used by the library to indicate when an ID type
+ *          can be destroyed.
+ *
+ *          The type parameter is the identifier for the ID type whose
+ *          reference count is to be incremented. This identifier must have
+ *          been created by a call to H5Iregister_type().
+ *
+ */
+H5_DLL int H5Iinc_type_ref(H5I_type_t type);
+/**
+ * \ingroup H5IUD
+ *
+ * \brief Decrements the reference count on an identifier type
+ *
+ * \param[in] type The identifier of the type whose reference count is to be decremented
+ *
+ * \return Returns the current reference count on success, negative on failure.
+ *
+ * \details H5Idec_type_ref() decrements the reference count on an identifier
+ *          type. The reference count is used by the library to indicate when
+ *          an identifier type can be destroyed. If the reference count reaches
+ *          zero, this function will destroy it.
+ *
+ *          The type parameter is the identifier for the identifier type whose
+ *          reference count is to be decremented. This identifier must have
+ *          been created by a call to H5Iregister_type().
+ *
+ */
+H5_DLL int H5Idec_type_ref(H5I_type_t type);
+/**
+ * \ingroup H5IUD
+ *
+ * \brief Retrieves the reference count on an ID type
+ *
+ * \param[in] type The identifier of the type whose reference count is to be retrieved
+ *
+ * \return Returns the current reference count on success, negative on failure.
+ *
+ * \details H5Iget_type_ref() retrieves the reference count on an ID type. The
+ *          reference count is used by the library to indicate when an ID type
+ *          can be destroyed.
+ *
+ *          The type parameter is the identifier for the ID type whose
+ *          reference count is to be retrieved. This identifier must have been
+ *          created by a call to H5Iregister_type().
+ *
+ */
+H5_DLL int H5Iget_type_ref(H5I_type_t type);
+/**
+ * \ingroup H5IUD
+ *
+ * \brief Finds the memory referred to by an ID within the given ID type such
+ *        that some criterion is satisfied
+ *
+ * \param[in] type The identifier of the type to be searched
+ * \param[in] func The function defining the search criteria
+ * \param[in] key A key for the search function
+ *
+ * \return Returns a pointer to the object which satisfies the search function
+ *         on success, NULL on failure.
+ *
+ * \details H5Isearch() searches through a given ID type to find an object that
+ *          satisfies the criteria defined by \p func. If such an object is
+ *          found, the pointer to the memory containing this object is
+ *          returned. Otherwise, NULL is returned. To do this, \p func is
+ *          called on every member of type \p type. The first member to satisfy
+ *          \p func is returned.
+ *
+ *          The \p type parameter is the identifier for the ID type which is to
+ *          be searched. This identifier must have been created by a call to
+ *          H5Iregister_type().
+ *
+ *          The parameter \p func is a function pointer to a function which
+ *          takes three parameters. The first parameter is a \c void* and will
+ *          be a pointer to the object to be tested. This is the same object
+ *          that was placed in storage using H5Iregister(). The second
+ *          parameter is a hid_t and is the ID of the object to be tested. The
+ *          last parameter is a \c void*. This is the \p key parameter and can
+ *          be used however the user finds helpful, or it can be ignored if it
+ *          is not needed. \p func returns 0 if the object it is testing does
+ *          not pass its criteria. A non-zero value should be returned if the
+ *          object does pass its criteria. H5I_search_func_t is defined in
+ *          H5Ipublic.h and is shown below.
+ *          \snippet this H5I_search_func_t_snip
+ *          The \p key parameter will be passed to the search function as a
+ *          parameter. It can be used to further define the search at run-time.
+ *
+ */
+H5_DLL void *H5Isearch(H5I_type_t type, H5I_search_func_t func, void *key);
+/**
+ * \ingroup H5IUD
+ *
+ * \brief Calls a callback for each member of the identifier type specified
+ *
+ * \param[in] type The identifier type
+ * \param[in] op The callback function
+ * \param[in,out] op_data The data for the callback function
+ *
+ * \return The last value returned by \p op
+ *
+ * \details H5Iiterate() calls the callback function \p op for each member of
+ *          the identifier type \p type. The callback function type for \p op,
+ *          H5I_iterate_func_t, is defined in H5Ipublic.h as:
+ *          \snippet this H5I_iterate_func_t_snip
+ *          \p op takes as parameters the identifier and a pass through of
+ *          \p op_data, and returns an herr_t.
+ *
+ *          A positive return from op will cause the iteration to stop and
+ *          H5Iiterate() will return the value returned by \p op. A negative
+ *          return from \p op will cause the iteration to stop and H5Iiterate()
+ *          will return failure. A zero return from \p op will allow iteration
+ *          to continue, as long as there are other identifiers remaining in
+ *          type.
+ *
+ * \warning  Adding or removing members of the identifier type during iteration
+ *           will lead to undefined behavior.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Iiterate(H5I_type_t type, H5I_iterate_func_t op, void *op_data);
+/**
+ * \ingroup H5IUD
+ *
+ * \brief Returns the number of identifiers in a given identifier type
+ *
+ * \param[in] type The identifier type
+ * \param[out] num_members Number of identifiers of the specified identifier type
+ *
+ * \return \herr_t
+ *
+ * \details H5Inmembers() returns the number of identifiers of the identifier
+ *          type specified in \p type.
+ *
+ *          The number of identifiers is returned in \p num_members. If no
+ *          identifiers of this type have been registered, the type does not
+ *          exist, or it has been destroyed, \p num_members is returned with
+ *          the value 0.
+ *
+ */
+H5_DLL herr_t H5Inmembers(H5I_type_t type, hsize_t *num_members);
+/**
+ * \ingroup H5IUD
+ *
+ * \brief Determines whether an identifier type is registered
+ *
+ * \param[in] type Identifier type
+ *
+ * \return \htri_t
+ *
+ * \details H5Itype_exists() determines whether the given identifier type,
+ *          \p type, is registered with the library.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL htri_t H5Itype_exists(H5I_type_t type);
+/**
+ * \ingroup H5I
+ *
+ * \brief Determines whether an identifier is valid
+ *
+ * \obj_id{id}
+ *
+ * \return \htri_t
+ *
+ * \details H5Iis_valid() determines whether the identifier \p id is valid.
+ *
+ * \details Valid identifiers are those that have been obtained by an
+ *          application and can still be used to access the original target.
+ *          Examples of invalid identifiers include:
+ *          \li Out-of-range values: negative, for example
+ *          \li Previously-valid identifiers that have been released:
+ *              for example, a dataset identifier for which the dataset has
+ *              been closed
+ *
+ *          H5Iis_valid() can be used with any type of identifier: object
+ *          identifier, property list identifier, attribute identifier, error
+ *          message identifier, etc. When necessary, a call to H5Iget_type()
+ *          can determine the type of object that the \p id identifies.
+ *
+ * \since 1.8.3
+ *
+ */
+H5_DLL htri_t H5Iis_valid(hid_t id);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* H5Ipublic_H */
diff --git a/install/include/H5LDpublic.h b/install/include/H5LDpublic.h
new file mode 100644
index 0000000000..1eee8b4f19
--- /dev/null
+++ b/install/include/H5LDpublic.h
@@ -0,0 +1,167 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef H5LDpublic_H
+#define H5LDpublic_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Retrieves the current dimension sizes of a dataset.
+ *
+ * \param[in] did       The dataset identifier
+ * \param[out] cur_dims The current dimension sizes of the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5LDget_dset_dims() retrieves the current dimension sizes
+ *          for the dataset \p did through the parameter \p cur_dims.
+ *          It will return failure if \p cur_dims is NULL.
+ *
+ * \note See Also:
+ * \note Dataset Watch functions (used with h5watch):
+ *       - H5LDget_dset_dims()
+ *       - H5LDget_dset_elmts()
+ *       - H5LDget_dset_type_size()
+ *
+ * \par Example:
+ * See the example code in H5LDget_dset_elmts() for usage of this routine.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_HLDLL herr_t H5LDget_dset_dims(hid_t did, hsize_t *cur_dims);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Returns the size in bytes of the dataset's datatype
+ *
+ * \param[in] did       The dataset identifier
+ * \param[in] fields    The pointer to a comma-separated list of fields for a compound datatype
+ *
+ * \return If successful, returns the size in bytes of the
+ *         dataset's datatype. Otherwise, returns 0.
+ *
+ * \details H5LDget_dset_type_size() allows the user to find out the datatype
+ *          size for the dataset associated with \p did. If the
+ *          parameter \p fields is NULL, this routine just returns the size
+ *          of the dataset's datatype. If the dataset has a compound datatype
+ *          and \p fields is non-NULL, this routine returns the size of the
+ *          datatype(s) for the selected fields specified in \p fields.
+ *          Note that , is the separator for the fields of a compound
+ *          datatype while . (dot) is the separator for a nested field.
+ *          Use a backslash ( \ ) to escape characters in field names that
+ *          conflict with these two separators.
+ *
+ * \note See Also:
+ * \note Dataset Watch functions (used with h5watch):
+ *       - H5LDget_dset_dims()
+ *       - H5LDget_dset_elmts()
+ *       - H5LDget_dset_type_size()
+ *
+ * \par Example:
+ * See the example code in H5LDget_dset_elmts() for usage of this routine.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_HLDLL size_t H5LDget_dset_type_size(hid_t did, const char *fields);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Retrieves selected data from the dataset
+ *
+ * \param[in] did       The dataset identifier
+ * \param[in] prev_dims The previous dimension size of the dataset
+ * \param[in] cur_dims  The current dimension sizes of the dataset
+ * \param[in] fields    A string containing a comma-separated list
+ *                      of fields for a compound datatype
+ * \param[out] buf      Buffer for storing data retrieved from the
+ *                      dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5LDget_dset_dims() retrieves selected data of the dataset
+ *          \p did and stores the data in the parameter \p buf.
+ *          The difference between the parameters \p prev_dims and
+ *          \p cur_dims indicates the dimension sizes of the data to be
+ *          selected from the dataset. Note that \p cur_dims must have
+ *          at least one dimension whose size is greater than the
+ *          corresponding dimension in \p prev_dims. Users can
+ *          determine the size of buf by multiplying the datatype
+ *          size of the dataset by the number of selected elements.
+ *
+ *          If the parameter \p fields is NULL, this routine returns
+ *          data for the selected elements of the dataset. If \p fields
+ *          is not NULL and the dataset has a compound datatype, \p fields
+ *          is a string containing a comma-separated list of fields.
+ *          Each name in \p fields specifies a field in the compound
+ *          datatype, and this routine returns data of the selected fields
+ *          for the dataset's selected elements. Note that , is the
+ *          separator for the fields of a compound datatype while
+ *          . is the separator for a nested field. Use backslash to
+ *          escape characters in field names that conflict with these
+ *          two separators.
+ *
+ * \note See Also:
+ * \note Dataset Watch functions (used with h5watch):
+ *       - H5LDget_dset_dims()
+ *       - H5LDget_dset_elmts()
+ *       - H5LDget_dset_type_size()
+ *
+ * \par Examples:
+ *
+ * For the first example, \c DSET1 is a two-dimensional chunked dataset with atomic type defined below:
+ * \snippet H5LDget_dset_elmts.c first_declare
+ *
+ * The following coding sample illustrates the reading of
+ * data elements appended to the dataset \c DSET1:
+ * \snippet H5LDget_dset_elmts.c first_reading
+ *
+ * The output buffer will contain data elements selected from
+ * \c DSET1 as follows:
+ * \snippet H5LDget_dset_elmts.c first_output
+ *
+ * For the second example, DSET2 is a one-dimensional chunked dataset
+ * with compound type defined below:
+ * \snippet H5LDget_dset_elmts.c second_declare
+ *
+ * The following coding sample illustrates the reading of data elements
+ * appended to the dataset \c DSET2 with compound datatype.
+ * This example selects only 2 fields: the fourth field \c d and a
+ * subfield of the sixth field \c s2.c:
+ * \snippet H5LDget_dset_elmts.c second_reading
+ *
+ * The output buffer will contain data for \c d and \c s2.c
+ * selected from \c DSET2 as follows:
+ * \snippet H5LDget_dset_elmts.c second_output
+ *
+ * \since 1.10.0
+ *
+ */
+H5_HLDLL herr_t H5LDget_dset_elmts(hid_t did, const hsize_t *prev_dims, const hsize_t *cur_dims,
+                                   const char *fields, void *buf);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5LDpublic_H */
diff --git a/install/include/H5LTpublic.h b/install/include/H5LTpublic.h
new file mode 100644
index 0000000000..1ce5c81d3e
--- /dev/null
+++ b/install/include/H5LTpublic.h
@@ -0,0 +1,1643 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef H5LTpublic_H
+#define H5LTpublic_H
+
+/* Flag definitions for H5LTopen_file_image() */
+#define H5LT_FILE_IMAGE_OPEN_RW   0x0001 /* Open image for read-write */
+#define H5LT_FILE_IMAGE_DONT_COPY 0x0002 /* The HDF5 lib won't copy   */
+/* user supplied image buffer. The same image is open with the core driver.  */
+#define H5LT_FILE_IMAGE_DONT_RELEASE 0x0004 /* The HDF5 lib won't        */
+/* deallocate user supplied image buffer. The user application is responsible */
+/* for doing so.                                                             */
+#define H5LT_FILE_IMAGE_ALL 0x0007
+
+typedef enum H5LT_lang_t {
+    H5LT_LANG_ERR = -1, /*this is the first*/
+    H5LT_DDL      = 0,  /*for DDL*/
+    H5LT_C        = 1,  /*for C*/
+    H5LT_FORTRAN  = 2,  /*for Fortran*/
+    H5LT_NO_LANG  = 3   /*this is the last*/
+} H5LT_lang_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** \page H5LT_UG The HDF5 High Level Lite
+ * @todo Under Construction
+ */
+
+/**\defgroup H5LT HDF5 Lite APIs (H5LT,H5LD)
+ * <em>Functions used to simplify creating and manipulating datasets,
+ * attributes and other features (H5LT, H5LD)</em>
+ *
+ * The HDF5 Lite API consists of higher-level functions which do
+ * more operations per call than the basic HDF5 interface.
+ * The purpose is to wrap intuitive functions around certain sets
+ * of features in the existing APIs.
+ * It has the following sets of functions listed below.
+ *
+ * \note \Bold{Programming hints:}
+ * \note To use any of these functions or subroutines,
+ *       you must first include the relevant include file (C) or
+ *       module (Fortran) in your application.
+ * \note The following line includes the HDF5 Lite package, H5LT,
+ *       in C applications:
+ *       \code #include "hdf5_hl.h" \endcode
+ * \note This line includes the H5LT module in Fortran applications:
+ *       \code use h5lt \endcode
+ *
+ * <table>
+ * <tr valign="top"><td style="border: none;">
+ *
+ * - Dataset Functions
+ *   - Make dataset functions
+ *      - \ref H5LTmake_dataset
+ *      - \ref H5LTmake_dataset_char
+ *      - \ref H5LTmake_dataset_short
+ *      - \ref H5LTmake_dataset_int
+ *      - \ref H5LTmake_dataset_long
+ *      - \ref H5LTmake_dataset_float
+ *      - \ref H5LTmake_dataset_double
+ *      - \ref H5LTmake_dataset_string
+ *
+ *   - Read dataset functions
+ *      - \ref H5LTread_dataset
+ *      - \ref H5LTread_dataset_char
+ *      - \ref H5LTread_dataset_short
+ *      - \ref H5LTread_dataset_int
+ *      - \ref H5LTread_dataset_long
+ *      - \ref H5LTread_dataset_float
+ *      - \ref H5LTread_dataset_double
+ *      - \ref H5LTread_dataset_string
+ *
+ *   - Query dataset functions
+ *      - \ref H5LTfind_dataset
+ *      - \ref H5LTget_dataset_ndims
+ *      - \ref H5LTget_dataset_info
+ *
+ *   - Dataset watch functions
+ *      - \ref H5LDget_dset_dims
+ *      - \ref H5LDget_dset_elmts
+ *      - \ref H5LDget_dset_type_size
+ *
+ * </td><td style="border: none;">
+ *
+ * - Attribute Functions
+ *   - Set attribute functions
+ *      - \ref H5LTset_attribute_string
+ *      - \ref H5LTset_attribute_char
+ *      - \ref H5LTset_attribute_uchar
+ *      - \ref H5LTset_attribute_short
+ *      - \ref H5LTset_attribute_ushort
+ *      - \ref H5LTset_attribute_int
+ *      - \ref H5LTset_attribute_uint
+ *      - \ref H5LTset_attribute_long
+ *      - \ref H5LTset_attribute_long_long
+ *      - \ref H5LTset_attribute_ulong
+ *      - \ref H5LTset_attribute_ullong
+ *      - \ref H5LTset_attribute_float
+ *      - \ref H5LTset_attribute_double
+ *      - <code>H5LTset_attribute_f</code> (fortran ONLY)
+ *
+ *   - Get attribute functions
+ *      - \ref H5LTget_attribute
+ *      - \ref H5LTget_attribute_string
+ *      - \ref H5LTget_attribute_char
+ *      - \ref H5LTget_attribute_uchar
+ *      - \ref H5LTget_attribute_short
+ *      - \ref H5LTget_attribute_ushort
+ *      - \ref H5LTget_attribute_int
+ *      - \ref H5LTget_attribute_uint
+ *      - \ref H5LTget_attribute_long
+ *      - \ref H5LTget_attribute_long_long
+ *      - \ref H5LTget_attribute_ulong
+ *      - \ref H5LTget_attribute_ullong
+ *      - \ref H5LTget_attribute_float
+ *      - \ref H5LTget_attribute_double
+ *
+ *   - Query attribute functions
+ *      - \ref H5LTfind_attribute
+ *      - \ref H5LTget_attribute_info
+ *      - \ref H5LTget_attribute_ndims
+ *
+ * </td><td style="border: none;">
+ *
+ * - Datatype Functions
+ *   - Datatype translation functions
+ *      - \ref H5LTtext_to_dtype
+ *      - \ref H5LTdtype_to_text
+ *
+ * - File image function
+ *   - Open file image function
+ *      - \ref H5LTopen_file_image
+ *
+ * - Path and object function
+ *   - Query path and object function
+ *      - \ref H5LTpath_valid
+ *
+ * </td></tr>
+ * </table>
+ *
+ */
+
+/*-------------------------------------------------------------------------
+ *
+ * Make dataset functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes a dataset of a type \p type_id.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The Name of the dataset to create
+ * \param[in] rank      Number of dimensions of dataspace
+ * \param[in] dims      An array of the size of each dimension
+ * \param[in] type_id   Identifier of the datatype to use when creating the dataset
+ * \param[in] buffer    Buffer with data to be written to the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5LTmake_dataset() creates and writes a dataset named
+ *          \p dset_name attached to the object specified by the
+ *          identifier \p loc_id.
+ *
+ *          The parameter \p type_id can be any valid HDF5 Prdefined \ref PDTNAT;
+ *          For example, setting \p type_id to #H5T_NATIVE_INT will result in a dataset
+ *          of <em>signed \e integer datatype</em>.
+ *
+ * \version 1.10.0 Fortran 2003 subroutine added to accept a C address of the data buffer.
+ * \version 1.8.7 Fortran subroutine modified in this release to accommodate arrays
+ *                with more than three dimensions.
+ *
+ */
+H5_HLDLL herr_t H5LTmake_dataset(hid_t loc_id, const char *dset_name, int rank, const hsize_t *dims,
+                                 hid_t type_id, const void *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes a dataset.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The Name of the dataset to create
+ * \param[in] rank      Number of dimensions of dataspace
+ * \param[in] dims      An array of the size of each dimension
+ * \param[in] buffer    Buffer with data to be written to the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5LTmake_dataset_char() creates and writes a dataset
+ *          named \p dset_name attached to the object specified by
+ *          the identifier \p loc_id.
+ *
+ *          The dataset's datatype will be \e character, #H5T_NATIVE_CHAR.
+ *
+ */
+H5_HLDLL herr_t H5LTmake_dataset_char(hid_t loc_id, const char *dset_name, int rank, const hsize_t *dims,
+                                      const char *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes a dataset.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The Name of the dataset to create
+ * \param[in] rank      Number of dimensions of dataspace
+ * \param[in] dims      An array of the size of each dimension
+ * \param[in] buffer    Buffer with data to be written to the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5LTmake_dataset_short() creates and writes a dataset
+ *          named \p dset_name attached to the object specified by
+ *          the identifier \p loc_id.
+ *
+ *          The dataset's datatype will be <em>short signed integer</em>,
+ *          #H5T_NATIVE_SHORT.
+ *
+ */
+H5_HLDLL herr_t H5LTmake_dataset_short(hid_t loc_id, const char *dset_name, int rank, const hsize_t *dims,
+                                       const short *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes a dataset.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The Name of the dataset to create
+ * \param[in] rank      Number of dimensions of dataspace
+ * \param[in] dims      An array of the size of each dimension
+ * \param[in] buffer    Buffer with data to be written to the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5LTmake_dataset_int() creates and writes a dataset
+ *          named \p dset_name attached to the object specified by
+ *          the identifier \p loc_id.
+ *
+ *          The dataset's datatype will be <em>native signed integer</em>,
+ *          #H5T_NATIVE_INT.
+ *
+ * \version Fortran subroutine modified in this release to accommodate
+ *          arrays with more than three dimensions.
+ *
+ */
+H5_HLDLL herr_t H5LTmake_dataset_int(hid_t loc_id, const char *dset_name, int rank, const hsize_t *dims,
+                                     const int *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes a dataset.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The Name of the dataset to create
+ * \param[in] rank      Number of dimensions of dataspace
+ * \param[in] dims      An array of the size of each dimension
+ * \param[in] buffer    Buffer with data to be written to the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5LTmake_dataset_long() creates and writes a dataset
+ *          named \p dset_name attached to the object specified by
+ *          the identifier \p loc_id.
+ *
+ *          The dataset's datatype will be <em>long signed integer</em>,
+ *          #H5T_NATIVE_LONG.
+ *
+ */
+H5_HLDLL herr_t H5LTmake_dataset_long(hid_t loc_id, const char *dset_name, int rank, const hsize_t *dims,
+                                      const long *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes a dataset.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The Name of the dataset to create
+ * \param[in] rank      Number of dimensions of dataspace
+ * \param[in] dims      An array of the size of each dimension
+ * \param[in] buffer    Buffer with data to be written to the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5LTmake_dataset_float() creates and writes a dataset
+ *          named \p dset_name attached to the object specified by
+ *          the identifier \p loc_id.
+ *
+ *          The dataset's datatype will be <em>native floating point</em>,
+ *          #H5T_NATIVE_FLOAT.
+ *
+ * \version 1.8.7 Fortran subroutine modified in this release to accommodate
+ *                arrays with more than three dimensions.
+ *
+ */
+H5_HLDLL herr_t H5LTmake_dataset_float(hid_t loc_id, const char *dset_name, int rank, const hsize_t *dims,
+                                       const float *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes a dataset.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The Name of the dataset to create
+ * \param[in] rank      Number of dimensions of dataspace
+ * \param[in] dims      An array of the size of each dimension
+ * \param[in] buffer    Buffer with data to be written to the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5LTmake_dataset_double() creates and writes a dataset
+ *          named \p dset_name attached to the object specified by
+ *          the identifier \p loc_id.
+ *
+ *          The dataset's datatype will be
+ *          <em>native floating-point double</em>, #H5T_NATIVE_DOUBLE.
+ *
+ * \version 1.8.7 Fortran subroutine modified in this release to accommodate
+ *                arrays with more than three dimensions.
+ *
+ */
+H5_HLDLL herr_t H5LTmake_dataset_double(hid_t loc_id, const char *dset_name, int rank, const hsize_t *dims,
+                                        const double *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes a dataset with string datatype.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The name of the dataset to create
+ * \param[in] buf       Buffer with data to be written to the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5LTmake_dataset_string() creates and writes a dataset
+ *          named \p dset_name attached to the object specified by
+ *          the identifier \p loc_id.
+ *
+ *          The dataset's datatype will be <em>C string</em>, #H5T_C_S1.
+ *
+ */
+H5_HLDLL herr_t H5LTmake_dataset_string(hid_t loc_id, const char *dset_name, const char *buf);
+
+/*-------------------------------------------------------------------------
+ *
+ * Read dataset functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads a dataset from disk.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The name of the dataset to read
+ * \param[in] type_id   Identifier of the datatype to use when reading
+ *                      the dataset
+ * \param[out] buffer   Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTread_dataset() reads a dataset named \p dset_name
+ *          attached to the object specified by the identifier \p loc_id.
+ *
+ * \version 1.10.0  Fortran 2003 subroutine added to accept a C
+ *                  address of the data buffer.
+ * \version 1.8.7   Fortran subroutine modified in this release to
+ *                  accommodate arrays with more than three dimensions.
+ *
+ */
+H5_HLDLL herr_t H5LTread_dataset(hid_t loc_id, const char *dset_name, hid_t type_id, void *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads a dataset from disk.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The name of the dataset to read
+ * \param[out] buffer   Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTread_dataset_char() reads a dataset named \p dset_name
+ *          attached to the object specified by the identifier \p loc_id.
+ *          The HDF5 datatype is #H5T_NATIVE_CHAR.
+ *
+ */
+H5_HLDLL herr_t H5LTread_dataset_char(hid_t loc_id, const char *dset_name, char *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads a dataset from disk.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The name of the dataset to read
+ * \param[out] buffer   Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTread_dataset_short() reads a dataset named \p dset_name
+ *          attached to the object specified by the identifier \p loc_id.
+ *          The HDF5 datatype is #H5T_NATIVE_SHORT.
+ *
+ */
+H5_HLDLL herr_t H5LTread_dataset_short(hid_t loc_id, const char *dset_name, short *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads a dataset from disk.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The name of the dataset to read
+ * \param[out] buffer   Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTread_dataset_int() reads a dataset named \p dset_name
+ *          attached to the object specified by the identifier \p loc_id.
+ *          The HDF5 datatype is #H5T_NATIVE_INT.
+ *
+ * \version 1.8.7 Fortran subroutine modified in this release to
+ *                accommodate arrays with more than three dimensions.
+ *
+ */
+H5_HLDLL herr_t H5LTread_dataset_int(hid_t loc_id, const char *dset_name, int *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads a dataset from disk.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The name of the dataset to read
+ * \param[out] buffer   Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTread_dataset_long() reads a dataset named \p dset_name
+ *          attached to the object specified by the identifier \p loc_id.
+ *          The HDF5 datatype is #H5T_NATIVE_LONG.
+ *
+ */
+H5_HLDLL herr_t H5LTread_dataset_long(hid_t loc_id, const char *dset_name, long *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads a dataset from disk.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The name of the dataset to read
+ * \param[out] buffer   Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTread_dataset_float() reads a dataset named \p dset_name
+ *          attached to the object specified by the identifier \p loc_id.
+ *          The HDF5 datatype is #H5T_NATIVE_FLOAT.
+ *
+ * \version 1.8.7 Fortran subroutine modified in this release to
+ *                accommodate arrays with more than three dimensions.
+ */
+H5_HLDLL herr_t H5LTread_dataset_float(hid_t loc_id, const char *dset_name, float *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads a dataset from disk.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The name of the dataset to read
+ * \param[out] buffer   Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTread_dataset_double() reads a dataset named \p dset_name
+ *          attached to the object specified by the identifier \p loc_id.
+ *          The HDF5 datatype is #H5T_NATIVE_DOUBLE.
+ *
+ * \version 1.8.7 Fortran subroutine modified in this release to
+ *                accommodate arrays with more than three dimensions.
+ */
+H5_HLDLL herr_t H5LTread_dataset_double(hid_t loc_id, const char *dset_name, double *buffer);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads a dataset from disk.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name The name of the dataset to read
+ * \param[out] buf      Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTread_dataset_string() reads a dataset named \p dset_name
+ *          attached to the object specified by the identifier \p loc_id.
+ *          The HDF5 datatype is #H5T_C_S1.
+ *
+ */
+H5_HLDLL herr_t H5LTread_dataset_string(hid_t loc_id, const char *dset_name, char *buf);
+
+/*-------------------------------------------------------------------------
+ *
+ * Query dataset functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Gets the dimensionality of a dataset
+ *
+ * \param[in]   loc_id      Identifier of the object to
+ *                          locate the dataset within
+ * \param[in]   dset_name   The dataset name
+ * \param[out]  rank        The dimensionality of the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_dataset_ndims() gets the dimensionality of a dataset
+ *          named \p dset_name exists attached to the object \p loc_id.
+ *
+ */
+H5_HLDLL herr_t H5LTget_dataset_ndims(hid_t loc_id, const char *dset_name, int *rank);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Retrieves information about a dataset
+ *
+ * \param[in]   loc_id      Identifier of the object to locate
+ *                          the dataset within
+ * \param[in]   dset_name   The dataset name
+ * \param[out]  dims        The dimensions of the dataset
+ * \param[out]  type_class  The class identifier. #H5T_class_t is defined in
+ *                          H5Tpublic.h. See H5Tget_class() for a list
+ *                          of class types.
+ * \param[out]  type_size   The size of the datatype in bytes
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_dataset_info() retrieves information about a dataset
+ *          named \p dset_name attached to the object \p loc_id.
+ *
+ */
+H5_HLDLL herr_t H5LTget_dataset_info(hid_t loc_id, const char *dset_name, hsize_t *dims,
+                                     H5T_class_t *type_class, size_t *type_size);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Determines whether a dataset exists.
+ *
+ * \param[in]   loc_id  Identifier of the group containing the dataset
+ * \param[in]   name    Dataset name
+ *
+ * \return \htri_t
+ *
+ * \details H5LTfind_dataset() determines whether a dataset named
+ *          \p name exists in the group specified by \p loc_id.
+ *
+ *          \p loc_id must be a group identifier and \p name must
+ *          specify a dataset that is a member of that group.
+ *
+ */
+H5_HLDLL herr_t H5LTfind_dataset(hid_t loc_id, const char *name);
+
+/*-------------------------------------------------------------------------
+ *
+ * Set attribute functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes a string attribute.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to create the attribute within
+ * \param[in]   obj_name    The name of the object to attach the attribute
+ * \param[in]   attr_name   The attribute name
+ * \param[in]   attr_data   Buffer with data to be written to the attribute
+ *
+ * \return \herr_t
+ *
+ * \details H5LTset_attribute_string() creates and writes a string attribute
+ *          named \p attr_name and attaches it to the object specified by
+ *          the name \p obj_name. If the attribute already exists,
+ *          it is overwritten.
+ *
+ */
+H5_HLDLL herr_t H5LTset_attribute_string(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                         const char *attr_data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes an attribute.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to create the attribute within
+ * \param[in]   obj_name    The name of the object to attach the attribute
+ * \param[in]   attr_name   The attribute name
+ * \param[in]   buffer      Buffer with data to be written to the attribute
+ * \param[in]   size        The size of the 1D array (one in the case of a
+ *                          scalar attribute). This value is used by
+ *                          H5Screate_simple() to create the dataspace.
+ *
+ * \return \herr_t
+ *
+ * \details H5LTset_attribute_char() creates and writes a numerical attribute
+ *          named \p attr_name and attaches it to the object specified by the
+ *          name \p obj_name. The attribute has a dimensionality of 1.
+ *          The HDF5 datatype of the attribute is #H5T_NATIVE_CHAR.
+ *
+ */
+H5_HLDLL herr_t H5LTset_attribute_char(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                       const char *buffer, size_t size);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes an attribute.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to create the attribute within
+ * \param[in]   obj_name    The name of the object to attach the attribute
+ * \param[in]   attr_name   The attribute name
+ * \param[in]   buffer      Buffer with data to be written to the attribute
+ * \param[in]   size        The size of the 1D array (one in the case of a
+ *                          scalar attribute). This value is used by
+ *                          H5Screate_simple() to create the dataspace.
+ *
+ * \return \herr_t
+ *
+ * \details H5LTset_attribute_uchar() creates and writes a numerical attribute
+ *          named \p attr_name and attaches it to the object specified by the
+ *          name \p obj_name. The attribute has a dimensionality of 1.
+ *          The HDF5 datatype of the attribute is #H5T_NATIVE_UCHAR.
+ *
+ */
+H5_HLDLL herr_t H5LTset_attribute_uchar(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                        const unsigned char *buffer, size_t size);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes an attribute.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to create the attribute within
+ * \param[in]   obj_name    The name of the object to attach the attribute
+ * \param[in]   attr_name   The attribute name
+ * \param[in]   buffer      Buffer with data to be written to the attribute
+ * \param[in]   size        The size of the 1D array (one in the case of a
+ *                          scalar attribute). This value is used by
+ *                          H5Screate_simple() to create the dataspace.
+ *
+ * \return \herr_t
+ *
+ * \details H5LTset_attribute_short() creates and writes a numerical attribute
+ *          named \p attr_name and attaches it to the object specified by the
+ *          name \p obj_name. The attribute has a dimensionality of 1.
+ *          The HDF5 datatype of the attribute is #H5T_NATIVE_SHORT.
+ *
+ */
+H5_HLDLL herr_t H5LTset_attribute_short(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                        const short *buffer, size_t size);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes an attribute.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to create the attribute within
+ * \param[in]   obj_name    The name of the object to attach the attribute
+ * \param[in]   attr_name   The attribute name
+ * \param[in]   buffer      Buffer with data to be written to the attribute
+ * \param[in]   size        The size of the 1D array (one in the case of a
+ *                          scalar attribute). This value is used by
+ *                          H5Screate_simple() to create the dataspace.
+ *
+ * \return \herr_t
+ *
+ * \details H5LTset_attribute_ushort() creates and writes a numerical attribute
+ *          named \p attr_name and attaches it to the object specified by the
+ *          name \p obj_name. The attribute has a dimensionality of 1.
+ *          The HDF5 datatype of the attribute is #H5T_NATIVE_USHORT.
+ *
+ */
+H5_HLDLL herr_t H5LTset_attribute_ushort(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                         const unsigned short *buffer, size_t size);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes an attribute.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to create the attribute within
+ * \param[in]   obj_name    The name of the object to attach the attribute
+ * \param[in]   attr_name   The attribute name
+ * \param[in]   buffer      Buffer with data to be written to the attribute
+ * \param[in]   size        The size of the 1D array (one in the case of a
+ *                          scalar attribute). This value is used by
+ *                          H5Screate_simple() to create the dataspace.
+ *
+ * \return \herr_t
+ *
+ * \details H5LTset_attribute_int() creates and writes a numerical integer
+ *          attribute named \p attr_name and attaches it to the object
+ *          specified by the name \p obj_name. The attribute has a
+ *          dimensionality of 1.  The HDF5 datatype of the attribute
+ *          is #H5T_NATIVE_INT.
+ *
+ */
+H5_HLDLL herr_t H5LTset_attribute_int(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                      const int *buffer, size_t size);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes an attribute.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to create the attribute within
+ * \param[in]   obj_name    The name of the object to attach the attribute
+ * \param[in]   attr_name   The attribute name
+ * \param[in]   buffer      Buffer with data to be written to the attribute
+ * \param[in]   size        The size of the 1D array (one in the case of a
+ *                          scalar attribute). This value is used by
+ *                          H5Screate_simple() to create the dataspace.
+ *
+ * \return \herr_t
+ *
+ * \details H5LTset_attribute_uint() creates and writes a numerical integer
+ *          attribute named \p attr_name and attaches it to the object specified
+ *          by the name \p obj_name. The attribute has a dimensionality of 1.
+ *          The HDF5 datatype of the attribute is #H5T_NATIVE_UINT.
+ *
+ */
+H5_HLDLL herr_t H5LTset_attribute_uint(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                       const unsigned int *buffer, size_t size);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes an attribute.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to create the attribute within
+ * \param[in]   obj_name    The name of the object to attach the attribute
+ * \param[in]   attr_name   The attribute name
+ * \param[in]   buffer      Buffer with data to be written to the attribute
+ * \param[in]   size        The size of the 1D array (one in the case of a
+ *                          scalar attribute). This value is used by
+ *                          H5Screate_simple() to create the dataspace.
+ *
+ * \return \herr_t
+ *
+ * \details H5LTset_attribute_long() creates and writes a numerical
+ *          attribute named \p attr_name and attaches it to the object
+ *          specified by the name \p obj_name. The attribute has a
+ *          dimensionality of 1.  The HDF5 datatype of the attribute
+ *          is #H5T_NATIVE_LONG.
+ *
+ */
+H5_HLDLL herr_t H5LTset_attribute_long(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                       const long *buffer, size_t size);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes an attribute.
+ *
+ * \param[in]   loc_id      Location of the object to which the attribute
+ *                          is to be attached
+ * \param[in]   obj_name    That object's name
+ * \param[in]   attr_name   Attribute name
+ * \param[in]   buffer      Attribute value
+ * \param[in]   size        Attribute size
+ *
+ * \return \herr_t
+ *
+ * \details H5LTset_attribute_long_long() creates and writes a numerical
+ *          attribute named \p attr_name and attaches it to the object
+ *          specified by the name \p obj_name.
+ *
+ *          The attribute has a dimensionality of 1 and its HDF5 datatype
+ *          is #H5T_NATIVE_LLONG.
+ *
+ */
+H5_HLDLL herr_t H5LTset_attribute_long_long(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                            const long long *buffer, size_t size);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes an attribute.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to create the attribute within
+ * \param[in]   obj_name    The name of the object to attach the attribute
+ * \param[in]   attr_name   The attribute name
+ * \param[in]   buffer      Buffer with data to be written to the attribute
+ * \param[in]   size        The size of the 1D array (one in the case of a
+ *                          scalar attribute). This value is used by
+ *                          H5Screate_simple() to create the dataspace.
+ *
+ * \return \herr_t
+ *
+ * \details H5LTset_attribute_ulong() creates and writes a numerical
+ *          attribute named \p attr_name and attaches it to the object
+ *          specified by the name \p obj_name. The attribute has a
+ *          dimensionality of 1.  The HDF5 datatype of the attribute
+ *          is #H5T_NATIVE_ULONG.
+ *
+ */
+H5_HLDLL herr_t H5LTset_attribute_ulong(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                        const unsigned long *buffer, size_t size);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes an attribute.
+ *
+ * \param[in]   loc_id      Location of the object to which the attribute
+ *                          is to be attached
+ * \param[in]   obj_name    That object's name
+ * \param[in]   attr_name   Attribute name
+ * \param[in]   buffer      Attribute value
+ * \param[in]   size        Attribute size
+ *
+ * \return \herr_t
+ *
+ * \details H5LTset_attribute_ullong() creates and writes a numerical
+ *          attribute named \p attr_name and attaches it to the object
+ *          specified by the name \p obj_name.
+ *
+ *          The attribute has a dimensionality of 1 and its HDF5 datatype
+ *          is #H5T_NATIVE_ULLONG.
+ *
+ */
+H5_HLDLL herr_t H5LTset_attribute_ullong(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                         const unsigned long long *buffer, size_t size);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes an attribute.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to create the attribute within
+ * \param[in]   obj_name    The name of the object to attach the attribute
+ * \param[in]   attr_name   The attribute name
+ * \param[in]   buffer      Buffer with data to be written to the attribute
+ * \param[in]   size        The size of the 1D array (one in the case of a
+ *                          scalar attribute). This value is used by
+ *                          H5Screate_simple() to create the dataspace.
+ *
+ * \return \herr_t
+ *
+ * \details H5LTset_attribute_float() creates and writes a numerical
+ *          floating point attribute named \p attr_name and attaches
+ *          it to the object specified by the name \p obj_name.
+ *          The attribute has a dimensionality of 1.  The HDF5 datatype
+ *          of the attribute is #H5T_NATIVE_FLOAT.
+ *
+ */
+H5_HLDLL herr_t H5LTset_attribute_float(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                        const float *buffer, size_t size);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates and writes an attribute.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to create the attribute within
+ * \param[in]   obj_name    The name of the object to attach the attribute
+ * \param[in]   attr_name   The attribute name
+ * \param[in]   buffer      Buffer with data to be written to the attribute
+ * \param[in]   size        The size of the 1D array (one in the case of a
+ *                          scalar attribute). This value is used by
+ *                          H5Screate_simple() to create the dataspace.
+ *
+ * \return \herr_t
+ *
+ * \details H5LTset_attribute_double() creates and writes a numerical
+ *          attribute named \p attr_name and attaches
+ *          it to the object specified by the name \p obj_name.
+ *          The attribute has a dimensionality of 1.  The HDF5 datatype
+ *          of the attribute is #H5T_NATIVE_DOUBLE.
+ *
+ */
+H5_HLDLL herr_t H5LTset_attribute_double(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                         const double *buffer, size_t size);
+
+/*-------------------------------------------------------------------------
+ *
+ * Get attribute functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads an attribute from disk.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[in]   mem_type_id Identifier of the memory datatype
+ * \param[out]  data        Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute() reads an attribute named
+ *          \p attr_name with the memory type \p mem_type_id.
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                  hid_t mem_type_id, void *data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads an attribute from disk.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  data        Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_string() reads an attribute named
+ *          \p attr_name that is attached to the object specified
+ *          by the name \p obj_name.  The datatype is a string.
+ *
+ * \version 1.8.9 The content of the buffer returned by the Fortran
+ *                subroutine has changed in this release:\n
+ *                If the returned buffer requires padding,
+ *                h5ltget_attribute_string_f() now employs space
+ *                padding; this buffer was previously returned with a C NULL terminator.
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_string(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                         char *data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads an attribute from disk.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  data        Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_char() reads an attribute named
+ *          \p attr_name that is attached to the object specified
+ *          by the name \p obj_name.  The datatype of the attribute
+ *          is #H5T_NATIVE_CHAR.
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_char(hid_t loc_id, const char *obj_name, const char *attr_name, char *data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads an attribute from disk.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  data        Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_uchar() reads an attribute named
+ *          \p attr_name that is attached to the object specified
+ *          by the name \p obj_name.  The HDF5 datatype of the
+ *          attribute is #H5T_NATIVE_UCHAR
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_uchar(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                        unsigned char *data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads an attribute from disk.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  data        Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_short() reads an attribute named
+ *          \p attr_name that is attached to the object specified
+ *          by the name \p obj_name.  The HDF5 datatype of the
+ *          attribute is #H5T_NATIVE_SHORT
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_short(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                        short *data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads an attribute from disk.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  data        Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_ushort() reads an attribute named
+ *          \p attr_name that is attached to the object specified
+ *          by the name \p obj_name.  The HDF5 datatype of the
+ *          attribute is #H5T_NATIVE_USHORT.
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_ushort(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                         unsigned short *data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads an attribute from disk.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  data        Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_int() reads an attribute named
+ *          \p attr_name that is attached to the object specified
+ *          by the name \p obj_name.  The HDF5 datatype of the
+ *          attribute is #H5T_NATIVE_INT.
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_int(hid_t loc_id, const char *obj_name, const char *attr_name, int *data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads an attribute from disk.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  data        Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_uint() reads an attribute named
+ *          \p attr_name that is attached to the object specified
+ *          by the name \p obj_name.  The HDF5 datatype of the
+ *          attribute is #H5T_NATIVE_INT.
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_uint(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                       unsigned int *data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads an attribute from disk.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  data        Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_long() reads an attribute named
+ *          \p attr_name that is attached to the object specified
+ *          by the name \p obj_name.  The HDF5 datatype of the
+ *          attribute is #H5T_NATIVE_LONG.
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_long(hid_t loc_id, const char *obj_name, const char *attr_name, long *data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads a \e long \e long attribute.
+ *
+ * \param[in]   loc_id      Location of the object to which
+ *                          the attribute is attached
+ * \param[in]   obj_name    That object's name
+ * \param[in]   attr_name   Attribute name
+ * \param[out]  data        Attribute value
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_long_long() reads the attribute
+ *          specified by \p loc_id and \p obj_name.
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_long_long(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                            long long *data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads an attribute from disk.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  data        Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_ulong() reads an attribute named
+ *          \p attr_name that is attached to the object specified
+ *          by the name \p obj_name.  The HDF5 datatype of the
+ *          attribute is #H5T_NATIVE_ULONG.
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_ulong(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                        unsigned long *data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads an attribute from disk.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  data        Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_ullong() reads an attribute named
+ *          \p attr_name that is attached to the object specified
+ *          by the name \p obj_name.  The HDF5 datatype of the
+ *          attribute is #H5T_NATIVE_ULLONG.
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_ullong(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                         unsigned long long *data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads an attribute from disk.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  data        Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_float() reads an attribute named
+ *          \p attr_name that is attached to the object specified
+ *          by the name \p obj_name.  The HDF5 datatype of the
+ *          attribute is #H5T_NATIVE_FLOAT.
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_float(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                        float *data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Reads an attribute from disk.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  data        Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_double() reads an attribute named
+ *          \p attr_name that is attached to the object specified
+ *          by the name \p obj_name.  The HDF5 datatype of the
+ *          attribute is #H5T_NATIVE_DOUBLE.
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_double(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                         double *data);
+
+/*-------------------------------------------------------------------------
+ *
+ * Query attribute functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Gets the dimensionality of an attribute.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  rank        The dimensionality of the attribute
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_ndims() gets the dimensionality of an attribute
+ *          named \p attr_name that is attached to the object specified
+ *          by the name \p obj_name.
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_ndims(hid_t loc_id, const char *obj_name, const char *attr_name, int *rank);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Gets information about an attribute.
+ *
+ * \param[in]   loc_id      Identifier of the object (dataset or group)
+ *                          to read the attribute from
+ * \param[in]   obj_name    The name of the object that the attribute is
+ *                          attached to
+ * \param[in]   attr_name   The attribute name
+ * \param[out]  dims        The dimensions of the attribute
+ * \param[out]  type_class  The class identifier. #H5T_class_t is
+ *                          defined in H5Tpublic.h. For a list of valid class
+ *                          types see: H5Tget_class().
+ * \param[out]  type_size   The size of the datatype in bytes
+ *
+ * \return \herr_t
+ *
+ * \details H5LTget_attribute_info() gets information about an attribute
+ *          named \p attr_name attached to the object specified by
+ *          the name \p obj_name.
+ *
+ * \par Example
+ * \snippet H5LT_examples.c get_attribute_info
+ *
+ */
+H5_HLDLL herr_t H5LTget_attribute_info(hid_t loc_id, const char *obj_name, const char *attr_name,
+                                       hsize_t *dims, H5T_class_t *type_class, size_t *type_size);
+
+/*-------------------------------------------------------------------------
+ *
+ * General functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates an HDF5 datatype given a text description.
+ *
+ * \param[in] text      A character string containing a DDL
+ *                      definition of the datatype to be created
+ * \param[in] lang_type The language used to describe the datatype.
+ *                      The only currently supported language is
+ *                      #H5LT_DDL.
+ *
+ * \return  Returns the datatype identifier(non-negative) if successful;
+ *          otherwise returns a negative value.
+ *
+ * \details Given a text description of a datatype, this function creates
+ *          an HDF5 datatype and returns the datatype identifier.
+ *          The text description of the datatype has to comply with the
+ *          \p lang_type definition of HDF5 datatypes.
+ *          Currently, only the DDL(#H5LT_DDL) is supported.
+ *          The complete DDL definition of HDF5 datatypes can be found in
+ *          the last chapter of the
+ *          <a href="https://portal.hdfgroup.org/display/HDF5/HDF5+User+Guides">
+ *          HDF5 User's Guide</a>.
+ *
+ * \par Example
+ * An example of DDL definition of \c enum type is shown as follows.
+ * \snippet H5LT_examples.c enum
+ *
+ */
+H5_HLDLL hid_t H5LTtext_to_dtype(const char *text, H5LT_lang_t lang_type);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Creates a text description of an HDF5 datatype.
+ *
+ * \param[in] dtype     Identifier of the datatype to be converted
+ * \param[out] str      Buffer for the text description of the datatype
+ * \param[in] lang_type The language used to describe the datatype.
+ *                      The currently supported language is #H5LT_DDL.
+ * \param[out] len      The size of buffer needed to store the text description
+ *
+ * \return  \herr_t
+ *
+ * \details Given an HDF5 datatype identifier, this function creates
+ *          a description of this datatype in \p lang_type language format.
+ *          A preliminary H5LTdtype_to_text() call can be made to determine
+ *          the size of the buffer needed with a NULL passed in for \p str.
+ *          This value is returned as \p len. That value can then be assigned
+ *          to len for a second H5Ttype_to_text() call, which will
+ *          retrieve the actual text description for the datatype.
+ *
+ *          If \p len is not big enough for the description, the text
+ *          description will be truncated to fit in the buffer.
+ *
+ *          Currently only DDL (#H5LT_DDL) is supported for \p lang_type.
+ *          The complete DDL definition of HDF5 data types can be found in
+ *          the last chapter of the
+ *          <a href="https://portal.hdfgroup.org/display/HDF5/HDF5+User+Guides">
+ *          HDF5 User's Guide</a>.
+ *
+ * \par Example
+ * An example of DDL definition of \c enum type is shown as follows.
+ * \snippet H5LT_examples.c enum
+ *
+ */
+H5_HLDLL herr_t H5LTdtype_to_text(hid_t dtype, char *str, H5LT_lang_t lang_type, size_t *len);
+
+/*-------------------------------------------------------------------------
+ *
+ * Utility functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Determines whether an attribute exists.
+ *
+ * \param[in] loc_id    Identifier of the object to which the attribute
+ *                      is expected to be attached
+ * \param[in] name      Attribute name
+ *
+ * \return  \htri_t
+ *
+ * \details H5LTfind_attribute() determines whether an attribute named
+ *          \p name exists attached to the object specified
+ *          by \p loc_id.
+ *
+ *          \p loc_id must be an object identifier and \p name
+ *          must specify an attribute that is expected to be attached
+ *          to that object.
+ *
+ */
+H5_HLDLL herr_t H5LTfind_attribute(hid_t loc_id, const char *name);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Determines whether an HDF5 path is valid and, optionally,
+ *        whether the path resolves to an HDF5 object.
+ *
+ * \param[in] loc_id                Identifier of an object in the file
+ * \param[in] path                  The path to the object to check;
+ *                                  links in \p path may be of any type.
+ * \param[in] check_object_valid    If TRUE, determine whether the final
+ *                                  component of \p path resolves to
+ *                                  an object; if FALSE, do not check.
+ *
+ * \return  Upon success:
+ * \return  If \p check_object_valid is set to \c FALSE:
+ * \return  Returns \c TRUE if the path is valid;
+ *          otherwise returns \c FALSE.
+ * \return  If \p check_object_valid is set to \c TRUE:
+ * \return  Returns \c TRUE if the path is valid and
+ *          resolves to an HDF5 object;
+ *          otherwise returns \c FALSE.
+ *
+ * \return  Upon error, returns a negative value.
+ *
+ * \details H5LTpath_valid() checks the validity of \p path relative
+ *          to the identifier of an object, \p loc_id. Optionally,
+ *          \p check_object_valid can be set to determine whether the
+ *          final component of \p path resolves to an HDF5 object;
+ *          if not, the final component is a dangling link.
+ *
+ *          The meaning of the function's return value depends on the
+ *          value of \p check_object_valid:
+ *
+ *          If \p check_object_valid is set to \c FALSE, H5LTpath_valid()
+ *          will check all links in \p path to verify that they exist.
+ *          If all the links in \p path exist, the function will
+ *          return \c TRUE; otherwise the function will return \c FALSE.
+ *
+ *          If \p check_object_valid is set to \c TRUE,
+ *          H5LTpath_valid() will first check the links in \p path,
+ *          as described above. If all the links exist,
+ *          \p check_object_valid will then determine whether the final
+ *          component of \p path resolves to an actual HDF5 object.
+ *          H5LTpath_valid() will return \c TRUE if all the links in
+ *          \p path exist and the final component resolves to an
+ *          actual object; otherwise, it will return \c FALSE.
+ *
+ *          \p path can be any one of the following:
+ *
+ *          - An absolute path, which starts with a slash (\c /)
+ *            indicating the file's root group, followed by the members
+ *          - A relative path with respect to \p loc_id
+ *          - A dot (\c .), if \p loc_id is the object identifier for
+ *            the object itself.
+ *
+ *          If \p path is an absolute path, then \p loc_id can be an
+ *          identifier for any object in the file as it is used only to
+ *          identify the file. If \p path is a relative path, then
+ *          \p loc_id must be a file or a group identifier.
+ *
+ * \note
+ * <b>Note on Behavior Change:</b>
+ * The behavior of  H5LTpath_valid() was changed in the 1.10.0 release
+ * in the case where the root group, /, is the value of path.
+ * This change is described below:
+ *     - Let \p loc_id denote a valid HDF5 file identifier, and let
+ *       \p check_object_valid be set to true or false.
+ *       A call to  H5LTpath_valid() with arguments \p loc_id, /,
+ *       and \p check_object_valid returns a positive value;
+ *       in other words, H5LTpath_valid(loc_id, "/", check_object_valid)
+ *       returns a positive value.
+ *       In HDF5 version 1.8.16, this function returns 0.
+ *     - Let root denote a valid HDF5 group identifier that refers
+ *       to the root group of an HDF5 file, and let \p check_object_valid
+ *       be set to true or false.
+ *       A call to H5LTpath_valid() with arguments root, /, and
+ *       \p check_object_valid returns a positive value;
+ *       in other words, H5LTpath_valid(root, "/", check_object_valid)
+ *       returns a positive value.
+ *       In HDF5 version 1.8.16, this function returns 0.
+ *
+ * \version 1.10.0 Function behavior changed in this release.
+ *                 See the Note on Behavior Change section above.
+ *
+ */
+H5_HLDLL htri_t H5LTpath_valid(hid_t loc_id, const char *path, hbool_t check_object_valid);
+
+/*-------------------------------------------------------------------------
+ *
+ * File image operations functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5LT
+ *
+ * \brief Opens an HDF5 file image in memory.
+ *
+ * \param[in] buf_ptr   A pointer to the supplied initial image
+ * \param[in] buf_size  Size of the supplied buffer
+ * \param[in] flags     Flags specifying whether to open the image
+ *                      read-only or read/write, whether HDF5 is to
+ *                      take control of the buffer, and instruction
+ *                      regarding releasing the buffer.
+ *
+ * \return  Returns a file identifier if successful;
+ *          otherwise returns a negative value.
+ * \warning \Bold{Failure Modes:}
+ * \warning H5LTopen_file_image() will fail if either \p buf_ptr is NULL
+ *          or \p buf_size equals 0 (zero).
+ *
+ *
+ * \details H5LTopen_file_image() opens the HDF5 file image that is
+ *          located in system memory at the address indicated by
+ *          \p buf_ptr of size \p buf_size.
+ *          H5LTopen_file_image() opens a file image with the
+ *          Core driver, #H5FD_CORE.
+ *
+ *          A value of NULL for \p buf_ptr is invalid and will
+ *          cause the function to fail.
+ *
+ *          A value of 0 for \p buf_size is invalid and will cause
+ *          the function to fail.
+ *
+ *          The flags passed in \p flags specify whether to open the image
+ *          read-only or read/write, whether HDF5 is to take control of the
+ *          buffer, and instruction regarding releasing the buffer.
+ *          Valid values are:
+ *          - #H5LT_FILE_IMAGE_OPEN_RW
+ *            - Specifies opening the file image in read/write mode.
+ *            - Default without this flag: File image will be opened read-only.
+ *
+ *          - #H5LT_FILE_IMAGE_DONT_COPY
+ *            - Specifies to not copy the provided file image buffer;
+ *              the buffer will be used directly. HDF5 will release the
+ *              file image when finished.
+ *            - Default without this flag: Copy the file image buffer and
+ *              open the copied file image.
+ *
+ *          - #H5LT_FILE_IMAGE_DONT_RELEASE
+ *            - Specifies that HDF5 is not to release the buffer when
+ *              the file opened with H5LTopen_file_image() is closed;
+ *              releasing the buffer will be left to the application.
+ *            - Default without this flag: HDF5 will automatically
+ *              release the file image buffer after the file image is
+ *              closed.  This flag is valid only when used with
+ *              #H5LT_FILE_IMAGE_DONT_COPY.
+ *
+ * \note      **Motivation:**
+ * \note      H5LTopen_file_image() and other elements of HDF5
+ *            are used to load an image of an HDF5 file into system memory
+ *            and open that image as a regular HDF5 file. An application can
+ *            then use the file without the overhead of disk I/O.
+ *
+ * \note      **Recommended Reading:**
+ * \note      This function is part of the file image operations feature set.
+ *            It is highly recommended to study the guide
+ *            <a href="https://portal.hdfgroup.org/display/HDF5/HDF5+File+Image+Operations">
+ *            HDF5 File Image Operations</a> before using this feature set.\n
+ *            See the See Also section below for links to other elements of
+ *            HDF5 file image operations.
+ *
+ * \todo There is no "See Also" section???
+ *
+ * \since 1.8.9
+ */
+H5_HLDLL hid_t H5LTopen_file_image(void *buf_ptr, size_t buf_size, unsigned flags);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5Ldevelop.h b/install/include/H5Ldevelop.h
new file mode 100644
index 0000000000..148a5a5746
--- /dev/null
+++ b/install/include/H5Ldevelop.h
@@ -0,0 +1,324 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5L (link) developer
+ *      support routines.
+ */
+
+#ifndef H5Ldevelop_H
+#define H5Ldevelop_H
+
+/* Include package's public header */
+#include "H5Lpublic.h"
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/**
+ * \brief Current version of the H5L_class_t struct
+ */
+#define H5L_LINK_CLASS_T_VERS 1
+
+/**
+ * \brief Version of external link format
+ */
+#define H5L_EXT_VERSION 0
+
+/**
+ * \brief Valid flags for external links
+ */
+#define H5L_EXT_FLAGS_ALL 0
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/* The H5L_class_t struct can be used to override the behavior of a
+ * "user-defined" link class. Users should populate the struct with callback
+ * functions defined below.
+ */
+/* Callback prototypes for user-defined links */
+/**
+ * \brief Link creation callback
+ */
+typedef herr_t (*H5L_create_func_t)(const char *link_name, hid_t loc_group, const void *lnkdata,
+                                    size_t lnkdata_size, hid_t lcpl_id);
+/**
+ * \brief Callback for link move
+ */
+typedef herr_t (*H5L_move_func_t)(const char *new_name, hid_t new_loc, const void *lnkdata,
+                                  size_t lnkdata_size);
+/**
+ * \brief Callback for link copy
+ */
+typedef herr_t (*H5L_copy_func_t)(const char *new_name, hid_t new_loc, const void *lnkdata,
+                                  size_t lnkdata_size);
+/**
+ * \brief Callback during link traversal
+ */
+typedef hid_t (*H5L_traverse_func_t)(const char *link_name, hid_t cur_group, const void *lnkdata,
+                                     size_t lnkdata_size, hid_t lapl_id, hid_t dxpl_id);
+/**
+ * \brief Callback for link deletion
+ */
+typedef herr_t (*H5L_delete_func_t)(const char *link_name, hid_t file, const void *lnkdata,
+                                    size_t lnkdata_size);
+/**
+ * \brief Callback for querying the link.
+ *
+ * Returns the size of the buffer needed.
+ */
+typedef ssize_t (*H5L_query_func_t)(const char *link_name, const void *lnkdata, size_t lnkdata_size,
+                                    void *buf /*out*/, size_t buf_size);
+
+/**
+ * \brief Link prototype
+ *
+ * The H5L_class_t struct can be used to override the behavior of a
+ * "user-defined" link class. Users should populate the struct with callback
+ * functions defined elsewhere.
+ */
+//! <!-- [H5L_class_t_snip] -->
+typedef struct {
+    int                 version;     /**< Version number of this struct       */
+    H5L_type_t          id;          /**< Link type ID                        */
+    const char         *comment;     /**< Comment for debugging               */
+    H5L_create_func_t   create_func; /**< Callback during link creation       */
+    H5L_move_func_t     move_func;   /**< Callback after moving link          */
+    H5L_copy_func_t     copy_func;   /**< Callback after copying link         */
+    H5L_traverse_func_t trav_func;   /**< Callback during link traversal      */
+    H5L_delete_func_t   del_func;    /**< Callback for link deletion          */
+    H5L_query_func_t    query_func;  /**< Callback for queries                */
+} H5L_class_t;
+//! <!-- [H5L_class_t_snip] -->
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \ingroup H5LA
+ *
+ * \brief Registers a user-defined link class or changes behavior of an
+ *        existing class
+ *
+ * \param[in] cls Pointer to a buffer containing the struct describing the
+ *            user-defined link class
+ *
+ * \return \herr_t
+ *
+ * \details H5Lregister() registers a class of user-defined links, or changes
+ *          the behavior of an existing class.
+ *
+ *          \p cls is a pointer to a buffer containing a copy of the
+ *          H5L_class_t struct. This struct is defined in H5Lpublic.h as
+ *          follows:
+ *          \snippet this H5L_class_t_snip
+ *
+ *          The class definition passed with \p cls must include at least the
+ *          following:
+ *          \li An H5L_class_t version (which should be #H5L_LINK_CLASS_T_VERS)
+ *          \li A link class identifier, \c class_id
+ *          \li A traversal function, \c trav_func
+ *
+ *          Remaining \c struct members are optional and may be passed as NULL.
+ *
+ *          The link class passed in \c class_id must be in the user-definable
+ *          range between #H5L_TYPE_UD_MIN and #H5L_TYPE_UD_MAX
+ *          (see the table below) and will override
+ *          any existing link class with that identifier.
+ *
+ *          As distributed, valid values of \c class_id used in HDF5 include
+ *          the following (defined in H5Lpublic.h):
+ *          \link_types
+ *
+ *          The hard and soft link class identifiers cannot be modified or
+ *          reassigned, but the external link class is implemented as an
+ *          example in the user-definable link class identifier range.
+ *          H5Lregister() is used to register additional link classes. It could
+ *          also be used to modify the behavior of the external link class,
+ *          though that is not recommended.
+ *
+ *          The following table summarizes existing link types and values and
+ *          the reserved and user-definable link class identifier value ranges.
+ *          <table>
+ *            <tr>
+ *              <th>Link class identifier or Value range</th>
+ *              <th>Description</th>
+ *              <th>Link class or label</th>
+ *            </tr>
+ *            <tr>
+ *              <td>0 to 63</td>
+ *              <td>Reserved range</td>
+ *              <td></td>
+ *            </tr>
+ *            <tr>
+ *              <td>64 to 255</td>
+ *              <td>User-definable range</td>
+ *              <td></td>
+ *            </tr>
+ *            <tr>
+ *              <td>64</td>
+ *              <td>Minimum user-defined value</td>
+ *              <td>#H5L_TYPE_UD_MIN</td>
+ *            </tr>
+ *            <tr>
+ *              <td>64</td>
+ *              <td>External link</td>
+ *              <td>#H5L_TYPE_EXTERNAL</td>
+ *            </tr>
+ *            <tr>
+ *              <td>255</td>
+ *              <td>Maximum user-defined value</td>
+ *              <td>#H5L_TYPE_UD_MAX</td>
+ *            </tr>
+ *            <tr>
+ *              <td>255</td>
+ *              <td>Maximum value</td>
+ *              <td>#H5L_TYPE_MAX</td>
+ *            </tr>
+ *            <tr>
+ *              <td>-1</td>
+ *              <td>Error</td>
+ *              <td>#H5L_TYPE_ERROR</td>
+ *            </tr>
+ *          </table>
+ *
+ *          Note that HDF5 internally registers user-defined link classes only
+ *          by the numeric value of the link class identifier. An application,
+ *          on the other hand, will generally use a name for a user-defined
+ *          class, if for no other purpose than as a variable name. Assume,
+ *          for example, that a complex link type is registered with the link
+ *          class identifier 73 and that the code includes the following
+ *          assignment:
+ *          \code
+ *          H5L_TYPE_COMPLEX_A = 73
+ *          \endcode
+ *          The application can refer to the link class with a term,
+ *          \c  H5L_TYPE_COMPLEX_A, that conveys meaning to a human reviewing
+ *          the code, while HDF5 recognizes it by the more cryptic numeric
+ *          identifier, 73.
+ *
+ * \attention Important details and considerations include the following:
+ *            \li If you plan to distribute files or software with a
+ *                user-defined link class, please contact the Help Desk at
+ *                The HDF Group to help prevent collisions between \c class_id
+ *                values. See below.
+ *            \li As distributed with HDF5, the external link class is
+ *                implemented as an example of a user-defined link class with
+ *                #H5L_TYPE_EXTERNAL equal to #H5L_TYPE_UD_MIN. \c class_id in
+ *                the H5L_class_t \c struct must not equal #H5L_TYPE_UD_MIN
+ *                unless you intend to overwrite or modify the behavior of
+ *                external links.
+ *            \li H5Lregister() can be used only with link class identifiers
+ *                in the user-definable range (see table above).
+ *            \li The hard and soft links defined by the HDF5 library,
+ *                #H5L_TYPE_HARD and #H5L_TYPE_SOFT, reside in the reserved
+ *                range below #H5L_TYPE_UD_MIN and cannot be redefined or
+ *                modified.
+ *            \li H5Lis_registered() can be used to determine whether a desired
+ *                link class identifier is available. \Emph{Note that this
+ *                function will tell you only whether the link class identifier
+ *                has been registered with the installed copy of HDF5; it
+ *                cannot tell you whether the link class has been registered
+ *                with The HDF Group.}
+ *            \li #H5L_TYPE_MAX is the maximum allowed value for a link type
+ *                identifier.
+ *            \li #H5L_TYPE_UD_MIN equals #H5L_TYPE_EXTERNAL.
+ *            \li #H5L_TYPE_UD_MAX equals #H5L_TYPE_MAX.
+ *            \li #H5L_TYPE_ERROR indicates that an error has occurred.
+ *
+ * \note \Bold{Registration with The HDF Group:}\n
+ *       There are sometimes reasons to take a broader approach to registering
+ *       a user-defined link class than just invoking H5Lregister(). For
+ *       example:
+ *       \li A user-defined link class is intended for use across an
+ *           organization, among collaborators, or across a community of users.
+ *       \li An application or library overlying HDF5 invokes a user-defined
+ *           link class that must be shipped with the software.
+ *       \li Files are distributed that make use of a user-defined link class.
+ *       \li Or simply, a specific user-defined link class is thought to be
+ *           widely useful.
+ *
+ *       In such cases, you are encouraged to register that link class with
+ *       The HDF Group's Helpdesk. The HDF Group maintains a registry of known
+ *       user-defined link classes and tracks the selected link class
+ *       identifiers. This registry is intended to reduce the risk of
+ *       collisions between \c class_id values and to help coordinate the use
+ *       of specialized link classes.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Lregister(const H5L_class_t *cls);
+/**
+ * \ingroup H5LA
+ *
+ * \brief Unregisters a class of user-defined links
+ *
+ * \param[in] id User-defined link class identifier
+ *
+ * \return \herr_t
+ *
+ * \details H5Lunregister() unregisters a class of user-defined links,
+ *          preventing them from being traversed, queried, moved, etc.
+ *
+ * \note A link class can be re-registered using H5Lregister().
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Lunregister(H5L_type_t id);
+
+#ifdef __cplusplus
+}
+#endif
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Previous versions of the H5L_class_t struct */
+#define H5L_LINK_CLASS_T_VERS_0 0
+
+/** Callback during link traversal */
+typedef hid_t (*H5L_traverse_0_func_t)(const char *link_name, hid_t cur_group, const void *lnkdata,
+                                       size_t lnkdata_size, hid_t lapl_id);
+
+/** User-defined link types */
+typedef struct {
+    int                   version;     /**< Version number of this struct        */
+    H5L_type_t            id;          /**< Link type ID                         */
+    const char           *comment;     /**< Comment for debugging                */
+    H5L_create_func_t     create_func; /**< Callback during link creation        */
+    H5L_move_func_t       move_func;   /**< Callback after moving link           */
+    H5L_copy_func_t       copy_func;   /**< Callback after copying link          */
+    H5L_traverse_0_func_t trav_func;   /**< Callback during link traversal       */
+    H5L_delete_func_t     del_func;    /**< Callback for link deletion           */
+    H5L_query_func_t      query_func;  /**< Callback for queries                 */
+} H5L_class_0_t;
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#endif /* H5Ldevelop_H */
diff --git a/install/include/H5Lpublic.h b/install/include/H5Lpublic.h
new file mode 100644
index 0000000000..2bf3c53b83
--- /dev/null
+++ b/install/include/H5Lpublic.h
@@ -0,0 +1,1955 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5Lpublic.h
+ *
+ * Purpose:             Public declarations for the H5L package (links)
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef H5Lpublic_H
+#define H5Lpublic_H
+
+#include "H5public.h"  /* Generic Functions                        */
+#include "H5Ipublic.h" /* Identifiers                              */
+#include "H5Opublic.h" /* Object Headers                           */
+#include "H5Tpublic.h" /* Datatypes                                */
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/**
+ * \brief Maximum length of a link's name
+ *
+ * The maximum length of a link's name is encoded in a 32-bit unsigned integer.
+ */
+#define H5L_MAX_LINK_NAME_LEN UINT32_MAX
+
+/**
+ * \brief Macro to indicate operation occurs on same location
+ */
+#define H5L_SAME_LOC 0 /* (hid_t) */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/**
+ * \brief  Link class types.
+ *
+ * Values less than 64 are reserved for the HDF5 library's internal use. Values
+ * 64 to 255 are for "user-defined" link class types; these types are defined
+ * by HDF5 but their behavior can be overridden by users. Users who want to
+ * create new classes of links should contact the HDF5 development team at
+ * mailto:help@hdfgroup.org. These values can never change because they appear
+ * in HDF5 files.
+ */
+typedef enum {
+    H5L_TYPE_ERROR    = (-1), /**< Invalid link type id         */
+    H5L_TYPE_HARD     = 0,    /**< Hard link id                 */
+    H5L_TYPE_SOFT     = 1,    /**< Soft link id                 */
+    H5L_TYPE_EXTERNAL = 64,   /**< External link id             */
+    H5L_TYPE_MAX      = 255   /**< Maximum link type id         */
+} H5L_type_t;
+/**
+ * \brief  Maximum value link value for "built-in" link types
+ */
+#define H5L_TYPE_BUILTIN_MAX H5L_TYPE_SOFT
+/**
+ * \brief Link ids at or above this value are "user-defined" link types.
+ */
+#define H5L_TYPE_UD_MIN H5L_TYPE_EXTERNAL
+/**
+ * \brief Maximum link id value for "user-defined" link types.
+ */
+#define H5L_TYPE_UD_MAX H5L_TYPE_MAX
+
+/**
+ * \brief Information struct for links
+ */
+//! <!-- [H5L_info2_t_snip] -->
+typedef struct {
+    H5L_type_t type;         /**< Type of link                   */
+    hbool_t    corder_valid; /**< Indicate if creation order is valid */
+    int64_t    corder;       /**< Creation order                 */
+    H5T_cset_t cset;         /**< Character set of link name     */
+    union {
+        H5O_token_t token;    /**< Token of location that hard link points to */
+        size_t      val_size; /**< Size of a soft link or user-defined link value */
+    } u;
+} H5L_info2_t;
+//! <!-- [H5L_info2_t_snip] -->
+
+/**
+ * \brief Prototype for H5Literate2(), H5Literate_by_name2() operator
+ *
+ * The H5O_token_t version is used in the VOL layer and future public API calls.
+ */
+//! <!-- [H5L_iterate2_t_snip] -->
+typedef herr_t (*H5L_iterate2_t)(hid_t group, const char *name, const H5L_info2_t *info, void *op_data);
+//! <!-- [H5L_iterate2_t_snip] -->
+
+/**
+ * \brief Callback for external link traversal
+ */
+typedef herr_t (*H5L_elink_traverse_t)(const char *parent_file_name, const char *parent_group_name,
+                                       const char *child_file_name, const char *child_object_name,
+                                       unsigned *acc_flags, hid_t fapl_id, void *op_data);
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+/**
+ * \ingroup H5L
+ *
+ * \brief Moves a link within an HDF5 file
+ *
+ * \fgdta_loc_id{src_loc}
+ * \param[in] src_name Original link name
+ * \fgdta_loc_id{dst_loc}
+ * \param[in] dst_name New link name
+ * \lcpl_id
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Lmove() moves a link within an HDF5 file. The original link,
+ *          \p src_name, is removed from \p src_loc and the new link,
+ *          \p dst_name, is inserted at dst_loc. This change is
+ *          accomplished as an atomic operation.
+ *
+ *          \p src_loc and \p src_name identify the original link.
+ *          \p src_loc is the original location identifier; \p src_name is
+ *          the path to the link and is interpreted relative to \p src_loc.
+ *
+ *          \p dst_loc and \p dst_name identify the new link. \p dst_loc is
+ *          either a file or group identifier; \p dst_name is the path to
+ *          the link and is interpreted relative to \p dst_loc.
+ *
+ *          \p lcpl_id and \p lapl_id are the link creation and link access
+ *          property lists, respectively, associated with the new link,
+ *          \p dst_name.
+ *
+ *          Through these property lists, several properties are available to
+ *          govern the behavior of H5Lmove(). The property controlling creation
+ *          of missing intermediate groups is set in the link creation property
+ *          list with H5Pset_create_intermediate_group(); H5Lmove() ignores any
+ *          other properties in the link creation property list. Properties
+ *          controlling character encoding, link traversals, and external link
+ *          prefixes are set in the link access property list with
+ *          H5Pset_char_encoding(), H5Pset_nlinks(), and H5Pset_elink_prefix(),
+ *          respectively.
+ *
+ * \note Note that H5Lmove() does not modify the value of the link; the new
+ *       link points to the same object as the original link pointed to.
+ *       Furthermore, if the object pointed to by the original link was already
+ *       open with a valid object identifier, that identifier will remain valid
+ *       after the call to H5Lmove().
+ *
+ * \attention Exercise care in moving links as it is possible to render data in
+ *            a file inaccessible with H5Lmove(). If the link being moved is on
+ *            the only path leading to an HDF5 object, that object may become
+ *            permanently inaccessible in the file.
+ *
+ * \since 1.8.0
+ *
+ *-------------------------------------------------------------------------
+ */
+H5_DLL herr_t H5Lmove(hid_t src_loc, const char *src_name, hid_t dst_loc, const char *dst_name, hid_t lcpl_id,
+                      hid_t lapl_id);
+/**
+ * \ingroup H5L
+ *
+ * \brief Creates an identical copy of a link with the same creation time and
+ *        target.  The new link can have a different name and be in a different
+ *        location than the original.
+ *
+ * \fgdt_loc_id{src_loc}
+ * \param[in] src_name   Name of the link to be copied
+ * \fgdt_loc_id{dst_loc}
+ * \param[in] dst_name   Name to be assigned to the new copy
+ * \lcpl_id
+ * \lapl_id
+ * \return \herr_t
+ *
+ * \details H5Lcopy() copies the link specified by \p src_name from the location
+ *          specified by \p src_loc_id to the location specified by
+ *          \p dst_loc_id. The new copy of the link is created with the name
+ *          \p dst_name.
+ *
+ *          If \p dst_loc_id is a file identifier, \p dst_name will be
+ *          interpreted relative to that file's root group.
+ *
+ *          The new link is created with the creation and access property lists
+ *          specified by \p lcpl_id and \p lapl_id. The interpretation of
+ *          \p lcpl_id is limited in the manner described in the next paragraph.
+ *
+ *          H5Lcopy() retains the creation time and the target of the original
+ *          link. However, since the link may be renamed, the character
+ *          encoding is specified in \p lcpl_id rather than in that of the
+ *          original link. Other link creation properties are ignored.
+ *
+ *          If the link is a soft link, also known as a symbolic link, its
+ *          target is interpreted relative to the location of the copy.
+ *
+ *          Several properties are available to govern the behavior of
+ *          H5Lcopy(). These properties are set in the link creation and access
+ *          property lists, \p lcpl_id and \p lapl_id, respectively. The
+ *          property controlling creation of missing intermediate groups is set
+ *          in the link creation property list with
+ *          H5Pset_create_intermediate_group(); this function ignores any
+ *          other properties in the link creation property list. Properties
+ *          controlling character encoding, link traversals, and external link
+ *          prefixes are set in the link access property list with
+ *          H5Pset_char_encoding(), H5Pset_nlinks(), and
+ *          H5Pset_elink_prefix().
+ *
+ * \note H5Lcopy() does not affect the object that the link points to.
+ *
+ * \attention H5Lcopy() cannot copy hard links across files as a hard link is
+ *            not valid without a target object; to copy objects from one file
+ *            to another, see H5Ocopy().
+ *
+ * \see H5Ocopy()
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Lcopy(hid_t src_loc, const char *src_name, hid_t dst_loc, const char *dst_name, hid_t lcpl_id,
+                      hid_t lapl_id);
+/**
+ * \ingroup H5L
+ *
+ * \brief Creates a hard link to an object
+ *
+ * \fgdta_loc_id{cur_loc}
+ * \param[in] cur_name Name of the target object, which must already exist
+ * \fgdta_loc_id{dst_loc}
+ * \param[in] dst_name The name of the new link
+ * \lcpl_id
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Lcreate_hard() creates a new hard link to a pre-existing object
+ *          in an HDF5 file.
+ *
+ *          \p cur_loc and \p cur_name specify the location
+ *          and name, respectively, of the target object, i.e., the object that
+ *          the new hard link points to. \p dst_loc and \p dst_name specify the
+ *          location and name, respectively, of the new hard link.
+ *
+ *          \p cur_name and \p dst_name are interpreted relative to \p cur_loc
+ *          and \p dst_loc, respectively. If a given name begins with \c /,
+ *          then it will be interpreted as absolute path in the file.
+ *          The names of the created links will be the last element of
+ *          each provided path. Prior elements in each path are used to
+ *          locate the parent groups of each new link. If \p cur_loc and
+ *          \p dst_loc are the same location, the HDF5 macro
+ *          #H5L_SAME_LOC can be used for either parameter (but not both).
+ *
+ *          \p lcpl_id and \p lapl_id are the link creation and access property
+ *          lists associated with the new link.
+ *
+ * \note Hard and soft links are for use only if the target object is in the
+ *       current file. If the desired target object is in a different file from
+ *       the new link, an external link may be created with
+ *       H5Lcreate_external().
+ *
+ * \note The HDF5 library keeps a count of all hard links pointing to an
+ *       object; if the hard link count reaches zero (0), the object will be
+ *       deleted from the file. Creating new hard links to an object will
+ *       prevent it from being deleted if other links are removed. The
+ *       library maintains no similar count for soft links and they can dangle.
+ *
+ * \note The new link may be one of many that point to that object.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Lcreate_hard(hid_t cur_loc, const char *cur_name, hid_t dst_loc, const char *dst_name,
+                             hid_t lcpl_id, hid_t lapl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Lcreate_hard}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Lcreate_hard_async(const char *app_file, const char *app_func, unsigned app_line,
+                                   hid_t cur_loc_id, const char *cur_name, hid_t new_loc_id,
+                                   const char *new_name, hid_t lcpl_id, hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL herr_t H5Lcreate_hard_async(hid_t cur_loc_id, const char *cur_name, hid_t new_loc_id,
+                                   const char *new_name, hid_t lcpl_id, hid_t lapl_id, hid_t es_id);
+#endif
+/**
+ * \ingroup H5L
+ *
+ * \brief Creates a soft link
+ *
+ * \param[in] link_target An HDF5 path name
+ * \fgdta_loc_id{link_loc_id}
+ * \param[in] link_name The name of the new link
+ * \lcpl_id
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Lcreate_soft() creates a new soft link to an object in an HDF5
+ *          file.
+ *
+ *          \p link_target specifies the HDF5 path name the soft link contains.
+ *          \p link_target can be an arbitrary HDF5 path name and is
+ *          interpreted only at lookup time. This path may be absolute in the
+ *          file or relative to \p link_loc_id.
+ *
+ *          \p link_loc_id and \p link_name specify the location and name,
+ *          respectively, of the new soft link. \p link_name is interpreted
+ *          as a path relative to \p link_loc_id, or an absolute path if it
+ *          begins with \c /. The name of the created link will be the last
+ *          element of the provided path. Prior elements in the path are
+ *          used to locate the parent group of the new link.
+ *
+ *          If \p link_loc_id is a group identifier, the object pointed to by
+ *          \p link_name will be accessed as a member of that group. If
+ *          \p link_loc_id is a file identifier, the object will be accessed as a
+ *          member of the file's root group.
+ *
+ *          \p lcpl_id and \p lapl_id are the link creation and access property
+ *          lists associated with the new link.
+ *
+ *          For instance, if target_path is \c ./foo, \p link_loc_id specifies
+ *          \c ./x/y/bar, and the name of the new link is \c new_link, then a
+ *          subsequent request for \c ./x/y/bar/new_link will return the same
+ *          object as would be found at \c ./foo.
+ *
+ * \note H5Lcreate_soft() is for use only if the target object is in the
+ *       current file. If the desired target object is in a different file from
+ *       the new link, use H5Lcreate_external() to create an external link.
+ *
+ * \note Soft links and external links are also known as symbolic links as they
+ *       use a name to point to an object; hard links employ an object's
+ *       address in the file.
+ *
+ * \note Unlike hard links, a soft link in an HDF5 file is allowed to dangle,
+ *       meaning that the target object need not exist at the time that the
+ *       link is created.
+ *
+ * \note The HDF5 library does not keep a count of soft links as it does of
+ *       hard links.
+ *
+ * \note The new link may be one of many that point to that object.
+ *
+ * \see H5Lcreate_hard(), H5Lcreate_external()
+ *
+ * \since 1.8.0
+ *
+
+ */
+H5_DLL herr_t H5Lcreate_soft(const char *link_target, hid_t link_loc_id, const char *link_name, hid_t lcpl_id,
+                             hid_t lapl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Lcreate_soft}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Lcreate_soft_async(const char *app_file, const char *app_func, unsigned app_line,
+                                   const char *link_target, hid_t link_loc_id, const char *link_name,
+                                   hid_t lcpl_id, hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL herr_t H5Lcreate_soft_async(const char *link_target, hid_t link_loc_id, const char *link_name,
+                                   hid_t lcpl_id, hid_t lapl_id, hid_t es_id);
+#endif
+/**
+ * \ingroup H5L
+ *
+ * \brief Removes a link from a group
+ *
+ * \fgdta_loc_id
+ * \param[in] name Name of the link to delete
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Ldelete() removes the link specified by \p name from the location
+ *          \p loc_id.
+ *
+ *          If the link being removed is a hard link, H5Ldelete() also
+ *          decrements the link count for the object to which name points.
+ *          Unless there is a duplicate hard link in that group, this action
+ *          removes the object to which name points from the group that
+ *          previously contained it.
+ *
+ *          Object headers keep track of how many hard links refer to an
+ *          object; when the hard link count, also referred to as the reference
+ *          count, reaches zero, the object can be removed from the file. The
+ *          file space associated will then be released, i.e., identified in
+ *          memory as freespace. Objects which are open are not removed until
+ *          all identifiers to the object are closed.
+ *
+ * \attention Exercise caution in the use of H5Ldelete(); if the link being
+ *            removed is on the only path leading to an HDF5 object, that
+ *            object may become permanently inaccessible in the file.
+ *
+ * \see H5Lcreate_hard(), H5Lcreate_soft(), H5Lcreate_external()
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Ldelete(hid_t loc_id, const char *name, hid_t lapl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Ldelete}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Ldelete_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                              const char *name, hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL herr_t H5Ldelete_async(hid_t loc_id, const char *name, hid_t lapl_id, hid_t es_id);
+#endif
+/**
+ * \ingroup H5L
+ *
+ * \brief Removes the \Emph{n}-th link in a group
+ *
+ * \fgdta_loc_id
+ * \param[in] group_name Name of subject group
+ * \param[in] idx_type Index or field which determines the order
+ * \param[in] order Order within field or index
+ * \param[in] n Link for which to retrieve information
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Ldelete_by_idx() removes the \Emph{n}-th link in a group
+ *          according to the specified order, \p order, in the specified index,
+ *          \p index.
+ *
+ *          If \p loc_id specifies the group in which the link resides,
+ *          \p group_name can be a dot (\c .).
+ *
+ * \see H5Ldelete()
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Ldelete_by_idx(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                               H5_iter_order_t order, hsize_t n, hid_t lapl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Ldelete_by_idx}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Ldelete_by_idx_async(const char *app_file, const char *app_func, unsigned app_line,
+                                     hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                     H5_iter_order_t order, hsize_t n, hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL herr_t H5Ldelete_by_idx_async(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                     H5_iter_order_t order, hsize_t n, hid_t lapl_id, hid_t es_id);
+#endif
+/**
+ * \ingroup H5L
+ *
+ * \brief Returns the value of a link
+ *
+ * \fgdta_loc_id
+ * \param[in] name Link name
+ * \param[out] buf The buffer to hold the link value
+ * \param[in] size Maximum number of bytes of link value to be returned
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Lget_val() returns the value of link \p name. For symbolic links,
+ *          this is the path to which the link points, including the null
+ *          terminator. For external and user-defined links, it is the link
+ *          buffer.
+ *
+ *          \p size is the size of \p buf and should be the size of the link
+ *          value being returned. This size value can be determined through a
+ *          call to H5Lget_info(); it is returned in the \c val_size field of
+ *          the \ref H5L_info_t \c struct.
+ *
+ *          If \p size is smaller than the size of the returned value, then the
+ *          string stored in \p buf will be truncated to \p size bytes. For
+ *          soft links, this means that the value will not be null terminated.
+ *
+ *          In the case of external links, the target file and object names are
+ *          extracted from \p buf by calling H5Lunpack_elink_val().
+ *
+ *          The link class of link \p name can be determined with a call to
+ *          H5Lget_info().
+ *
+ *          \p lapl_id specifies the link access property list associated with
+ *          the link \p name. In the general case, when default link access
+ *          properties are acceptable, this can be passed in as #H5P_DEFAULT. An
+ *          example of a situation that requires a non-default link access
+ *          property list is when the link is an external link; an external
+ *          link may require that a link prefix be set in a link access
+ *          property list (see H5Pset_elink_prefix()).
+ *
+ *          This function should be used only after H5Lget_info() has been
+ *          called to verify that \p name is a symbolic link. This can be
+ *          determined from the \c link_type field of the \ref H5L_info_t
+ *          \c struct.
+ *
+ * \note This function will fail if called on a hard link.
+ *
+ * \see H5Lget_val_by_idx()
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Lget_val(hid_t loc_id, const char *name, void *buf /*out*/, size_t size, hid_t lapl_id);
+/**
+ * \ingroup H5L
+ *
+ * \brief Retrieves value of the \Emph{n}-th link in a group, according to the order within an index
+ *
+ * \fgdta_loc_id
+ * \param[in] group_name Group name
+ * \param[in] idx_type Type of index
+ * \param[in] order Order within field or index
+ * \param[in] n Link position for which to retrieve information
+ * \param[out] buf The buffer to hold the link value
+ * \param[in] size Maximum number of bytes of link value to be returned
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Lget_val_by_idx() retrieves the value of the \Emph{n}-th link in
+ *          a group, according to the specified order, \p order, within an
+ *          index, \p index.
+ *
+ *          For soft links, the value is an HDF5 path name.
+ *
+ *          For external links, this is a compound value containing file and
+ *          path name information; to use this external link information, it
+ *          must first be decoded with H5Lunpack_elink_val()
+ *
+ *          For user-defined links, this value will be described in the
+ *          definition of the user-defined link type.
+ *
+ *          \p loc_id specifies the location identifier of the group specified
+ *          by \p group_name.
+ *
+ *          \p group_name specifies the group in which the link exists. If
+ *          \p loc_id already specifies the group in which the link exists,
+ *          \p group_name must be a dot (\c .).
+ *
+ *          The size in bytes of link_val is specified in \p size. The size
+ *          value can be determined through a call to H5Lget_info_by_idx(); it
+ *          is returned in the \c val_size field of the \ref H5L_info_t
+ *          \c struct. If
+ *          size is smaller than the size of the returned value, then the
+ *          string stored in link_val will be truncated to size bytes. For soft
+ *          links, this means that the value will not be null terminated.
+ *
+ *          If the type of the link is unknown or uncertain, H5Lget_val_by_idx()
+ *          should be called only after the type has been determined via a call
+ *          to H5Lget_info_by_idx().
+ *
+ * \note This function will fail if called on a hard link.
+ *
+ * \see H5Lget_val()
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Lget_val_by_idx(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                H5_iter_order_t order, hsize_t n, void *buf /*out*/, size_t size,
+                                hid_t lapl_id);
+/**
+ * \ingroup H5L
+ *
+ * \brief Determines whether a link with the specified name exists in a group
+ *
+ * \fgdta_loc_id
+ * \param[in] name Link name
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Lexists() allows an application to determine whether the link \p
+ *          name exists in the location specified by \p loc_id. The link may be
+ *          of any type; only the presence of a link with that name is checked.
+ *
+ *          Note that H5Lexists() verifies only that the target link exists. If
+ *          name includes either a relative path or an absolute path to the
+ *          target link, intermediate steps along the path must be verified
+ *          before the existence of the target link can be safely checked. If
+ *          the path is not verified, and an intermediate element of the path
+ *          does not exist, H5Lexists() will fail. The example in the next
+ *          paragraph illustrates one step-by-step method for verifying the
+ *          existence of a link with a relative or absolute path.
+ *
+ *          \Bold{Example:} Use the following steps to verify the existence of
+ *          the link \c datasetD in the \c group group1/group2/softlink_to_group3/,
+ *          where \c group1 is a member of the group specified by \c loc_id:
+ *
+ *          1. First, use H5Lexists() to verify that the \c group1 exists.
+ *          2. If \c group1 exists, use H5Lexists() again, this time with name
+ *             set to \c group1/group2, to verify that \c group2 exists.
+ *          3. If \c group2 exists, use H5Lexists() with name set to
+ *             \c group1/group2/softlink_to_group3 to verify that
+ *             \c softlink_to_group3 exists.
+ *          4. If \c softlink_to_group3 exists, you can now safely use
+ *             H5Lexists() with \c name set to
+ *             \c group1/group2/softlink_to_group3/datasetD to verify that the
+ *             target link, \c datasetD, exists.
+ *
+ *          If the link to be verified is specified with an absolute path, the
+ *          same approach should be used, but starting with the first link in
+ *          the file's root group. For instance, if \c datasetD were in
+ *          \c /group1/group2/softlink_to_group3, the first call to H5Lexists()
+ *          would have name set to \c /group1.
+ *
+ *          Note that this is an outline and does not include all the necessary
+ *          details. Depending on circumstances, for example, you may need to
+ *          verify that an intermediate link points to a group and that a soft
+ *          link points to an existing target.
+ *
+ * \note The behavior of H5Lexists() was changed in the 1.10 release in the
+ *       case where the root group, \c "/", is the name of the link. This
+ *       change is described below:
+ *       <ol>
+ *       <li>Let \c file denote a valid HDF5 file identifier, and let \c lapl
+ *          denote a valid link access property list identifier. A call to
+ *          H5Lexists() with arguments \c file, \c "/", and \c lapl
+ *          returns a positive value; in other words,
+ *          \Code{H5Lexists(file, "/", lapl)} returns a positive value.
+ *          In the HDF5 1.8 release, this function returns 0.</li>
+ *       <li>Let \c root denote a valid HDF5 group identifier that refers to the
+ *          root group of an HDF5 file, and let \c lapl denote a valid link
+ *          access property list identifier. A call to H5Lexists() with
+ *          arguments c root, \c "/", and \c lapl returns a positive value;
+ *          in other words, \Code{H5Lexists(root, "/", lapl)} returns a positive
+ *          value. In the HDF5 1.8 release, this function returns 0.</li>
+ *       </ol>
+ *       Note that the function accepts link names and path names. This is
+ *       potentially misleading to callers, and we plan to separate the
+ *       functionality for link names and path names in a future release.
+ *
+ * \attention H5Lexists() checks the existence of only the final element in a
+ *            relative or absolute path; it does not check any other path
+ *            elements. The function will therefore fail when both of the
+ *            following conditions exist:
+ *            - \c name is not local to the group specified by \c loc_id or,
+ *              if \c loc_id is something other than a group identifier, \c name
+ *              is not local to the root group.
+ *            - Any element of the relative path or absolute path in name,
+ *              except the target link, does not exist.
+ *
+ * \version 1.10.0 Function behavior changed in this release. (See the note.)
+ * \since 1.8.0
+ *
+ */
+H5_DLL htri_t H5Lexists(hid_t loc_id, const char *name, hid_t lapl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Lexists}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Lexists_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                              const char *name, hbool_t *exists, hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL herr_t H5Lexists_async(hid_t loc_id, const char *name, hbool_t *exists, hid_t lapl_id, hid_t es_id);
+#endif
+/**
+ * \ingroup H5L
+ *
+ * \brief Returns information about a link
+ *
+ * \fgdta_loc_id
+ * \param[in] name Link name
+ * \param[out] linfo Buffer in which link information is returned
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Lget_info2() returns information about the specified link through
+ *          the \p linfo argument.
+ *
+ *          The location identifier, \p loc_id, specifies the location of the
+ *          link. A link name, \p name, interpreted relative to \p loc_id,
+ *          specifies the link being queried.
+ *
+ *          \p lapl_id is the link access property list associated with the
+ *          link name. In the general case, when default link access properties
+ *          are acceptable, this can be passed in as #H5P_DEFAULT. An example
+ *          of a situation that requires a non-default link access property
+ *          list is when the link is an external link; an external link may
+ *          require that a link prefix be set in a link access property list
+ *          (see H5Pset_elink_prefix()).
+ *
+ *          H5Lget_info2() returns information about name in the data structure
+ *          H5L_info2_t, which is described below and defined in H5Lpublic.h.
+ *          This structure is returned in the buffer \p linfo.
+ *          \snippet this H5L_info2_t_snip
+ *          In the above struct, \c type specifies the link class. Valid values
+ *          include the following:
+ *          \link_types
+ *          There will be additional valid values if user-defined links have
+ *          been registered.
+ *
+ *          \p corder specifies the link's creation order position, while
+ *          \p corder_valid indicates whether the value in corder is valid.
+ *
+ *          If \p corder_valid is \c true, the value in \p corder is known to
+ *          be valid; if \p corder_valid is \c false, the value in \p corder is
+ *          presumed to be invalid; \p corder starts at zero (0) and is
+ *          incremented by one (1) as new links are created. But
+ *          higher-numbered entries are not adjusted when a lower-numbered link
+ *          is deleted; the deleted link's creation order position is simply
+ *          left vacant. In such situations, the value of \p corder for the
+ *          last link created will be larger than the number of links remaining
+ *          in the group.
+ *
+ *          \p cset specifies the character set in which the link name is
+ *          encoded. Valid values include the following:
+ *          \csets
+ *          This value is set with #H5Pset_char_encoding.
+ *
+ *          \c token is the location that a hard link points to, and
+ *          \c val_size is the size of a soft link or user-defined link value.
+ *          H5O_token_t is used in the VOL layer. It is defined in H5public.h
+ *          as:
+ *          \snippet H5public.h H5O_token_t_snip
+ *
+ *          If the link is a symbolic link, \c val_size will be the length of
+ *          the link value, e.g., the length of the HDF5 path name with a null
+ *          terminator.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Lget_info2(hid_t loc_id, const char *name, H5L_info2_t *linfo, hid_t lapl_id);
+/**
+ * \ingroup H5L
+ *
+ * \brief Retrieves metadata for a link in a group, according to the order
+ *        within a field or index
+ *
+ * \loc_id
+ * \param[in] group_name Group name
+ * \idx_type
+ * \order
+ * \param[in] n Link position for which to retrieve information
+ * \param[out] linfo Buffer in which link information is returned
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5get_info_by_idx2() returns the metadata for a link in a group
+ *          according to a specified field or index and a specified order. The
+ *          link for which information is to be returned is specified by \p
+ *          idx_type, \p order, and \p n as follows:
+ *
+ *          - \p idx_type specifies the field by which the links in \p
+ *            group_name are ordered. The links may be indexed on this field,
+ *            in which case operations seeking specific links are likely to
+ *            complete more quickly.
+ *          - \p order specifies the order in which
+ *            the links are to be referenced for the purposes of this function.
+ *          - \p n specifies the position of the subject link. Note that this
+ *            count is zero-based; 0 (zero) indicates that the function will
+ *            return the value of the first link; if \p n is 5, the function
+ *            will return the value of the sixth link; etc.
+ *
+ *          For example, assume that \p idx_type, \p order, and \p n are
+ *          #H5_INDEX_NAME, #H5_ITER_DEC, and 5, respectively. #H5_INDEX_NAME
+ *          indicates that the links are accessed in lexicographic order by
+ *          their names. #H5_ITER_DEC specifies that the list be traversed in
+ *          reverse order, or in decremented order. And 5 specifies that this
+ *          call to the function will return the metadata for the 6th link
+ *          (\c n + 1) from the end.
+ *
+ *          See H5Literate2() for a list of valid values and further discussion
+ *          regarding \p idx_type and \p order.
+ *
+ *          If \p loc_id specifies the group in which the link resides,
+ *          \p group_name can be a dot (\c .).
+ *
+ * \since 1.12.0
+ *
+ * \see H5Lget_info2()
+ *
+ */
+H5_DLL herr_t H5Lget_info_by_idx2(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                  H5_iter_order_t order, hsize_t n, H5L_info2_t *linfo, hid_t lapl_id);
+/**
+ * \ingroup H5L
+ *
+ * \brief Retrieves name of the \Emph{n}-th link in a group, according to the
+ *        order within a specified field or index
+ *
+ * \loc_id
+ * \param[in] group_name Group name
+ * \idx_type
+ * \order
+ * \param[in] n Link position for which to retrieve information
+ * \param[out] name Buffer in which link name is returned
+ * \param[in] size Size in bytes of \p name
+ * \lapl_id
+ *
+ * \return Returns the size of the link name if successful; otherwise returns a
+ *         negative value.
+ *
+ * \details H5get_name_by_idx() retrieves the name of the \Emph{n}-th link in a
+ *          group, according to the specified order, \p order, within a specified
+ *          field or index, \p idx_type.
+ *
+ *          \p idx_type specifies the index that is used. Valid values include
+ *          the following:
+ *          \indexes
+ *
+ *          \p order specifies the order in which objects are inspected along
+ *          the index specified in \p idx_type. Valid values include the
+ *          following:
+ *          \orders
+ *
+ *          If \p loc_id specifies the group in which the link resides,
+ *          \p group_name can be a dot (\c .).
+ *
+ *          The size in bytes of name is specified in \p size. If \p size is
+ *          unknown, it can be determined via an initial H5Lget_name_by_idx()
+ *          call with name set to NULL; the function's return value will be the
+ *          size of the name.
+ *
+ * \note Please note that in order for the specified index to correspond to the
+ *       creation order index, \p order must be set to #H5_ITER_INC or
+ *       #H5_ITER_DEC when calling H5Lget_name_by_idx(). \note The index \p n
+ *       passed to H5Lget_name_by_idx() is the index of the link within the
+ *       link table, sorted according to \p order and \p idx_type. If order is
+ *       #H5_ITER_NATIVE, then the link table is not sorted, and it does not
+ *       matter what \p idx_type is. Specifying #H5_ITER_NATIVE does not
+ *       guarantee any particular order, only that it remains consistent.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL ssize_t H5Lget_name_by_idx(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                  H5_iter_order_t order, hsize_t n, char *name /*out*/, size_t size,
+                                  hid_t lapl_id);
+/**
+ * \ingroup TRAV
+ *
+ * \brief Iterates over links in a group, with user callback routine,
+ *        according to the order within an index.
+ *
+ * \group_id{grp_id}
+ * \idx_type
+ * \order
+ * \param[in,out] idx Pointer to an iteration index to allow
+ *                    continuing a previous iteration
+ * \op
+ * \op_data
+ * \return \success{The return value of the first operator that returns
+ *                  non-zero, or zero if all members were processed with no
+ *                  operator returning non-zero.}
+ * \return \failure{Negative if an error occurs in the library, or the negative
+ *                  value returned by one of the operators.}
+ *
+ * \details H5Literate2() iterates through the links in a file or
+ *          group, \p group_id, in the order of the specified
+ *          index, \p idx_type, using a user-defined callback routine
+ *          \p op. H5Literate2() does not recursively follow links into
+ *          subgroups of the specified group.
+ *
+ *          Three parameters are used to manage progress of the iteration:
+ *          \p idx_type, \p order, and \p idx_p.
+ *
+ *          \p idx_type specifies the index to be used. If the links have
+ *          not been indexed by the index type, they will first be sorted by
+ *          that index then the iteration will begin; if the links have been
+ *          so indexed, the sorting step will be unnecessary, so the iteration
+ *          may begin more quickly. Valid values include the following:
+ *          \indexes
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index \p idx_type. Valid values include the following:
+ *          \orders
+ *
+ *          \p idx_p tracks the iteration and allows an iteration to be
+ *          resumed if it was stopped before all members were processed. It is
+ *          passed in by the application with a starting point and returned by
+ *          the library with the point at which the iteration stopped.
+ *
+ *          \p op_data is a user-defined pointer to the data required to
+ *          process links in the course of the iteration. This pointer is
+ *          passed back to each step of the iteration in the \p op callback
+ *          function's \p op_data parameter. \p op is invoked for each link
+ *          encounter.
+ *
+ *          \p op_data is passed to and from each iteration and can be used to
+ *          supply or aggregate information across iterations.
+ *
+ * \remark Same pattern of behavior as H5Giterate().
+ *
+ * \note This function is also available through the H5Literate() macro.
+ *
+ * \warning The behavior of H5Literate2() is undefined if the link
+ *          membership of \p group_id changes during the iteration.
+ *          This does not limit the ability to change link destinations
+ *          while iterating, but caution is advised.
+ *
+ *
+ * \since 1.12.0
+ *
+ * \see H5Literate_by_name2(), H5Lvisit2(), H5Lvisit_by_name2()
+ *
+ */
+H5_DLL herr_t H5Literate2(hid_t grp_id, H5_index_t idx_type, H5_iter_order_t order, hsize_t *idx,
+                          H5L_iterate2_t op, void *op_data);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ *
+ * \warning The returned value of the callback routine op will not be set
+ *          in the return value for H5Literate_async(), so the \p herr_t value
+ *          should not be used for determining the return state of the callback routine.
+ *
+ * \async_variant_of{H5Literate}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Literate_async(const char *app_file, const char *app_func, unsigned app_line, hid_t group_id,
+                               H5_index_t idx_type, H5_iter_order_t order, hsize_t *idx_p, H5L_iterate2_t op,
+                               void *op_data, hid_t es_id);
+#else
+H5_DLL herr_t H5Literate_async(hid_t group_id, H5_index_t idx_type, H5_iter_order_t order, hsize_t *idx_p,
+                               H5L_iterate2_t op, void *op_data, hid_t es_id);
+#endif
+/**
+ * \ingroup TRAV
+ *
+ * \brief Iterates through links in a group
+ *
+ * \loc_id
+ * \param[in] group_name Group name
+ * \idx_type
+ * \order
+ * \param[in,out] idx iteration position at which to start (\Emph{IN}) or
+ *                    position at which an interrupted iteration may be restarted
+ *                    (\Emph{OUT})
+ * \op
+ * \op_data
+ * \lapl_id
+ * \return \success{The return value of the first operator that returns
+ *                  non-zero, or zero if all members were processed with no
+ *                  operator returning non-zero.}
+ * \return \failure{Negative if an error occurs in the library, or the negative
+ *                  value returned by one of the operators.}
+ *
+ * \details H5Literate_by_name2() iterates through the links in a group
+ *          specified by \p loc_id and \p group_name, in the order of the
+ *          specified index, \p idx_type, using a user-defined callback routine
+ *          \p op. H5Literate_by_name2() does not recursively follow links into
+ *          subgroups of the specified group.
+ *
+ *          \p idx_type specifies the index to be used. If the links have not
+ *          been indexed by the index type, they will first be sorted by that
+ *          index then the iteration will begin; if the links have been so
+ *          indexed, the sorting step will be unnecessary, so the iteration may
+ *          begin more quickly. Valid values include the following:
+ *          \indexes
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index specified in \p idx_type. Valid values include the
+ *          following:
+ *          \orders
+ *
+ *          \p idx_p allows an interrupted iteration to be resumed; it is
+ *          passed in by the application with a starting point and returned by
+ *          the library with the point at which the iteration stopped.
+ *
+ * \warning H5Literate_by_name2() assumes that the membership of the group being
+ *          iterated over remains unchanged through the iteration; if any of the
+ *          links in the group change during the iteration, the function's
+ *          behavior is undefined. Note, however, that objects pointed to by the
+ *          links can be modified.
+ *
+ * \note H5Literate_by_name2() is not recursive. In particular, if a member of
+ *       \p group_name is found to be a group, call it \c subgroup_a,
+ *       H5Literate_by_name2() does not examine the members of \c subgroup_a.
+ *       When recursive iteration is required, the application must handle the
+ *       recursion, explicitly calling H5Literate_by_name2() on discovered
+ *       subgroups.
+ *
+ * \note H5Literate_by_name2() is the same as H5Literate2(), except that
+ *       H5Literate2() always proceeds in alphanumeric order.
+ *
+ * \since 1.12.0
+ *
+ * \see H5Literate(), H5Lvisit()
+ *
+ */
+H5_DLL herr_t H5Literate_by_name2(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                  H5_iter_order_t order, hsize_t *idx, H5L_iterate2_t op, void *op_data,
+                                  hid_t lapl_id);
+/**
+ * \ingroup TRAV
+ *
+ * \brief Recursively visits all links starting from a specified group
+ *
+ * \group_id{grp_id}
+ * \idx_type
+ * \order
+ * \op
+ * \op_data
+ * \return \success{The return value of the first operator that returns
+ *                  non-zero, or zero if all members were processed with no
+ *                  operator returning non-zero.}
+ * \return \failure{Negative if an error occurs in the library, or the negative
+ *                  value returned by one of the operators.}
+ *
+ * \details H5Lvisit2() is a recursive iteration function to visit all links in
+ *          and below a group in an HDF5 file, thus providing a mechanism for
+ *          an application to perform a common set of operations across all of
+ *          those links or a dynamically selected subset. For non-recursive
+ *          iteration across the members of a group, see H5Literate2().
+ *
+ *          The group serving as the root of the iteration is specified by its
+ *          group or file identifier, \p group_id.
+ *
+ *          Two parameters are used to establish the iteration: \p idx_type and
+ *          \p order.
+ *
+ *          \p idx_type specifies the index to be used. If the links have not
+ *          been indexed by the index type, they will first be sorted by that
+ *          index then the iteration will begin; if the links have been so
+ *          indexed, the sorting step will be unnecessary, so the iteration may
+ *          begin more quickly. Valid values include the following:
+ *          \indexes
+ *
+ *          Note that the index type passed in \p idx_type is a best effort
+ *          setting. If the application passes in a value indicating iteration
+ *          in creation order and a group is encountered that was not tracked
+ *          in creation order, that group will be iterated over in
+ *          lexicographic order by name, or name order. (Name order is the
+ *          native order used by the HDF5 library and is always available.)
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index specified in \p idx_type. Valid values include the
+ *          following:
+ *          \orders
+ *
+ *          \p op is a callback function of type \ref H5L_iterate2_t that is invoked
+ *          for each link encountered.
+ *          \snippet this H5L_iterate2_t_snip
+ *
+ *          The \ref H5L_info2_t struct is defined (in H5Lpublic.h) as follows:
+ *          \snippet this H5L_info2_t_snip
+ *
+ *          The possible return values from the callback function, and the
+ *          effect of each, are as follows:
+ *          \li Zero causes the visit iterator to continue, returning zero when
+ *              all group members have been processed.
+ *          \li  A positive value causes the visit iterator to immediately
+ *               return that positive value, indicating short-circuit success.
+ *          \li A negative value causes the visit iterator to immediately
+ *              return that value, indicating failure.
+ *
+ *          The H5Lvisit2() \p op_data parameter is a user-defined pointer to
+ *          the data required to process links in the course of the iteration.
+ *          This pointer is passed back to each step of the iteration in the
+ *          \p op callback function's \p op_data parameter.
+ *
+ *          H5Lvisit2() and H5Ovisit2() are companion functions: one for
+ *          examining and operating on links; the other for examining and
+ *          operating on the objects that those links point to. Both functions
+ *          ensure that by the time the function completes successfully, every
+ *          link or object below the specified point in the file has been
+ *          presented to the application for whatever processing the
+ *          application requires.
+ *
+ * \since 1.12.0
+ *
+ * \see H5Literate()
+ *
+ */
+H5_DLL herr_t H5Lvisit2(hid_t grp_id, H5_index_t idx_type, H5_iter_order_t order, H5L_iterate2_t op,
+                        void *op_data);
+/**
+ * \ingroup TRAV
+ *
+ * \brief Recursively visits all links starting from a specified group
+ *
+ * \loc_id
+ * \param[in] group_name Group name
+ * \idx_type
+ * \order
+ * \op
+ * \op_data
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Lvisit_by_name2() is a recursive iteration function to visit all
+ *          links in and below a group in an HDF5 file, thus providing a
+ *          mechanism for an application to perform a common set of operations
+ *          across all of those links or a dynamically selected subset. For
+ *          non-recursive iteration across the members of a group, see
+ *          H5Literate2().
+ *
+ *          The group serving as the root of the iteration is specified by the
+ *          \p loc_id / \p group_name parameter pair. \p loc_id specifies a
+ *          file or group; group_name specifies either a group in the file
+ *          (with an absolute name based in the file's root group) or a group
+ *          relative to \p loc_id. If \p loc_id fully specifies the group that
+ *          is to serve as the root of the iteration, group_name should be '.'
+ *          (a dot). (Note that when \p loc_id fully specifies the group
+ *          that is to serve as the root of the iteration, the user may wish to
+ *          consider using H5Lvisit2() instead of H5Lvisit_by_name2().)
+ *
+ *          Two parameters are used to establish the iteration: \p idx_type and
+ *          \p order.
+ *
+ *          \p idx_type specifies the index to be used. If the links have not
+ *          been indexed by the index type, they will first be sorted by that
+ *          index then the iteration will begin; if the links have been so
+ *          indexed, the sorting step will be unnecessary, so the iteration may
+ *          begin more quickly. Valid values include the following:
+ *          \indexes
+ *
+ *          Note that the index type passed in \p idx_type is a best effort
+ *          setting. If the application passes in a value indicating iteration
+ *          in creation order and a group is encountered that was not tracked
+ *          in creation order, that group will be iterated over in
+ *          lexicographic order by name, or name order. (Name order is the
+ *          native order used by the HDF5 library and is always available.)
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index specified in \p idx_type. Valid values include the
+ *          following:
+ *          \orders
+ *
+ *          The \p op callback function, the related \ref H5L_info2_t
+ *          \c struct, and the effect that the callback function's return value
+ *          has on the application are described in H5Lvisit2().
+ *
+ *          The H5Lvisit_by_name2() \p op_data parameter is a user-defined
+ *          pointer to the data required to process links in the course of the
+ *          iteration. This pointer is passed back to each step of the
+ *          iteration in the callback function's \p op_data parameter.
+ *
+ *          \p lapl_id is a link access property list. In the general case,
+ *          when default link access properties are acceptable, this can be
+ *          passed in as #H5P_DEFAULT. An example of a situation that requires
+ *          a non-default link access property list is when the link is an
+ *          external link; an external link may require that a link prefix be
+ *          set in a link access property list (see H5Pset_elink_prefix()).
+ *
+ *          H5Lvisit_by_name2() and H5Ovisit_by_name2() are companion
+ *          functions: one for examining and operating on links; the other for
+ *          examining and operating on the objects that those links point to.
+ *          Both functions ensure that by the time the function completes
+ *          successfully, every link or object below the specified point in the
+ *          file has been presented to the application for whatever processing
+ *          the application requires.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Lvisit_by_name2(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                H5_iter_order_t order, H5L_iterate2_t op, void *op_data, hid_t lapl_id);
+/* UD link functions */
+/**
+ * \ingroup H5L
+ *
+ * \brief Creates a link of a user-defined type
+ *
+ * \loc_id{link_loc_id}
+ * \param[in] link_name Link name
+ * \param[in] link_type User-defined link class
+ * \param[in] udata User-supplied link information
+ * \param[in] udata_size Size of udata buffer
+ * \lcpl_id
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Lcreate_ud() creates a link of user-defined type \p link_type
+ *          named \p link_name at the location specified in \p link_loc_id with
+ *          user-specified data \p udata.
+ *
+ *          \p link_name is interpreted relative to \p link_loc_id. If
+ *          \p link_name begins with \c /, then it will be interpreted as
+ *          an absolute path in the file. The name of the created link
+ *          will be the last element of the provided path. Prior elements
+ *          in the path are used to locate the parent group of the new link.
+ *
+ *          Valid values for the link class of the new link, \p link_type,
+ *          include #H5L_TYPE_EXTERNAL and any user-defined link classes that
+ *          have been registered with the library. See H5Lregister() for
+ *          further information.
+ *
+ *          The format of the information pointed to by \p udata is defined by
+ *          the user. \p udata_size specifies the size of the \p udata buffer.
+ *          \p udata may be NULL if \p udata_size is zero (0).
+ *
+ *          The property lists specified by \p lcpl_id and \p lapl_id specify
+ *          properties used to create and access the link.
+ *
+ * \note The external link type, #H5L_TYPE_EXTERNAL, included in the HDF5
+ *       library distribution, is implemented as a user-defined link type. This
+ *       was done, in part, to provide a model for the implementation of other
+ *       user-defined links.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Lcreate_ud(hid_t link_loc_id, const char *link_name, H5L_type_t link_type, const void *udata,
+                           size_t udata_size, hid_t lcpl_id, hid_t lapl_id);
+/**
+ * \ingroup H5LA
+ *
+ * \brief Determines whether a class of user-defined links is registered
+ *
+ * \param[in] id User-defined link class identifier
+ *
+ * \return \htri_t
+ *
+ * \details H5Lis_registered() tests whether a user-defined link class is
+ *          currently registered, either by the HDF5 library or by the user
+ *          through the use of H5Lregister().
+ *
+ * \note A link class must be registered to create new links of that type or to
+ *       traverse existing links of that type.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL htri_t H5Lis_registered(H5L_type_t id);
+
+/* External link functions */
+/**
+ * \ingroup H5L
+ *
+ * \brief Decodes external link information
+ *
+ * \param[in] ext_linkval Buffer containing external link information
+ * \param[in] link_size Size, in bytes, of the \p ext_linkval buffer
+ * \param[out] flags External link flags, packed as a bitmap (\Emph{Reserved as
+ *                   a bitmap for flags; no flags are currently defined, so the
+ *                   only valid value * is 0.})
+ * \param[out] filename Returned filename \param[out] obj_path Returned
+ * object path, relative to \p filename
+ *
+ * \return \herr_t
+ *
+ * \details H5Lunpack_elink_val() decodes the external link information
+ *          returned by H5Lget_val() in the \p ext_linkval buffer.
+ *
+ *          \p ext_linkval should be the buffer set by H5Lget_val() and will
+ *          consist of two NULL-terminated strings, the filename and object
+ *          path, one after the other.
+ *
+ *          Given this buffer, H5Lunpack_elink_val() creates pointers to the
+ *          filename and object path within the buffer and returns them in
+ *          \p filename and \p obj_path, unless they are passed in as NULL.
+ *
+ *          H5Lunpack_elink_val() requires that \p ext_linkval contain a
+ *          concatenated pair of null-terminated strings, so use of this
+ *          function on a string that is not an external link \p udata buffer
+ *          may result in a segmentation fault. This failure can be avoided by
+ *          adhering to the following procedure:
+ *          <ol>
+ *            <li>Call H5Lget_info() to get the link type and the size of the
+ *                link value.<li>
+ *            <li>Verify that the link is an external link, i.e., that its link
+ *                type is #H5L_TYPE_EXTERNAL.</li>
+ *            <li>Call H5Lget_val() to get the link value.</li>
+ *            <li>Call H5Lunpack_elink_val() to unpack that value.</li>
+ *          </ol>
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Lunpack_elink_val(const void *ext_linkval /*in*/, size_t link_size, unsigned *flags,
+                                  const char **filename /*out*/, const char **obj_path /*out*/);
+/**
+ * \ingroup H5L
+ *
+ * \brief Creates an external link, a soft link to an object in a different file.
+ *
+ * \param[in] file_name   Name of the target file containing the target object.
+ * \param[in] obj_name    Path within the target file to the target object
+ * \fgdt_loc_id{link_loc_id}
+ * \param[in] link_name   Name of the new link, relative to \p link_loc_id
+ * \lcpl_id
+ * \lapl_id
+ * \return \herr_t
+ *
+ * \details H5Lcreate_external() creates a new external link. An external link
+ *          is a soft link to an object in a different HDF5 file from the
+ *          location of the link, i.e., to an external object.
+ *
+ *          \p file_name identifies the target file containing the target
+ *          object; \p obj_name specifies the path of the target object within
+ *          that file. \p obj_name must be an absolute pathname in
+ *          \p file_name, i.e., it must start at the target file's root group,
+ *          but it is not interpreted until an application attempts to traverse
+ *          it.
+ *
+ *          \p link_loc_id and \p link_name specify the location and name,
+ *          respectively, of the new link. \p link_name is interpreted relative
+ *          to \p link_loc_id. If \p link_name begins with \c /, then it is
+ *          interpreted as an absolute path in the file. The name of the created
+ *          link will be the last element of the provided path. Prior elements in
+ *          the path are used to locate the parent group of the new link.
+ *
+ *          \p lcpl_id is the link creation property list used in creating the
+ *          new link.
+ *
+ *          \p lapl_id is the link access property list used in traversing the
+ *          new link. Note that an external file opened by the traversal of an
+ *          external link is always opened with the weak file close degree
+ *          property setting, #H5F_CLOSE_WEAK (see H5Pset_fclose_degree());
+ *          any file close degree property setting in \p lapl_id is ignored.
+ *
+ *          An external link behaves similarly to a soft link, and like a soft
+ *          link in an HDF5 file, it may dangle: the target file and object
+ *          need not exist at the time that the external link is created.
+ *
+ *          When the external link \p link_name is accessed, the library will
+ *          search for the target file \p file_name as described below:
+ *
+ *          - If \p file_name is a relative pathname, the following steps are
+ *            performed:
+ *            - The library will get the prefix(es) set in the environment
+ *              variable \c HDF5_EXT_PREFIX and will try to prepend each prefix
+ *              to \p file_name to form a new \p file_name.
+ *            - If the new \p file_name does not exist or if \c HDF5_EXT_PREFIX
+ *              is not set, the library will get the prefix set via
+ *              H5Pset_elink_prefix() and prepend it to \p file_name to form a
+ *              new \p file_name.
+ *            - If the new \p file_name does not exist or no prefix is being
+ *              set by H5Pset_elink_prefix(), then the path of the file
+ *              associated with \p link_loc_id is obtained. This path can be
+ *              the absolute path or the current working directory plus the
+ *              relative path of that file when it is created/opened. The
+ *              library will prepend this path to \p file_name to form a new
+ *              \p file_name.
+ *            - If the new \p file_name does not exist, then the library will
+ *              look for \p file_name and will return failure/success
+ *              accordingly.
+ *          - If \p file_name is an absolute pathname, the library will first
+ *            try to find \p file_name. If \p file_name does not exist,
+ *            \p file_name is stripped of directory paths to form a new
+ *            \p file_name. The search for the new \p file_name then follows
+ *            the same steps as described above for a relative pathname. See
+ *            examples below illustrating how target_file_name is stripped to
+ *            form a new \p file_name.
+ *
+ *          Note that \p file_name is considered to be an absolute pathname
+ *          when the following condition is true:
+ *
+ *          - For Unix, the first character of \p file_name is a slash (\c /).
+ *            For example, consider a \p file_name of \c /tmp/A.h5.
+ *            If that target file does not exist, the new \p file_name after
+ *            stripping will be \c A.h5.
+ *          - For Windows, there are 6 cases:
+ *            -# \p file_name is an absolute drive with an absolute pathname.
+ *               For example, consider a \p file_name of \c /tmp/A.h5. If that
+ *               target file does not exist, the new \p file_name after
+ *               stripping will be \c A.h5.
+ *            -# \p file_name is an absolute pathname without specifying drive
+ *               name. For example, consider a \p file_name of \c /tmp/A.h5.
+ *               If that target file does not exist, the new \p file_name after
+ *               stripping will be \c A.h5.
+ *            -# \p file_name is an absolute drive with a relative pathname.
+ *               For example, consider a \p file_name of \c /tmp/A.h5. If that
+ *               target file does not exist, the new \p file_name after
+ *               stripping will be \c tmp\A.h5.
+ *            -# \p file_name is in UNC (Uniform Naming Convention) format with
+ *               a server name, share name, and pathname. For example, consider
+ *               a \p file_name of \c /tmp/A.h5. If that target file does not
+ *               exist, the new \p file_name after stripping will be \c A.h5.
+ *            -# \p file_name is in Long UNC (Uniform Naming Convention) format
+ *               with a server name, share name, and pathname. For example,
+ *               consider a \p file_name of \c /tmp/A.h5. If that target file
+ *               does not exist, the new \p file_name after stripping will be
+ *               \c A.h5.
+ *            -# \p file_name is in Long UNC (Uniform Naming Convention) format
+ *               with an absolute drive and an absolute pathname. For example,
+ *               consider a \p file_name of \c /tmp/A.h5. If that target file
+ *               does not exist, the new \p file_name after stripping will be
+ *               \c A.h5.
+ *
+ *          The library opens the target file \p file_name with the file access
+ *          property list that is set via H5Pset_elink_fapl() when the external
+ *          link link_name is accessed. If no such property list is set, the
+ *          library uses the file access property list associated with the file
+ *          of \p link_loc_id to open the target file.
+ *
+ *          If an application requires additional control over file access
+ *          flags or the file access property list, see H5Pset_elink_cb(); this
+ *          function enables the use of an external link callback function as
+ *          described in H5L_elink_traverse_t().
+ *
+ * \attention A file close degree property setting (H5Pset_fclose_degree()) in
+ *            the external link file access property list or in the external
+ *            link callback function will be ignored. A file opened by means of
+ *            traversing an external link is always opened with the weak file
+ *            close degree property setting, #H5F_CLOSE_WEAK .
+ *
+ * \see H5Lcreate_hard(), H5Lcreate_soft(), H5Lcreate_ud()
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Lcreate_external(const char *file_name, const char *obj_name, hid_t link_loc_id,
+                                 const char *link_name, hid_t lcpl_id, hid_t lapl_id);
+
+/// \cond DEV
+/* API Wrappers for async routines */
+/* (Must be defined _after_ the function prototype) */
+/* (And must only defined when included in application code, not the library) */
+#ifndef H5L_MODULE
+#define H5Lcreate_hard_async(...)   H5Lcreate_hard_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Lcreate_soft_async(...)   H5Lcreate_soft_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Ldelete_async(...)        H5Ldelete_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Ldelete_by_idx_async(...) H5Ldelete_by_idx_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Lexists_async(...)        H5Lexists_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Literate_async(...)       H5Literate_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+
+/* Define "wrapper" versions of function calls, to allow compile-time values to
+ *      be passed in by language wrapper or library layer on top of HDF5.
+ */
+#define H5Lcreate_hard_async_wrap   H5_NO_EXPAND(H5Lcreate_hard_async)
+#define H5Lcreate_soft_async_wrap   H5_NO_EXPAND(H5Lcreate_soft_async)
+#define H5Ldelete_async_wrap        H5_NO_EXPAND(H5Ldelete_async)
+#define H5Ldelete_by_idx_async_wrap H5_NO_EXPAND(H5Ldelete_by_idx_async)
+#define H5Lexists_async_wrap        H5_NO_EXPAND(H5Lexists_async)
+#define H5Literate_async_wrap       H5_NO_EXPAND(H5Literate_async)
+#endif /* H5L_MODULE */
+/// \endcond
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+
+/* Typedefs */
+
+//! <!-- [H5L_info1_t_snip] -->
+/**
+ * Information struct for link (for H5Lget_info1() and H5Lget_info_by_idx1())
+ */
+typedef struct {
+    H5L_type_t type;         /**< Type of link                   */
+    hbool_t    corder_valid; /**< Indicate if creation order is valid */
+    int64_t    corder;       /**< Creation order                 */
+    H5T_cset_t cset;         /**< Character set of link name     */
+    union {
+        haddr_t address;  /**< Address hard link points to    */
+        size_t  val_size; /**< Size of a soft link or UD link value */
+    } u;
+} H5L_info1_t;
+//! <!-- [H5L_info1_t_snip] -->
+
+/** Prototype for H5Literate1() / H5Literate_by_name1() operator */
+//! <!-- [H5L_iterate1_t_snip] -->
+typedef herr_t (*H5L_iterate1_t)(hid_t group, const char *name, const H5L_info1_t *info, void *op_data);
+//! <!-- [H5L_iterate1_t_snip] -->
+
+/* Function prototypes */
+/**
+ * \ingroup H5L
+ *
+ * \brief Returns information about a link
+ *
+ * \fgdta_loc_id
+ * \param[in] name Link name
+ * \param[out] linfo Buffer in which link information is returned
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Lget_info2() or the macro H5Lget_info().
+ *
+ * \details H5Lget_info1() returns information about the specified link through
+ *          the \p linfo argument.
+ *
+ *          The location identifier, \p loc_id, specifies the location of the
+ *          link. A link name, \p name, interpreted relative to \p loc_id,
+ *          specifies the link being queried.
+ *
+ *          \p lapl_id is the link access property list associated with the
+ *          link \p name. In the general case, when default link access
+ *          properties are acceptable, this can be passed in as #H5P_DEFAULT.
+ *          An example of a situation that requires a non-default link access
+ *          property list is when the link is an external link; an external
+ *          link may require that a link prefix be set in a link access
+ *          property list (see H5Pset_elink_prefix()).
+ *
+ *          H5Lget_info1() returns information about name in the data structure
+ *          \ref H5L_info1_t, which is described below and defined in
+ *          H5Lpublic.h. This structure is returned in the buffer \p linfo.
+ *          \snippet this H5L_info1_t_snip
+ *          In the above struct, type specifies the link class. Valid values
+ *          include the following:
+ *          \link_types
+ *          There will be additional valid values if user-defined links have
+ *          been registered.
+ *
+ *          \c corder specifies the link's creation order position while
+ *          \c corder_valid indicates whether the value in \c corder is valid.
+ *
+ *          If \c corder_valid is \c true, the value in \c corder is known to
+ *          be valid; if \c corder_valid is \c false, the value in \c corder is
+ *          presumed to be invalid;
+ *
+ *          \c corder starts at zero (0) and is incremented by one (1) as new
+ *          links are created. But higher-numbered entries are not adjusted
+ *          when a lower-numbered link is deleted; the deleted link's creation
+ *          order position is simply left vacant. In such situations, the value
+ *          of \c corder for the last link created will be larger than the
+ *          number of links remaining in the group.
+ *
+ *          \c cset specifies the character set in which the link name is
+ *          encoded. Valid values include the following:
+ *          \csets
+ *          This value is set with #H5Pset_char_encoding.
+ *
+ *          \c address and \c val_size are returned for hard and symbolic
+ *          links, respectively. Symbolic links include soft and external links
+ *          and some user-defined links.
+ *
+ *          If the link is a hard link, \c address specifies the file address
+ *          that the link points to.
+ *
+ *          If the link is a symbolic link, \c val_size will be the length of
+ *          the link value, e.g., the length of the HDF5 path name with a null
+ *          terminator.
+ *
+ * \version 1.12.0 Function was deprecated.
+ * \version 1.8.2 Fortran subroutine added in this release.
+ * \version 1.8.4 Fortran subroutine syntax changed in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Lget_info1(hid_t loc_id, const char *name, H5L_info1_t *linfo /*out*/, hid_t lapl_id);
+/**
+ * \ingroup H5L
+ *
+ * \brief Retrieves metadata for a link in a group, according to the order
+ *        within a field or index
+ *
+ * \loc_id
+ * \param[in] group_name Group name
+ * \idx_type
+ * \order
+ * \param[in] n Link position for which to retrieve information
+ * \param[out] linfo Buffer in which link information is returned
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Lget_info_by_idx2() and the macro
+ *             H5Lget_info_by_idx().
+ *
+ * \details H5get_info_by_idx1() returns the metadata for a link in a group
+ *          according to a specified field or index and a specified order.
+ *
+ *          The link for which information is to be returned is specified by \p
+ *          idx_type, \p order, and \p n as follows:
+ *
+ *          - \p idx_type specifies the field by which the links in \p
+ *            group_name are ordered. The links may be indexed on this field,
+ *            in which case operations seeking specific links are likely to
+ *            complete more quickly.
+ *          - \p order specifies the order in which
+ *            the links are to be referenced for the purposes of this function.
+ *          - \p n specifies the position of the subject link. Note that this
+ *            count is zero-based; 0 (zero) indicates that the function will
+ *            return the value of the first link; if \p n is 5, the function
+ *            will return the value of the sixth link; etc.
+ *
+ *          For example, assume that \p idx_type, \p order, and \p n are
+ *          #H5_INDEX_NAME, #H5_ITER_DEC, and 5, respectively. #H5_INDEX_NAME
+ *          indicates that the links are accessed in lexicographic order by
+ *          their names. #H5_ITER_DEC specifies that the list be traversed in
+ *          reverse order, or in decremented order. And 5 specifies that this
+ *          call to the function will return the metadata for the 6th link
+ *          (\c n + 1) from the end.
+ *
+ *          See H5Literate1() for a list of valid values and further discussion
+ *          regarding \p idx_type and \p order.
+ *
+ *          If \p loc_id specifies the group in which the link resides,
+ *          \p group_name can be a dot (\c .).
+ *
+ * \version 1.12.0 Function was renamed to H5Lget_index_by_idx1() and deprecated.
+ * \version 1.8.4 Fortran subroutine syntax changed in this release.
+ * \version 1.8.2 Fortran subroutine added in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Lget_info_by_idx1(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                  H5_iter_order_t order, hsize_t n, H5L_info1_t *linfo /*out*/,
+                                  hid_t lapl_id);
+/**
+ * \ingroup TRAV
+ *
+ * \brief Iterates over links in a group, with user callback routine,
+ *        according to the order within an index.
+ *
+ * \group_id{grp_id}
+ * \idx_type
+ * \order
+ * \param[in,out] idx Pointer to an iteration index to allow
+ *                    continuing a previous iteration
+ * \op
+ * \op_data
+ * \return \success{The return value of the first operator that returns
+ *                  non-zero, or zero if all members were processed with no
+ *                  operator returning non-zero.}
+ * \return \failure{Negative if an error occurs in the library, or the negative
+ *                  value returned by one of the operators.}
+ *
+ * \deprecated Deprecated in favor of H5Literate2().
+ *
+ * \details H5Literate1() iterates through the links in a file or
+ *          group, \p group_id, in the order of the specified
+ *          index, \p idx_type, using a user-defined callback routine
+ *          \p op. H5Literate1() does not recursively follow links into
+ *          subgroups of the specified group.
+ *
+ *          Three parameters are used to manage progress of the iteration:
+ *          \p idx_type, \p order, and \p idx_p.
+ *
+ *          \p idx_type specifies the index to be used. If the links have
+ *          not been indexed by the index type, they will first be sorted by
+ *          that index then the iteration will begin; if the links have been
+ *          so indexed, the sorting step will be unnecessary, so the iteration
+ *          may begin more quickly. Valid values include the following:
+ *          \indexes
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index \p idx_type. Valid values include the following:
+ *          \orders
+ *
+ *          \p idx_p tracks the iteration and allows an iteration to be
+ *          resumed if it was stopped before all members were processed. It is
+ *          passed in by the application with a starting point and returned by
+ *          the library with the point at which the iteration stopped.
+ *
+ *          \p op_data is a user-defined pointer to the data required to
+ *          process links in the course of the iteration. This pointer is
+ *          passed back to each step of the iteration in the \p op callback
+ *          function's \p op_data parameter. \p op is invoked for each link
+ *          encounter.
+ *
+ *          \p op_data is passed to and from each iteration and can be used to
+ *          supply or aggregate information across iterations.
+ *
+ * \remark Same pattern of behavior as H5Giterate().
+ *
+ * \note This function is also available through the H5Literate() macro.
+ *
+ * \warning The behavior of H5Literate1() is undefined if the link
+ *          membership of \p group_id changes during the iteration.
+ *          This does not limit the ability to change link destinations
+ *          while iterating, but caution is advised.
+ *
+ * \version 1.12.0 Function was deprecated in this release.
+ * \since 1.8.0
+ *
+ * \see H5Literate_by_name2(), H5Lvisit2(), H5Lvisit_by_name2()
+ *
+ */
+H5_DLL herr_t H5Literate1(hid_t grp_id, H5_index_t idx_type, H5_iter_order_t order, hsize_t *idx,
+                          H5L_iterate1_t op, void *op_data);
+/**
+ * \ingroup TRAV
+ *
+ * \brief Iterates through links in a group by its name
+ *
+ * \loc_id
+ * \param[in] group_name Group name
+ * \idx_type
+ * \order
+ * \param[in,out] idx iteration position at which to start (\Emph{IN}) or
+ *                position at which an interrupted iteration may be restarted
+ *                (\Emph{OUT})
+ * \op
+ * \op_data
+ * \lapl_id
+ *
+ * \return \success{The return value of the first operator that returns
+ *                  non-zero, or zero if all members were processed with no
+ *                  operator returning non-zero.}
+ * \return \failure{Negative if an error occurs in the library, or the negative
+ *                  value returned by one of the operators.}
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Literate_by_name2() or the macro
+ *             H5Literate_by_name().
+ *
+ * \details H5Literate_by_name1() iterates through the links in a group
+ *          specified by \p loc_id and \p group_name, in the order of the
+ *          specified index, \p idx_type, using a user-defined callback routine
+ *          \p op. H5Literate_by_name1() does not recursively follow links into
+ *          subgroups of the specified group.
+ *
+ *          \p idx_type specifies the index to be used. If the links have not
+ *          been indexed by the index type, they will first be sorted by that
+ *          index then the iteration will begin; if the links have been so
+ *          indexed, the sorting step will be unnecessary, so the iteration may
+ *          begin more quickly. Valid values include the following:
+ *          \indexes
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index specified in \p idx_type. Valid values include the
+ *          following:
+ *          \orders
+ *
+ *          \p idx allows an interrupted iteration to be resumed; it is
+ *          passed in by the application with a starting point and returned by
+ *          the library with the point at which the iteration stopped.
+ *
+ * \warning H5Literate_by_name1() assumes that the membership of the group being
+ *          iterated over remains unchanged through the iteration; if any of the
+ *          links in the group change during the iteration, the function's
+ *          behavior is undefined. Note, however, that objects pointed to by the
+ *          links can be modified.
+ *
+ * \note H5Literate_by_name1() is not recursive. In particular, if a member of
+ *       \p group_name is found to be a group, call it \c subgroup_a,
+ *       H5Literate_by_name1() does not examine the members of \c subgroup_a.
+ *       When recursive iteration is required, the application must handle the
+ *       recursion, explicitly calling H5Literate_by_name1() on discovered
+ *       subgroups.
+ *
+ * \note H5Literate_by_name1() is the same as H5Giterate(), except that
+ *       H5Giterate() always proceeds in lexicographic order.
+ *
+ * \version 1.12.0 Function H5Literate_by_name() was renamed to
+ *                 H5Literate_by_name1() and deprecated.
+ * \version 1.8.8 Fortran subroutine added.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Literate_by_name1(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                  H5_iter_order_t order, hsize_t *idx, H5L_iterate1_t op, void *op_data,
+                                  hid_t lapl_id);
+/**
+ * \ingroup TRAV
+ *
+ * \brief Recursively visits all links starting from a specified group
+ *
+ * \group_id{grp_id}
+ * \idx_type
+ * \order
+ * \op
+ * \op_data
+ *
+ * \return \success{The return value of the first operator that returns
+ *                  non-zero, or zero if all members were processed with no
+ *                  operator returning non-zero.}
+ * \return \failure{Negative if an error occurs in the library, or the negative
+ *                  value returned by one of the operators.}
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Lvisit2() or the macro H5Lvisit().
+ *
+ * \details H5Lvisit1() is a recursive iteration function to visit all links in
+ *          and below a group in an HDF5 file, thus providing a mechanism for
+ *          an application to perform a common set of operations across all of
+ *          those links or a dynamically selected subset. For non-recursive
+ *          iteration across the members of a group, see H5Literate1().
+ *
+ *          The group serving as the root of the iteration is specified by its
+ *          group or file identifier, \p group_id.
+ *
+ *          Two parameters are used to establish the iteration: \p idx_type and
+ *          \p order.
+ *
+ *          \p idx_type specifies the index to be used. If the links have not
+ *          been indexed by the index type, they will first be sorted by that
+ *          index then the iteration will begin; if the links have been so
+ *          indexed, the sorting step will be unnecessary, so the iteration may
+ *          begin more quickly. Valid values include the following:
+ *          \indexes
+ *
+ *          Note that the index type passed in \p idx_type is a best effort
+ *          setting. If the application passes in a value indicating iteration
+ *          in creation order and a group is encountered that was not tracked
+ *          in creation order, that group will be iterated over in
+ *          lexicographic order by name, or name order. (Name order is the
+ *          native order used by the HDF5 library and is always available.)
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index specified in \p idx_type. Valid values include the
+ *          following:
+ *          \orders
+ *
+ *          \p op is a callback function of type \ref H5L_iterate1_t that is invoked
+ *          for each link encountered.
+ *          \snippet this H5L_iterate1_t_snip
+ *
+ *          The \ref H5L_info1_t struct is defined (in H5Lpublic.h) as follows:
+ *          \snippet this H5L_info1_t_snip
+ *
+ *          The possible return values from the callback function, and the
+ *          effect of each, are as follows:
+ *          \li Zero causes the visit iterator to continue, returning zero when
+ *              all group members have been processed.
+ *          \li  A positive value causes the visit iterator to immediately
+ *               return that positive value, indicating short-circuit success.
+ *          \li A negative value causes the visit iterator to immediately
+ *              return that value, indicating failure.
+ *
+ *          The H5Lvisit1() \p op_data parameter is a user-defined pointer to
+ *          the data required to process links in the course of the iteration.
+ *          This pointer is passed back to each step of the iteration in the
+ *          \p op callback function's \p op_data parameter.
+ *
+ *          H5Lvisit1() and H5Ovisit1() are companion functions: one for
+ *          examining and operating on links; the other for examining and
+ *          operating on the objects that those links point to. Both functions
+ *          ensure that by the time the function completes successfully, every
+ *          link or object below the specified point in the file has been
+ *          presented to the application for whatever processing the
+ *          application requires.
+ *
+ * \version 1.12.0 Function was renamed from H5Lvisit() to H5Lvisit1() and
+ *                 deprecated.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Lvisit1(hid_t grp_id, H5_index_t idx_type, H5_iter_order_t order, H5L_iterate1_t op,
+                        void *op_data);
+/**
+ * \ingroup TRAV
+ *
+ * \brief Recursively visits all links starting from a specified group
+ *
+ * \loc_id
+ * \param[in] group_name Group name
+ * \idx_type
+ * \order
+ * \op
+ * \op_data
+ * \lapl_id
+ *
+ * \return \success{The return value of the first operator that returns
+ *                  non-zero, or zero if all members were processed with no
+ *                  operator returning non-zero.}
+ * \return \failure{Negative if an error occurs in the library, or the negative
+ *                  value returned by one of the operators.}
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Lvisit_by_name2() or the macro H5Lvisit_by_name().
+ *
+ * \details H5Lvisit_by_name1() is a recursive iteration function to visit all
+ *          links in and below a group in an HDF5 file, thus providing a
+ *          mechanism for an application to perform a common set of operations
+ *          across all of those links or a dynamically selected subset. For
+ *          non-recursive iteration across the members of a group, see
+ *          H5Literate1().
+ *
+ *          The group serving as the root of the iteration is specified by the
+ *          \p loc_id / \p group_name parameter pair. \p loc_id specifies a
+ *          file or group; group_name specifies either a group in the file
+ *          (with an absolute name based in the file's root group) or a group
+ *          relative to \p loc_id. If \p loc_id fully specifies the group that
+ *          is to serve as the root of the iteration, group_name should be '.'
+ *          (a dot). (Note that when \p loc_id fully specifies the group
+ *          that is to serve as the root of the iteration, the user may wish to
+ *          consider using H5Lvisit1() instead of H5Lvisit_by_name1().)
+ *
+ *          Two parameters are used to establish the iteration: \p idx_type and
+ *          \p order.
+ *
+ *          \p idx_type specifies the index to be used. If the links have not
+ *          been indexed by the index type, they will first be sorted by that
+ *          index then the iteration will begin; if the links have been so
+ *          indexed, the sorting step will be unnecessary, so the iteration may
+ *          begin more quickly. Valid values include the following:
+ *          \indexes
+ *
+ *          Note that the index type passed in \p idx_type is a best effort
+ *          setting. If the application passes in a value indicating iteration
+ *          in creation order and a group is encountered that was not tracked
+ *          in creation order, that group will be iterated over in
+ *          lexicographic order by name, or name order. (Name order is the
+ *          native order used by the HDF5 library and is always available.)
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index specified in \p idx_type. Valid values include the
+ *          following:
+ *          \orders
+ *
+ *          The \p op callback function, the related \ref H5L_info1_t
+ *          \c struct, and the effect that the callback function's return value
+ *          has on the application are described in H5Lvisit1().
+ *
+ *          The H5Lvisit_by_name1() \p op_data parameter is a user-defined
+ *          pointer to the data required to process links in the course of the
+ *          iteration. This pointer is passed back to each step of the
+ *          iteration in the callback function's \p op_data parameter.
+ *
+ *          \p lapl_id is a link access property list. In the general case,
+ *          when default link access properties are acceptable, this can be
+ *          passed in as #H5P_DEFAULT. An example of a situation that requires
+ *          a non-default link access property list is when the link is an
+ *          external link; an external link may require that a link prefix be
+ *          set in a link access property list (see H5Pset_elink_prefix()).
+ *
+ *          H5Lvisit_by_name1() and H5Ovisit_by_name1() are companion
+ *          functions: one for examining and operating on links; the other for
+ *          examining and operating on the objects that those links point to.
+ *          Both functions ensure that by the time the function completes
+ *          successfully, every link or object below the specified point in the
+ *          file has been presented to the application for whatever processing
+ *          the application requires.
+ *
+ * \version 1.12.0 Function renamed from H5Lvisit_by_name() to
+ *                 H5Lvisit_by_name1() and deprecated.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Lvisit_by_name1(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                H5_iter_order_t order, H5L_iterate1_t op, void *op_data, hid_t lapl_id);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* H5Lpublic_H */
diff --git a/install/include/H5MMpublic.h b/install/include/H5MMpublic.h
new file mode 100644
index 0000000000..62172c9ea0
--- /dev/null
+++ b/install/include/H5MMpublic.h
@@ -0,0 +1,36 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5MMpublic.h
+ *
+ * Purpose:             Public declarations for the H5MM (memory management)
+ *                      package.
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef H5MMpublic_H
+#define H5MMpublic_H
+
+#include "H5public.h" /* Generic Functions                        */
+
+/* These typedefs are currently used for VL datatype allocation/freeing */
+//! <!-- [H5MM_allocate_t_snip] -->
+typedef void *(*H5MM_allocate_t)(size_t size, void *alloc_info);
+//! <!-- [H5MM_allocate_t_snip] -->
+
+//! <!-- [H5MM_free_t_snip] -->
+typedef void (*H5MM_free_t)(void *mem, void *free_info);
+//! <!-- [H5MM_free_t_snip] -->
+
+#endif /* H5MMpublic_H */
diff --git a/install/include/H5Mpublic.h b/install/include/H5Mpublic.h
new file mode 100644
index 0000000000..48625a5538
--- /dev/null
+++ b/install/include/H5Mpublic.h
@@ -0,0 +1,656 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5M module.
+ *
+ * NOTE:    This is an experimental API. Everything in the H5M package
+ *          is subject to revision in a future release.
+ */
+#ifndef H5Mpublic_H
+#define H5Mpublic_H
+
+#include "H5public.h"   /* Generic Functions                        */
+#include "H5Ipublic.h"  /* Identifiers                              */
+#include "H5VLpublic.h" /* Virtual Object Layer                     */
+
+/* Exposes VOL connector types, so it needs the connector header */
+#include "H5VLconnector.h"
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* Macros defining operation IDs for map VOL callbacks (implemented using the
+ * "optional" VOL callback) */
+#define H5VL_MAP_CREATE   1
+#define H5VL_MAP_OPEN     2
+#define H5VL_MAP_GET_VAL  3
+#define H5VL_MAP_EXISTS   4
+#define H5VL_MAP_PUT      5
+#define H5VL_MAP_GET      6
+#define H5VL_MAP_SPECIFIC 7
+#define H5VL_MAP_OPTIONAL 8
+#define H5VL_MAP_CLOSE    9
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/* types for map GET callback */
+typedef enum H5VL_map_get_t {
+    H5VL_MAP_GET_MAPL,     /* map access property list */
+    H5VL_MAP_GET_MCPL,     /* map creation property list */
+    H5VL_MAP_GET_KEY_TYPE, /* key type                 */
+    H5VL_MAP_GET_VAL_TYPE, /* value type               */
+    H5VL_MAP_GET_COUNT     /* key count                */
+} H5VL_map_get_t;
+
+/* types for map SPECIFIC callback */
+typedef enum H5VL_map_specific_t {
+    H5VL_MAP_ITER,  /* H5Miterate               */
+    H5VL_MAP_DELETE /* H5Mdelete                */
+} H5VL_map_specific_t;
+
+//! <!-- [H5M_iterate_t_snip] -->
+/**
+ * Callback for H5Miterate()
+ */
+typedef herr_t (*H5M_iterate_t)(hid_t map_id, const void *key, void *op_data);
+//! <!-- [H5M_iterate_t_snip] -->
+
+/* Parameters for map operations */
+typedef union H5VL_map_args_t {
+    /* H5VL_MAP_CREATE */
+    struct {
+        H5VL_loc_params_t loc_params;  /* Location parameters for object */
+        const char       *name;        /* Name of new map object */
+        hid_t             lcpl_id;     /* Link creation property list for map */
+        hid_t             key_type_id; /* Datatype for map keys */
+        hid_t             val_type_id; /* Datatype for map values */
+        hid_t             mcpl_id;     /* Map creation property list */
+        hid_t             mapl_id;     /* Map access property list */
+        void             *map;         /* Pointer to newly created map object (OUT) */
+    } create;
+
+    /* H5VL_MAP_OPEN */
+    struct {
+        H5VL_loc_params_t loc_params; /* Location parameters for object */
+        const char       *name;       /* Name of new map object */
+        hid_t             mapl_id;    /* Map access property list */
+        void             *map;        /* Pointer to newly created map object (OUT) */
+    } open;
+
+    /* H5VL_MAP_GET_VAL */
+    struct {
+        hid_t       key_mem_type_id;   /* Memory datatype for key */
+        const void *key;               /* Pointer to key */
+        hid_t       value_mem_type_id; /* Memory datatype for value */
+        void       *value;             /* Buffer for value (OUT) */
+    } get_val;
+
+    /* H5VL_MAP_EXISTS */
+    struct {
+        hid_t       key_mem_type_id; /* Memory datatype for key */
+        const void *key;             /* Pointer to key */
+        hbool_t     exists;          /* Flag indicating whether key exists in map (OUT) */
+    } exists;
+
+    /* H5VL_MAP_PUT */
+    struct {
+        hid_t       key_mem_type_id;   /* Memory datatype for key */
+        const void *key;               /* Pointer to key */
+        hid_t       value_mem_type_id; /* Memory datatype for value */
+        const void *value;             /* Pointer to value */
+    } put;
+
+    /* H5VL_MAP_GET */
+    struct {
+        H5VL_map_get_t get_type; /* 'get' operation to perform */
+
+        /* Parameters for each operation */
+        union {
+            /* H5VL_MAP_GET_MAPL */
+            struct {
+                hid_t mapl_id; /* Map access property list ID (OUT) */
+            } get_mapl;
+
+            /* H5VL_MAP_GET_MCPL */
+            struct {
+                hid_t mcpl_id; /* Map creation property list ID (OUT) */
+            } get_mcpl;
+
+            /* H5VL_MAP_GET_KEY_TYPE */
+            struct {
+                hid_t type_id; /* Datatype ID for map's keys (OUT) */
+            } get_key_type;
+
+            /* H5VL_MAP_GET_VAL_TYPE */
+            struct {
+                hid_t type_id; /* Datatype ID for map's values (OUT) */
+            } get_val_type;
+
+            /* H5VL_MAP_GET_COUNT */
+            struct {
+                hsize_t count; /* # of KV pairs in map (OUT) */
+            } get_count;
+        } args;
+    } get;
+
+    /* H5VL_MAP_SPECIFIC */
+    struct {
+        H5VL_map_specific_t specific_type; /* 'specific' operation to perform */
+
+        /* Parameters for each operation */
+        union {
+            /* H5VL_MAP_ITER */
+            struct {
+                H5VL_loc_params_t loc_params;      /* Location parameters for object */
+                hsize_t           idx;             /* Start/end iteration index (IN/OUT) */
+                hid_t             key_mem_type_id; /* Memory datatype for key */
+                H5M_iterate_t     op;              /* Iteration callback routine */
+                void             *op_data;         /* Pointer to callback context */
+            } iterate;
+
+            /* H5VL_MAP_DELETE */
+            struct {
+                H5VL_loc_params_t loc_params;      /* Location parameters for object */
+                hid_t             key_mem_type_id; /* Memory datatype for key */
+                const void       *key;             /* Pointer to key */
+            } del;
+        } args;
+    } specific;
+
+    /* H5VL_MAP_OPTIONAL */
+    /* Unused */
+
+    /* H5VL_MAP_CLOSE */
+    /* No args */
+} H5VL_map_args_t;
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* The map API is only built when requested since there's no support in
+ * the native file format at this time. It's only supported in a few VOL
+ * connectors.
+ */
+#ifdef H5_HAVE_MAP_API
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Creates a map object
+ *
+ * \fgdta_loc_id
+ * \param[in] name Map object name
+ * \type_id{key_type_id}
+ * \type_id{val_type_id}
+ * \lcpl_id
+ * \mcpl_id
+ * \mapl_id
+ * \returns \hid_t{map object}
+ *
+ * \details H5Mcreate() creates a new map object for storing key-value
+ *          pairs. The in-file datatype for keys is defined by \p key_type_id
+ *          and the in-file datatype for values is defined by \p val_type_id. \p
+ *          loc_id specifies the location to create the map object and \p
+ *          name specifies the name of the link to the map object relative to
+ *          \p loc_id.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL hid_t H5Mcreate(hid_t loc_id, const char *name, hid_t key_type_id, hid_t val_type_id, hid_t lcpl_id,
+                       hid_t mcpl_id, hid_t mapl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Mcreate}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Mcreate_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                             const char *name, hid_t key_type_id, hid_t val_type_id, hid_t lcpl_id,
+                             hid_t mcpl_id, hid_t mapl_id, hid_t es_id);
+#else
+H5_DLL hid_t  H5Mcreate_async(hid_t loc_id, const char *name, hid_t key_type_id, hid_t val_type_id,
+                              hid_t lcpl_id, hid_t mcpl_id, hid_t mapl_id, hid_t es_id);
+#endif
+
+/**
+ * \ingroup H5M
+ *
+ * \brief
+ *
+ * \details
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL hid_t H5Mcreate_anon(hid_t loc_id, hid_t key_type_id, hid_t val_type_id, hid_t mcpl_id, hid_t mapl_id);
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Opens a map object
+ *
+ * \fgdta_loc_id{loc_id}
+ * \param[in] name Map object name relative to \p loc_id
+ * \mapl_id
+ * \returns \hid_t{map object}
+ *
+ * \details H5Mopen() finds a map object specified by \p name under the location
+ *          specified by \p loc_id. The map object should be close with
+ *          H5Mclose() when the application is not longer interested in
+ *          accessing it.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL hid_t H5Mopen(hid_t loc_id, const char *name, hid_t mapl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Mopen}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Mopen_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                           const char *name, hid_t mapl_id, hid_t es_id);
+#else
+H5_DLL hid_t  H5Mopen_async(hid_t loc_id, const char *name, hid_t mapl_id, hid_t es_id);
+#endif
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Terminates access to a map object
+ *
+ * \map_id
+ * \returns \herr_t
+ *
+ * \details H5Mclose() closes access to a map object specified by \p map_id and
+ *          releases resources used by it.
+ *
+ *          It is illegal to subsequently use that same map identifier in calls
+ *          to other map functions.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Mclose(hid_t map_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Mclose}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Mclose_async(const char *app_file, const char *app_func, unsigned app_line, hid_t map_id,
+                             hid_t es_id);
+#else
+H5_DLL herr_t H5Mclose_async(hid_t map_id, hid_t es_id);
+#endif
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Gets key datatype for a map object
+ *
+ * \map_id
+ * \returns \hid_t{datatype}
+ *
+ * \details H5Mget_key_type() retrieves key datatype as stored in the file for a
+ *          map object specified by \p map_id and returns identifier for the
+ *          datatype.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL hid_t H5Mget_key_type(hid_t map_id);
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Gets value datatype for a map object
+ *
+ * \map_id
+ * \returns \hid_t{datatype}
+ *
+ * \details H5Mget_val_type() retrieves value datatype as stored in the file for
+ *          a map object specified by \p map_id and returns identifier for the
+ *          datatype .
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL hid_t H5Mget_val_type(hid_t map_id);
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Gets creation property list for a map object
+ *
+ * \map_id
+ * \returns \hid_t{map creation property list}
+ *
+ * \details H5Mget_create_plist() returns an identifier for a copy of the
+ *          creation property list for a map object specified by \p map_id.
+ *
+ *          The creation property list identifier should be released with
+ *          H5Pclose() to prevent resource leaks.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL hid_t H5Mget_create_plist(hid_t map_id);
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Gets access property list for a map object
+ *
+ * \map_id
+ * \returns \hid_t{map access property list}
+ *
+ * \details H5Mget_access_plist() returns an identifier for a copy of the access
+ *          property list for a map object specified by \p map_id.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL hid_t H5Mget_access_plist(hid_t map_id);
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Retrieves the number of key-value pairs in a map object
+ *
+ * \map_id
+ * \param[out] count The number of key-value pairs stored in the map object
+ * \dxpl_id
+ * \returns \herr_t
+ *
+ * \details H5Mget_count() retrieves the number of key-value pairs stored in a
+ *          map specified by map_id.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Mget_count(hid_t map_id, hsize_t *count, hid_t dxpl_id);
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Adds a key-value pair to a map object
+ *
+ * \map_id
+ * \type_id{key_mem_type_id}
+ * \param[in] key Pointer to key buffer
+ * \type_id{val_mem_type_id}
+ * \param[in] value Pointer to value buffer
+ * \dxpl_id
+ * \returns \herr_t
+ *
+ * \details H5Mput() adds a key-value pair to a map object specified by \p
+ *          map_id, or updates the value for the specified key if one was set
+ *          previously.
+ *
+ *          \p key_mem_type_id and \p val_mem_type_id specify the datatypes for
+ *          the provided key and value buffers, and if different from those used
+ *          to create the map object, the key and value will be internally
+ *          converted to the datatypes for the map object.
+ *
+ *          Any further options can be specified through the property list
+ *          \p dxpl_id.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Mput(hid_t map_id, hid_t key_mem_type_id, const void *key, hid_t val_mem_type_id,
+                     const void *value, hid_t dxpl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Mput}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Mput_async(const char *app_file, const char *app_func, unsigned app_line, hid_t map_id,
+                           hid_t key_mem_type_id, const void *key, hid_t val_mem_type_id, const void *value,
+                           hid_t dxpl_id, hid_t es_id);
+#else
+H5_DLL herr_t H5Mput_async(hid_t map_id, hid_t key_mem_type_id, const void *key, hid_t val_mem_type_id,
+                           const void *value, hid_t dxpl_id, hid_t es_id);
+#endif
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Retrieves a key-value pair from a map object
+ *
+ * \map_id
+ * \type_id{key_mem_type_id}
+ * \param[in] key Pointer to key buffer
+ * \type_id{val_mem_type_id}
+ * \param[out] value Pointer to value buffer
+ * \dxpl_id
+ * \returns \herr_t
+ *
+ * \details H5Mget() retrieves from a map object specified by \p map_id, the
+ *          value associated with the provided key \p key. \p key_mem_type_id
+ *          and \p val_mem_type_id specify the datatypes for the provided key
+ *          and value buffers. If if the datatype specified by \p
+ *          key_mem_type_id is different from that used to create the map object
+ *          the key will be internally converted to the datatype for the map
+ *          object for the query, and if the datatype specified by \p
+ *          val_mem_type_id is different from that used to create the map object
+ *          the returned value will be converted to have a datatype as specified
+ *          by \p val_mem_type_id before the function returns.
+ *
+ *          Any further options can be specified through the property list
+ *          \p dxpl_id.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Mget(hid_t map_id, hid_t key_mem_type_id, const void *key, hid_t val_mem_type_id, void *value,
+                     hid_t dxpl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Mget}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Mget_async(const char *app_file, const char *app_func, unsigned app_line, hid_t map_id,
+                           hid_t key_mem_type_id, const void *key, hid_t val_mem_type_id, void *value,
+                           hid_t dxpl_id, hid_t es_id);
+#else
+H5_DLL herr_t H5Mget_async(hid_t map_id, hid_t key_mem_type_id, const void *key, hid_t val_mem_type_id,
+                           void *value, hid_t dxpl_id, hid_t es_id);
+#endif
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Checks if provided key exists in a map object
+ *
+ * \map_id
+ * \type_id{key_mem_type_id}
+ * \param[in] key Pointer to key buffer
+ * \param[out] exists Pointer to a buffer to return the existence status
+ * \dxpl_id
+ * \returns \herr_t
+ *
+ * \details H5Mexists() checks if the provided key is stored in the map object
+ *          specified by \p map_id. If \p key_mem_type_id is different from that
+ *          used to create the map object the key will be internally converted
+ *          to the datatype for the map object for the query.
+ *
+ *          Any further options can be specified through the property list
+ *          \p dxpl_id.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Mexists(hid_t map_id, hid_t key_mem_type_id, const void *key, hbool_t *exists, hid_t dxpl_id);
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Iterates over all key-value pairs in a map object
+ *
+ * \map_id
+ * \param[in,out] idx iteration index
+ * \type_id{key_mem_type_id}
+ * \param[in] op User-defined iterator function
+ * \op_data
+ * \dxpl_id
+ * \returns \herr_t
+ *
+ * \details H5Miterate() iterates over all key-value pairs stored in the map
+ *          object specified by \p map_id, making the callback specified by \p
+ *          op for each. The \p idx parameter is an in/out parameter that may be
+ *          used to restart a previously interrupted iteration. At the start of
+ *          iteration \p idx should be set to 0, and to restart iteration at the
+ *          same location on a subsequent call to H5Miterate(), \p idx should be
+ *          the same value as returned by the previous call. Iterate callback is
+ *          defined as:
+ *          \snippet this H5M_iterate_t_snip
+ *          The \p key parameter is the buffer for the key for this iteration,
+ *          converted to the datatype specified by \p key_mem_type_id. The \p
+ *          op_data parameter is a simple pass through of the value passed to
+ *          H5Miterate(), which can be used to store application-defined data for
+ *          iteration. A negative return value from this function will cause
+ *          H5Miterate() to issue an error, while a positive return value will
+ *          cause H5Miterate() to stop iterating and return this value without
+ *          issuing an error. A return value of zero allows iteration to continue.
+ *
+ *          Any further options can be specified through the property list \p dxpl_id.
+ *
+ *  \warning Adding or removing key-value pairs to the map during iteration
+ *           will lead to undefined behavior.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Miterate(hid_t map_id, hsize_t *idx, hid_t key_mem_type_id, H5M_iterate_t op, void *op_data,
+                         hid_t dxpl_id);
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Iterates over all key-value pairs in a map object
+ *
+ * \loc_id
+ * \param[in] map_name Map object name relative to the location specified by \p loc_id
+ * \param[in,out] idx Iteration index
+ * \type_id{key_mem_type_id}
+ * \param[in] op User-defined iterator function
+ * \op_data
+ * \dxpl_id
+ * \lapl_id
+ * \returns \herr_t
+ *
+ * \details H5Miterate_by_name() iterates over all key-value pairs stored in the
+ *          map object specified by \p map_id, making the callback specified by
+ *          \p op for each. The \p idx parameter is an in/out parameter that may
+ *          be used to restart a previously interrupted iteration. At the start
+ *          of iteration \p idx should be set to 0, and to restart iteration at
+ *          the same location on a subsequent call to H5Miterate(), \p idx
+ *          should be the same value as returned by the previous call. Iterate
+ *          callback is defined as:
+ *          \snippet this H5M_iterate_t_snip
+ *          The\p key parameter is the buffer for the key for this iteration,
+ *          converted to the datatype specified by \p key_mem_type_id. The \p
+ *          op_data parameter is a simple pass through of the value passed to
+ *          H5Miterate(), which can be used to store application-defined data
+ *          for iteration. A negative return value from this function will cause
+ *          H5Miterate() to issue an error, while a positive return value will cause
+ *          H5Miterate() to stop iterating and return this value without issuing an
+ *          error. A return value of zero allows iteration to continue.
+ *
+ *          Any further options can be specified through the property list \p dxpl_id.
+ *
+ *  \warning Adding or removing key-value pairs to the map during iteration
+ *           will lead to undefined behavior.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Miterate_by_name(hid_t loc_id, const char *map_name, hsize_t *idx, hid_t key_mem_type_id,
+                                 H5M_iterate_t op, void *op_data, hid_t dxpl_id, hid_t lapl_id);
+
+/**
+ * \ingroup H5M
+ *
+ * \brief Deletes a key-value pair from a map object
+ *
+ * \map_id
+ * \type_id{key_mem_type_id}
+ * \param[in] key Pointer to key buffer
+ * \dxpl_id
+ * \returns \herr_t
+ *
+ * \details H5Mdelete() deletes a key-value pair from the map object specified
+ *          by \p map_id. \p key_mem_type_id specifies the datatype for the
+ *          provided key buffer key, and if different from that used to create
+ *          the map object, the key will be internally converted to the datatype
+ *          for the map object.
+ *
+ *          Any further options can be specified through the property list \p dxpl_id.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Mdelete(hid_t map_id, hid_t key_mem_type_id, const void *key, hid_t dxpl_id);
+
+/// \cond DEV
+/* API Wrappers for async routines */
+/* (Must be defined _after_ the function prototype) */
+/* (And must only defined when included in application code, not the library) */
+#ifndef H5M_MODULE
+#define H5Mcreate_async(...) H5Mcreate_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Mopen_async(...)   H5Mopen_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Mclose_async(...)  H5Mclose_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Mput_async(...)    H5Mput_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Mget_async(...)    H5Mget_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+
+/* Define "wrapper" versions of function calls, to allow compile-time values to
+ * be passed in by language wrapper or library layer on top of HDF5. */
+#define H5Mcreate_async_wrap H5_NO_EXPAND(H5Mcreate_async)
+#define H5Mopen_async_wrap   H5_NO_EXPAND(H5Mopen_async)
+#define H5Mclose_async_wrap  H5_NO_EXPAND(H5Mclose_async)
+#define H5Mput_async_wrap    H5_NO_EXPAND(H5Mput_async)
+#define H5Mget_async_wrap    H5_NO_EXPAND(H5Mget_async)
+#endif /* H5M_MODULE */
+/// \endcond
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#endif /*  H5_HAVE_MAP_API */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5Mpublic_H */
diff --git a/install/include/H5Opublic.h b/install/include/H5Opublic.h
new file mode 100644
index 0000000000..f35bdd0e7f
--- /dev/null
+++ b/install/include/H5Opublic.h
@@ -0,0 +1,2465 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*-------------------------------------------------------------------------
+ *
+ * Created:             H5Opublic.h
+ *
+ * Purpose:             Public declarations for the H5O (object header)
+ *                      package
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef H5Opublic_H
+#define H5Opublic_H
+
+#include "H5public.h"  /* Generic Functions                        */
+#include "H5Ipublic.h" /* Identifiers                              */
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* Flags for object copy (H5Ocopy) */
+#define H5O_COPY_SHALLOW_HIERARCHY_FLAG     (0x0001u) /**< Copy only immediate members */
+#define H5O_COPY_EXPAND_SOFT_LINK_FLAG      (0x0002u) /**< Expand soft links into new objects */
+#define H5O_COPY_EXPAND_EXT_LINK_FLAG       (0x0004u) /**< Expand external links into new objects */
+#define H5O_COPY_EXPAND_REFERENCE_FLAG      (0x0008u) /**< Copy objects that are pointed by references */
+#define H5O_COPY_WITHOUT_ATTR_FLAG          (0x0010u) /**< Copy object without copying attributes */
+#define H5O_COPY_PRESERVE_NULL_FLAG         (0x0020u) /**< Copy NULL messages (empty space) */
+#define H5O_COPY_MERGE_COMMITTED_DTYPE_FLAG (0x0040u) /**< Merge committed datatypes in dest file */
+#define H5O_COPY_ALL                        (0x007Fu) /**< All object copying flags (for internal checking) */
+
+/* Flags for shared message indexes.
+ * Pass these flags in using the mesg_type_flags parameter in
+ * H5P_set_shared_mesg_index.
+ * (Developers: These flags correspond to object header message type IDs,
+ * but we need to assign each kind of message to a different bit so that
+ * one index can hold multiple types.)
+ */
+#define H5O_SHMESG_NONE_FLAG    0x0000                  /**< No shared messages */
+#define H5O_SHMESG_SDSPACE_FLAG ((unsigned)1 << 0x0001) /**< Simple Dataspace Message.  */
+#define H5O_SHMESG_DTYPE_FLAG   ((unsigned)1 << 0x0003) /**< Datatype Message.  */
+#define H5O_SHMESG_FILL_FLAG    ((unsigned)1 << 0x0005) /**< Fill Value Message. */
+#define H5O_SHMESG_PLINE_FLAG   ((unsigned)1 << 0x000b) /**< Filter pipeline message.  */
+#define H5O_SHMESG_ATTR_FLAG    ((unsigned)1 << 0x000c) /**< Attribute Message.  */
+#define H5O_SHMESG_ALL_FLAG                                                                                  \
+    (H5O_SHMESG_SDSPACE_FLAG | H5O_SHMESG_DTYPE_FLAG | H5O_SHMESG_FILL_FLAG | H5O_SHMESG_PLINE_FLAG |        \
+     H5O_SHMESG_ATTR_FLAG)
+
+/* clang-format off */
+/* Object header status flag definitions */
+#define H5O_HDR_CHUNK0_SIZE             0x03 /**< 2-bit field indicating # of bytes to store the size of chunk 0's data */
+#define H5O_HDR_ATTR_CRT_ORDER_TRACKED  0x04 /**< Attribute creation order is tracked */
+#define H5O_HDR_ATTR_CRT_ORDER_INDEXED  0x08 /**< Attribute creation order has index */
+#define H5O_HDR_ATTR_STORE_PHASE_CHANGE 0x10 /**< Non-default attribute storage phase change values stored */
+#define H5O_HDR_STORE_TIMES             0x20 /**< Store access, modification, change & birth times for object */
+#define H5O_HDR_ALL_FLAGS                                                                                    \
+    (H5O_HDR_CHUNK0_SIZE | H5O_HDR_ATTR_CRT_ORDER_TRACKED | H5O_HDR_ATTR_CRT_ORDER_INDEXED |                 \
+     H5O_HDR_ATTR_STORE_PHASE_CHANGE | H5O_HDR_STORE_TIMES)
+/* clang-format on */
+
+/* Maximum shared message values.  Number of indexes is 8 to allow room to add
+ * new types of messages.
+ */
+#define H5O_SHMESG_MAX_NINDEXES  8
+#define H5O_SHMESG_MAX_LIST_SIZE 5000
+
+/* Flags for H5Oget_info.
+ * These flags determine which fields will be filled in the H5O_info_t
+ * struct.
+ */
+#define H5O_INFO_BASIC     0x0001u /**< Fill in the fileno, addr, type, and rc fields */
+#define H5O_INFO_TIME      0x0002u /**< Fill in the atime, mtime, ctime, and btime fields */
+#define H5O_INFO_NUM_ATTRS 0x0004u /**< Fill in the num_attrs field */
+#define H5O_INFO_ALL       (H5O_INFO_BASIC | H5O_INFO_TIME | H5O_INFO_NUM_ATTRS)
+
+//! <!-- [H5O_native_info_fields_snip] -->
+/**
+ * Flags for H5Oget_native_info().  These flags determine which fields will be
+ * filled in the \ref H5O_native_info_t struct.
+ */
+#define H5O_NATIVE_INFO_HDR       0x0008u /**< Fill in the hdr field */
+#define H5O_NATIVE_INFO_META_SIZE 0x0010u /**< Fill in the meta_size field */
+#define H5O_NATIVE_INFO_ALL       (H5O_NATIVE_INFO_HDR | H5O_NATIVE_INFO_META_SIZE)
+//! <!-- [H5O_native_info_fields_snip] -->
+
+/* Convenience macro to check if the token is the 'undefined' token value */
+#define H5O_IS_TOKEN_UNDEF(token) (!memcmp(&(token), &(H5O_TOKEN_UNDEF), sizeof(H5O_token_t)))
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+//! <!-- [H5O_type_t_snip] -->
+/**
+ * Types of objects in file
+ */
+typedef enum H5O_type_t {
+    H5O_TYPE_UNKNOWN = -1,   /**< Unknown object type        */
+    H5O_TYPE_GROUP,          /**< Object is a group          */
+    H5O_TYPE_DATASET,        /**< Object is a dataset        */
+    H5O_TYPE_NAMED_DATATYPE, /**< Object is a named data type    */
+    H5O_TYPE_MAP,            /**< Object is a map */
+    H5O_TYPE_NTYPES          /**< Number of different object types (must be last!) */
+} H5O_type_t;
+//! <!-- [H5O_type_t_snip] -->
+
+//! <!-- [H5O_hdr_info_t_snip] -->
+/**
+ * Information struct for object header metadata (for
+ * H5Oget_info(), H5Oget_info_by_name(), H5Oget_info_by_idx())
+ */
+typedef struct H5O_hdr_info_t {
+    unsigned version; /**< Version number of header format in file */
+    unsigned nmesgs;  /**< Number of object header messages */
+    unsigned nchunks; /**< Number of object header chunks */
+    unsigned flags;   /**< Object header status flags */
+    struct {
+        hsize_t total; /**< Total space for storing object header in file */
+        hsize_t meta;  /**< Space within header for object header metadata information */
+        hsize_t mesg;  /**< Space within header for actual message information */
+        hsize_t free;  /**< Free space within object header */
+    } space;
+    struct {
+        uint64_t present; /**< Flags to indicate presence of message type in header */
+        uint64_t shared;  /**< Flags to indicate message type is shared in header */
+    } mesg;
+} H5O_hdr_info_t;
+//! <!-- [H5O_hdr_info_t_snip] -->
+
+//! <!-- [H5O_info2_t_snip] -->
+/**
+ * Data model information struct for objects
+ * (For H5Oget_info(), H5Oget_info_by_name(), H5Oget_info_by_idx() version 3)
+ */
+typedef struct H5O_info2_t {
+    unsigned long fileno;    /**< File number that object is located in */
+    H5O_token_t   token;     /**< Token representing the object        */
+    H5O_type_t    type;      /**< Basic object type (group, dataset, etc.) */
+    unsigned      rc;        /**< Reference count of object            */
+    time_t        atime;     /**< Access time                          */
+    time_t        mtime;     /**< Modification time                    */
+    time_t        ctime;     /**< Change time                          */
+    time_t        btime;     /**< Birth time                           */
+    hsize_t       num_attrs; /**< Number of attributes attached to object   */
+} H5O_info2_t;
+//! <!-- [H5O_info2_t_snip] -->
+
+//! <!-- [H5O_native_info_t_snip] -->
+/**
+ * Native file format information struct for objects.
+ * (For H5Oget_native_info(), H5Oget_native_info_by_name(), H5Oget_native_info_by_idx())
+ */
+typedef struct H5O_native_info_t {
+    H5O_hdr_info_t hdr; /**< Object header information */
+    struct {
+        H5_ih_info_t obj;  /**< v1/v2 B-tree & local/fractal heap for groups, B-tree for chunked datasets */
+        H5_ih_info_t attr; /**< v2 B-tree & heap for attributes */
+    } meta_size;           /**< Extra metadata storage for obj & attributes */
+} H5O_native_info_t;
+//! <!-- [H5O_native_info_t_snip] -->
+
+/**
+ * Typedef for message creation indexes
+ */
+typedef uint32_t H5O_msg_crt_idx_t;
+
+//! <!-- [H5O_iterate2_t_snip] -->
+/**
+ * Prototype for H5Ovisit(), H5Ovisit_by_name() operator (version 3)
+ *
+ * \param[in] obj Object that serves as the root of the iteration;
+ *                the same value as the H5Ovisit3() \c obj_id parameter
+ * \param[in] name Name of object, relative to \p obj, being examined at current
+ *                 step of the iteration
+ * \param[out] info Information about that object
+ * \param[in,out] op_data User-defined pointer to data required by the application
+ *                        in processing the object; a pass-through of the \c op_data
+ *                        pointer provided with the H5Ovisit3() function call
+ * \return \herr_t_iter
+ *
+ */
+typedef herr_t (*H5O_iterate2_t)(hid_t obj, const char *name, const H5O_info2_t *info, void *op_data);
+//! <!-- [H5O_iterate2_t_snip] -->
+
+//! <!-- [H5O_mcdt_search_ret_t_snip] -->
+typedef enum H5O_mcdt_search_ret_t {
+    H5O_MCDT_SEARCH_ERROR = -1, /**< Abort H5Ocopy */
+    H5O_MCDT_SEARCH_CONT, /**< Continue the global search of all committed datatypes in the destination file
+                           */
+    H5O_MCDT_SEARCH_STOP  /**< Stop the search, but continue copying.  The committed datatype will be copied
+                             but not merged. */
+} H5O_mcdt_search_ret_t;
+//! <!-- [H5O_mcdt_search_ret_t_snip] -->
+
+//! <!-- [H5O_mcdt_search_cb_t_snip] -->
+/**
+ * Callback to invoke when completing the search for a matching committed
+ * datatype from the committed dtype list
+ */
+typedef H5O_mcdt_search_ret_t (*H5O_mcdt_search_cb_t)(void *op_data);
+//! <!-- [H5O_mcdt_search_cb_t_snip] -->
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Opens an object in an HDF5 file by location identifier and path name.
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] name Path to the object; relative to \p loc_id
+ * \lapl_id
+ *
+ * \return \hid_tv{object}
+ *
+ * \details H5Oopen() opens a group, dataset, or committed (named) datatype
+ *          specified by a location, \p loc_id, and a path name, \p name, in an HDF5 file.
+ *
+ *          This function opens the object in the same manner as H5Gopen(), H5Topen(), and H5Dopen().
+ *          However, H5Oopen() does not require the type of object to be known beforehand.
+ *          This can be useful with user-defined links, for instance, when only a path may be known.
+ *
+ *          H5Oopen() cannot be used to open a dataspace, attribute, property list, or file.
+ *
+ *          Once an object of an unknown type has been opened with H5Oopen(),
+ *          the type of that object can be determined by means of an H5Iget_type() call.
+ *
+ *          \p loc_id may be a file, group, dataset, named datatype, or attribute.
+ *          If an attribute is specified for \p loc_id then the object where the
+ *          attribute is attached will be accessed.
+ *
+ *          \p name must be the path to that object relative to \p loc_id.
+ *
+ *          \p lapl_id is the link access property list associated with the link pointing to
+ *          the object.  If default link access properties are appropriate, this can be
+ *          passed in as #H5P_DEFAULT.
+ *
+ *          When it is no longer needed, the opened object should be closed with
+ *          H5Oclose(), H5Gclose(), H5Tclose(), or H5Dclose().
+ *
+ * \version 1.8.1 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Oopen(hid_t loc_id, const char *name, hid_t lapl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Oopen}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Oopen_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                           const char *name, hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL hid_t  H5Oopen_async(hid_t loc_id, const char *name, hid_t lapl_id, hid_t es_id);
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Opens an object in an HDF5 file using its VOL independent token
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] token Object token
+ *
+ * \return \hid_ti{object}
+ *
+ * \details H5Oopen_by_token() opens an object specified by the object
+ *          identifier, \p loc_id and object token, \p token.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL hid_t H5Oopen_by_token(hid_t loc_id, H5O_token_t token);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Opens the nth object in a group
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] group_name Name of group, relative to \p loc_id, in which object is located
+ * \idx_type
+ * \order
+ * \param[in] n Object to open
+ * \lapl_id
+ *
+ * \return \hid_tv{object}
+ *
+ * \details H5Oopen_by_idx() opens the nth object in the group specified by \p loc_id
+ *          and \p group_name.
+ *
+ *          \p loc_id specifies a location identifier.
+ *          \p group_name specifies the group relative to \p loc_id in which the object can be found.
+ *          If \p loc_id fully specifies the group in which the object resides,
+ *          \p group_name can be a dot (.).
+ *
+ *          The specific object to be opened within the group is specified by the three parameters:
+ *          \p idx_type, \p order and \p n.
+ *
+ *          \p idx_type specifies the type of index by which objects are ordered.
+ *          Valid index types include the following:
+ *
+ *          \indexes
+ *
+ *          \p order specifies the order in which the objects are to be referenced for the purposes
+ *          of this function.  Valid orders include the following:
+ *
+ *          \orders
+ *
+ *          Note that for #H5_ITER_NATIVE, rather than implying a particular order,
+ *          it instructs the HDF5 library to iterate through the objects in the fastest
+ *          available order, i.e., in a natural order.
+ *
+ *          \p n specifies the position of the object within the index.  Note that this count is
+ *          zero-based; 0 (zero) indicates that the function will return the value of the first object;
+ *          if \p n is 5, the function will return the value of the sixth object; etc.
+ *
+ *          \p lapl_id specifies the link access property list to be used in accessing the object.
+ *
+ *          An object opened with this function should be closed when it is no longer needed so that
+ *          resource leaks will not develop.  H5Oclose() can be used to close groups, datasets,
+ *          or committed datatypes.
+ *
+ * \version 1.8.1 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Oopen_by_idx(hid_t loc_id, const char *group_name, H5_index_t idx_type, H5_iter_order_t order,
+                            hsize_t n, hid_t lapl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Oopen_by_idx}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Oopen_by_idx_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                                  const char *group_name, H5_index_t idx_type, H5_iter_order_t order,
+                                  hsize_t n, hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL hid_t  H5Oopen_by_idx_async(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                   H5_iter_order_t order, hsize_t n, hid_t lapl_id, hid_t es_id);
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Determines whether a link resolves to an actual object.
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] name The name of the link to check
+ * \lapl_id
+ *
+ * \return Returns a positive value if the object pointed to by
+ *         the \p loc_id and \p name combination exists.
+ * \return Returns 0 if the object pointed to by
+ *         the \p loc_id and \p name combination does not exist.
+ * \return Returns a negative value when the function fails.
+ *
+ * \details H5Oexists_by_name() allows an application to determine whether
+ *          the link \p name in the group or file specified with \p loc_id
+ *          resolves to an HDF5 object to open or if the link dangles. The
+ *          link may be of any type, but hard links will always resolve
+ *          to objects and do not need to be verified.
+ *
+ *          Note that H5Oexists_by_name() verifies only that the target
+ *          object exists. If \p name includes either a relative path or
+ *          an absolute path to the target link, intermediate steps
+ *          along the path must be verified before the existence of
+ *          the target link can be safely checked. If the path is not
+ *          verified and an intermediate element of the path does not
+ *          exist, H5Oexists_by_name() will fail. The example in the next
+ *          paragraph illustrates one step-by-step method for verifying
+ *          the existence of a link with a relative or absolute path.
+ *
+ * \par Example
+ *          Use the following steps to verify the existence of
+ *          the link \c datasetD in the \c group group1/group2/softlink_to_group3/,
+ *          where \c group1 is a member of the group specified by \c loc_id:
+ *
+ * \par
+ *      - First, use H5Lexists() to verify that a link named \c group1 exists.
+ *      - If \c group1 exists, use H5Oexists_by_name() to verify that the
+ *        link \c group1 resolves to an object.
+ *      - If \c group1 exists, use H5Lexists() again, this time with the name
+ *        set to \c group1/group2, to verify that the link \c group2 exists
+ *        in \c group1.
+ *      - If the \c group2 link exists, use H5Oexists_by_name() to verify
+ *        that \c group1/group2 resolves to an object.
+ *      - If \c group2 exists, use  H5Lexists() again, this time with the name
+ *        set to \c group1/group2/softlink_to_group3, to verify that the
+ *        link \c softlink_to_group3 exists in \c group2.
+ *      - If the \c softlink_to_group3 link exists, use H5Oexists_by_name()
+ *        to verify that \c group1/group2/softlink_to_group3 resolves to
+ *        an object.
+ *      - If \c softlink_to_group3 exists, you can now safely use H5Lexists
+ *        with the name set to \c group1/group2/softlink_to_group3/datasetD to
+ *        verify that the target link, \c datasetD, exists.
+ *      - And finally, if the link \c datasetD exists, use H5Oexists_by_name
+ *        to verify that \c group1/group2/softlink_to_group3/datasetD
+ *        resolves to an object.
+ *
+ * \par
+ *          If the link to be verified is specified with an absolute path,
+ *          the same approach should be used, but starting with the first
+ *          link in the file's root group. For instance, if \c datasetD
+ *          were in \c /group1/group2/softlink_to_group3, the first call to
+ *          H5Lexists() would have name set to \c /group1.
+ *
+ * \par
+ *          Note that this is an outline and does not include all the necessary
+ *          details. Depending on circumstances, for example, an application
+ *          may need to verify the type of an object also.
+ *
+ * \warning \Bold{Failure Modes:}
+ * \warning If \p loc_id and \p name both exist, but the combination does not
+ *          resolve to an object, the function will return 0 (zero);
+ *          the function does not fail in this case.
+ * \warning If either the location or the link specified by the \p loc_id
+ *          and \p name combination does not exist, the function will fail,
+ *          returning a negative value.
+ * \warning Note that verifying the existence of an object within an HDF5
+ *          file is a multistep process. An application can be certain the
+ *          object does not exist only if H5Lexists()  and H5Oexists_by_name()
+ *          have been used to verify the existence of the links and groups
+ *          in the hierarchy above that object. The example above, in the
+ *          function description, provides a step-by-step description of
+ *          that verification process.
+ *
+ * \version 1.8.11 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.5
+ *
+ */
+H5_DLL htri_t H5Oexists_by_name(hid_t loc_id, const char *name, hid_t lapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieves the metadata for an object specified by an identifier
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[out] oinfo Buffer in which to return object information
+ * \param[in] fields Flags specifying the fields to include in \p oinfo
+ *
+ * \return \herr_t
+ *
+ * \details H5Oget_info3() specifies an object by its identifier, \p loc_id , and
+ *          retrieves the metadata describing that object in \p oinfo.
+ *
+ *          The \p fields parameter contains flags to determine which fields will be filled in
+ *          the H5O_info2_t \c struct returned in \p oinfo.
+ *          These flags are defined in the H5Opublic.h file:
+ *
+ *          \obj_info_fields
+ *
+ * \par Example
+ *      An example snippet from examples/h5_attribute.c:
+ * \par
+ *      \snippet h5_attribute.c H5Oget_info3_snip
+ *
+ * \note If you are iterating through a lot of different objects to
+ *       retrieve information via the H5Oget_info() family of routines,
+ *       you may see memory building up. This can be due to memory
+ *       allocation for metadata, such as object headers and messages,
+ *       when the iterated objects are put into the metadata cache.
+ * \note
+ *       If the memory buildup is not desirable, you can configure a
+ *       smaller cache via H5Fset_mdc_config() or set the file access
+ *       property list via H5Pset_mdc_config(). A smaller sized cache
+ *       will force metadata entries to be evicted from the cache,
+ *       thus freeing the memory associated with the entries.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Oget_info3(hid_t loc_id, H5O_info2_t *oinfo, unsigned fields);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieves the metadata for an object, identifying the object by
+ *        location and relative name
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] name Name of object, relative to \p loc_id
+ * \param[out] oinfo Buffer in which to return object information
+ * \param[in] fields Flags specifying the fields to include in \p oinfo
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Oget_info_by_name3() specifies an object's location and name,
+ *          \p loc_id and \p name, respectively, and retrieves the metadata
+ *          describing that object in \p oinfo, an H5O_info2_t struct.
+ *
+ *          The \p fields parameter contains flags to determine which fields will be filled in
+ *          the H5O_info2_t \c struct returned in \p oinfo.
+ *          These flags are defined in the H5Opublic.h file:
+ *
+ *          \obj_info_fields
+ *
+ *          The link access property list, \c lapl_id, is not currently used;
+ *          it should be passed in as #H5P_DEFAULT.
+ *
+ * \par Example
+ *      An example snippet from test/vol.c:
+ *      \snippet vol.c H5Oget_info_by_name3_snip
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Oget_info_by_name3(hid_t loc_id, const char *name, H5O_info2_t *oinfo, unsigned fields,
+                                   hid_t lapl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Oget_info_by_name}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Oget_info_by_name_async(const char *app_file, const char *app_func, unsigned app_line,
+                                        hid_t loc_id, const char *name, H5O_info2_t *oinfo /*out*/,
+                                        unsigned fields, hid_t lapl_id, hid_t es_id);
+#else
+H5_DLL herr_t H5Oget_info_by_name_async(hid_t loc_id, const char *name, H5O_info2_t *oinfo /*out*/,
+                                        unsigned fields, hid_t lapl_id, hid_t es_id);
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieves the metadata for an object, identifying the object
+ *        by an index position
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] group_name Name of group in which object is located
+ * \idx_type
+ * \order
+ * \param[in] n Position within the index
+ * \param[out] oinfo Buffer in which to return object information
+ * \param[in] fields Flags specifying the fields to include in \p oinfo
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Oget_info_by_idx3() retrieves the metadata describing an
+ *          object in the \c struct \p oinfo, as specified by the location,
+ *          \p loc_id, group name, \p group_name, the index by which objects
+ *          in that group are tracked, \p idx_type, the order by which the
+ *          index is to be traversed, \p order, and an object's position
+ *          \p n within that index.
+ *
+ *          If \p loc_id fully specifies the group in which the object resides,
+ *          \p group_name can be a dot (\c .).
+ *
+ *          The \p fields parameter contains flags to determine which fields will be filled in
+ *          the H5O_info2_t \c struct returned in \p oinfo.
+ *          These flags are defined in the H5Opublic.h file:
+ *          \obj_info_fields
+ *
+ *          The link access property list, \c lapl_id, is not currently used;
+ *          it should be passed in as #H5P_DEFAULT.
+ *
+ * \par Example
+ *      An example snippet from test/titerate.c:
+ *      \snippet titerate.c H5Oget_info_by_idx3_snip
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Oget_info_by_idx3(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                  H5_iter_order_t order, hsize_t n, H5O_info2_t *oinfo, unsigned fields,
+                                  hid_t lapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieve native file format information about an object
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[out] oinfo Buffer in which to return native object information
+ * \param[in] fields Flags to determine which fields in \p oinfo are filled in
+ *
+ * \return \herr_t
+ *
+ * \details H5Oget_native_info() retrieves the native file format information for an object
+ *          specified by \p loc_id.
+ *
+ *          The \p fields parameter indicates which fields to fill in
+ *          H5O_native_info_t. Possible values defined in H5Opublic.h are:
+ *
+ *          \snippet this H5O_native_info_fields_snip
+ *
+ * \par Example
+ *      An example snippet from test/tfile.c:
+ * \par
+ *      \snippet tfile.c H5Oget_native_info_snip
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Oget_native_info(hid_t loc_id, H5O_native_info_t *oinfo, unsigned fields);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieve native file format information about an object given its name
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] name Name of object
+ * \param[out] oinfo Buffer in which to return native object information
+ * \param[in] fields Flags to determine which fields in \p oinfo are filled in
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Oget_native_info_by_name() retrieves the native file format
+ *          information for an object specified by \p loc_id and the name \p
+ *          name.
+ *
+ *          The \p fields parameter which fields to fill in H5O_native_info_t.
+ *          Possible values defined in H5Opublic.h are:
+ *
+ *          \snippet this H5O_native_info_fields_snip
+ *
+ * \par Example
+ *      An example snippet from test/tfile.c:
+ *      \snippet tfile.c H5Oget_native_info_by_name_snip
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Oget_native_info_by_name(hid_t loc_id, const char *name, H5O_native_info_t *oinfo,
+                                         unsigned fields, hid_t lapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieve native file format information about an object
+ *        according to the order of an index
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] group_name Name of group in which object is located
+ * \idx_type
+ * \order
+ * \param[in] n Position within the index
+ * \param[out] oinfo Buffer in which to return native object information
+ * \param[in] fields Flags to determine which fields in \p oinfo are filled in
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Oget_native_info_by_idx() retrieves the native file format information for an object
+ *          specified by \p loc_id, group name, \p group_name, the index by which
+ *          objects in the group are tracked, \p idx_type, the order by which
+ *          the index is to be traversed, \p order , and an object's position
+ *          \p n within that index.
+ *
+ *          The \p fields parameter indicates which fields to fill in H5O_native_info_t.
+ *          Possible values defined in H5Opublic.h are:
+ *          \snippet this H5O_native_info_fields_snip
+ *
+ *          The link access property list, \c lapl_id, is not currently used;
+ *          it should be passed in as #H5P_DEFAULT.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Oget_native_info_by_idx(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                        H5_iter_order_t order, hsize_t n, H5O_native_info_t *oinfo,
+                                        unsigned fields, hid_t lapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Creates a hard link to an object in an HDF5 file
+ *
+ * \param[in] obj_id Object to be linked
+ * \param[in] new_loc_id Location identifier at which object is to be linked;
+ *                       may be a file, group, dataset, named datatype or attribute identifier.
+ * \param[in] new_name Name of link to be created, relative to \p new_loc_id.
+ * \lcpl_id
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Olink() creates a new hard link to an object in an HDF5 file.
+ *          \p new_loc_id and \p \p new_link_name specify the location and name of the
+ *          new link, while \p object_id identifies the object that the link
+ *          points to.
+ *
+ *          H5Olink() is designed for two purposes:
+ *          - To create the first hard link to an object that has just
+ *            been created with H5Dcreate_anon(), H5Gcreate_anon(), or
+ *            H5Tcommit_anon().
+ *          - To add additional structure to an existing
+ *            file so that, for example, an object can be shared among
+ *            multiple groups.
+ *
+ *          \p lcpl and \p lapl are the link creation and access property lists
+ *          associated with the new link.
+ *
+ * \par Example:
+ *      To create a new link to an object while simultaneously creating
+ *      missing intermediate groups: Suppose that an application must
+ *      create the group C with the path /A/B01/C but may not know
+ *      at run time whether the groups A and B01 exist. The following
+ *      code ensures that those groups are created if they are missing:
+ * \par
+ * \code
+ *
+ *      // Creates a link creation property list (LCPL).
+ *      hid_t lcpl_id = H5Pcreate(H5P_LINK_CREATE);
+ *
+ *      // Sets "create missing intermediate groups" property in that LCPL.
+ *      int status = H5Pset_create_intermediate_group(lcpl_id, true);
+ *
+ *      // Creates a group without linking it into the file structure.
+ *      hid_t gid  = H5Gcreate_anon(file_id, H5P_DEFAULT, H5P_DEFAULT);
+ *
+ *      // Links group into file structure.
+ *      status = H5Olink(gid, file_id, "/A/B01/C", lcpl_id, H5P_DEFAULT);
+ *
+ * \endcode
+ *
+ * \par
+ *      Note that unless the object is intended to be temporary,
+ *      the H5O_LINK call is mandatory if an object created with one
+ *      of the H5*_CREATE_ANON functions (or with H5T_COMMIT_ANON)
+ *      is to be retained in the file; without an H5O_LINK call,
+ *      the object will not be linked into the HDF5 file structure
+ *      and will be deleted when the file is closed.
+ *
+ * \version 1.8.1 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Olink(hid_t obj_id, hid_t new_loc_id, const char *new_name, hid_t lcpl_id, hid_t lapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Increments an object reference count
+ *
+ * \fgdta_loc_obj_id{object_id}
+ *
+ * \return \herr_t
+ *
+ * \details H5Oincr_refcount() increments the hard link reference count for an object.
+ *          It should be used any time a user-defined link that references
+ *          an object by address is added. When the link is deleted,
+ *          H5Odecr_refcount() should be used.
+ *
+ *          An object's reference count is the number of hard links in the
+ *          file that point to that object. See the Programming Model
+ *          section of the HDF5 Groups chapter in the -- <em>\ref UG</em>
+ *          for a complete discussion of reference counts.
+ *
+ *          If a user application needs to determine an object's reference
+ *          count, an H5Oget_info() call is required; the reference count
+ *          is returned in the \c rc field of the #H5O_info_t \c struct.
+ *
+ * \warning This function must be used with care!
+ * \warning Improper use can lead to inaccessible data, wasted space in the file,
+ *          or <b><em>file corruption</em></b>.
+ *
+ * \version 1.8.11 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Oincr_refcount(hid_t object_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Decrements an object reference count
+ *
+ * \fgdta_loc_obj_id{object_id}
+ *
+ * \return \herr_t
+ *
+ * \details H5Odecr_refcount() decrements the hard link reference count for an object.
+ *          It should be used any time a user-defined link that references
+ *          an object by address is deleted. In general, H5Oincr_refcount() will have
+ *          been used previously, when the link was created.
+ *
+ *          An object's reference count is the number of hard links in the
+ *          file that point to that object. See the Programming Model
+ *          section of the HDF5 Groups chapter in the <em>\ref UG</em>
+ *          for a more complete discussion of reference counts.
+ *
+ *          If a user application needs to determine an object's reference
+ *          count, an H5Oget_info() call is required; the reference count
+ *          is returned in the \c rc field of the #H5O_info_t \c struct.
+ *
+ * \warning This function must be used with care!
+ * \warning Improper use can lead to inaccessible data, wasted space in the file,
+ *          or <b><em>file corruption</em></b>.
+ *
+ * \version 1.8.11 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Odecr_refcount(hid_t object_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Copies an object in an HDF5 file
+ *
+ * \param[in] src_loc_id Object identifier indicating the location of the
+ *                       source object to be copied
+ * \param[in] src_name Name of the source object to be copied
+ * \param[in] dst_loc_id Location identifier specifying the destination
+ * \param[in] dst_name Name to be assigned to the new copy
+ * \param[in] ocpypl_id Object copy property list
+ * \lcpl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Ocopy() copies the group, dataset or committed datatype
+ *          specified by \p src_name from the file or group specified by
+ *          \p src_loc_id to the destination location \p dst_loc_id.
+ *
+ *          The destination location, as specified in dst_loc_id, may
+ *          be a group in the current file or a location in a different
+ *          file. If dst_loc_id is a file identifier, the copy will be
+ *          placed in that file's root group.
+ *
+ *          The copy will be created with the path specified in \p dst_name,
+ *          which must not pre-exist in the destination location. If
+ *          \p dst_name already exists at the location \p dst_loc_id,
+ *          H5Ocopy() will fail. If \p dst_name is an absolute path,
+ *          the copy will be created relative to the file's root group.
+ *
+ *          The copy of the object is created with the property lists
+ *          specified by \p ocpypl_id and \p lcpl_id. #H5P_DEFAULT can be passed
+ *          in for these property lists. The default behavior:
+ *
+ *          - of the link creation property list is to NOT create
+ *             intermediate groups.
+ *          - of the flags specified by the object creation property list
+ *            is described in H5Pset_copy_object().
+ *
+ *          These property lists or flags can be modified to govern the
+ *          behavior of H5Ocopy() as follows:
+ *
+ *          - A flag controlling the creation of intermediate groups that
+ *              may not yet exist is set in the link creation property list
+ *              \p lcpl_id with H5Pset_create_intermediate_group().
+ *
+ *          - Copying of committed datatypes can be tuned through the use
+ *              of H5Pset_copy_object(), H5Padd_merge_committed_dtype_path(),
+ *              H5Pset_mcdt_search_cb(), and related functions.
+ *
+ *          - Flags controlling other aspects of object copying are set in the
+ *              object copy property list \p ocpypl_id with H5Pset_copy_object().
+ *
+ *          H5Ocopy() will always try to make a copy of the object specified
+ *          in \p src_name.
+ *
+ *          - If the object specified by \p src_name is a group containing a
+ *              soft or external link, the default is that the new copy will
+ *              contain a soft or external link with the same value as the
+ *              original. See H5Pset_copy_object() for optional settings.
+ *
+ *          - If the path specified in \p src_name is or contains a soft link
+ *              or an external link, H5Ocopy() will copy the target object.
+ *              Use H5Lcopy() if the intent is to create a new soft or external
+ *              link with the same value as the original link.
+ *
+ *          H5Ocopy() can be used to copy an object in an HDF5 file. If
+ *          an object has been changed since it was opened, it should be
+ *          written back to the file before using H5Ocopy(). The object
+ *          can be written back either by closing the object (H5Gclose(),
+ *          H5Oclose(), H5Dclose(), or H5Tclose()) or by flushing
+ *          the HDF5 file (H5Fflush()).
+ *
+ * \par See Also:
+ *      - Functions to modify the behavior of H5Ocopy():
+ *          - H5Padd_merge_committed_dtype_path()
+ *          - H5Pset_copy_object()
+ *          - H5Pset_create_intermediate_group()
+ *          - H5Pset_mcdt_search_cb()
+ *      - Copying Committed Datatypes with #H5Ocopy - A comprehensive
+ *        discussion of copying committed datatypes (PDF) in
+ *        Advanced Topics in HDF5
+ *
+ * \version 1.8.9 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Ocopy(hid_t src_loc_id, const char *src_name, hid_t dst_loc_id, const char *dst_name,
+                      hid_t ocpypl_id, hid_t lcpl_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Ocopy}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Ocopy_async(const char *app_file, const char *app_func, unsigned app_line, hid_t src_loc_id,
+                            const char *src_name, hid_t dst_loc_id, const char *dst_name, hid_t ocpypl_id,
+                            hid_t lcpl_id, hid_t es_id);
+#else
+H5_DLL herr_t H5Ocopy_async(hid_t src_loc_id, const char *src_name, hid_t dst_loc_id, const char *dst_name,
+                            hid_t ocpypl_id, hid_t lcpl_id, hid_t es_id);
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Sets comment for specified object
+ *
+ * \fgdta_loc_obj_id{obj_id}
+ * \param[in] comment The new comment
+ *
+ * \return \herr_t
+ *
+ * \details H5Oset_comment() sets the comment for the specified object
+ *          to the contents of \p comment. Any previously existing comment
+ *          is overwritten.
+ *
+ *          The target object is specified by an identifier, \p obj_id.
+ *          If \p comment is an empty string or a null pointer, any existing
+ *          comment message is removed from the object.
+ *
+ *          Comments should be relatively short, null-terminated, ASCII strings.
+ *
+ *          Comments can be attached to any object that has an object
+ *          header. Datasets, groups, and committed (named) datatypes have
+ *          object headers. Symbolic links do not have object headers.
+ *
+ *          If a comment is being added to an object attribute, this comment
+ *          will be attached to the object to which the attribute belongs
+ *          and not to the attribute itself.
+ *
+ * \version 1.8.11 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Oset_comment(hid_t obj_id, const char *comment);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Sets comment for specified object
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] name Name of the object whose comment is to be set or reset
+ * \param[in] comment The new comment
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Oset_comment_by_name() sets the comment for the specified object
+ *          to the contents of \p comment. Any previously existing comment
+ *          is overwritten.
+ *
+ *          The target object is specified by \p loc_id and \p name.
+ *          \p loc_id can specify any object in the file.
+ *          \p name can be one of the following:
+ *
+ *          - The name of the object specified as a path relative to \p loc_id
+ *          - An absolute name of the object, starting from \c /, the file's root group
+ *          - A dot (\c .), if \p loc_id fully specifies the object
+ *
+ *          If \p comment is an empty string or a null pointer, any existing
+ *          comment message is removed from the object.
+ *
+ *          Comments should be relatively short, null-terminated, ASCII strings.
+ *
+ *          Comments can be attached to any object that has an object
+ *          header. Datasets, groups, and committed (named) datatypes have
+ *          object headers. Symbolic links do not have object headers.
+ *
+ *          If a comment is being added to an object attribute, this comment
+ *          will be attached to the object to which the attribute belongs
+ *          and not to the attribute itself.
+ *
+ *          \p lapl_id contains a link access property list identifier. A
+ *          link access property list can come into play when traversing
+ *          links to access an object.
+ *
+ * \version 1.8.11 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Oset_comment_by_name(hid_t loc_id, const char *name, const char *comment, hid_t lapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieves comment for specified object
+ *
+ * \fgdta_loc_obj_id{obj_id}
+ * \param[out] comment The comment
+ * \param[in] bufsize Anticipated required size of the comment buffer
+ *
+ * \return Upon success, returns the number of characters in the
+ *         comment, not including the \c NULL terminator, or zero (\c 0) if
+ *         the object has no comment. The value returned may be larger
+ *         than \p bufsize. Otherwise returns a negative value.
+ *
+ * \details H5Oget_comment() retrieves the comment for the specified object in
+ *          the buffer \p comment.
+ *
+ *          The target object is specified by an identifier, \p object_id.
+ *
+ *          The size in bytes of the buffer \p comment, including the \c NULL
+ *          terminator, is specified in \p bufsize. If \p bufsize is unknown,
+ *          a preliminary H5Oget_comment() call with the pointer \p comment
+ *          set to \c NULL will return the size of the comment <em>without</em>
+ *          the \c NULL terminator.
+ *
+ *          If \p bufsize is set to a smaller value than described above,
+ *          only \p bufsize bytes of the comment, without a \c NULL terminator,
+ *          are returned in \p comment.
+ *
+ *          If an object does not have a comment, an empty string is
+ *          returned in \p comment.
+ *
+ * \version 1.8.11 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL ssize_t H5Oget_comment(hid_t obj_id, char *comment, size_t bufsize);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieves comment for specified object
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] name Name of the object whose comment is to be retrieved
+ * \param[out] comment The comment
+ * \param[in] bufsize Anticipated required size of the \p comment buffer
+ * \lapl_id
+ *
+ * \return Upon success, returns the number of characters in the comment,
+ *         not including the \c NULL terminator, or zero (\c 0) if the object
+ *         has no comment. The value returned may be larger than \c bufsize.
+ *         Otherwise returns a negative value.
+ *
+ * \details H5Oget_comment_by_name() retrieves the comment for an object
+ *          in the buffer \p comment.
+ *
+ *          The target object is specified by \p loc_id and \p name.
+ *          \p loc_id can specify any object in the file.
+ *          \p name can be one of the following:
+ *
+ *          - The name of the object relative to \p loc_id
+ *          - An absolute name of the object, starting from \c /, the file's root group
+ *          - A dot (\c .), if \p loc_id fully specifies the object
+ *
+ *          The size in bytes of the comment, including the \c NULL terminator,
+ *          is specified in \p bufsize. If \p bufsize is unknown, a preliminary
+ *          H5Oget_comment_by_name() call with the pointer \p comment set
+ *          to \c NULL will return the size of the comment <em>without</em>
+ *          the \c NULL terminator.
+ *
+ *          If \p bufsize is set to a smaller value than described above,
+ *          only \p bufsize bytes of the comment, without a \c NULL terminator,
+ *          are returned in \p comment.
+ *
+ *          If an object does not have a comment, an empty string is
+ *          returned in \p comment.
+ *
+ *          \p lapl_id contains a link access property list identifier. A
+ *          link access property list can come into play when traversing
+ *          links to access an object.
+ *
+ * \version 1.8.11 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL ssize_t H5Oget_comment_by_name(hid_t loc_id, const char *name, char *comment, size_t bufsize,
+                                      hid_t lapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Recursively visits all objects accessible from a specified object
+ *
+ * \fgdta_loc_obj_id{obj_id}
+ * \idx_type
+ * \order
+ * \param[in] op Callback function passing data regarding the object
+ *               to the calling application
+ * \param[in] op_data User-defined pointer to data required by the application
+ *                    for its processing of the object
+ * \param[in] fields Flags specifying the fields to be retrieved to the
+ *                   callback \p op
+ *
+ * \return On success, returns the return value of the first operator
+ *         that returns a positive value, or zero if all members were
+ *         processed with no operator returning non-zero.
+ *
+ * \return On failure, returns a negative value if something goes wrong
+ *         within the library, or the first negative value returned by
+ *         an operator.
+ *
+ * \details H5Ovisit3() is a recursive iteration function to visit the
+ *          object \p obj_id and, if \p obj_id is a group, all objects in
+ *          and below it in an HDF5 file, thus providing a mechanism for
+ *          an application to perform a common set of operations across
+ *          all of those objects or a dynamically selected subset.
+ *          For non-recursive iteration across the members of a group,
+ *          see H5Literate2().
+ *
+ *          If \p obj_id is a group identifier, that group serves as the
+ *          root of a recursive iteration. If \p obj_id is a file identifier,
+ *          that file's root group serves as the root of the recursive
+ *          iteration.  If \p obj_id is an attribute identifier,
+ *          then the object where the attribute is attached will be iterated.
+ *          If \p obj_id is any other type of object, such as a dataset or
+ *          named datatype, there is no iteration.
+ *
+ *          Two parameters are used to establish the iteration: \p idx_type
+ *          and \p order.
+ *
+ *          \p idx_type specifies the index to be used. If the links in
+ *          a group have not been indexed by the index type, they will
+ *          first be sorted by that index then the iteration will begin;
+ *          if the links have been so indexed, the sorting step will be
+ *          unnecessary, so the iteration may begin more quickly.
+
+ *          Note that the index type passed in \p idx_type is a
+ *          <em>best effort</em> setting. If the application passes in
+ *          a value indicating iteration in creation order and a group is
+ *          encountered that was not tracked in creation order, that group
+ *          will be iterated over in alphanumeric order by name, or
+ *          <em>name order</em>.  (<em>Name order</em> is the native order
+ *          used by the HDF5 library and is always available.)
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index specified in \p idx_type.
+ *
+ *          The H5Ovisit3() \p op_data parameter is a user-defined pointer to the data
+ *          required to process objects in the course of the iteration. This pointer
+ *          is passed back to each step of the iteration in the callback
+ *          function's \p op_data parameter.
+ *
+ *          The \p fields parameter contains flags to determine which fields will
+ *          be retrieved by the \p op callback function. These flags are defined
+ *          in the H5Opublic.h file:
+ *          \obj_info_fields
+ *
+ *          H5Lvisit2() and H5Ovisit3() are companion functions: one for
+ *          examining and operating on links; the other for examining
+ *          and operating on the objects that those links point to. Both
+ *          functions ensure that by the time the function completes
+ *          successfully, every link or object below the specified point
+ *          in the file has been presented to the application for whatever
+ *          processing the application requires. These functions assume
+ *          that the membership of the group being iterated over remains
+ *          unchanged through the iteration; if any of the links in the
+ *          group change during the iteration, the resulting behavior
+ *          is undefined.
+ *
+ * \par Example
+ *      An example snippet from test/links.c:
+ *      \snippet links.c H5Ovisit3_snip
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Ovisit3(hid_t obj_id, H5_index_t idx_type, H5_iter_order_t order, H5O_iterate2_t op,
+                        void *op_data, unsigned fields);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Recursively visits all objects accessible from a specified object
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] obj_name Name of the object, generally relative to
+ *                     \p loc_id, that will serve as root of the iteration
+ * \idx_type
+ * \order
+ * \param[in] op Callback function passing data regarding the object
+ *               to the calling application
+ * \param[in] op_data User-defined pointer to data required by the application
+ *                    for its processing of the object
+ * \param[in] fields Flags specifying the fields to be retrieved to the
+ *                   callback function \p op
+ * \lapl_id
+ *
+ * \return On success, returns the return value of the first operator
+ *         that returns a positive value, or zero if all members were
+ *         processed with no operator returning non-zero.
+ *
+ * \return On failure, returns a negative value if something goes wrong
+ *         within the library, or the first negative value returned by
+ *         an operator.
+ *
+ * \details H5Ovisit_by_name3() is a recursive iteration function to visit
+ *          the object specified by the \p loc_id / \p obj_name parameter
+ *          pair and, if that object is a group, all objects in and below it
+ *          in an HDF5 file, thus providing a mechanism for an application to
+ *          perform a common set of operations across all of those objects or
+ *          a dynamically selected subset. For non-recursive iteration across
+ *          the members of a group, see H5Literate2().
+ *
+ *          The object serving as the root of the iteration is specified
+ *          by the \p loc_id / \p obj_name parameter pair. \p loc_id specifies
+ *          a file or an object in a file;  if \p loc_id is an attribute identifier,
+ *          the object where the attribute is attached will be used.
+ *          \p obj_name specifies either an object in the file (with an absolute
+ *          name based on the file's root group) or an object name relative
+ *          to \p loc_id. If \p loc_id fully specifies the object that is to serve
+ *          as the root of the iteration, \p obj_name should be '\c .' (a dot).
+ *          (Note that when \p loc_id fully specifies the object that is to serve
+ *          as the root of the iteration, the user may wish to consider
+ *          using H5Ovisit3() instead of H5Ovisit_by_name3().)
+ *
+ *          Two parameters are used to establish the iteration: \p idx_type
+ *          and \p order.
+ *
+ *          \p idx_type specifies the index to be used. If the links in
+ *          a group have not been indexed by the index type, they will
+ *          first be sorted by that index then the iteration will begin;
+ *          if the links have been so indexed, the sorting step will be
+ *          unnecessary, so the iteration may begin more quickly.
+ *
+ *          Note that the index type passed in \p idx_type is a
+ *          <em>best effort</em> setting. If the application passes in a
+ *          value indicating iteration in creation order and a group is
+ *          encountered that was not tracked in creation order, that group
+ *          will be iterated over in alphanumeric order by name, or
+ *          <em>name order</em>.  (<em>Name order</em> is the native order
+ *          used by the HDF5 library and is always available.)
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index specified in \p idx_type.
+ *
+ *          The H5Ovisit_by_name3() \p op_data parameter is a user-defined
+ *          pointer to the data required to process objects in the course
+ *          of the iteration. This pointer is passed back to each step of
+ *          the iteration in the callback function's \p op_data parameter.
+ *
+ *          \p lapl_id is a link access property list. In the general case,
+ *          when default link access properties are acceptable, this can
+ *          be passed in as #H5P_DEFAULT. An example of a situation that
+ *          requires a non-default link access property list is when
+ *          the link is an external link; an external link may require
+ *          that a link prefix be set in a link access property list
+ *          (see H5Pset_elink_prefix()).
+ *
+ *          The \p fields parameter contains flags to determine which fields will
+ *          be retrieved by the \p op callback function. These flags are defined
+ *          in the H5Opublic.h file:
+ *          \obj_info_fields
+ *
+ *          H5Lvisit_by_name2() and H5Ovisit_by_name3() are companion
+ *          functions: one for examining and operating on links; the other
+ *          for examining and operating on the objects that those links point to.
+ *          Both functions ensure that by the time the function completes
+ *          successfully, every link or object below the specified point
+ *          in the file has been presented to the application for whatever
+ *          processing the application requires.
+ *
+ * \par Example
+ *      An example snippet from test/links.c:
+ *      \snippet links.c H5Ovisit_by_name3_snip
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Ovisit_by_name3(hid_t loc_id, const char *obj_name, H5_index_t idx_type,
+                                H5_iter_order_t order, H5O_iterate2_t op, void *op_data, unsigned fields,
+                                hid_t lapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Closes an object in an HDF5 file
+ *
+ * \obj_id{object_id}
+ *
+ * \return \herr_t
+ *
+ * \details H5Oclose() closes the group, dataset, or named datatype specified by
+ *          object_id.
+ *
+ *          This function is the companion to H5Oopen(), and has the same
+ *          effect as calling H5Gclose(), H5Dclose(), or H5Tclose().
+ *
+ *          H5Oclose() is not used to close a dataspace, attribute, property
+ *          list, or file.
+ *
+ * \version 1.8.8 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Oclose(hid_t object_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Oclose}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Oclose_async(const char *app_file, const char *app_func, unsigned app_line, hid_t object_id,
+                             hid_t es_id);
+#else
+H5_DLL herr_t H5Oclose_async(hid_t object_id, hid_t es_id);
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Flushes all buffers associated with an HDF5 object to disk
+ *
+ * \fgdta_loc_obj_id{obj_id}
+ *
+ * \return \herr_t
+ *
+ * \details H5Oflush() causes all buffers associated with an object to be immediately
+ *          flushed to disk without removing the data from the cache.
+ *
+ *          The object associated with \p object_id can be any named object in an
+ *          HDF5 file, including a dataset, a group, or a committed datatype.
+ *
+ * \warning H5Oflush doesn't work correctly with parallel. It causes an assertion
+ *          failure in metadata cache during H5Fclose().
+ *
+ * \note HDF5 does not possess full control over buffering. H5Oflush()
+ *       flushes the internal HDF5 buffers and then asks the operating
+ *       system (the OS) to flush the system buffers for the open
+ *       files. After that, the OS is responsible for ensuring that
+ *       the data is actually flushed to disk.
+ *
+ * \see H5Dflush(), H5Drefresh(), H5Oflush(), H5Grefresh(), H5Oflush(),
+ *      H5Orefresh(), H5Tflush(), H5Trefresh()
+ * \see H5DOappend(), H5Fstart_swmr_write(), H5Pget_append_flush(),
+ *      H5Pget_object_flush_cb(), H5Pset_append_flush(), H5Pset_object_flush_cb()
+ * \see H5Oare_mdc_flushes_disabled(), H5Odisable_mdc_flushes(), H5Oenable_mdc_flushes()
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Oflush(hid_t obj_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Oflush}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Oflush_async(const char *app_file, const char *app_func, unsigned app_line, hid_t obj_id,
+                             hid_t es_id);
+#else
+H5_DLL herr_t H5Oflush_async(hid_t obj_id, hid_t es_id);
+#endif
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Refreshes all buffers associated with an HDF5 object
+ *
+ * \fgdta_loc_obj_id{oid}
+ *
+ * \return \herr_t
+ *
+ * \details H5Orefresh() causes all buffers associated with an object to be cleared
+ *          and immediately re-loaded with updated contents from disk.
+ *
+ *          This function essentially closes the object, evicts all
+ *          metadata associated with it from the cache, and then re-opens
+ *          the object. The reopened object is automatically re-registered
+ *          with the same identifier.
+ *
+ *          The object associated with \p oid can be any named object in an
+ *          HDF5 file including a dataset, a group, or a committed datatype.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Orefresh(hid_t oid);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Orefresh}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Orefresh_async(const char *app_file, const char *app_func, unsigned app_line, hid_t oid,
+                               hid_t es_id);
+#else
+H5_DLL herr_t H5Orefresh_async(hid_t oid, hid_t es_id);
+#endif
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Prevents metadata entries for an HDF5 object from being flushed
+ *        from the metadata cache to storage
+ *
+ * \param[in] object_id Identifier of the object that will have flushes disabled;
+ *                      may be a group, named datatype, or dataset identifier
+ *
+ * \return \herr_t
+ *
+ * \details H5Odisable_mdc_flushes(), H5Oenable_mdc_flushes() and associated flush
+ *          functions can be used to control the flushing of entries from
+ *          a file's metadata cache.
+ *
+ *          This function prevents an object's or cache's dirty metadata
+ *          entries from being flushed from the cache by the usual cache
+ *          eviction/flush policy. Instead, users must manually flush the
+ *          cache or entries for individual objects via the appropriate
+ *          H5Fflush(), H5Dflush(), H5Gflush(), H5Tflush(), and H5Oflush() calls.
+ *
+ *          Metadata cache entries can be controlled at both the individual
+ *          HDF5 object level (datasets, groups, committed datatypes)
+ *          and the entire metadata cache level.
+ *
+ * \note HDF5 objects include datasets, groups, and committed datatypes.  Only
+ *       #hid_t identifiers that represent these objects can be passed to the
+ *       function.  Passing in a #hid_t identifier that represents any other
+ *       HDF5 entity is considered an error.  It is an error to pass an HDF5
+ *       file identifier (obtained from H5Fopen() or H5Fcreate()) to this
+ *       function.  Misuse of this function can cause the cache to exhaust
+ *       available memory.  Objects can be returned to the default automatic
+ *       flush behavior with H5Oenable_mdc_flushes().  Flush prevention only
+ *       pertains to new or dirty metadata entries.  Clean entries can be
+ *       evicted from the cache.  Calling this function on an object that has
+ *       already had flushes disabled will return an error.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Odisable_mdc_flushes(hid_t object_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Enables flushing of dirty metadata entries from a file's metadata cache
+ *
+ * \param[in] object_id Identifier of the object that will have flushes re-enabled;
+ *                      may be a group, named datatype, or dataset identifier
+ *
+ * \return \herr_t
+ *
+ * \details H5Oenable_mdc_flushes(), H5Odisable_mdc_flushes()
+ *          and associated flush functions can be used to control the flushing
+ *          of entries from a file's metadata cache.
+ *
+ *          This function allows an object or cache's dirty metadata entries to be
+ *          flushed from the cache by the usual cache eviction/flush policy.
+ *
+ *          Metadata cache entries can be controlled at both the individual HDF5
+ *          object level (datasets, groups, committed datatypes) and the entire
+ *          metadata cache level.
+ *
+ *
+ * \note HDF5 objects include datasets, groups, and committed datatypes.  Only
+ *       #hid_t identifiers that represent these objects can be passed to the
+ *       function.  Passing in a #hid_t identifier that represents any other
+ *       HDF5 entity is considered an error.  It is an error to pass an HDF5
+ *       file identifier (obtained from H5Fopen() or H5Fcreate()) to this
+ *       function.  Using this function on an object that has not had flushes
+ *       disabled is considered an error. The state of an object can be
+ *       determined with H5Oare_mdc_flushes_disabled().  An object will be
+ *       returned to the default flush algorithm when it is closed.  All objects
+ *       will be returned to the default flush algorithm when the file is
+ *       closed.  An object's entries will not necessarily be flushed as a
+ *       result of calling this function.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Oenable_mdc_flushes(hid_t object_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieves comment for specified object
+ *
+ * \param[in] object_id Identifier of an object in the cache;
+ *                      may be a group, named datatype, or dataset identifier
+ * \param[out] are_disabled Flushes enabled/disabled
+ *
+ * \return \p are_disabled will be set to \c 1 if an object has had flushes disabled
+ *            and \c 0 if it has not had flushes disabled.
+ * \return \herr_t
+ *
+ * \details H5Oare_mdc_flushes_disabled() determines if an HDF5 object (dataset, group, committed
+ *          datatype) has had flushes of metadata entries disabled.
+ *
+ *          The H5Oenable_mdc_flushes(), H5Odisable_mdc_flushes() and
+ *          associated flush functions can be used to control the flushing of
+ *          entries from a file's metadata cache. Metadata cache entries can be controlled
+ *          at both the individual HDF5 object level (datasets, groups,
+ *          committed datatypes) and the entire metadata cache level.
+ *
+ * \note HDF5 objects include datasets, groups, and committed datatypes.
+ *       Only #hid_t identifiers that represent these objects can be passed to the function.
+ * \note Passing in a #hid_t identifier that represents any other HDF5 entity is
+ *       considered an error.
+ * \note It is an error to pass an HDF5 file identifier
+ *       (obtained from H5Fopen() or H5Fcreate()) to this function.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Oare_mdc_flushes_disabled(hid_t object_id, hbool_t *are_disabled);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Compares two VOL connector object tokens
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] token1 First object token
+ * \param[in] token2 Second object token
+ * \param[out] cmp_value Comparison value
+ *
+ * \return \herr_t
+ *
+ * \details H5Otoken_cmp() compares two VOL connector object tokens, \p token1
+ *          and \p token2 for the file or group identifier specified by \p loc_id.
+ *          Both object tokens must be from the same VOL connector class.
+ *
+ *          H5O_token_t is defined in H5public.h as follows:
+ *          \snippet H5public.h H5O_token_t_snip
+ *
+ *          A comparison value, \p cmp_value, is returned, which indicates the
+ *          result of the comparison:
+ *
+ * <table>
+ *  <tr>
+ *      <th>cmp_value</th>
+ *      <th>Result</th>
+ * </tr>
+ *  <tr>
+ *      <td> > 0</td>
+ *      <td> \p token1 > \p token2</td>
+ *  </tr>
+ *  <tr>
+ *      <td> < 0</td>
+ *      <td>\p token1 < \p token2</td>
+ *  </tr>
+ *  <tr>
+ *      <td>0</td>
+ *      <td>\p token1 = \p token2</td>
+ *  </tr>
+ * </table>
+ *
+ * \par Example
+ *      An example snippet from test/links.c:
+ *      \snippet links.c H5Otoken_cmp_snip
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Otoken_cmp(hid_t loc_id, const H5O_token_t *token1, const H5O_token_t *token2,
+                           int *cmp_value);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Serializes a connector's object token into a string
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] token Connector object token
+ * \param[out] token_str String for connector object token \p token
+ *
+ * \return \herr_t
+ *
+ * \details H5Otoken_to_str() serializes a connector's object token specified by
+ *          \p token and the location identifier for the object, \p loc_id,
+ *          into a string, \p token_str.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Otoken_to_str(hid_t loc_id, const H5O_token_t *token, char **token_str);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Deserializes a string into a connector object token
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] token_str Object token string
+ * \param[out] token Connector object token
+ *
+ * \return \herr_t
+ *
+ * \details H5Otoken_from_str() deserializes a string, \p token_str, into a
+ *          connector object token, \p token, for the object specified by the
+ *          location identifier, \p loc_id.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Otoken_from_str(hid_t loc_id, const char *token_str, H5O_token_t *token);
+
+/// \cond DEV
+/* API Wrappers for async routines */
+/* (Must be defined _after_ the function prototype) */
+/* (And must only defined when included in application code, not the library) */
+#ifndef H5O_MODULE
+#define H5Oopen_async(...)             H5Oopen_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Oopen_by_idx_async(...)      H5Oopen_by_idx_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Oget_info_by_name_async(...) H5Oget_info_by_name_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Oclose_async(...)            H5Oclose_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Oflush_async(...)            H5Oflush_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Orefresh_async(...)          H5Orefresh_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Ocopy_async(...)             H5Ocopy_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+
+/* Define "wrapper" versions of function calls, to allow compile-time values to
+ *      be passed in by language wrapper or library layer on top of HDF5.
+ */
+#define H5Oopen_async_wrap             H5_NO_EXPAND(H5Oopen_async)
+#define H5Oopen_by_idx_async_wrap      H5_NO_EXPAND(H5Oopen_by_idx_async)
+#define H5Oget_info_by_name_async_wrap H5_NO_EXPAND(H5Oget_info_by_name_async)
+#define H5Oclose_async_wrap            H5_NO_EXPAND(H5Oclose_async)
+#define H5Oflush_async_wrap            H5_NO_EXPAND(H5Oflush_async)
+#define H5Orefresh_async_wrap          H5_NO_EXPAND(H5Orefresh_async)
+#define H5Ocopy_async_wrap             H5_NO_EXPAND(H5Ocopy_async)
+#endif
+/// \endcond
+
+/* The canonical 'undefined' token value */
+#define H5O_TOKEN_UNDEF (H5OPEN H5O_TOKEN_UNDEF_g)
+H5_DLLVAR const H5O_token_t H5O_TOKEN_UNDEF_g;
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+
+/* Deprecated flags for earlier versions of H5Oget_info* */
+#define H5O_INFO_HDR       0x0008u /**< Fill in the hdr field */
+#define H5O_INFO_META_SIZE 0x0010u /**< Fill in the meta_size field */
+#undef H5O_INFO_ALL
+#define H5O_INFO_ALL (H5O_INFO_BASIC | H5O_INFO_TIME | H5O_INFO_NUM_ATTRS | H5O_INFO_HDR | H5O_INFO_META_SIZE)
+
+/* Typedefs */
+
+//! <!-- [H5O_stat_t_snip] -->
+/**
+ * A struct that's part of the \ref H5G_stat_t structure
+ * \deprecated
+ */
+typedef struct H5O_stat_t {
+    hsize_t  size;    /**< Total size of object header in file */
+    hsize_t  free;    /**< Free space within object header */
+    unsigned nmesgs;  /**< Number of object header messages */
+    unsigned nchunks; /**< Number of object header chunks */
+} H5O_stat_t;
+//! <!-- [H5O_stat_t_snip] -->
+
+//! <!-- [H5O_info1_t_snip] -->
+/**
+ * Information struct for object (For H5Oget_info(), H5Oget_info_by_name(),
+ * H5Oget_info_by_idx() versions 1 & 2.)
+ */
+typedef struct H5O_info1_t {
+    unsigned long  fileno;    /**< File number that object is located in */
+    haddr_t        addr;      /**< Object address in file                */
+    H5O_type_t     type;      /**< Basic object type (group, dataset, etc.) */
+    unsigned       rc;        /**< Reference count of object    */
+    time_t         atime;     /**< Access time                  */
+    time_t         mtime;     /**< Modification time            */
+    time_t         ctime;     /**< Change time                  */
+    time_t         btime;     /**< Birth time                   */
+    hsize_t        num_attrs; /**< Number of attributes attached to object */
+    H5O_hdr_info_t hdr;       /**< Object header information */
+    /* Extra metadata storage for obj & attributes */
+    struct {
+        H5_ih_info_t obj;  /**< v1/v2 B-tree & local/fractal heap for groups, B-tree for chunked datasets */
+        H5_ih_info_t attr; /**< v2 B-tree & heap for attributes */
+    } meta_size;
+} H5O_info1_t;
+//! <!-- [H5O_info1_t_snip] -->
+
+//! <!-- [H5O_iterate1_t_snip] -->
+/**
+ * Prototype for H5Ovisit(), H5Ovisit_by_name() operator (versions 1 & 2)
+ *
+ * \param[in] obj Object that serves as the root of the iteration;
+ *                the same value as the H5Ovisit1() \c obj_id parameter
+ * \param[in] name Name of object, relative to \p obj, being examined at current
+ *                 step of the iteration
+ * \param[out] info Information about that object
+ * \param[in,out] op_data User-defined pointer to data required by the application
+ *                        in processing the object
+ * \return \herr_t_iter
+ *
+ */
+typedef herr_t (*H5O_iterate1_t)(hid_t obj, const char *name, const H5O_info1_t *info, void *op_data);
+//! <!-- [H5O_iterate1_t_snip] -->
+
+/* Function prototypes */
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Opens an object using its address within an HDF5 file.
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] addr Object's address in the file
+ *
+ * \return \hid_tv{object}
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Oopen_by_token().
+ *
+ * \details H5Oopen_by_addr() opens a group, dataset, or committed (named) datatype using its
+ *          address within an HDF5 file, \p addr. The resulting opened object is identical to
+ *          an object opened with H5Oopen() and should be closed with H5Oclose() or an
+ *          object-type-specific closing function (such as H5Gclose()) when no longer needed.
+ *
+ *          \p loc_id is a location identifier in the file.
+ *
+ *          The object's address within the file, \p addr, is the byte offset of the first byte
+ *          of the object header from the beginning of the HDF5 file space, i.e., from the
+ *          beginning of the superblock (see the HDF5 Storage Model section of the The
+ *          HDF5 Data Model and File Structure chapter of the <em>HDF5 User's Guide</em>.)
+ *
+ *          \p addr can be obtained via either of two function calls. H5Gget_objinfo() returns
+ *          the object's address in the \c objno field of the H5G_stat_t \c struct;
+ *          H5Lget_info() returns the address in the \c address field of the #H5L_info_t \c struct.
+ *
+ *          The address of the HDF5 file on a physical device has no effect on H5Oopen_by_addr(),
+ *          nor does the use of any file driver. As stated above, the object address is its
+ *          offset within the HDF5 file; HDF5's file drivers will transparently map this to an
+ *          address on a storage device.
+ *
+ * \warning This function must be used with care!
+ * \warning Improper use can lead to inaccessible data, wasted space in the file,
+ *          or <b><em>file corruption</em></b>.
+ * \warning This function is dangerous if called on an invalid address. The risk can be safely
+ *          overcome by retrieving the object address with H5Gget_objinfo() or H5Lget_info()
+ *          immediately before calling H5Oopen_by_addr(). The immediacy of the operation can be
+ *          important; if time has elapsed and the object has been deleted from the file,
+ *          the address will be invalid, and file corruption can result.
+ *
+ * \version 1.8.4 Fortran subroutine added in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Oopen_by_addr(hid_t loc_id, haddr_t addr);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieves the metadata for an object specified by an identifier
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[out] oinfo Buffer in which to return object information
+ *
+ * \return \herr_t
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Oget_info3() or the macro #H5Oget_info.
+ *
+ * \details H5Oget_info1() specifies an object by its identifier, \p loc_id , and
+ *          retrieves the metadata describing that object in \p oinfo.
+ *
+ * \note If you are iterating through a lot of different objects to
+ *       retrieve information via the H5Oget_info() family of routines,
+ *       you may see memory building up. This can be due to memory
+ *       allocation for metadata, such as object headers and messages,
+ *       when the iterated objects are put into the metadata cache.
+ * \note
+ *       If the memory buildup is not desirable, you can configure a
+ *       smaller cache via H5Fset_mdc_config() or set the file access
+ *       property list via H5Pset_mdc_config(). A smaller sized cache
+ *       will force metadata entries to be evicted from the cache,
+ *       thus freeing the memory associated with the entries.
+ *
+ * \version 1.10.5 The macro #H5Oget_info was removed and the function
+ *                 H5Oget_info1() was copied to H5Oget_info().
+ * \version 1.10.3 Function H5Oget_info() was copied to H5Oget_info1(),
+ *                 and the macro #H5Oget_info was created.
+ * \version 1.8.15 Added a note about the valid values for the \c version
+ *                 field in the H5O_hdr_info_t structure.
+ * \version 1.8.11 Fortran subroutine introduced in this release.
+ * \version 1.8.10 Added #H5O_type_t structure to the Description section. \n
+ *                 Separated H5O_hdr_info_t structure from #H5O_info_t in the
+ *                 Description section. \n
+ *                 Clarified the definition and implementation of the time fields.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Oget_info1(hid_t loc_id, H5O_info1_t *oinfo);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieves the metadata for an object, identifying the object
+ *        by location and relative name
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] name Name of object, relative to \p loc_id
+ * \param[out] oinfo Buffer in which to return object information
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Oget_info_by_name2() or the macro #H5Oget_info_by_name.
+ *
+ * \details H5Oget_info_by_name1() specifies an object's location and name, \p loc_id
+ *          and \p name, respectively, and retrieves the metadata describing that object
+ *          in \p oinfo, an H5O_info1_t \c struct.
+ *
+ *          The \c struct H5O_info1_t is defined in H5Opublic.h and described
+ *          in the H5Oget_info1() function entry.
+ *
+ *          The link access property list, \p lapl_id, is not currently used;
+ *          it should be passed in as #H5P_DEFAULT.
+ *
+ * \version 1.10.5 The macro #H5Oget_info_by_name was removed and the function
+ *                 H5Oget_info_by_name1() was copied to H5Oget_info_by_name().
+ * \version 1.10.3 Function H5Oget_info_by_name() was copied to H5Oget_info_by_name1()
+ *                 and the macro #H5Oget_info_by_name was created.
+ * \version 1.8.8 Fortran 2003 subroutine and \c h5o_info_t derived type introduced
+ *                in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Oget_info_by_name1(hid_t loc_id, const char *name, H5O_info1_t *oinfo, hid_t lapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieves the metadata for an object, identifying the object
+ *        by an index position
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] group_name Name of group in which object is located
+ * \idx_type
+ * \order
+ * \param[in] n Position within the index
+ * \param[out] oinfo Buffer in which to return object information
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Oget_info_by_idx3() or the macro H5Oget_info_by_idx().
+ *
+ * \details H5Oget_info_by_idx1() retrieves the metadata describing an
+ *          object in the \c struct \p oinfo, as specified by the location,
+ *          \p loc_id, group name, \p group_name, the index by which objects
+ *          in that group are tracked, \p idx_type, the order by which the
+ *          index is to be traversed, \p order, and an object's position
+ *          \p n within that index.
+ *
+ *          If \p loc_id fully specifies the group in which the object resides,
+ *          \p group_name can be a dot (\c .).
+ *
+ *          The link access property list, \c lapl_id, is not currently used;
+ *          it should be passed in as #H5P_DEFAULT.
+ *
+ * \version 1.10.5 The macro #H5Oget_info_by_idx was removed and the function
+ *                 H5Oget_info_by_idx() was copied to H5Oget_info_by_idx1().
+ * \version 1.10.3 Function H5Oget_info_by_idx() was copied to H5Oget_info_by_idx1()
+ *                 and the macro #H5Oget_info_by_idx was created.
+ * \version 1.8.11 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Oget_info_by_idx1(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                  H5_iter_order_t order, hsize_t n, H5O_info1_t *oinfo, hid_t lapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieves the metadata for an object specified by an identifier
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[out] oinfo Buffer in which to return object information
+ * \param[in] fields Flags specifying the fields to include in \p oinfo
+ *
+ * \return \herr_t
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Oget_info3() or the macro H5Oget_info().
+ *
+ * \details H5Oget_info2() specifies an object by its identifier, \p loc_id , and
+ *          retrieves the metadata describing that object in \p oinfo , an H5O_info1_t \c struct.
+ *          This \c struct type is described in H5Oget_info1().
+ *
+ *          The \p fields parameter contains flags to determine which fields will be filled in
+ *          the H5O_info1_t \c struct returned in \p oinfo.
+ *          These flags are defined in the H5Opublic.h file:
+ *
+ *          \obj_info_fields
+ *
+ * \note If you are iterating through a lot of different objects to
+ *       retrieve information via the H5Oget_info() family of routines,
+ *       you may see memory building up. This can be due to memory
+ *       allocation for metadata, such as object headers and messages,
+ *       when the iterated objects are put into the metadata cache.
+ * \note
+ *       If the memory buildup is not desirable, you can configure a
+ *       smaller cache via H5Fset_mdc_config() or set the file access
+ *       property list via H5Pset_mdc_config(). A smaller sized cache
+ *       will force metadata entries to be evicted from the cache,
+ *       thus freeing the memory associated with the entries.
+ *
+ * \since 1.10.3
+ *
+ */
+H5_DLL herr_t H5Oget_info2(hid_t loc_id, H5O_info1_t *oinfo, unsigned fields);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieves the metadata for an object, identifying the object
+ *        by location and relative name
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] name Name of object, relative to \p loc_id
+ * \param[out] oinfo Buffer in which to return object information
+ * \param[in] fields Flags specifying the fields to include in \p oinfo
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Oget_info_by_name3() or the macro H5Oget_info_by_name().
+ *
+ * \details H5Oget_info_by_name2() specifies an object's location and name, \p loc_id and
+ *          \p name, respectively, and retrieves the metadata describing
+ *          that object in \p oinfo, an H5O_info1_t \c struct.
+ *
+ *          The \c struct H5O_info1_t is defined in H5Opublic.h and described
+ *          in the H5Oget_info1() function entry.
+ *
+ *          The \p fields parameter contains flags to determine which fields
+ *          will be filled in the H5O_info1_t \c struct returned in
+ *          \p oinfo. These flags are defined in the H5Opublic.h file:
+ *
+ *          \obj_info_fields
+ *
+ *          The link access property list, \p lapl_id, is not currently used;
+ *          it should be passed in as #H5P_DEFAULT.
+ *
+ * \since 1.10.3
+ *
+ */
+H5_DLL herr_t H5Oget_info_by_name2(hid_t loc_id, const char *name, H5O_info1_t *oinfo, unsigned fields,
+                                   hid_t lapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Retrieves the metadata for an object, identifying the object
+ *        by an index position
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] group_name Name of group in which object is located
+ * \idx_type
+ * \order
+ * \param[in]  n Position within the index
+ * \param[out] oinfo Buffer in which to return object information
+ * \param[in] fields Flags specifying the fields to include in \p oinfo
+ * \lapl_id
+ *
+ * \return \herr_t
+ *
+ * \deprecated As of HDF5-1.12 this function is deprecated in favor of
+ *             the function H5Oget_info_by_idx3() or the macro #H5Oget_info_by_idx.
+ *
+ * \details H5Oget_info_by_idx2() retrieves the metadata describing an
+ *          object in the \c struct \p oinfo, as specified by the location,
+ *          \p loc_id, group name, \p group_name, the index by which objects
+ *          in that group are tracked, \p idx_type, the order by which the
+ *          index is to be traversed, \p order, and an object's position
+ *          \p n within that index.
+ *
+ *          \p oinfo, in which the object information is returned, is a \c struct of
+ *          type H5O_info1_t.  This and other \c struct types used
+ *          by H5Oget_info_by_idx2() are described in H5Oget_info_by_idx1().
+ *
+ *          If \p loc_id fully specifies the group in which the object resides,
+ *          i\p group_name can be a dot (\c .).
+ *
+ *          The \p fields parameter contains flags to determine which fields will be
+ *          filled in the H5O_info1_t \c struct returned in \p oinfo.
+ *          These flags are defined in the H5Opublic.h file:
+ *          \obj_info_fields
+ *
+ *          The link access property list, \c lapl_id, is not currently used;
+ *          it should be passed in as #H5P_DEFAULT.
+ *
+ * \since 1.10.3
+ *
+ */
+H5_DLL herr_t H5Oget_info_by_idx2(hid_t loc_id, const char *group_name, H5_index_t idx_type,
+                                  H5_iter_order_t order, hsize_t n, H5O_info1_t *oinfo, unsigned fields,
+                                  hid_t lapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Recursively visits all objects accessible from a specified object
+ *
+ * \fgdta_loc_obj_id{obj_id}
+ * \idx_type
+ * \order
+ * \param[in] op Callback function passing data regarding the object
+ *               to the calling application
+ * \param[in] op_data User-defined pointer to data required by the application
+ *                    for its processing of the object
+ *
+ * \return On success, returns the return value of the first operator
+ *         that returns a positive value, or zero if all members were
+ *         processed with no operator returning non-zero.
+ *
+ * \return On failure, returns a negative value if something goes wrong
+ *         within the library, or the first negative value returned by
+ *         an operator.
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Ovisit3() or the macro #H5Ovisit.
+ *
+ * \details H5Ovisit1() is a recursive iteration function to visit the
+ *          object \p obj_id and, if \p obj_id is a group, all objects in
+ *          and below it in an HDF5 file, thus providing a mechanism for
+ *          an application to perform a common set of operations across all
+ *          of those objects or a dynamically selected subset. For
+ *          non-recursive iteration across the members of a group,
+ *          see  H5Literate1().
+ *
+ *          If \p obj_id is a group identifier, that group serves as the
+ *          root of a recursive iteration. If \p obj_id is a file identifier,
+ *          that file's root group serves as the root of the recursive
+ *          iteration.  If \p obj_id is an attribute identifier,
+ *          then the object where the attribute is attached will be iterated.
+ *          If \p obj_id is any other type of object, such as a dataset or
+ *          named datatype, there is no iteration.
+ *
+ *          Two parameters are used to establish the iteration: \p idx_type
+ *          and \p order.
+ *
+ *          \p idx_type specifies the index to be used. If the links in
+ *          a group have not been indexed by the index type, they will
+ *          first be sorted by that index then the iteration will begin;
+ *          if the links have been so indexed, the sorting step will be
+ *          unnecessary, so the iteration may begin more quickly.
+ *
+ *          Note that the index type passed in \p idx_type is a
+ *          <em>best effort</em> setting. If the application passes in
+ *          a value indicating iteration in creation order and a group is
+ *          encountered that was not tracked in creation order, that group
+ *          will be iterated over in alphanumeric order by name, or
+ *          <em>name order</em>.  (<em>Name order</em> is the native order
+ *          used by the HDF5 library and is always available.)
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index specified in \p idx_type.
+ *
+ *          H5Lvisit1() and H5Ovisit1() are companion functions: one for
+ *          examining and operating on links; the other for examining
+ *          and operating on the objects that those links point to. Both
+ *          functions ensure that by the time the function completes
+ *          successfully, every link or object below the specified point
+ *          in the file has been presented to the application for whatever
+ *          processing the application requires. These functions assume
+ *          that the membership of the group being iterated over remains
+ *          unchanged through the iteration; if any of the links in the
+ *          group change during the iteration, the resulting behavior
+ *          is undefined.
+ *
+ * \version 1.10.5 The macro #H5Ovisit was removed and the function
+ *          H5Ovisit1() was copied to H5Ovisit().
+ * \version 1.10.3 Function H5Ovisit() was copied to H5Ovisit1(),
+ *          and the macro #H5Ovisit was created.
+ * \version 1.8.8 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Ovisit1(hid_t obj_id, H5_index_t idx_type, H5_iter_order_t order, H5O_iterate1_t op,
+                        void *op_data);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Recursively visits all objects starting from a specified object
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] obj_name Name of the object, generally relative to
+ *                     \p loc_id, that will serve as root of the iteration
+ * \idx_type
+ * \order
+ * \param[in] op Callback function passing data regarding the object
+ *               to the calling application
+ * \param[in] op_data User-defined pointer to data required by the application
+ *                    for its processing of the object
+ * \lapl_id
+ *
+ * \return On success, returns the return value of the first operator
+ *         that returns a positive value, or zero if all members were
+ *         processed with no operator returning non-zero.
+ *
+ * \return On failure, returns a negative value if something goes wrong
+ *         within the library, or the first negative value returned by
+ *         an operator.
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Ovisit_by_name3() or the macro #H5Ovisit_by_name.
+ *
+ * \details H5Ovisit_by_name1() is a recursive iteration function to visit
+ *          the object specified by the \p loc_id / \p obj_name parameter
+ *          pair and, if that object is a group, all objects in and below it
+ *          in an HDF5 file, thus providing a mechanism for an application to
+ *          perform a common set of operations across all of those objects or
+ *          a dynamically selected subset. For non-recursive iteration across
+ *          the members of a group, see H5Literate1().
+ *
+ *          The object serving as the root of the iteration is specified
+ *          by the \p loc_id / \p obj_name parameter pair. \p loc_id specifies
+ *          a file or an object in a file;  if \p loc_id is an attribute identifier,
+ *          the object where the attribute is attached will be used.
+ *          \p obj_name specifies either an object in the file (with an absolute
+ *          name based on the file's root group) or an object name relative
+ *          to \p loc_id. If \p loc_id fully specifies the object that is to serve
+ *          as the root of the iteration, \p obj_name should be '\c .' (a dot).
+ *          (Note that when \p loc_id fully specifies the object that is to serve
+ *          as the root of the iteration, the user may wish to consider
+ *          using H5Ovisit1() instead of H5Ovisit_by_name1().)
+ *
+ *          Two parameters are used to establish the iteration: \p idx_type
+ *          and \p order.
+ *
+ *          \p idx_type specifies the index to be used. If the links in
+ *          a group have not been indexed by the index type, they will
+ *          first be sorted by that index then the iteration will begin;
+ *          if the links have been so indexed, the sorting step will be
+ *          unnecessary, so the iteration may begin more quickly.
+ *
+ *          Note that the index type passed in \p idx_type is a
+ *          <em>best effort</em> setting. If the application passes in a
+ *          value indicating iteration in creation order and a group is
+ *          encountered that was not tracked in creation order, that group
+ *          will be iterated over in alphanumeric order by name, or
+ *          <em>name order</em>.  (<em>Name order</em> is the native order
+ *          used by the HDF5 library and is always available.)
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index specified in \p idx_type.
+ *
+ *          The \p op callback function and the effect of the callback
+ *          function's return value on the application are described
+ *          in H5Ovisit1().
+ *
+ *          The H5O_info1_t \c struct is defined in H5Opublic.h
+ *          and described in the H5Oget_info1() function entry.
+ *
+ *          The H5Ovisit_by_name1() \p op_data parameter is a user-defined
+ *          pointer to the data required to process objects in the course
+ *          of the iteration. This pointer is passed back to each step of
+ *          the iteration in the callback function's \p op_data parameter.
+ *
+ *          \p lapl_id is a link access property list. In the general case,
+ *          when default link access properties are acceptable, this can
+ *          be passed in as #H5P_DEFAULT. An example of a situation that
+ *          requires a non-default link access property list is when
+ *          the link is an external link; an external link may require
+ *          that a link prefix be set in a link access property list
+ *          (see H5Pset_elink_prefix()).
+ *
+ *          H5Lvisit_by_name1() and H5Ovisit_by_name1() are companion
+ *          functions: one for examining and operating on links; the other
+ *          for examining and operating on the objects that those links point to.
+ *          Both functions ensure that by the time the function completes
+ *          successfully, every link or object below the specified point
+ *          in the file has been presented to the application for whatever
+ *          processing the application requires.
+ *
+ * \version 1.10.5 The macro #H5Ovisit_by_name was removed and the function
+ *          H5Ovisit_by_name1() was copied to #H5Ovisit_by_name.
+ * \version 1.10.3 The H5Ovisit_by_name() function was renamed to H5Ovisit_by_name1(),
+ *          and the macro #H5Ovisit_by_name was created.
+ * \version 1.8.11 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Ovisit_by_name1(hid_t loc_id, const char *obj_name, H5_index_t idx_type,
+                                H5_iter_order_t order, H5O_iterate1_t op, void *op_data, hid_t lapl_id);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Recursively visits all objects accessible from a specified object
+ *
+ * \fgdta_loc_obj_id{obj_id}
+ * \idx_type
+ * \order
+ * \param[in] op Callback function passing data regarding the object
+ *               to the calling application
+ * \param[in] op_data User-defined pointer to data required by the application
+ *                    for its processing of the object
+ * \param[in] fields Flags specifying the fields to be retrieved to the
+ *                   callback \p op
+ *
+ * \return On success, returns the return value of the first operator
+ *         that returns a positive value, or zero if all members were
+ *         processed with no operator returning non-zero.
+ *
+ * \return On failure, returns a negative value if something goes wrong
+ *         within the library, or the first negative value returned by
+ *         an operator.
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Ovisit3() or the macro #H5Ovisit.
+ *
+ * \details H5Ovisit2() is a recursive iteration function to visit the
+ *          object \p obj_id and, if \p obj_id is a group, all objects in
+ *          and below it in an HDF5 file, thus providing a mechanism for
+ *          an application to perform a common set of operations across all
+ *          of those objects or a dynamically selected subset. For
+ *          non-recursive iteration across the members of a group,
+ *          see H5Literate1().
+ *
+ *          If \p obj_id is a group identifier, that group serves as the
+ *          root of a recursive iteration. If \p obj_id is a file identifier,
+ *          that file's root group serves as the root of the recursive
+ *          iteration.  If \p obj_id is an attribute identifier,
+ *          then the object where the attribute is attached will be iterated.
+ *          If \p obj_id is any other type of object, such as a dataset or
+ *          named datatype, there is no iteration.
+ *
+ *          Two parameters are used to establish the iteration: \p idx_type
+ *          and \p order.
+ *
+ *          \p idx_type specifies the index to be used. If the links in
+ *          a group have not been indexed by the index type, they will
+ *          first be sorted by that index then the iteration will begin;
+ *          if the links have been so indexed, the sorting step will be
+ *          unnecessary, so the iteration may begin more quickly.
+ *
+ *          Note that the index type passed in \p idx_type is a
+ *          <em>best effort</em> setting. If the application passes in
+ *          a value indicating iteration in creation order and a group is
+ *          encountered that was not tracked in creation order, that group
+ *          will be iterated over in alphanumeric order by name, or
+ *          <em>name order</em>.  (<em>Name order</em> is the native order
+ *          used by the HDF5 library and is always available.)
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index specified in \p idx_type.
+ *
+ *          The \p fields parameter contains flags to determine which fields will
+ *          be retrieved by the \p op callback function. These flags are defined
+ *          in the H5Opublic.h file:
+ *          \obj_info_fields
+ *
+ *          H5Lvisit() and H5Ovisit() are companion functions: one for
+ *          examining and operating on links; the other for examining
+ *          and operating on the objects that those links point to. Both
+ *          functions ensure that by the time the function completes
+ *          successfully, every link or object below the specified point
+ *          in the file has been presented to the application for whatever
+ *          processing the application requires. These functions assume
+ *          that the membership of the group being iterated over remains
+ *          unchanged through the iteration; if any of the links in the
+ *          group change during the iteration, the resulting behavior
+ *          is undefined.
+ *
+ *
+ * \since 1.10.3
+ *
+ */
+H5_DLL herr_t H5Ovisit2(hid_t obj_id, H5_index_t idx_type, H5_iter_order_t order, H5O_iterate1_t op,
+                        void *op_data, unsigned fields);
+
+/**
+ *-------------------------------------------------------------------------
+ * \ingroup H5O
+ *
+ * \brief Recursively visits all objects starting from a specified object
+ *
+ * \fgdta_loc_obj_id{loc_id}
+ * \param[in] obj_name Name of the object, generally relative to
+ *                     \p loc_id, that will serve as root of the iteration
+ * \idx_type
+ * \order
+ * \param[in] op Callback function passing data regarding the object
+ *               to the calling application
+ * \param[in] op_data User-defined pointer to data required by the application
+ *                    for its processing of the object
+ * \param[in] fields Flags specifying the fields to be retrieved to the
+ *                   callback function \p op
+ * \lapl_id
+ *
+ * \return On success, returns the return value of the first operator
+ *         that returns a positive value, or zero if all members were
+ *         processed with no operator returning non-zero.
+ *
+ * \return On failure, returns a negative value if something goes wrong
+ *         within the library, or the first negative value returned by
+ *         an operator.
+ *
+ * \deprecated As of HDF5-1.12 this function has been deprecated in favor of
+ *             the function H5Ovisit_by_name3() or the macro #H5Ovisit_by_name.
+ *
+ * \details H5Ovisit_by_name2() is a recursive iteration function to visit
+ *          the object specified by the \p loc_id / \p obj_name parameter
+ *          pair and, if that object is a group, all objects in and below it
+ *          in an HDF5 file, thus providing a mechanism for an application to
+ *          perform a common set of operations across all of those objects or
+ *          a dynamically selected subset. For non-recursive iteration across
+ *          the members of a group, see #H5Literate.
+ *
+ *          The object serving as the root of the iteration is specified
+ *          by the \p loc_id / \p obj_name parameter pair. \p loc_id specifies
+ *          a file or an object in a file;  if \p loc_id is an attribute identifier,
+ *          the object where the attribute is attached will be used.
+ *          \p obj_name specifies either an object in the file (with an absolute
+ *          name based in the file's root group) or an object name relative
+ *          to \p loc_id. If \p loc_id fully specifies the object that is to serve
+ *          as the root of the iteration, \p obj_name should be '\c .' (a dot).
+ *          (Note that when \p loc_id fully specifies the object that is to serve
+ *          as the root of the iteration, the user may wish to consider
+ *          using H5Ovisit2() instead of #H5Ovisit_by_name.)
+ *
+ *          Two parameters are used to establish the iteration: \p idx_type
+ *          and \p order.
+ *
+ *          \p idx_type specifies the index to be used. If the links in
+ *          a group have not been indexed by the index type, they will
+ *          first be sorted by that index then the iteration will begin;
+ *          if the links have been so indexed, the sorting step will be
+ *          unnecessary, so the iteration may begin more quickly.
+ *
+ *          Note that the index type passed in \p idx_type is a
+ *          <em>best effort</em> setting. If the application passes in a
+ *          value indicating iteration in creation order and a group is
+ *          encountered that was not tracked in creation order, that group
+ *          will be iterated over in alphanumeric order by name, or
+ *          <em>name order</em>.  (<em>Name order</em> is the native order
+ *          used by the HDF5 library and is always available.)
+ *
+ *          \p order specifies the order in which objects are to be inspected
+ *          along the index specified in \p idx_type.
+ *
+ *          The \p op callback function and the effect of the callback
+ *          function's return value on the application are described
+ *          in H5Ovisit2().
+ *
+ *          The H5O_info1_t \c struct is defined in H5Opublic.h
+ *          and described in the H5Oget_info1() function entry.
+ *
+ *          The H5Ovisit_by_name2() \p op_data parameter is a user-defined
+ *          pointer to the data required to process objects in the course
+ *          of the iteration. This pointer is passed back to each step of
+ *          the iteration in the callback function's \p op_data parameter.
+ *
+ *          \p lapl_id is a link access property list. In the general case,
+ *          when default link access properties are acceptable, this can
+ *          be passed in as #H5P_DEFAULT. An example of a situation that
+ *          requires a non-default link access property list is when
+ *          the link is an external link; an external link may require
+ *          that a link prefix be set in a link access property list
+ *          (see H5Pset_elink_prefix()).
+ *
+ *          The \p fields parameter contains flags to determine which fields will
+ *          be retrieved by the \p op callback function. These flags are defined
+ *          in the H5Opublic.h file:
+ *          \obj_info_fields
+ *
+ *          #H5Lvisit_by_name and #H5Ovisit_by_name are companion
+ *          functions: one for examining and operating on links; the other
+ *          for examining and operating on the objects that those links point to.
+ *          Both functions ensure that by the time the function completes
+ *          successfully, every link or object below the specified point
+ *          in the file has been presented to the application for whatever
+ *          processing the application requires.
+ *
+ * \since 1.10.3
+ *
+ */
+H5_DLL herr_t H5Ovisit_by_name2(hid_t loc_id, const char *obj_name, H5_index_t idx_type,
+                                H5_iter_order_t order, H5O_iterate1_t op, void *op_data, unsigned fields,
+                                hid_t lapl_id);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* H5Opublic_H */
diff --git a/install/include/H5PLextern.h b/install/include/H5PLextern.h
new file mode 100644
index 0000000000..d136051bed
--- /dev/null
+++ b/install/include/H5PLextern.h
@@ -0,0 +1,43 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:     Header file for writing external HDF5 plugins.
+ */
+
+#ifndef H5PLextern_H
+#define H5PLextern_H
+
+/* Include HDF5 header */
+#include "hdf5.h"
+
+/* plugins always export */
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5PLUGIN_DLL __declspec(dllexport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5PLUGIN_DLL __attribute__((visibility("default")))
+#else
+#define H5PLUGIN_DLL
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5PLUGIN_DLL H5PL_type_t H5PLget_plugin_type(void);
+H5PLUGIN_DLL const void *H5PLget_plugin_info(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5PLextern_H */
diff --git a/install/include/H5PLpublic.h b/install/include/H5PLpublic.h
new file mode 100644
index 0000000000..ca99697748
--- /dev/null
+++ b/install/include/H5PLpublic.h
@@ -0,0 +1,228 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5PL module.
+ */
+
+#ifndef H5PLpublic_H
+#define H5PLpublic_H
+
+#include "H5public.h" /* Generic Functions                        */
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/* Special string to indicate no plugin loading.
+ */
+#define H5PL_NO_PLUGIN "::"
+
+//! <!-- [H5PL_type_t_snip] -->
+/**
+ * Plugin type (bit-position) used by the plugin library
+ */
+typedef enum H5PL_type_t {
+    H5PL_TYPE_ERROR  = -1, /**< Error                */
+    H5PL_TYPE_FILTER = 0,  /**< Filter               */
+    H5PL_TYPE_VOL    = 1,  /**< VOL connector        */
+    H5PL_TYPE_VFD    = 2,  /**< VFD                  */
+    H5PL_TYPE_NONE   = 3   /**< Sentinel: This must be last!   */
+} H5PL_type_t;
+//! <!-- [H5PL_type_t_snip] -->
+
+/* Common dynamic plugin type flags used by the set/get_loading_state functions */
+#define H5PL_FILTER_PLUGIN 0x0001
+#define H5PL_VOL_PLUGIN    0x0002
+#define H5PL_VFD_PLUGIN    0x0004
+#define H5PL_ALL_PLUGIN    0xFFFF
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* plugin state */
+/**
+ * \ingroup H5PL
+ * \brief Controls the loadability of dynamic plugin types
+ *
+ * \param[in] plugin_control_mask The list of dynamic plugin types to enable or disable.\n
+ *                                A plugin bit set to 0 (zero) prevents use of that dynamic plugin.\n
+ *                                A plugin bit set to 1 (one) enables use of that dynamic plugin.\n
+ *                                Setting \p plugin_control_mask to a negative value enables all dynamic
+ *                                plugin types.\n
+ *                                Setting \p plugin_control_mask to 0 (zero) disables all dynamic plugin\n
+ *                                types.
+ * \return \herr_t
+ *
+ * \details H5PLset_loading_state() uses one argument to enable or disable individual plugin types.
+ *
+ * \details The \p plugin_control_mask parameter is an encoded integer in which each bit controls a specific
+ *          plugin type. Bit positions allocated to date are specified in \ref H5PL_type_t as follows:
+ *          \snippet this H5PL_type_t_snip
+ *
+ *          A plugin bit set to 0 (zero) prevents the use of the dynamic plugin type corresponding to that bit
+ *          position. A plugin bit set to 1 (one) allows the use of that dynamic plugin type.
+ *
+ *          All dynamic plugin types can be enabled by setting \p plugin_control_mask to a negative value. A
+ *          value of 0 (zero) will disable all dynamic plugin types.
+ *
+ *          The loading of external dynamic plugins can be controlled during runtime with an environment
+ *          variable, \c HDF5_PLUGIN_PRELOAD. H5PLset_loading_state() inspects the \c HDF5_PLUGIN_PRELOAD
+ *          environment variable every time it is called. If the environment variable is set to the special
+ *          \c :: string, all dynamic plugins are disabled.
+ *
+ * \warning The environment variable \c HDF5_PLUGIN_PRELOAD controls the loading of dynamic plugin types at
+ *          runtime. If it is set to disable all plugin types, then it will disable them for \Emph{all}
+ *          running programs that access the same variable instance.
+ *
+ * \since 1.8.15
+ *
+ */
+H5_DLL herr_t H5PLset_loading_state(unsigned int plugin_control_mask);
+/**
+ * \ingroup H5PL
+ * \brief Queries the loadability of dynamic plugin types
+ *
+ * \param[out] plugin_control_mask List of dynamic plugin types that are enabled or disabled.\n
+ *                                 A plugin bit set to 0 (zero) indicates that the dynamic plugin type is
+ *                                 disabled.\n
+ *                                 A plugin bit set to 1 (one) indicates that the dynamic plugin type is
+ *                                 enabled.\n
+ *                                 If the value of \p plugin_control_mask is negative, all dynamic plugin
+ *                                 types are enabled.\n
+ *                                 If the value of \p plugin_control_mask is 0 (zero), all dynamic plugins
+ *                                 are disabled.
+ * \return \herr_t
+ *
+ * \details H5PLget_loading_state() retrieves the bitmask that controls whether a certain type of plugin
+ *          (e.g.: filters, VOL drivers) will be loaded by the HDF5 library.
+ *
+ *          Bit positions allocated to date are specified in \ref H5PL_type_t as follows:
+ *          \snippet this H5PL_type_t_snip
+ *
+ * \since 1.8.15
+ *
+ */
+H5_DLL herr_t H5PLget_loading_state(unsigned int *plugin_control_mask /*out*/);
+/**
+ * \ingroup H5PL
+ * \brief Inserts a plugin path at the end of the plugin search path list
+ *
+ * \param[in] search_path A plugin path
+ * \return \herr_t
+ *
+ * \details H5PLappend() inserts a plugin path at the end of the plugin search path list.
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5PLappend(const char *search_path);
+/**
+ * \ingroup H5PL
+ * \brief Inserts a plugin path at the beginning of the plugin search path list
+ *
+ * \param[in] search_path A plugin path
+ * \return \herr_t
+ *
+ * \details H5PLprepend() inserts a plugin path at the end of the plugin search path list.
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5PLprepend(const char *search_path);
+/**
+ * \ingroup H5PL
+ * \brief Replaces the path at the specified index in the plugin search path list
+ *
+ * \param[in] search_path A plugin path
+ * \param[in] index Index
+ * \return \herr_t
+ *
+ * \details H5PLreplace() replaces a plugin path at the specified index in the plugin search path list.
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5PLreplace(const char *search_path, unsigned int index);
+/**
+ * \ingroup H5PL
+ * \brief Inserts a path at the specified index in the plugin search path list
+ *
+ * \param[in] search_path A plugin path
+ * \param[in] index Index
+ * \return \herr_t
+ *
+ * \details H5PLinsert() inserts a plugin path at the specified index in the plugin search path list,
+ *          moving other paths after \p index.
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5PLinsert(const char *search_path, unsigned int index);
+/**
+ * \ingroup H5PL
+ * \brief Removes a plugin path at a specified index from the plugin search path list
+ *
+ * \param[in] index Index
+ * \return \herr_t
+ *
+ * \details H5PLremove() removes a plugin path at the specified \p index and compacts the plugin search path
+ *          list.
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5PLremove(unsigned int index);
+/**
+ * \ingroup H5PL
+ * \brief Queries the plugin search path list at the specified index
+ *
+ * \param[in] index Index
+ * \param[out] path_buf Pathname
+ * \param[in] buf_size Size of \p path_buf
+ * \return Returns the length of the path, a non-negative value, if successful; otherwise returns a negative
+ *         value.
+ *
+ * \details H5PLget() queries the plugin path at a specified index. If \p path_buf is non-NULL then it writes
+ *          up to \p buf_size bytes into that buffer and always returns the length of the path name.
+ *
+ *          If \p path_buf is NULL, this function will simply return the number of characters required to
+ *          store the path name, ignoring \p path_buf and \p buf_size.
+ *
+ *          If an error occurs then the buffer pointed to by \p path_buf (NULL or non-NULL) is unchanged and
+ *          the function returns a negative value. If a zero is returned for the name's length, then there is
+ *          no path name associated with the index. and the \p path_buf buffer will be unchanged.
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL ssize_t H5PLget(unsigned int index, char *path_buf /*out*/, size_t buf_size);
+/**
+ * \ingroup H5PL
+ * \brief Retrieves the number of stored plugin paths
+ *
+ * \param[out] num_paths Current length of the plugin search path list
+ * \return \herr_t
+ *
+ * \details H5PLsize() retrieves the number of paths stored in the plugin search path list.
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5PLsize(unsigned int *num_paths /*out*/);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5PLpublic_H */
diff --git a/install/include/H5PTpublic.h b/install/include/H5PTpublic.h
new file mode 100644
index 0000000000..3016e77ba6
--- /dev/null
+++ b/install/include/H5PTpublic.h
@@ -0,0 +1,517 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef H5PTpublic_H
+#define H5PTpublic_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** \page H5PT_UG The HDF5 High Level Packet Table
+ * @todo Under Construction
+ */
+
+/**\defgroup H5PT HDF5 Packet Table APIs (H5PT)
+ *
+ * <em>Creating and manipulating HDF5 datasets to support append-
+ * and read-only operations on table data (H5PT)</em>
+ *
+ * The HDF5 Packet Table API is designed to allow records to be
+ * appended to and read from a table. Packet Table datasets are
+ * chunked, allowing them to grow as needed.
+ *
+ * The Packet Table API, with the H5PT prefix, is not to be confused with
+ * the H5TB Table API (H5TB prefix). The H5TB APIs are stateless
+ * (H5TB Tables do not need to be opened or closed) but H5PT Packet Tables
+ * require less performance overhead. Also, H5TB Tables support insertions
+ * and deletions, while H5PT Packet Tables support only append operations.
+ * H5TB functions should not be called on tables created with the
+ * H5PT API, or vice versa.
+ *
+ * Packet Tables are datasets in an HDF5 file, so while their contents
+ * should not be changed outside of the H5PT API calls, the datatypes of
+ * Packet Tables can be queried using \ref H5Dget_type.
+ * Packet Tables can also be given attributes using the normal HDF5 APIs.
+ *
+ * \note \Bold{Programming hints:}
+ * \note The following line includes the HDF5 Packet Table package, H5PT,
+ *       in C applications:
+ *       \code #include "hdf5_hl.h" \endcode
+ *       Without this include, an application will not have access to
+ *       these functions.
+ *
+ * - \ref H5PTappend
+ *   \n Appends packets to the end of a packet table.
+ * - \ref H5PTclose
+ *   \n Closes an open packet table.
+ * - \ref H5PTcreate
+ *   \n Creates a packet table to store fixed-length
+ *      or variable-length packets.
+ * - \ref H5PTcreate_fl
+ *   \n Creates a packet table to store fixed-length packets.
+ * - \ref H5PTcreate_index
+ *   \n Resets a packet table's index to the first packet.
+ * - \ref H5PTfree_vlen_buff
+ *   \n Releases memory allocated in the process of
+ *      reading variable-length packets.
+ * - \ref H5PTget_dataset
+ *   \n Returns the backend dataset of this packet table.
+ * - \ref H5PTget_index
+ *   \n Gets the current record index for a packet table
+ * - \ref H5PTget_next
+ *   \n Reads packets from a packet table starting at the
+ *      current index.
+ * - \ref H5PTget_num_packets
+ *   \n Returns the number of packets in a packet table.
+ * - \ref H5PTget_type
+ *   \n Returns the backend datatype of this packet table.
+ * - \ref H5PTis_valid
+ *   \n Determines whether an identifier points to a packet table.
+ * - \ref H5PTis_varlen
+ *   \n Determines whether a packet table contains variable-length
+ *      or fixed-length packets.
+ * - \ref H5PTopen
+ *   \n Opens an existing packet table.
+ * - \ref H5PTread_packets
+ *   \n Reads a number of packets from a packet table.
+ * - \ref H5PTset_index
+ *   \n Sets a packet table's index.
+ *
+ */
+
+/*-------------------------------------------------------------------------
+ * Create/Open/Close functions
+ *-------------------------------------------------------------------------
+ */
+/* NOTE: H5PTcreate is replacing H5PTcreate_fl for better name due to the
+   removal of H5PTcreate_vl.  H5PTcreate_fl may be retired in 1.8.19. */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief   Creates a packet table to store fixed-length or
+ *          variable-length packets.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name     The name of the packet table to create
+ * \param[in] dtype_id      The datatype of the packet
+ * \param[in] chunk_size    The size in number of table entries per chunk
+ * \param[in] plist_id      Identifier of the property list. Can be used to
+ *                          specify the compression of the packet table.
+ *
+ * \return Returns an identifier for the new packet table or
+ *         #H5I_INVALID_HID on error.
+ *
+ * \details The H5PTcreate() creates and opens a packet table named
+ *          \p dset_name attached to the object specified by the
+ *          identifier \p loc_id. The created packet table should be closed
+ *          with H5PTclose(), eventually.
+ *
+ *          The datatype, \p dtype_id, may specify any datatype, including
+ *          variable-length data.  If \p dtype_id specifies a compound
+ *          datatype, one or more fields in that compound type may be
+ *          variable-length.
+ *
+ *          \p chunk_size is the size in number of table entries per chunk.
+ *          Packet table datasets use HDF5 chunked storage
+ *          to allow them to grow. This value allows the user
+ *          to set the size of a chunk. The chunk size affects
+ *          performance.
+ *
+ * \since   1.10.0 and 1.8.17
+ *
+ */
+H5_HLDLL hid_t H5PTcreate(hid_t loc_id, const char *dset_name, hid_t dtype_id, hsize_t chunk_size,
+                          hid_t plist_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Opens an existing packet table.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name     The name of the packet table to open
+ *
+ * \return Returns an identifier for the packet table or
+ *         #H5I_INVALID_HID on error.
+ *
+ * \details H5PTopen() opens an existing packet table in the file or group
+ *          specified by \p loc_id. \p dset_name is the name of the packet
+ *          table and is used to identify it in the file. This function is
+ *          used to open both fixed-length packet tables and variable-length
+ *          packet tables. The packet table should later be closed with
+ *          H5PTclose().
+ *
+ */
+H5_HLDLL hid_t H5PTopen(hid_t loc_id, const char *dset_name);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Closes an open packet table.
+ *
+ * \param[in] table_id  Identifier of packet table to be closed
+ *
+ * \return \herr_t
+ *
+ * \details The H5PTclose() ends access to a packet table specified
+ *          by \p table_id.
+ *
+ */
+H5_HLDLL herr_t H5PTclose(hid_t table_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Creates a packet table to store fixed-length packets
+ *
+ * \fg_loc_id
+ * \param[in] dset_name     The name of the dataset to create
+ * \param[in] dtype_id      The datatype of a packet.
+ * \param[in] chunk_size    The size in number of table entries per
+ *                          chunk.
+ * \param[in] compression   The compression level;
+ *                          a value of 0 through 9.
+ *
+ * \return Returns an identifier for the packet table or
+ *         #H5I_INVALID_HID on error.
+ *
+ * \deprecated This function was deprecated in favor of the function
+ *             H5PTcreate().
+ *
+ * \details The H5PTcreate_fl() creates and opens a packet table
+ *          named \p dset_name attached to the object specified by
+ *          the identifier \p loc_id. It should be closed
+ *          with H5PTclose().
+ *
+ *          The datatype, \p dtype_id, may specify any datatype,
+ *          including variable-length data. If \p dtype_id specifies a
+ *          compound datatype, one or more fields in that compound type
+ *          may be variable-length.
+ *
+ *          \p chunk_size is the size in number of table entries per chunk.
+ *          Packet table datasets use HDF5 chunked storage
+ *          to allow them to grow. This value allows the user
+ *          to set the size of a chunk. The chunk size affects
+ *          performance.
+ *
+ *          \p compression is the compression level, a value of 0 through 9.
+ *          Level 0 is faster but offers the least compression;
+ *          level 9 is slower but offers maximum compression.
+ *          A setting of -1 indicates that no compression is desired.
+ *
+ */
+/* This function may be removed from the packet table in release 1.8.19. */
+H5_HLDLL hid_t H5PTcreate_fl(hid_t loc_id, const char *dset_name, hid_t dtype_id, hsize_t chunk_size,
+                             int compression);
+
+/*-------------------------------------------------------------------------
+ * Write functions
+ *-------------------------------------------------------------------------
+ */
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Appends packets to the end of a packet table.
+ *
+ * \param[in] table_id  Identifier of packet table to which
+ *                      packets should be appended
+ * \param[in] nrecords  Number of packets to be appended
+ * \param[in] data      Buffer holding data to write
+ *
+ * \return \herr_t
+ *
+ * \details The H5PTappend() writes \p nrecords packets to the end of a
+ *          packet table specified by \p table_id. \p data is a buffer
+ *          containing the data to be written. For a packet table holding
+ *          fixed-length packets, this data should be in the packet
+ *          table's datatype. For a variable-length packet table,
+ *          the data should be in the form of #hvl_t structs.
+ *
+ */
+H5_HLDLL herr_t H5PTappend(hid_t table_id, size_t nrecords, const void *data);
+
+/*-------------------------------------------------------------------------
+ * Read functions
+ *-------------------------------------------------------------------------
+ */
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Reads packets from a packet table starting at the current index.
+ *
+ * \param[in] table_id  Identifier of packet table to read from
+ * \param[in] nrecords  Number of packets to be read
+ * \param[out] data     Buffer into which to read data
+ *
+ * \return \herr_t
+ *
+ * \details The H5PTget_next() reads \p nrecords packets starting with
+ *          the "current index" from a packet table specified by \p table_id.
+ *          The packet table's index is set and reset with H5PTset_index()
+ *          and H5PTcreate_index(). \p data is a buffer into which the
+ *          data should be read.
+ *
+ *          For a packet table holding variable-length records, the data
+ *          returned in the buffer will be in form of a #hvl_t struct
+ *          containing the length of the data and a pointer to it in memory.
+ *          The memory used by this data must be freed using H5PTfree_vlen_buff().
+ *
+ */
+H5_HLDLL herr_t H5PTget_next(hid_t table_id, size_t nrecords, void *data);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Reads a number of packets from a packet table.
+ *
+ * \param[in] table_id  Identifier of packet table to read from
+ * \param[in] start     Packet to start reading from
+ * \param[in] nrecords  Number of packets to be read
+ * \param[out] data     Buffer into which to read data.
+ *
+ * \return \herr_t
+ *
+ * \details The H5PTread_packets() reads \p nrecords packets starting at
+ *          packet number \p start from a packet table specified by
+ *          \p table_id. \p data is a buffer into which the data should
+ *          be read.
+ *
+ *          For a packet table holding variable-length records, the data
+ *          returned in the buffer will be in form of #hvl_t structs,
+ *          each containing the length of the data and a pointer to it in
+ *          memory. The memory used by this data must be freed using
+ *          H5PTfree_vlen_buff().
+ *
+ */
+H5_HLDLL herr_t H5PTread_packets(hid_t table_id, hsize_t start, size_t nrecords, void *data);
+
+/*-------------------------------------------------------------------------
+ * Inquiry functions
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Returns the number of packets in a packet table.
+ *
+ * \param[in] table_id  Identifier of packet table to query
+ * \param[out] nrecords Number of packets in packet table
+ *
+ * \return \herr_t
+ *
+ * \details The H5PTget_num_packets() returns by reference the number
+ *          of packets in a packet table specified by \p table_id.
+ *
+ */
+H5_HLDLL herr_t H5PTget_num_packets(hid_t table_id, hsize_t *nrecords);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Determines whether an identifier points to a packet table.
+ *
+ * \param[in] table_id  Identifier to query
+ *
+ * \return Returns a non-negative value if \p table_id is
+ *         a valid packet table, otherwise returns a negative value.
+ *
+ * \details The H5PTis_valid() returns a non-negative value if
+ *          \p table_id corresponds to an open packet table,
+ *          and returns a negative value otherwise.
+ *
+ */
+H5_HLDLL herr_t H5PTis_valid(hid_t table_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Determines whether a packet table contains
+ *        variable-length or fixed-length packets.
+ *
+ * \param[in] table_id  Packet table to query
+ *
+ * \return Returns 1 for a variable-length packet table,
+ *         0 for fixed-length, or a negative value on error.
+ *
+ * \details The H5PTis_varlen() returns 1 (TRUE) if \p table_id is
+ *          a packet table containing variable-length records.
+ *          It returns 0 (FALSE) if \p table_id is a packet table
+ *          containing fixed-length records. If \p table_id is not a
+ *          packet table, a negative value is returned.
+ *
+ * \version 1.10.0 and 1.8.17 Function re-introduced.
+ *                            Function had been removed in 1.8.3.
+ *
+ */
+H5_HLDLL herr_t H5PTis_varlen(hid_t table_id);
+
+/*-------------------------------------------------------------------------
+ *
+ * Accessor functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Returns the backend dataset of this packet table.
+ *
+ * \param[in] table_id  Identifier of the packet table
+ *
+ * \return Returns a dataset identifier or H5I_INVALID_HID on error.
+ *
+ * \details The H5PTget_dataset() returns the identifier of the dataset
+ *          storing the packet table \p table_id. This dataset identifier
+ *          will be closed by H5PTclose().
+ *
+ * \since 1.10.0 and 1.8.17
+ *
+ */
+H5_HLDLL hid_t H5PTget_dataset(hid_t table_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Returns the backend datatype of this packet table.
+ *
+ * \param[in] table_id  Identifier of the packet table
+ *
+ * \return Returns a datatype identifier or H5I_INVALID_HID on error.
+ *
+ * \details The H5PTget_type() returns the identifier of the datatype
+ *          used by the packet table \p table_id. This datatype
+ *          identifier will be closed by H5PTclose().
+ *
+ * \since 1.10.0 and 1.8.17
+ *
+ */
+H5_HLDLL hid_t H5PTget_type(hid_t table_id);
+
+/*-------------------------------------------------------------------------
+ *
+ * Packet Table "current index" functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Resets a packet table's index to the first packet.
+ *
+ * \param[in] table_id  Identifier of packet table whose index
+ *                      should be initialized.
+ *
+ * \return \herr_t
+ *
+ * \details Each packet table keeps an index of the "current" packet
+ *          so that \c get_next can iterate through the packets in order.
+ *          H5PTcreate_index() initializes a packet table's index, and
+ *          should be called before using \c get_next. The index must be
+ *          initialized every time a packet table is created or opened;
+ *          this information is lost when the packet table is closed.
+ *
+ */
+H5_HLDLL herr_t H5PTcreate_index(hid_t table_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Sets a packet table's index.
+ *
+ * \param[in] table_id  Identifier of packet table whose index is to be set
+ * \param[in] pt_index  The packet to which the index should point
+ *
+ * \return \herr_t
+ *
+ * \details Each packet table keeps an index of the "current" packet
+ *          so that \c get_next can iterate through the packets in order.
+ *          H5PTset_index() sets this index to point to a user-specified
+ *          packet (the packets are zero-indexed).
+ *
+ */
+H5_HLDLL herr_t H5PTset_index(hid_t table_id, hsize_t pt_index);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Gets the current record index for a packet table.
+ *
+ * \param[in] table_id  Table identifier
+ * \param[out] pt_index Current record index
+ *
+ * \return \herr_t
+ *
+ * \details The H5PTget_index() returns the current record index
+ *          \p pt_index for the table identified by \p table_id.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_HLDLL herr_t H5PTget_index(hid_t table_id, hsize_t *pt_index);
+
+/*-------------------------------------------------------------------------
+ *
+ * Memory Management functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5PT
+ *
+ * \brief Releases memory allocated in the process of reading
+ *        variable-length packets.
+ *
+ * \param[in] table_id  Packet table whose memory should be freed.
+ * \param[in] bufflen   Size of \p buff
+ * \param[in] buff      Buffer that was used to read in variable-length
+ *                      packets
+ *
+ * \return \herr_t
+ *
+ * \details When variable-length packets are read, memory is automatically
+ *          allocated to hold them, and must be freed. H5PTfree_vlen_buff()
+ *          frees this memory, and should be called whenever packets are
+ *          read from a variable-length packet table.
+ *
+ * \version 1.10.0 and 1.8.17 Function re-introduced.
+ *                            Function had been removed in 1.8.3.
+ *
+ */
+H5_HLDLL herr_t H5PTfree_vlen_buff(hid_t table_id, size_t bufflen, void *buff);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5Ppublic.h b/install/include/H5Ppublic.h
new file mode 100644
index 0000000000..3a059105a1
--- /dev/null
+++ b/install/include/H5Ppublic.h
@@ -0,0 +1,10353 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains function prototypes for each exported function in the
+ * H5P module.
+ */
+#ifndef H5Ppublic_H
+#define H5Ppublic_H
+
+#include "H5public.h"   /* Generic Functions                        */
+#include "H5ACpublic.h" /* Metadata Cache                           */
+#include "H5Dpublic.h"  /* Datasets                                 */
+#include "H5Fpublic.h"  /* Files                                    */
+#include "H5FDpublic.h" /* (Virtual) File Drivers                   */
+#include "H5Ipublic.h"  /* Identifiers                              */
+#include "H5Lpublic.h"  /* Links                                    */
+#include "H5MMpublic.h" /* Memory Management                        */
+#include "H5Opublic.h"  /* Object Headers                           */
+#include "H5Spublic.h"  /* Dataspaces                               */
+#include "H5Tpublic.h"  /* Datatypes                                */
+#include "H5Zpublic.h"  /* Data Filters                             */
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* When this header is included from a private HDF5 header, don't make calls to H5open() */
+#undef H5OPEN
+#ifndef H5private_H
+#define H5OPEN H5open(),
+#else /* H5private_H */
+#define H5OPEN
+#endif /* H5private_H */
+
+/*
+ * The library's property list classes
+ */
+
+#define H5P_ROOT             (H5OPEN H5P_CLS_ROOT_ID_g)
+#define H5P_OBJECT_CREATE    (H5OPEN H5P_CLS_OBJECT_CREATE_ID_g)
+#define H5P_FILE_CREATE      (H5OPEN H5P_CLS_FILE_CREATE_ID_g)
+#define H5P_FILE_ACCESS      (H5OPEN H5P_CLS_FILE_ACCESS_ID_g)
+#define H5P_DATASET_CREATE   (H5OPEN H5P_CLS_DATASET_CREATE_ID_g)
+#define H5P_DATASET_ACCESS   (H5OPEN H5P_CLS_DATASET_ACCESS_ID_g)
+#define H5P_DATASET_XFER     (H5OPEN H5P_CLS_DATASET_XFER_ID_g)
+#define H5P_FILE_MOUNT       (H5OPEN H5P_CLS_FILE_MOUNT_ID_g)
+#define H5P_GROUP_CREATE     (H5OPEN H5P_CLS_GROUP_CREATE_ID_g)
+#define H5P_GROUP_ACCESS     (H5OPEN H5P_CLS_GROUP_ACCESS_ID_g)
+#define H5P_DATATYPE_CREATE  (H5OPEN H5P_CLS_DATATYPE_CREATE_ID_g)
+#define H5P_DATATYPE_ACCESS  (H5OPEN H5P_CLS_DATATYPE_ACCESS_ID_g)
+#define H5P_MAP_CREATE       (H5OPEN H5P_CLS_MAP_CREATE_ID_g)
+#define H5P_MAP_ACCESS       (H5OPEN H5P_CLS_MAP_ACCESS_ID_g)
+#define H5P_STRING_CREATE    (H5OPEN H5P_CLS_STRING_CREATE_ID_g)
+#define H5P_ATTRIBUTE_CREATE (H5OPEN H5P_CLS_ATTRIBUTE_CREATE_ID_g)
+#define H5P_ATTRIBUTE_ACCESS (H5OPEN H5P_CLS_ATTRIBUTE_ACCESS_ID_g)
+#define H5P_OBJECT_COPY      (H5OPEN H5P_CLS_OBJECT_COPY_ID_g)
+#define H5P_LINK_CREATE      (H5OPEN H5P_CLS_LINK_CREATE_ID_g)
+#define H5P_LINK_ACCESS      (H5OPEN H5P_CLS_LINK_ACCESS_ID_g)
+#define H5P_VOL_INITIALIZE   (H5OPEN H5P_CLS_VOL_INITIALIZE_ID_g)
+#define H5P_REFERENCE_ACCESS (H5OPEN H5P_CLS_REFERENCE_ACCESS_ID_g)
+
+/*
+ * The library's default property lists
+ */
+#define H5P_FILE_CREATE_DEFAULT      (H5OPEN H5P_LST_FILE_CREATE_ID_g)
+#define H5P_FILE_ACCESS_DEFAULT      (H5OPEN H5P_LST_FILE_ACCESS_ID_g)
+#define H5P_DATASET_CREATE_DEFAULT   (H5OPEN H5P_LST_DATASET_CREATE_ID_g)
+#define H5P_DATASET_ACCESS_DEFAULT   (H5OPEN H5P_LST_DATASET_ACCESS_ID_g)
+#define H5P_DATASET_XFER_DEFAULT     (H5OPEN H5P_LST_DATASET_XFER_ID_g)
+#define H5P_FILE_MOUNT_DEFAULT       (H5OPEN H5P_LST_FILE_MOUNT_ID_g)
+#define H5P_GROUP_CREATE_DEFAULT     (H5OPEN H5P_LST_GROUP_CREATE_ID_g)
+#define H5P_GROUP_ACCESS_DEFAULT     (H5OPEN H5P_LST_GROUP_ACCESS_ID_g)
+#define H5P_DATATYPE_CREATE_DEFAULT  (H5OPEN H5P_LST_DATATYPE_CREATE_ID_g)
+#define H5P_DATATYPE_ACCESS_DEFAULT  (H5OPEN H5P_LST_DATATYPE_ACCESS_ID_g)
+#define H5P_MAP_CREATE_DEFAULT       (H5OPEN H5P_LST_MAP_CREATE_ID_g)
+#define H5P_MAP_ACCESS_DEFAULT       (H5OPEN H5P_LST_MAP_ACCESS_ID_g)
+#define H5P_ATTRIBUTE_CREATE_DEFAULT (H5OPEN H5P_LST_ATTRIBUTE_CREATE_ID_g)
+#define H5P_ATTRIBUTE_ACCESS_DEFAULT (H5OPEN H5P_LST_ATTRIBUTE_ACCESS_ID_g)
+#define H5P_OBJECT_COPY_DEFAULT      (H5OPEN H5P_LST_OBJECT_COPY_ID_g)
+#define H5P_LINK_CREATE_DEFAULT      (H5OPEN H5P_LST_LINK_CREATE_ID_g)
+#define H5P_LINK_ACCESS_DEFAULT      (H5OPEN H5P_LST_LINK_ACCESS_ID_g)
+#define H5P_VOL_INITIALIZE_DEFAULT   (H5OPEN H5P_LST_VOL_INITIALIZE_ID_g)
+#define H5P_REFERENCE_ACCESS_DEFAULT (H5OPEN H5P_LST_REFERENCE_ACCESS_ID_g)
+
+/* Common creation order flags (for links in groups and attributes on objects) */
+#define H5P_CRT_ORDER_TRACKED 0x0001
+#define H5P_CRT_ORDER_INDEXED 0x0002
+
+/**
+ * Default value of type \ref hid_t for all property list classes
+ */
+#define H5P_DEFAULT 0 /* (hid_t) */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/* Define property list class callback function pointer types */
+//! <!-- [H5P_cls_create_func_t_snip] -->
+/**
+ * \brief Callback function for H5Pcreate_class()
+ *
+ * \param[in] prop_id     The identifier of the property list class being created
+ * \param[in] create_data User pointer to any class creation data required
+ * \return \herr_t
+ *
+ * \details This function is called when a new property list of the class
+ *          with which this function was registered is being created.  The
+ *          function is called after any registered parent create function is
+ *          called for each property value.
+ *
+ *          If the create function returns a negative value, the new list is not
+ *          returned to the user and the property list creation routine returns
+ *          an error value.
+ *
+ * \since 1.4.0
+ *
+ */
+typedef herr_t (*H5P_cls_create_func_t)(hid_t prop_id, void *create_data);
+//! <!-- [H5P_cls_create_func_t_snip] -->
+
+//! <!-- [H5P_cls_copy_func_t_snip] -->
+/**
+ * \brief Callback function for H5Pcreate_class()
+ *
+ * \param[in] new_prop_id The identifier of the property list copy
+ * \param[in] old_prop_id The identifier of the property list being copied
+ * \param[in] copy_data User pointer to any copy data required
+ * \return \herr_t
+ *
+ * \details This function is called when an existing property list of this
+ *          class is copied. The copy callback function is called after any
+ *          registered parent copy callback function is called for each property
+ *          value.
+ *
+ *          If the copy routine returns a negative value, the new list is not
+ *          returned to the user and the property list copy function returns an
+ *          error value.
+ *
+ * \since 1.4.0
+ *
+ */
+typedef herr_t (*H5P_cls_copy_func_t)(hid_t new_prop_id, hid_t old_prop_id, void *copy_data);
+//! <!-- [H5P_cls_copy_func_t_snip] -->
+
+//! <!-- [H5P_cls_close_func_t_snip] -->
+/**
+ * \brief Callback function for H5Pcreate_class()
+ *
+ * \param[in] prop_id    The identifier of the property list class being created
+ * \param[in] close_data User pointer to any close data required
+ * \return \herr_t
+ *
+ * \details This function is called when a property list of the class
+ *          with which this function was registered is being closed.  The
+ *          function is called after any registered parent close function is
+ *          called for each property value.
+ *
+ *          If the close function returns a negative value, the new list is not
+ *          returned to the user and the property list close routine returns
+ *          an error value.
+ *
+ * \since 1.4.0
+ *
+ */
+typedef herr_t (*H5P_cls_close_func_t)(hid_t prop_id, void *close_data);
+//! <!-- [H5P_cls_close_func_t_snip] -->
+
+/* Define property list callback function pointer types */
+//! <!-- [H5P_prp_cb1_t_snip] -->
+/**
+ * \brief Callback function for H5Pregister2(),H5Pregister1(),H5Pinsert2(),H5Pinsert1()
+ *
+ * \param[in]     name  The name of the property
+ * \param[in]     size  The size of the property in bytes
+ * \param[in,out] value The value for the property
+ * \return \herr_t
+ *
+ * \details The H5P_prp_cb1_t() function describes the parameters used by the
+ *          property create, copy and close callback functions.
+ */
+typedef herr_t (*H5P_prp_cb1_t)(const char *name, size_t size, void *value);
+//! <!-- [H5P_prp_cb1_t_snip] -->
+
+//! <!-- [H5P_prp_cb2_t_snip] -->
+/**
+ * \brief Callback function for H5Pregister2(),H5Pregister1(),H5Pinsert2(),H5Pinsert1()
+ *
+ * \plist_id{prop_id}
+ * \param[in]     name  The name of the property
+ * \param[in]     size  The size of the property in bytes
+ * \param[in]     value The value for the property
+ * \return \herr_t
+ *
+ * \details The H5P_prp_cb2_t() function describes the parameters used by the
+ *          property set, copy and delete callback functions.
+ */
+typedef herr_t (*H5P_prp_cb2_t)(hid_t prop_id, const char *name, size_t size, void *value);
+//! <!-- [H5P_prp_cb2_t_snip] -->
+
+typedef H5P_prp_cb1_t H5P_prp_create_func_t;
+typedef H5P_prp_cb2_t H5P_prp_set_func_t;
+typedef H5P_prp_cb2_t H5P_prp_get_func_t;
+//! <!-- [H5P_prp_encode_func_t_snip] -->
+/**
+ * \brief Callback function for encoding property values
+ *
+ * \param[in]  value The property value to be encoded
+ * \param[out] buf   The encoded property value
+ * \param[out] size  The size of \p buf
+ * \return \herr_t
+ *
+ * \note There is currently no public API which exposes a callback of this type.
+ *
+ */
+typedef herr_t (*H5P_prp_encode_func_t)(const void *value, void **buf, size_t *size);
+//! <!-- [H5P_prp_encode_func_t_snip] -->
+//! <!-- [H5P_prp_decode_func_t_snip] -->
+/**
+ * \brief Callback function for decoding property values
+ *
+ * \param[in]  buf   A buffer containing an encoded property value
+ * \param[out] value The decoded property value
+ * \return \herr_t
+ *
+ * \note There is currently no public API which exposes a callback of this type.
+ *
+ */
+typedef herr_t (*H5P_prp_decode_func_t)(const void **buf, void *value);
+//! <!-- [H5P_prp_decode_func_t_snip] -->
+typedef H5P_prp_cb2_t H5P_prp_delete_func_t;
+typedef H5P_prp_cb1_t H5P_prp_copy_func_t;
+
+//! <!-- [H5P_prp_compare_func_t_snip] -->
+/**
+ * \brief Callback function for comparing property values
+ *
+ * \param[in] value1 A property value
+ * \param[in] value2 A property value
+ * \param[in] size   The size of the \p value1 and \p value2 buffers
+ * \return Returns a positive value if \c value1 is greater than \c value2, a
+ *         negative value if \c value2 is greater than \c value1 and zero if
+ *         \c value1 and \c value2 are equal.
+ *
+ * \see H5Pregister(), H5Pinsert()
+ */
+typedef int (*H5P_prp_compare_func_t)(const void *value1, const void *value2, size_t size);
+//! <!-- [H5P_prp_compare_func_t_snip] -->
+
+typedef H5P_prp_cb1_t H5P_prp_close_func_t;
+
+/* Define property list iteration function type */
+//! <!-- [H5P_iterate_t_snip] -->
+/**
+ * \brief Callback function for H5Piterate()
+ *
+ * \param[in]     id        The identifier of a property list or property list class
+ * \param[in]     name      The name of the current property
+ * \param[in,out] iter_data The user context passed to H5Piterate()
+ * \return \herr_t_iter
+ *
+ * \details This function is called for each property encountered when
+ *          iterating over a property list or property list class
+ *          via H5Piterate().
+ *
+ * \since 1.4.0
+ *
+ */
+typedef herr_t (*H5P_iterate_t)(hid_t id, const char *name, void *iter_data);
+//! <!-- [H5P_iterate_t_snip] -->
+
+//! <!--[H5D_mpio_actual_chunk_opt_mode_t_snip] -->
+/**
+ * Actual IO mode property
+ *
+ * \details The default value, #H5D_MPIO_NO_CHUNK_OPTIMIZATION, is used for all
+ *          I/O operations that do not use chunk optimizations, including
+ *          non-collective I/O and contiguous collective I/O.
+ */
+typedef enum H5D_mpio_actual_chunk_opt_mode_t {
+    H5D_MPIO_NO_CHUNK_OPTIMIZATION = 0,
+    /**< No chunk optimization was performed. Either no collective I/O was
+        attempted or the dataset wasn't chunked. */
+    H5D_MPIO_LINK_CHUNK,
+    /**< Collective I/O is performed on all chunks simultaneously. */
+    H5D_MPIO_MULTI_CHUNK
+    /**< Each chunk was individually assigned collective or independent I/O based
+         on what fraction of processes access the chunk. If the fraction is greater
+         than the multi chunk ratio threshold, collective I/O is performed on that
+         chunk. The multi chunk ratio threshold can be set using
+         H5Pset_dxpl_mpio_chunk_opt_ratio(). The default value is 60%. */
+} H5D_mpio_actual_chunk_opt_mode_t;
+//! <!--[H5D_mpio_actual_chunk_opt_mode_t_snip] -->
+
+//! <!-- [H5D_mpio_actual_io_mode_t_snip] -->
+/**
+ * The following values are conveniently defined as a bit field so that
+ * we can switch from the default to independent or collective and then to
+ * mixed without having to check the original value.
+ */
+typedef enum H5D_mpio_actual_io_mode_t {
+    H5D_MPIO_NO_COLLECTIVE = 0x0,
+    /**< No collective I/O was performed. Collective I/O was not requested or
+         collective I/O isn't possible on this dataset */
+    H5D_MPIO_CHUNK_INDEPENDENT = 0x1,
+    /**< HDF5 performed one the chunk collective optimization schemes and each
+         chunk was accessed independently */
+    H5D_MPIO_CHUNK_COLLECTIVE = 0x2,
+    /**< HDF5 performed one the chunk collective optimization schemes and each
+         chunk was accessed collectively */
+    H5D_MPIO_CHUNK_MIXED = 0x1 | 0x2,
+    /**< HDF5 performed one the chunk collective optimization schemes and some
+         chunks were accessed independently, some collectively. */
+    H5D_MPIO_CONTIGUOUS_COLLECTIVE = 0x4
+    /**< Collective I/O was performed on a contiguous dataset */
+} H5D_mpio_actual_io_mode_t;
+//! <!-- [H5D_mpio_actual_io_mode_t_snip] -->
+
+//! <!-- [H5D_mpio_no_collective_cause_t_snip] -->
+/**
+ * Broken collective IO property
+ */
+typedef enum H5D_mpio_no_collective_cause_t {
+    H5D_MPIO_COLLECTIVE = 0x00,
+    /**< Collective I/O was performed successfully */
+    H5D_MPIO_SET_INDEPENDENT = 0x01,
+    /**< Collective I/O was not performed because independent I/O was requested */
+    H5D_MPIO_DATATYPE_CONVERSION = 0x02,
+    /**< Collective I/O was not performed because datatype conversions were required and selection I/O was not
+       possible (see below) */
+    H5D_MPIO_DATA_TRANSFORMS = 0x04,
+    /**< Collective I/O was not performed because data transforms needed to be applied */
+    H5D_MPIO_MPI_OPT_TYPES_ENV_VAR_DISABLED = 0x08,
+    /**< Collective I/O was disabled by environment variable (\Code{HDF5_MPI_OPT_TYPES}) */
+    H5D_MPIO_NOT_SIMPLE_OR_SCALAR_DATASPACES = 0x10,
+    /**< Collective I/O was not performed because one of the dataspaces was neither simple nor scalar */
+    H5D_MPIO_NOT_CONTIGUOUS_OR_CHUNKED_DATASET = 0x20,
+    /**< Collective I/O was not performed because the dataset was neither contiguous nor chunked */
+    H5D_MPIO_PARALLEL_FILTERED_WRITES_DISABLED = 0x40,
+    /**< Collective I/O was not performed because parallel filtered writes are disabled */
+    H5D_MPIO_ERROR_WHILE_CHECKING_COLLECTIVE_POSSIBLE = 0x80,
+    /**< Error */
+    H5D_MPIO_NO_SELECTION_IO = 0x100,
+    /**< Collective I/O would be supported by selection or vector I/O but that feature was disabled
+       (see causes via H5Pget_no_selection_io_cause()) */
+    H5D_MPIO_NO_COLLECTIVE_MAX_CAUSE = 0x200
+    /**< Sentinel */
+} H5D_mpio_no_collective_cause_t;
+//! <!-- [H5D_mpio_no_collective_cause_t_snip] -->
+
+/**
+ * Causes for H5Pget_no_selection_io_cause() property
+ */
+#define H5D_SEL_IO_DISABLE_BY_API                                                                            \
+    (0x0001u) /**< Selection I/O was not performed because                                                   \
+                 the feature was disabled by the API */
+#define H5D_SEL_IO_NOT_CONTIGUOUS_OR_CHUNKED_DATASET                                                         \
+    (0x0002u) /**< Selection I/O was not performed because the                                               \
+                 dataset was neither contiguous nor chunked */
+#define H5D_SEL_IO_CONTIGUOUS_SIEVE_BUFFER                                                                   \
+    (0x0004u) /**< Selection I/O was not performed because of                                                \
+                 sieve buffer for contiguous dataset */
+#define H5D_SEL_IO_NO_VECTOR_OR_SELECTION_IO_CB                                                              \
+    (0x0008u) /**< Selection I/O was not performed because the VFD                                           \
+                 does not have vector or selection I/O callback */
+#define H5D_SEL_IO_PAGE_BUFFER                                                                               \
+    (0x0010u) /**< Selection I/O was not performed because of                                                \
+                 page buffer */
+#define H5D_SEL_IO_DATASET_FILTER                                                                            \
+    (0x0020u) /**< Selection I/O was not performed because of                                                \
+                 dataset filters */
+#define H5D_SEL_IO_CHUNK_CACHE                                                                               \
+    (0x0040u) /**< Selection I/O was not performed because of                                                \
+                 chunk cache */
+#define H5D_SEL_IO_TCONV_BUF_TOO_SMALL                                                                       \
+    (0x0080u) /**< Selection I/O was not performed because the                                               \
+                 type conversion buffer is too small */
+#define H5D_SEL_IO_BKG_BUF_TOO_SMALL                                                                         \
+    (0x0100u) /**< Selection I/O was not performed because the                                               \
+                 type conversion background buffer is too small */
+#define H5D_SEL_IO_DEFAULT_OFF                                                                               \
+    (0x0200u) /**< Selection I/O was not performed because the                                               \
+                   selection I/O mode is DEFAULT and the library                                             \
+                   chose it to be off for this case */
+
+/* Causes for H5D_MPIO_NO_SELECTION_IO */
+#define H5D_MPIO_NO_SELECTION_IO_CAUSES                                                                      \
+    (H5D_SEL_IO_DISABLE_BY_API | H5D_SEL_IO_TCONV_BUF_TOO_SMALL | H5D_SEL_IO_BKG_BUF_TOO_SMALL |             \
+     H5D_SEL_IO_DATASET_FILTER | H5D_SEL_IO_CHUNK_CACHE)
+
+//! <!--[H5D_selection_io_mode_t_snip] -->
+/**
+ * Selection I/O mode property
+ *
+ * \details The default value, #H5D_SELECTION_IO_MODE_DEFAULT,
+ *          indicates selection I/O can be ON or OFF as
+ *          determined by library internal.
+ */
+typedef enum H5D_selection_io_mode_t {
+    H5D_SELECTION_IO_MODE_DEFAULT = 0,
+    /**< Default selection I/O mode. */
+    H5D_SELECTION_IO_MODE_OFF,
+    /**< Selection I/O is off. */
+    H5D_SELECTION_IO_MODE_ON
+    /**< Selection I/O is on. */
+} H5D_selection_io_mode_t;
+//! <!--[H5D_selection_io_mode_t_snip] -->
+
+/**
+ * Causes for H5Pget_actual_selection_io_mode() property
+ */
+#define H5D_SCALAR_IO    (0x0001u) /**< Scalar (or legacy MPIO) I/O was performed */
+#define H5D_VECTOR_IO    (0x0002u) /**< Vector I/O was performed */
+#define H5D_SELECTION_IO (0x0004u) /**< Selection I/O was performed */
+
+/********************/
+/* Public Variables */
+/********************/
+
+/* Property list class IDs */
+/* (Internal to library, do not use!  Use macros above) */
+H5_DLLVAR hid_t H5P_CLS_ROOT_ID_g;
+H5_DLLVAR hid_t H5P_CLS_OBJECT_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_FILE_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_FILE_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_CLS_DATASET_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_DATASET_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_CLS_DATASET_XFER_ID_g;
+H5_DLLVAR hid_t H5P_CLS_FILE_MOUNT_ID_g;
+H5_DLLVAR hid_t H5P_CLS_GROUP_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_GROUP_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_CLS_DATATYPE_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_DATATYPE_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_CLS_MAP_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_MAP_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_CLS_STRING_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_ATTRIBUTE_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_ATTRIBUTE_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_CLS_OBJECT_COPY_ID_g;
+H5_DLLVAR hid_t H5P_CLS_LINK_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_LINK_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_CLS_VOL_INITIALIZE_ID_g;
+H5_DLLVAR hid_t H5P_CLS_REFERENCE_ACCESS_ID_g;
+
+/* Default property list IDs */
+/* (Internal to library, do not use!  Use macros above) */
+H5_DLLVAR hid_t H5P_LST_FILE_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_LST_FILE_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_LST_DATASET_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_LST_DATASET_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_LST_DATASET_XFER_ID_g;
+H5_DLLVAR hid_t H5P_LST_FILE_MOUNT_ID_g;
+H5_DLLVAR hid_t H5P_LST_GROUP_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_LST_GROUP_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_LST_DATATYPE_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_LST_DATATYPE_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_LST_MAP_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_LST_MAP_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_LST_ATTRIBUTE_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_LST_ATTRIBUTE_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_LST_OBJECT_COPY_ID_g;
+H5_DLLVAR hid_t H5P_LST_LINK_CREATE_ID_g;
+H5_DLLVAR hid_t H5P_LST_LINK_ACCESS_ID_g;
+H5_DLLVAR hid_t H5P_LST_VOL_INITIALIZE_ID_g;
+H5_DLLVAR hid_t H5P_LST_REFERENCE_ACCESS_ID_g;
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+/* Generic property list routines */
+
+/**
+ * \ingroup PLCR
+ *
+ * \brief Terminates access to a property list
+ *
+ * \plist_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Pclose() terminates access to a property list. All property
+ *          lists should be closed when the application is finished
+ *          accessing them. This frees resources used by the property
+ *          list.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pclose(hid_t plist_id);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Closes an existing property list class
+ *
+ * \plistcls_id{plist_id}
+ *
+ * \return \herr_t
+ *
+ * \details H5Pclose_class() removes a property list class from the library.
+ *          Existing property lists of this class will continue to exist,
+ *          but new ones are not able to be created.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pclose_class(hid_t plist_id);
+/**
+ * \ingroup PLCR
+ *
+ * \brief Copies an existing property list to create a new property list
+ *
+ * \plist_id
+ *
+ * \return \hid_t{property list}
+ *
+ * \details H5Pcopy() copies an existing property list to create a new
+ *          property list. The new property list has the same properties
+ *          and values as the original property list.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL hid_t H5Pcopy(hid_t plist_id);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Copies a property from one list or class to another
+ *
+ * \param[in] dst_id Identifier of the destination property list or class
+ * \param[in] src_id Identifier of the source property list or class
+ * \param[in] name Name of the property to copy
+ *
+ * \return \herr_t
+ *
+ * \details H5Pcopy_prop() copies a property from one property list or
+ *          class to another.
+ *
+ *          If a property is copied from one class to another, all the
+ *          property information will be first deleted from the destination
+ *          class and then the property information will be copied from the
+ *          source class into the destination class.
+ *
+ *          If a property is copied from one list to another, the property
+ *          will be first deleted from the destination list (generating a
+ *          call to the close callback for the property, if one exists)
+ *          and then the property is copied from the source list to the
+ *          destination list (generating a call to the copy callback for
+ *          the property, if one exists).
+ *
+ *          If the property does not exist in the class or list, this
+ *          call is equivalent to calling H5Pregister() or H5Pinsert() (for
+ *          a class or list, as appropriate) and the create callback will
+ *          be called in the case of the property being copied into a list
+ *          (if such a callback exists for the property).
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pcopy_prop(hid_t dst_id, hid_t src_id, const char *name);
+/**
+ * \ingroup PLCR
+ *
+ * \brief Creates a new property list as an instance of a property list class
+ *
+ * \plistcls_id{cls_id}
+ *
+ * \return \hid_t{property list}
+ *
+ * \details H5Pcreate() creates a new property list as an instance of
+ *          some property list class. The new property list is initialized
+ *          with default values for the specified class. The classes are as
+ *          follows:
+ *
+ * <table>
+ *   <tr>
+ *     <th>Class Identifier</th>
+ *     <th>Class Name</th>
+ *     <th>Comments</th>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_ATTRIBUTE_CREATE</td>
+ *     <td>attribute create</td>
+ *     <td>Properties for attribute creation</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_DATASET_ACCESS</td>
+ *     <td>dataset access</td>
+ *     <td>Properties for dataset access</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_DATASET_CREATE</td>
+ *     <td>dataset create</td>
+ *     <td>Properties for dataset creation</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_DATASET_XFER</td>
+ *     <td>data transfer</td>
+ *     <td>Properties for raw data transfer</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_DATATYPE_ACCESS</td>
+ *     <td>datatype access</td>
+ *     <td>Properties for datatype access</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_DATATYPE_CREATE</td>
+ *     <td>datatype create</td>
+ *     <td>Properties for datatype creation</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_FILE_ACCESS</td>
+ *     <td>file access</td>
+ *     <td>Properties for file access</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_FILE_CREATE</td>
+ *     <td>file create</td>
+ *     <td>Properties for file creation</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_FILE_MOUNT</td>
+ *     <td>file mount</td>
+ *     <td>Properties for file mounting</td>
+ *   </tr>
+ *   <tr valign="top">
+ *     <td>#H5P_GROUP_ACCESS</td>
+ *     <td>group access</td>
+ *     <td>Properties for group access</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_GROUP_CREATE</td>
+ *     <td>group create</td>
+ *     <td>Properties for group creation</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_LINK_ACCESS</td>
+ *     <td>link access</td>
+ *     <td>Properties governing link traversal when accessing objects</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_LINK_CREATE</td>
+ *     <td>link create</td>
+ *     <td>Properties governing link creation</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_OBJECT_COPY</td>
+ *     <td>object copy</td>
+ *     <td>Properties governing the object copying process</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_OBJECT_CREATE</td>
+ *     <td>object create</td>
+ *     <td>Properties for object creation</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_STRING_CREATE</td>
+ *     <td>string create</td>
+ *     <td>Properties for character encoding when encoding strings or
+ *       object names</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5P_VOL_INITIALIZE</td>
+ *     <td>vol initialize</td>
+ *     <td>Properties for VOL initialization</td>
+ *   </tr>
+ * </table>
+ *
+ * This property list must eventually be closed with H5Pclose();
+ * otherwise, errors are likely to occur.
+ *
+ * \version 1.12.0 The #H5P_VOL_INITIALIZE property list class was added
+ * \version 1.8.15 For each class, the class name returned by
+ *                 H5Pget_class_name() was added.
+ *                 The list of possible Fortran values was updated.
+ * \version 1.8.0 The following property list classes were added at this
+ *                release: #H5P_DATASET_ACCESS, #H5P_GROUP_CREATE,
+ *                #H5P_GROUP_ACCESS, #H5P_DATATYPE_CREATE,
+ *                #H5P_DATATYPE_ACCESS, #H5P_ATTRIBUTE_CREATE
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL hid_t H5Pcreate(hid_t cls_id);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Creates a new property list class
+ *
+ * \plistcls_id{parent}
+ * \param[in] name        Name of property list class to register
+ * \param[in] create      Callback routine called when a property list is
+ *                        created
+ * \param[in] create_data Pointer to user-defined class create data, to be
+ *                        passed along to class create callback
+ * \param[in] copy        Callback routine called when a property list is
+ *                        copied
+ * \param[in] copy_data   Pointer to user-defined class copy data, to be
+ *                        passed along to class copy callback
+ * \param[in] close       Callback routine called when a property list is
+ *                        being closed
+ * \param[in] close_data  Pointer to user-defined class close data, to be
+ *                        passed along to class close callback
+ *
+ * \return \hid_t{property list class}
+ *
+ * \details H5Pcreate_class() registers a new property list class with the
+ *          library. The new property list class can inherit from an
+ *          existing property list class, \p parent, or may be derived
+ *          from the default empty class, NULL. New classes with
+ *          inherited properties from existing classes may not remove
+ *          those existing properties, only add or remove their own class
+ *          properties. Property list classes defined and supported in the
+ *          HDF5 library distribution are listed and briefly described in
+ *          H5Pcreate(). The \p create, \p copy, \p close functions are called
+ *          when a property list of the new class is created, copied, or closed,
+ *          respectively.
+ *
+ *          H5Pclose_class() must be used to release the property list class
+ *          identifier returned by this function.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL hid_t H5Pcreate_class(hid_t parent, const char *name, H5P_cls_create_func_t create, void *create_data,
+                             H5P_cls_copy_func_t copy, void *copy_data, H5P_cls_close_func_t close,
+                             void *close_data);
+/**
+ * \ingroup PLCR
+ *
+ * \brief Decodes property list received in a binary object buffer and
+ *        returns a new property list identifier
+ *
+ * \param[in] buf Buffer holding the encoded property list
+ *
+ * \return \hid_tv{object}
+ *
+ * \details Given a binary property list description in a buffer, H5Pdecode()
+ *          reconstructs the HDF5 property list and returns an identifier
+ *          for the new property list. The binary description of the property
+ *          list is encoded by H5Pencode().
+ *
+ *          The user is responsible for passing in the correct buffer.
+ *
+ *          The property list identifier returned by this function should be
+ *          released with H5Pclose() when the identifier is no longer needed
+ *          so that resource leaks will not develop.
+ *
+ * \note Some properties cannot be encoded and therefore will not be available
+ *       in the decoded property list. These properties are discussed in
+ *       H5Pencode().
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL hid_t H5Pdecode(const void *buf);
+/**
+ * \ingroup PLCR
+ *
+ * \brief Encodes the property values in a property list into a binary
+ *        buffer
+ *
+ * \plist_id
+ * \param[out] buf    Buffer into which the property list will be encoded.
+ *                    If the provided buffer is NULL, the size of the
+ *                    buffer required is returned through \p nalloc; the
+ *                    function does nothing more.
+ * \param[out] nalloc The size of the required buffer
+ * \fapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Pencode2() encodes the property list \p plist_id into the
+ *          binary buffer \p buf, according to the file format setting
+ *          specified by the file access property list \p fapl_id.
+ *
+ *          If the required buffer size is unknown, \p buf can be passed
+ *          in as NULL and the function will set the required buffer size
+ *          in \p nalloc. The buffer can then be created and the property
+ *          list encoded with a subsequent H5Pencode2() call.
+ *
+ *          If the buffer passed in is not big enough to hold the encoded
+ *          properties, the H5Pencode2() call can be expected to fail with
+ *          a segmentation fault.
+ *
+ *          The file access property list \p fapl_id is used to
+ *          control the encoding via the \a libver_bounds property
+ *          (see H5Pset_libver_bounds()). If the \a libver_bounds
+ *          property is missing, H5Pencode2() proceeds as if the \a
+ *          libver_bounds property were set to (#H5F_LIBVER_EARLIEST,
+ *          #H5F_LIBVER_LATEST). (Functionally, H5Pencode1() is identical to
+ *          H5Pencode2() with \a libver_bounds set to (#H5F_LIBVER_EARLIEST,
+ *          #H5F_LIBVER_LATEST).)
+ *          Properties that do not have encode callbacks will be skipped.
+ *          There is currently no mechanism to register an encode callback for
+ *          a user-defined property, so user-defined properties cannot currently
+ *          be encoded.
+ *
+ *          Some properties cannot be encoded, particularly properties that are
+ *          reliant on local context.
+ *
+ *      \b Motivation:
+ *       This function was introduced in HDF5-1.12 as part of the \a H5Sencode
+ *       format change to enable 64-bit selection encodings and a dataspace
+ *       selection that is tied to a file.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Pencode2(hid_t plist_id, void *buf, size_t *nalloc, hid_t fapl_id);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Compares two property lists or classes for equality
+ *
+ * \param[in] id1 First property object to be compared
+ * \param[in] id2 Second property object to be compared
+ *
+ * \return \htri_t
+ *
+ * \details H5Pequal() compares two property lists or classes to determine
+ *          whether they are equal to one another.
+ *
+ *          Either both \p id1 and \p id2 must be property lists or both
+ *          must be classes; comparing a list to a class is an error.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL htri_t H5Pequal(hid_t id1, hid_t id2);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Queries whether a property name exists in a property list or
+ *       class
+ *
+ * \param[in] plist_id   Identifier for the property list or class to query
+ * \param[in] name       Name of property to check for
+ *
+ * \return \htri_t
+ *
+ * \details  H5Pexist() determines whether a property exists within a
+ *           property list or class.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL htri_t H5Pexist(hid_t plist_id, const char *name);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Queries the value of a property
+ *
+ * \plist_id
+ * \param[in]  name  Name of property to query
+ * \param[out] value Pointer to a location to which to copy the value of
+ *                   the property
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget() retrieves a copy of the value for a property in a
+ *          property list. If there is a \p get callback routine registered
+ *          for this property, the copy of the value of the property will
+ *          first be passed to that routine and any changes to the copy of
+ *          the value will be used when returning the property value from
+ *          this routine.
+ *
+ *          This routine may be called for zero-sized properties with the
+ *          \p value set to NULL. The \p get routine will be called with
+ *          a NULL value if the callback exists.
+ *
+ *          The property name must exist or this routine will fail.
+ *
+ *          If the \p get callback routine returns an error, \ value will
+ *          not be modified.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pget(hid_t plist_id, const char *name, void *value);
+/**
+ * \ingroup PLCR
+ *
+ * \brief Returns the property list class identifier for a property list
+ *
+ * \plist_id
+ *
+ * \return \hid_t{property list class}
+ *
+ * \details H5Pget_class() returns the property list class identifier for
+ *          the property list identified by the \p plist_id parameter.
+ *
+ *          Note that H5Pget_class() returns a value of #hid_t type, an
+ *          internal HDF5 identifier, rather than directly returning a
+ *          property list class. That identifier can then be used with
+ *          either H5Pequal() or H5Pget_class_name() to determine which
+ *          predefined HDF5 property list class H5Pget_class() has returned.
+ *
+ *          A full list of valid predefined property list classes appears
+ *          in the description of H5Pcreate().
+ *
+ *          Determining the HDF5 property list class name with H5Pequal()
+ *          requires a series of H5Pequal() calls in an if-else sequence.
+ *          An iterative sequence of H5Pequal() calls can compare the
+ *          identifier returned by H5Pget_class() to members of the list of
+ *          valid property list class names. A pseudo-code snippet might
+ *          read as follows:
+ *
+ *          \code
+ *          plist_class_id = H5Pget_class (dsetA_plist);
+ *
+ *          if H5Pequal (plist_class_id, H5P_OBJECT_CREATE) = true;
+ *              [ H5P_OBJECT_CREATE is the property list class    ]
+ *              [ returned by H5Pget_class.                        ]
+ *
+ *          else if H5Pequal (plist_class_id, H5P_DATASET_CREATE) = true;
+ *              [ H5P_DATASET_CREATE is the property list class.  ]
+ *
+ *          else if H5Pequal (plist_class_id, H5P_DATASET_XFER) = true;
+ *              [ H5P_DATASET_XFER is the property list class.    ]
+ *
+ *          .
+ *          .   [ Continuing the iteration until a match is found. ]
+ *          .
+ *          \endcode
+ *
+ *          H5Pget_class_name() returns the property list class name directly
+ *          as a string:
+ *
+ *          \code
+ *          plist_class_id = H5Pget_class (dsetA_plist);
+ *          plist_class_name = H5Pget_class_name (plist_class_id)
+ *          \endcode
+ *
+ *          Note that frequent use of H5Pget_class_name() can become a
+ *          performance problem in a high-performance environment. The
+ *          H5Pequal() approach is generally much faster.
+ *
+ * \version 1.6.0 Return type changed in this release.
+ * \since 1.0.0
+ *
+ */
+H5_DLL hid_t H5Pget_class(hid_t plist_id);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Retrieves the name of a class
+ *
+ * \plistcls_id{pclass_id}
+ *
+ * \return Returns a pointer to an allocated string containing the class
+ *         name if successful, and NULL if not successful.
+ *
+ * \details H5Pget_class_name() retrieves the name of a generic property
+ *          list class. The pointer to the name must be freed by the user
+ *          with a call to H5free_memory() after each successful call.
+ *
+ *          <table>
+ *           <tr>
+ *            <th>Class Name (class identifier) Returned</th>
+ *            <th>Property List Class</th>
+ *            <th>Expanded Name of the Property List Class</th>
+ *            <th>The Class Identifier Used with H5Pcreate</th>
+ *            <th>Comments</th>
+ *           </tr>
+ *           <tr>
+ *            <td>attribute create</td>
+ *            <td>acpl</td>
+ *            <td>Attribute Creation Property List</td>
+ *            <td>H5P_ATTRIBUTE_CREATE</td>
+ *            <td> </td>
+ *           </tr>
+ *           <tr>
+ *            <td>dataset access</td>
+ *            <td>dapl</td>
+ *            <td>Dataset Access Property List</td>
+ *            <td>H5P_DATASET_ACCESS</td>
+ *            <td> </td>
+ *           </tr>
+ *           <tr>
+ *            <td>dataset create</td>
+ *            <td>dcpl</td>
+ *            <td>Dataset Creation Property List</td>
+ *            <td>H5P_DATASET_CREATE</td>
+ *            <td> </td>
+ *           </tr>
+ *           <tr>
+ *            <td>data transfer</td>
+ *            <td>dxpl</td>
+ *            <td>Data Transfer Property List</td>
+ *            <td>H5P_DATASET_XFER</td>
+ *            <td> </td>
+ *           </tr>
+ *           <tr>
+ *            <td>datatype access</td>
+ *            <td> </td>
+ *            <td> </td>
+ *            <td>H5P_DATATYPE_ACCESS</td>
+ *            <td>This class can be created, but there are no properties
+ *                in the class currently.
+ *            </td>
+ *           </tr>
+ *           <tr>
+ *            <td>datatype create</td>
+ *            <td> </td>
+ *            <td> </td>
+ *            <td>H5P_DATATYPE_CREATE</td>
+ *            <td>This class can be created, but there
+ *                are no properties in the class currently.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>file access</td>
+ *            <td>fapl</td>
+ *            <td>File Access Property List</td>
+ *            <td>H5P_FILE_ACCESS</td>
+ *            <td> </td>
+ *           </tr>
+ *           <tr>
+ *            <td>file create</td>
+ *            <td>fcpl</td>
+ *            <td>File Creation Property List</td>
+ *            <td>H5P_FILE_CREATE</td>
+ *            <td> </td>
+ *           </tr>
+ *           <tr>
+ *            <td>file mount</td>
+ *            <td>fmpl</td>
+ *            <td>File Mount Property List</td>
+ *            <td>H5P_FILE_MOUNT</td>
+ *            <td> </td>
+ *           </tr>
+ *           <tr>
+ *            <td>group access</td>
+ *            <td> </td>
+ *            <td> </td>
+ *            <td>H5P_GROUP_ACCESS</td>
+ *            <td>This class can be created, but there
+ *                are no properties in the class currently.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>group create</td>
+ *            <td>gcpl</td>
+ *            <td>Group Creation Property List</td>
+ *            <td>H5P_GROUP_CREATE</td>
+ *            <td> </td>
+ *           </tr>
+ *           <tr>
+ *             <td>link access</td>
+ *             <td>lapl</td>
+ *             <td>Link Access Property List</td>
+ *             <td>H5P_LINK_ACCESS</td>
+ *             <td> </td>
+ *           </tr>
+ *           <tr>
+ *            <td>link create</td>
+ *            <td>lcpl</td>
+ *            <td>Link Creation Property List</td>
+ *            <td>H5P_LINK_CREATE</td>
+ *            <td> </td>
+ *           </tr>
+ *           <tr>
+ *            <td>object copy</td>
+ *            <td>ocpypl</td>
+ *            <td>Object Copy Property List</td>
+ *            <td>H5P_OBJECT_COPY</td>
+ *            <td> </td>
+ *           </tr>
+ *           <tr>
+ *            <td>object create</td>
+ *            <td>ocpl</td>
+ *            <td>Object Creation Property List</td>
+ *            <td>H5P_OBJECT_CREATE</td>
+ *            <td> </td>
+ *           </tr>
+ *           <tr>
+ *            <td>string create</td>
+ *            <td>strcpl</td>
+ *            <td>String Creation Property List</td>
+ *            <td>H5P_STRING_CREATE</td>
+ *            <td> </td>
+ *           </tr>
+ *          </table>
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL char *H5Pget_class_name(hid_t pclass_id);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Retrieves the parent class of a property class
+ *
+ * \plistcls_id{pclass_id}
+ *
+ * \return \hid_t{parent class object}
+ *
+ * \details H5Pget_class_parent() retrieves an identifier for the parent
+ *          class of a property class.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL hid_t H5Pget_class_parent(hid_t pclass_id);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief  Queries the number of properties in a property list or class
+ *
+ * \param[in]  id     Identifier for property object to query
+ * \param[out] nprops Number of properties in object
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_nprops() retrieves the number of properties in a
+ *          property list or property list class.
+ *
+ *          If \p id is a property list identifier, the current number of
+ *          properties in the list is returned in \p nprops.
+ *
+ *          If \p id is a property list class identifier, the number of
+ *          registered properties in the class is returned in \p nprops.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pget_nprops(hid_t id, size_t *nprops);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Queries the size of a property value in bytes
+ *
+ * \param[in]  id   Identifier of property object to query
+ * \param[in]  name Name of property to query
+ * \param[out] size Size of property in bytes
+ *
+ * \return  \herr_t
+ *
+ * \details H5Pget_size() retrieves the size of a property's value in
+ *          bytes. This function operates on both property lists and
+ *          property classes.
+ *
+ *          Zero-sized properties are allowed and return 0.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pget_size(hid_t id, const char *name, size_t *size);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Registers a temporary property with a property list
+ *
+ * \plist_id
+ * \param[in] name    Name of property to create
+ * \param[in] size    Size of property in bytes
+ * \param[in] value   Initial value for the property
+ * \param[in] set     Callback routine called before a new value is copied
+ *                    into the property's value
+ * \param[in] get     Callback routine called when a property value is
+ *                    retrieved from the property
+ * \param[in] prp_del Callback routine called when a property is deleted
+ *                    from a property list
+ * \param[in] copy    Callback routine called when a property is copied
+ *                    from an existing property list
+ * \param[in] compare Callback routine called when a property is compared
+ *                    with another property list
+ * \param[in] close   Callback routine called when a property list is
+ *                    being closed and the property value will be disposed
+ *                    of
+ *
+ * \return \herr_t
+ *
+ * \details H5Pinsert2() creates a new property in a property
+ *          list. The property will exist only in this property list and
+ *          copies made from it.
+ *
+ *          The initial property value must be provided in \p value and
+ *          the property value will be set accordingly.
+ *
+ *          The name of the property must not already exist in this list,
+ *          or this routine will fail.
+ *
+ *          The \p set and \p get callback routines may be set to NULL
+ *          if they are not needed.
+ *
+ *          Zero-sized properties are allowed and do not store any data
+ *          in the property list. The default value of a zero-size
+ *          property may be set to NULL. They may be used to indicate the
+ *          presence or absence of a particular piece of information.
+ *
+ *          The \p set routine is called before a new value is copied
+ *          into the property. The #H5P_prp_set_func_t callback function
+ *          is defined as follows:
+ *          \snippet this H5P_prp_cb2_t_snip
+ *
+ *          The parameters to the callback function are defined as follows:
+ *          <table>
+ *           <tr>
+ *            <td>\ref hid_t \c prop_id</td>
+ *            <td>IN: The identifier of the property list being
+ *                modified</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{const char * name}</td>
+ *            <td>IN: The name of the property being modified</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{size_t size}</td>
+ *            <td>IN: The size of the property in bytes</td>
+ *           </tr>
+ *           <tr>
+ *             <td>\Code{void * value}</td>
+ *             <td>IN: Pointer to new value pointer for the property
+ *                 being modified</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The \p set routine may modify the value pointer to be set and
+ *          those changes will be used when setting the property's value.
+ *          If the \p set routine returns a negative value, the new property
+ *          value is not copied into the property and the \p  set routine
+ *          returns an error value. The \p set routine will be called for
+ *          the initial value.
+ *
+ *          \b Note: The \p set callback function may be useful to range
+ *          check the value being set for the property or may perform some
+ *          transformation or translation of the value set. The \p get
+ *          callback would then reverse the transformation or translation.
+ *          A single \p get or \p set callback could handle multiple
+ *          properties by performing different actions based on the
+ *          property name or other properties in the property list.
+ *
+ *          The \p get routine is called when a value is retrieved from
+ *          a property value. The #H5P_prp_get_func_t callback function
+ *          is defined as follows:
+ *
+ *          \snippet this H5P_prp_cb2_t_snip
+ *
+ *          The parameters to the above callback function are:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>\ref hid_t \c prop_id</td>
+ *            <td>IN: The identifier of the property list being queried</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{const char * name}</td>
+ *            <td>IN: The name of the property being queried</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{size_t  size}</td>
+ *            <td>IN: The size of the property in bytes</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{void *  value}</td>
+ *            <td>IN: The value of the property being returned</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The \p get routine may modify the value to be returned from
+ *          the query and those changes will be preserved. If the \p get
+ *          routine returns a negative value, the query routine returns
+ *          an error value.
+ *
+ *          The \p prp_del routine is called when a property is being
+ *          deleted from a property list. The #H5P_prp_delete_func_t
+ *          callback function is defined as follows:
+ *
+ *          \snippet this H5P_prp_cb2_t_snip
+ *
+ *          The parameters to the above callback function are:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>\ref hid_t \c prop_id</td>
+ *            <td>IN: The identifier of the property list the property is
+ *                being deleted from</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{const char * name}</td>
+ *            <td>IN: The name of the property in the list</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{size_t size}</td>
+ *            <td>IN: The size of the property in bytes</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{void * value}</td>
+ *            <td>IN: The value for the property being deleted</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The \p prp_del routine may modify the value passed in, but the
+ *          value is not used by the library when the \p prp_del routine
+ *          returns. If the \p prp_del routine returns a negative value,
+ *          the property list \p prp_del routine returns an error value but
+ *          the property is still deleted.
+ *
+ *          The \p copy routine is called when a new property list with
+ *          this property is being created through a \p copy operation.
+ *
+ *          The #H5P_prp_copy_func_t callback function is defined as follows:
+ *
+ *          \snippet this H5P_prp_cb1_t_snip
+ *
+ *          The parameters to the above callback function are:
+ *          <table>
+ *           <tr>
+ *            <td>\Code{const char * name}</td>
+ *            <td>IN: The name of the property being copied</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{size_t size}</td>
+ *            <td>IN: The size of the property in bytes</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{void * value}</td>
+ *            <td>IN/OUT: The value for the property being copied</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The \p copy routine may modify the value to be set and those
+ *          changes will be stored as the new value of the property. If the
+ *          \p copy routine returns a negative value, the new property value
+ *          is not copied into the property and the copy routine returns an
+ *          error value.
+ *
+ *          The \p compare routine is called when a property list with this
+ *          property is compared to another property list with the same
+ *          property.
+ *
+ *          The #H5P_prp_compare_func_t callback function is defined as
+ *          follows:
+ *
+ *          \snippet this H5P_prp_compare_func_t_snip
+ *
+ *          The parameters to the callback function are defined as follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>\Code{const void * value1}</td>
+ *            <td>IN: The value of the first property to compare</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{const void * value2}</td>
+ *            <td>IN: The value of the second property to compare</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{size_t size}</td>
+ *            <td>IN: The size of the property in bytes</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The \p compare routine may not modify the values. The \p compare
+ *          routine should return a positive value if \p value1 is greater
+ *          than \p value2, a negative value if \p value2 is greater than
+ *          \p value1 and zero if \p value1 and \p value2 are equal.
+ *
+ *          The \p close routine is called when a property list with this
+ *          property is being closed.
+ *
+ *          The #H5P_prp_close_func_t callback function is defined as follows:
+ *          \snippet this H5P_prp_cb1_t_snip
+ *
+ *          The parameters to the callback function are defined as follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>\Code{const char * name}</td>
+ *            <td>IN: The name of the property in the list</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{size_t size}</td>
+ *            <td>IN: The size of the property in bytes</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{void * value}</td>
+ *            <td>IN: The value for the property being closed</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The \p close routine may modify the value passed in, the
+ *          value is not used by the library when the close routine
+ *          returns. If the \p close routine returns a negative value,
+ *          the property list \p close routine returns an error value
+ *          but the property list is still closed.
+ *
+ *          \b Note: There is no \p create callback routine for temporary
+ *          property list objects; the initial value is assumed to
+ *          have any necessary setup already performed on it.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pinsert2(hid_t plist_id, const char *name, size_t size, void *value, H5P_prp_set_func_t set,
+                         H5P_prp_get_func_t get, H5P_prp_delete_func_t prp_del, H5P_prp_copy_func_t copy,
+                         H5P_prp_compare_func_t compare, H5P_prp_close_func_t close);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Determines whether a property list is a member of a class
+ *
+ * \plist_id
+ * \plistcls_id{pclass_id}
+ *
+ * \return \htri_t
+ *
+ * \details H5Pisa_class() checks to determine whether the property list
+ *          \p plist_id is a member of the property list class
+ *          \p pclass_id.
+ *
+ * \see H5Pcreate()
+ *
+ * \since  1.6.0
+ *
+ */
+H5_DLL htri_t H5Pisa_class(hid_t plist_id, hid_t pclass_id);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Iterates over properties in a property class or list
+ *
+ * \param[in]     id  Identifier of property object to iterate over
+ * \param[in,out] idx Index of the property to begin with
+ * \param[in]     iter_func  Function pointer to function to be called
+ *                           with each property iterated over
+ * \param[in,out] iter_data  Pointer to iteration data from user
+ *
+ * \return On success: the return value of the last call to \p iter_func if
+ *         it was non-zero; zero if all properties have been processed.
+ *         On Failure, a negative value
+ *
+ * \details H5Piterate() iterates over the properties in the property
+ *          object specified in \p id, which may be either a property
+ *          list or a property class, performing a specified operation
+ *          on each property in turn.
+ *
+ *          For each property in the object, \p iter_func and the
+ *          additional information specified below are passed to the
+ *          #H5P_iterate_t operator function.
+ *
+ *          The iteration begins with the \p idx-th property in the
+ *          object; the next element to be processed by the operator
+ *          is returned in \p idx. If \p idx is NULL, the iterator
+ *          starts at the first property; since no stopping point is
+ *          returned in this case, the iterator cannot be restarted if
+ *          one of the calls to its operator returns non-zero.
+ *
+ *          The operation \p iter_func receives the property list or class
+ *          identifier for the object being iterated over, \p id, the
+ *          name of the current property within the object, \p name,
+ *          and the pointer to the operator data passed in to H5Piterate(),
+ *          \p iter_data.
+ *
+ * \warning H5Piterate() assumes that the properties in the object
+ *          identified by \p id remain unchanged through the iteration.
+ *          If the membership changes during the iteration, the function's
+ *          behavior is undefined.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL int H5Piterate(hid_t id, int *idx, H5P_iterate_t iter_func, void *iter_data);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Registers a permanent property with a property list class
+ *
+ * \plistcls_id{cls_id}
+ * \param[in] name       Name of property to register
+ * \param[in] size       Size of property in bytes
+ * \param[in] def_value  Default value for property in newly created
+ *                       property lists
+ * \param[in] create     Callback routine called when a property list is
+ *                       being created and the property value will be
+ *                       initialized
+ * \param[in] set        Callback routine called before a new value is
+ *                       copied into the property's value
+ * \param[in] get        Callback routine called when a property value is
+ *                       retrieved from the property
+ * \param[in] prp_del    Callback routine called when a property is deleted
+ *                       from a property list
+ * \param[in] copy       Callback routine called when a property is copied
+ *                       from a property list
+ * \param[in] compare    Callback routine called when a property is compared
+ *                       with another property list
+ * \param[in] close      Callback routine called when a property list is
+ *                       being closed and the property value will be
+ *                       disposed of
+ *
+ * \return  \herr_t
+ *
+ * \details H5Pregister2() registers a new property with a property list
+ *          class. The \p cls_id identifier can be obtained by calling
+ *          H5Pcreate_class(). The property will exist in all property
+ *          list objects of \p cl_id created after this routine finishes. The
+ *          name of the property must not already exist, or this routine
+ *          will fail. The default property value must be provided and all
+ *          new property lists created with this property will have the
+ *          property value set to the default value. Any of the callback
+ *          routines may be set to NULL if they are not needed.
+ *
+ *          Zero-sized properties are allowed and do not store any data in
+ *          the property list. These may be used as flags to indicate the
+ *          presence or absence of a particular piece of information. The
+ *          default pointer for a zero-sized property may be set to NULL.
+ *          The property \p create and \p close callbacks are called for
+ *          zero-sized properties, but the \p set and \p get callbacks are
+ *          never called.
+ *
+ *          The \p create routine is called when a new property list with
+ *          this property is being created. The #H5P_prp_create_func_t
+ *          callback function is defined as follows:
+ *
+ *          \snippet this H5P_prp_cb1_t_snip
+ *
+ *          The parameters to this callback function are defined as follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>\Code{const char * name}</td>
+ *            <td>IN: The name of the property being modified</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{size_t size}</td>
+ *            <td>IN: The size of the property in bytes</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{void * value}</td>
+ *            <td>IN/OUT: The default value for the property being created,
+ *                which will be passed to H5Pregister2()</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The \p create routine may modify the value to be set and those
+ *          changes will be stored as the initial value of the property.
+ *          If the \p create routine returns a negative value, the new
+ *          property value is not copied into the property and the
+ *          \p create routine returns an error value.
+ *
+ *          The \p set routine is called before a new value is copied into
+ *          the property. The #H5P_prp_set_func_t callback function is defined
+ *          as follows:
+ *
+ *          \snippet this H5P_prp_cb2_t_snip
+ *
+ *          The parameters to this callback function are defined as follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>\ref hid_t \c prop_id</td>
+ *            <td>IN: The identifier of the property list being modified</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{const char * name}</td>
+ *            <td>IN: The name of the property being modified</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{size_t size}</td>
+ *            <td>IN: The size of the property in bytes</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{void *value}</td>
+ *            <td>IN/OUT: Pointer to new value pointer for the property
+ *                being modified</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The \p set routine may modify the value pointer to be set and
+ *          those changes will be used when setting the property's value.
+ *          If the \p set routine returns a negative value, the new property
+ *          value is not copied into the property and the \p set routine
+ *          returns an error value. The \p set routine will not be called
+ *          for the initial value; only the \p create routine will be called.
+ *
+ *          \b Note: The \p set callback function may be useful to range
+ *          check the value being set for the property or may perform some
+ *          transformation or translation of the value set. The \p get
+ *          callback would then reverse the transformation or translation.
+ *          A single \p get or \p set callback could handle multiple
+ *          properties by performing different actions based on the property
+ *          name or other properties in the property list.
+ *
+ *          The \p get routine is called when a value is retrieved from a
+ *          property value. The #H5P_prp_get_func_t callback function is
+ *          defined as follows:
+ *
+ *          \snippet this H5P_prp_cb2_t_snip
+ *
+ *          The parameters to the callback function are defined as follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>\ref hid_t \c prop_id</td>
+ *            <td>IN: The identifier of the property list being
+ *                queried</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{const char * name}</td>
+ *            <td>IN: The name of the property being queried</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{size_t size}</td>
+ *            <td>IN: The size of the property in bytes</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{void * value}</td>
+ *            <td>IN/OUT: The value of the property being returned</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The \p get routine may modify the value to be returned from the
+ *          query and those changes will be returned to the calling routine.
+ *          If the \p set routine returns a negative value, the query
+ *          routine returns an error value.
+ *
+ *          The \p prp_del routine is called when a property is being
+ *          deleted from a property list. The #H5P_prp_delete_func_t
+ *          callback function is defined as follows:
+ *
+ *          \snippet this H5P_prp_cb2_t_snip
+ *
+ *          The parameters to the callback function are defined as follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>\ref hid_t \c prop_id</td>
+ *            <td>IN: The identifier of the property list the property is
+ *                being deleted from</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{const char * name}</td>
+ *            <td>IN: The name of the property in the list</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{size_t size}</td>
+ *            <td>IN: The size of the property in bytes</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{void * value}</td>
+ *            <td>IN: The value for the property being deleted</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The \p prp_del routine may modify the value passed in, but the
+ *          value is not used by the library when the \p prp_del routine
+ *          returns. If the \p prp_del routine returns a negative value,
+ *          the property list  delete routine returns an error value but
+ *          the property is still deleted.
+ *
+ *          The \p copy routine is called when a new property list with
+ *          this property is being created through a \p copy operation.
+ *          The #H5P_prp_copy_func_t callback function is defined as follows:
+ *
+ *          \snippet this H5P_prp_cb1_t_snip
+ *
+ *          The parameters to the callback function are defined as follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>\Code{const char * name}</td>
+ *            <td>IN: The name of the property being copied</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{size_t size}</td>
+ *            <td>IN: The size of the property in bytes</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{void * value}</td>
+ *            <td>IN/OUT: The value for the property being copied</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The \p copy routine may modify the value to be set and those
+ *          changes will be stored as the new value of the property. If
+ *          the \p copy routine returns a negative value, the new
+ *          property value is not copied into the property and the \p copy
+ *          routine returns an error value.
+ *
+ *          The \p compare routine is called when a property list with this
+ *          property is compared to another property list with the same
+ *          property. The #H5P_prp_compare_func_t callback function is
+ *          defined as follows:
+ *
+ *          \snippet this H5P_prp_compare_func_t_snip
+ *
+ *          The parameters to the callback function are defined as follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>\Code{const void * value1}</td>
+ *            <td>IN: The value of the first property to compare</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{const void * value2}</td>
+ *            <td>IN: The value of the second property to compare</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{size_t size}</td>
+ *            <td>IN: The size of the property in bytes</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The \p compare routine may not modify the values. The \p compare
+ *          routine should return a positive value if \p value1 is greater
+ *          than \p value2, a negative value if \p value2 is greater than
+ *          \p value1 and zero if \p value1 and \p value2 are equal.
+ *
+ *          The \p close routine is called when a property list with this
+ *          property is being closed. The #H5P_prp_close_func_t callback
+ *          function is defined as follows:
+ *
+ *          \snippet this H5P_prp_cb1_t_snip
+ *
+ *          The parameters to the callback function are defined as follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>\Code{const char * name}</td>
+ *            <td>IN: The name of the property in the list</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{size_t size}</td>
+ *            <td>IN: The size of the property in bytes</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\Code{void * value}</td>
+ *            <td>IN: The value for the property being closed</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The \p close routine may modify the value passed in, but the
+ *          value is not used by the library when the \p close routine returns.
+ *          If the \p close routine returns a negative value, the property
+ *          list close routine returns an error value but the property list is
+ *          still closed.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pregister2(hid_t cls_id, const char *name, size_t size, void *def_value,
+                           H5P_prp_create_func_t create, H5P_prp_set_func_t set, H5P_prp_get_func_t get,
+                           H5P_prp_delete_func_t prp_del, H5P_prp_copy_func_t copy,
+                           H5P_prp_compare_func_t compare, H5P_prp_close_func_t close);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Removes a property from a property list
+ *
+ * \plist_id
+ * \param[in] name Name of property to remove
+ *
+ * \return \herr_t
+ *
+ * \details H5Premove() removes a property from a property list. Both
+ *          properties which were in existence when the property list was
+ *          created (i.e. properties registered with H5Pregister()) and
+ *          properties added to the list after it was created (i.e. added
+ *          with H5Pinsert1() may be removed from a property list.
+ *          Properties do not need to be removed from a property list
+ *          before the list itself is closed; they will be released
+ *          automatically when H5Pclose() is called.
+ *
+ *          If a \p close callback exists for the removed property, it
+ *          will be called before the property is released.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Premove(hid_t plist_id, const char *name);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Sets a property list value
+ *
+ * \plist_id
+ * \param[in] name  Name of property to modify
+ * \param[in] value Pointer to value to set the property to
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset() sets a new value for a property in a property list.
+ *          If there is a \p set callback routine registered for this
+ *          property, the \p value will be passed to that routine and any
+ *          changes to the \p value will be used when setting the property
+ *          value. The information pointed to by the \p value pointer
+ *          (possibly modified by the \p set callback) is copied into the
+ *          property list value and may be changed by the application
+ *          making the H5Pset() call without affecting the property value.
+ *
+ *          The property name must exist or this routine will fail.
+ *
+ *          If the \p set callback routine returns an error, the property
+ *          value will not be modified.
+ *
+ *          This routine may not be called for zero-sized properties and
+ *          will return an error in that case.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Pset(hid_t plist_id, const char *name, const void *value);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Removes a property from a property list class
+ *
+ * \plistcls_id{pclass_id}
+ * \param[in] name Name of property to remove
+ *
+ * \return \herr_t
+ *
+ * \details H5Punregister() removes a property from a property list class.
+ *          Future property lists created of that class will not contain
+ *          this property; existing property lists containing this property
+ *          are not affected.
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL herr_t H5Punregister(hid_t pclass_id, const char *name);
+
+/**
+ * \ingroup DCPL
+ *
+ * \brief Verifies that all required filters are available
+ *
+ * \plist_id
+ *
+ * \return \htri_t
+ *
+ * \details H5Pall_filters_avail() verifies that all of the filters set in
+ *         the dataset or group creation property list \p plist_id are
+ *         currently available.
+ *
+ * \version 1.8.5 Function extended to work with group creation property
+ *                lists.
+ * \since 1.6.0
+ *
+ */
+H5_DLL htri_t H5Pall_filters_avail(hid_t plist_id);
+
+/* Object creation property list (OCPL) routines */
+
+/**
+ * \ingroup OCPL
+ *
+ * \brief Retrieves tracking and indexing settings for attribute creation
+ *        order
+ *
+ * \plist_id
+ * \param[out] crt_order_flags Flags specifying whether to track and
+ *             index attribute creation order
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_attr_creation_order() retrieves the settings for
+ *          tracking and indexing attribute creation order on an object.
+ *
+ *          \p plist_id is an object creation property list (\p ocpl),
+ *          as it can be a dataset or group creation property list
+ *          identifier. The term \p ocpl is used when different types
+ *          of objects may be involved.
+ *
+ *          \p crt_order_flags returns flags with the following meanings:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>#H5P_CRT_ORDER_TRACKED</td>
+ *            <td>Attribute creation order is tracked but not necessarily
+ *                indexed.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5P_CRT_ORDER_INDEXED </td>
+ *            <td>Attribute creation order is indexed (requires
+ *                #H5P_CRT_ORDER_TRACKED).</td>
+ *           </tr>
+ *          </table>
+ *
+ *          If \p crt_order_flags is returned with a value of 0 (zero),
+ *          attribute creation order is neither tracked nor indexed.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_attr_creation_order(hid_t plist_id, unsigned *crt_order_flags);
+/**
+ * \ingroup OCPL
+ *
+ * \brief Retrieves attribute storage phase change thresholds
+ *
+ * \plist_id
+ * \param[out] max_compact Maximum number of attributes to be stored in
+ *                         compact storage (Default: 8)
+ * \param[out] min_dense   Minimum number of attributes to be stored in
+ *                         dense storage (Default: 6)
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_attr_phase_change() retrieves threshold values for
+ *          attribute storage on an object. These thresholds determine the
+ *          point at which attribute storage changes from compact storage
+ *          (i.e., storage in the object header) to dense storage (i.e.,
+ *          storage in a heap and indexed with a B-tree).
+ *
+ *          In the general case, attributes are initially kept in compact
+ *          storage. When the number of attributes exceeds \p max_compact,
+ *          attribute storage switches to dense storage. If the number of
+ *          attributes subsequently falls below \p min_dense, the
+ *          attributes are returned to compact storage.
+ *
+ *          If \p max_compact is set to 0 (zero), dense storage always used.
+ *
+ *          \p plist_id is an object creation property list (\p ocpl), as it
+ *          can be a dataset or group creation property list identifier.
+ *          The term \p ocpl is used when different types of objects may be
+ *          involved.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_attr_phase_change(hid_t plist_id, unsigned *max_compact, unsigned *min_dense);
+/**
+ * \ingroup OCPL
+ *
+ * \brief Returns information about a filter in a pipeline
+ *
+ * \ocpl_id{plist_id}
+ * \param[in] idx    Sequence number within the filter pipeline of the filter
+ *                   for which information is sought
+ * \param[out] flags Bit vector specifying certain general properties of the
+ *                   filter
+ * \param[in,out] cd_nelmts Number of elements in \p cd_values
+ * \param[out]    cd_values Auxiliary data for the filter
+ * \param[in]     namelen   Anticipated number of characters in \p name
+ * \param[out]    name      Name of the filter
+ * \param[out] filter_config Bit field, as described in H5Zget_filter_info()
+ *
+ * \return Returns a negative value on failure, and the filter identifier
+ *         if successful (see #H5Z_filter_t):
+ *         - #H5Z_FILTER_DEFLATE     Data compression filter,
+ *                                    employing the gzip algorithm
+ *         - #H5Z_FILTER_SHUFFLE     Data shuffling filter
+ *         - #H5Z_FILTER_FLETCHER32  Error detection filter, employing the
+ *                                     Fletcher32 checksum algorithm
+ *         - #H5Z_FILTER_SZIP        Data compression filter, employing the
+ *                                     SZIP algorithm
+ *         - #H5Z_FILTER_NBIT        Data compression filter, employing the
+ *                                     N-bit algorithm
+ *         - #H5Z_FILTER_SCALEOFFSET Data compression filter, employing the
+ *                                     scale-offset algorithm
+ *
+ * \details H5Pget_filter2() returns information about a filter specified by
+ *          its filter number, in a filter pipeline specified by the property
+ *          list with which it is associated.
+ *
+ *          \p plist_id must be a dataset or group creation property list.
+ *
+ *          \p idx is a value between zero and N-1, as described in
+ *          H5Pget_nfilters(). The function will return a negative value if
+ *          the filter number is out of range.
+ *
+ *          The structure of the \p flags argument is discussed in
+ *          H5Pset_filter().
+ *
+ *          On input, \p cd_nelmts indicates the number of entries in the
+ *          \p cd_values array, as allocated by the caller; on return,
+ *          \p cd_nelmts contains the number of values defined by the filter.
+ *
+ *          If \p name is a pointer to an array of at least \p namelen bytes,
+ *          the filter name will be copied into that array. The name will be
+ *          null terminated if \p namelen is large enough. The filter name
+ *          returned will be the name appearing in the file, the name
+ *          registered for the filter, or an empty string.
+ *
+ *          \p filter_config is the bit field described in
+ *          H5Zget_filter_info().
+ *
+ * \version 1.8.5 Function extended to work with group creation property
+ *                lists.
+ * \since 1.8.0
+ *
+ */
+H5_DLL H5Z_filter_t H5Pget_filter2(hid_t plist_id, unsigned idx, unsigned int *flags /*out*/,
+                                   size_t *cd_nelmts /*out*/, unsigned cd_values[] /*out*/, size_t namelen,
+                                   char name[], unsigned *filter_config /*out*/);
+/**
+ * \ingroup OCPL
+ *
+ * \brief Returns information about the specified filter
+ *
+ * \ocpl_id{plist_id}
+ * \param[in]     filter_id     Filter identifier
+ * \param[out]    flags         Bit vector specifying certain general
+ *                              properties of the filter
+ * \param[in,out] cd_nelmts     Number of elements in \p cd_values
+ * \param[out]    cd_values[]   Auxiliary data for the filter
+ * \param[in]     namelen       Length of filter name and number of
+ *                              elements in \p name
+ * \param[out]    name[]        Name of filter
+ * \param[out]    filter_config Bit field, as described in
+ *                              H5Zget_filter_info()
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_filter_by_id2() returns information about the filter
+ *          specified in \p filter_id, a filter identifier.
+ *
+ *          \p plist_id must be a dataset or group creation property list
+ *          and \p filter_id must be in the associated filter pipeline.
+ *
+ *          The \p filter_id and \p flags parameters are used in the same
+ *          manner as described in the discussion of H5Pset_filter().
+ *
+ *          Aside from the fact that they are used for output, the
+ *          parameters \p cd_nelmts and \p cd_values[] are used in the same
+ *          manner as described in the discussion of H5Pset_filter(). On
+ *          input, the \p cd_nelmts parameter indicates the number of
+ *          entries in the \p cd_values[] array allocated by the calling
+ *          program; on exit it contains the number of values defined by
+ *          the filter.
+ *
+ *          On input, the \p namelen parameter indicates the number of
+ *          characters allocated for the filter name by the calling program
+ *          in the array \p name[]. On exit \p name[] contains the name of the
+ *          filter with one character of the name in each element of the
+ *          array.
+ *
+ *          \p filter_config is the bit field described in
+ *          H5Zget_filter_info().
+ *
+ *          If the filter specified in \p filter_id is not set for the
+ *          property list, an error will be returned and
+ *          H5Pget_filter_by_id2() will fail.
+ *
+ * \version 1.8.5 Function extended to work with group creation property
+ *                lists.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_filter_by_id2(hid_t plist_id, H5Z_filter_t filter_id, unsigned int *flags /*out*/,
+                                   size_t *cd_nelmts /*out*/, unsigned cd_values[] /*out*/, size_t namelen,
+                                   char name[] /*out*/, unsigned *filter_config /*out*/);
+/**
+ * \ingroup OCPL
+ *
+ * \brief Returns the number of filters in the pipeline
+ *
+ * \ocpl_id{plist_id}
+ *
+ * \return  Returns the number of filters in the pipeline if successful;
+ *          otherwise returns a negative value.
+ *
+ * \details H5Pget_nfilters() returns the number of filters defined in the
+ *          filter pipeline associated with the property list \p plist_id.
+ *
+ *          In each pipeline, the filters are numbered from 0 through \Code{N-1},
+ *          where \c N is the value returned by this function. During output to
+ *          the file, the filters are applied in increasing order; during
+ *          input from the file, they are applied in decreasing order.
+ *
+ *          H5Pget_nfilters() returns the number of filters in the pipeline,
+ *          including zero (0) if there are none.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL int H5Pget_nfilters(hid_t plist_id);
+/**
+ * \ingroup OCPL
+ *
+ * \brief Determines whether times associated with an object
+ *       are being recorded
+ *
+ * \plist_id
+ * \param[out] track_times Boolean value, 1 (true) or 0 (false),
+ *             specifying whether object times are being recorded
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_obj_track_times() queries the object creation property
+ *          list, \p plist_id, to determine whether object times are being
+ *          recorded.
+ *
+ *          If \p track_times is returned as 1, times are being recorded;
+ *          if \p track_times is returned as 0, times are not being
+ *          recorded.
+ *
+ *          Time data can be retrieved with H5Oget_info(), which will return
+ *          it in the #H5O_info_t struct.
+ *
+ *          If times are not tracked, they will be reported as follows
+ *          when queried: 12:00 AM UDT, Jan. 1, 1970
+ *
+ *          See H5Pset_obj_track_times() for further discussion.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_obj_track_times(hid_t plist_id, hbool_t *track_times);
+/**
+ * \ingroup OCPL
+ *
+ * \brief Modifies a filter in the filter pipeline
+ *
+ * \ocpl_id{plist_id}
+ * \param[in] filter      Filter to be modified
+ * \param[in] flags       Bit vector specifying certain general properties
+ *                        of the filter
+ * \param[in] cd_nelmts   Number of elements in \p cd_values
+ * \param[in] cd_values[] Auxiliary data for the filter
+ *
+ * \return \herr_t
+ *
+ * \details H5Pmodify_filter() modifies the specified \p filter in the
+ *          filter pipeline. \p plist_id must be a dataset or group
+ *          creation property list.
+ *
+ *          The \p filter, \p flags \p cd_nelmts[], and \p cd_values
+ *          parameters are used in the same manner and accept the same
+ *          values as described in the discussion of H5Pset_filter().
+ *
+ * \version 1.8.5 Function extended to work with group creation property
+ *                lists.
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pmodify_filter(hid_t plist_id, H5Z_filter_t filter, unsigned int flags, size_t cd_nelmts,
+                               const unsigned int cd_values[/*cd_nelmts*/]);
+/**
+ * \ingroup OCPL
+ *
+ * \brief    Delete one or more filters in the filter pipeline
+ *
+ * \ocpl_id{plist_id}
+ * \param[in] filter Filter to be deleted
+ *
+ * \return \herr_t
+ *
+ * \details H5Premove_filter() removes the specified \p filter from the
+ *          filter pipeline in the dataset or group creation property
+ *          list \p plist_id.
+ *
+ *          The \p filter parameter specifies the filter to be removed.
+ *          Valid values for use in \p filter are as follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>#H5Z_FILTER_ALL</td>
+ *            <td>Removes all filters from the filter pipeline</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5Z_FILTER_DEFLATE</td>
+ *            <td>Data compression filter, employing the gzip
+ *                algorithm</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5Z_FILTER_SHUFFLE</td>
+ *            <td>Data shuffling filter</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5Z_FILTER_FLETCHER32</td>
+ *            <td>Error detection filter, employing the Fletcher32
+ *                checksum algorithm</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5Z_FILTER_SZIP</td>
+ *            <td>Data compression filter, employing the SZIP
+ *                algorithm</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5Z_FILTER_NBIT</td>
+ *            <td>Data compression filter, employing the N-Bit
+ *                algorithm</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5Z_FILTER_SCALEOFFSET</td>
+ *            <td>Data compression filter, employing the scale-offset
+ *                algorithm</td>
+ *           </tr>
+ *          </table>
+ *
+ *          Additionally, user-defined filters can be removed with this
+ *          routine by passing the filter identifier with which they were
+ *          registered with the HDF5 library.
+ *
+ *          Attempting to remove a filter that is not in the filter
+ *          pipeline is an error.
+ *
+ * \version 1.8.5 Function extended to work with group creation property
+ *                lists.
+ * \since 1.6.3
+ *
+ */
+H5_DLL herr_t H5Premove_filter(hid_t plist_id, H5Z_filter_t filter);
+/**
+ * \ingroup OCPL
+ *
+ * \brief Sets tracking and indexing of attribute creation order
+ *
+ * \plist_id
+ * \param[in] crt_order_flags Flags specifying whether to track and index
+ *                            attribute creation order. \em Default: No
+ *                            flag set; attribute creation order is neither
+ *                            tracked not indexed
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_attr_creation_order() sets flags for tracking and
+ *          indexing attribute creation order on an object.
+ *
+ *          \p plist_id is a dataset or group creation property list
+ *          identifier.
+ *
+ *          \p crt_order_flags contains flags with the following meanings:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>#H5P_CRT_ORDER_TRACKED</td>
+ *            <td>Attribute creation order is tracked but not necessarily
+ *                indexed.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5P_CRT_ORDER_INDEXED </td>
+ *            <td>Attribute creation order is indexed (requires
+ *                #H5P_CRT_ORDER_TRACKED).</td>
+ *           </tr>
+ *          </table>
+ *
+ *          Default behavior is that attribute creation order is neither
+ *          tracked nor indexed.
+ *
+ *          H5Pset_attr_creation_order() can be used to set attribute
+ *          creation order tracking, or to set attribute creation order
+ *          tracking and indexing.
+ *
+ * \note If a creation order index is to be built, it must be specified in
+ *       the object creation property list. HDF5 currently provides no
+ *       mechanism to turn on attribute creation order tracking at object
+ *       creation time and to build the index later.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_attr_creation_order(hid_t plist_id, unsigned crt_order_flags);
+/**
+ * \ingroup OCPL
+ *
+ * \brief Sets attribute storage phase change thresholds
+ *
+ * \plist_id
+ * \param[in] max_compact  Maximum number of attributes to be stored in
+ *                         compact storage (\em Default: 8); must be greater
+ *                         than or equal to \p min_dense
+ *
+ * \param[in] min_dense    Minimum number of attributes to be stored in
+ *                         dense storage (\em Default: 6)
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_attr_phase_change() sets threshold values for attribute
+ *          storage on an object. These thresholds determine the point at
+ *          which attribute storage changes from compact storage (i.e.,
+ *          storage in the object header) to dense storage (i.e., storage
+ *          in a heap and indexed with a B-tree).
+ *
+ *          In the general case, attributes are initially kept in compact
+ *          storage. When the number of attributes exceeds \p max_compact,
+ *          attribute storage switches to dense storage. If the number of
+ *          attributes subsequently falls below \p min_dense, the attributes
+ *          are returned to compact storage.
+ *
+ *          If \p max_compact is set to 0 (zero), dense storage is always
+ *          used.  \p min_dense must be set to 0 (zero) when \p max_compact
+ *          is 0 (zero).
+ *
+ *          \p plist_id is a dataset or group creation property list
+ *          identifier.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_attr_phase_change(hid_t plist_id, unsigned max_compact, unsigned min_dense);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Sets deflate (GNU gzip) compression method and compression level
+ *
+ * \ocpl_id{plist_id}
+ * \param[in] level Compression level
+ *
+ * \return \herr_t
+ *
+ * \par_compr_note
+ *
+ * \details H5Pset_deflate() sets the deflate compression method and the
+ *          compression level, \p level, for a dataset or group creation
+ *          property list, \p plist_id.
+ *
+ *          The filter identifier set in the property list is
+ *          #H5Z_FILTER_DEFLATE.
+ *
+ *          The compression level, \p level, is a value from zero to nine,
+ *          inclusive. A compression level of 0 (zero) indicates no
+ *          compression; compression improves but speed slows progressively
+ *          from levels 1 through 9:
+ *
+ *          <table>
+ *            <tr>
+ *              <th>Compression Level</th>
+ *              <th>Gzip Action</th>
+ *            </tr>
+ *            <tr>
+ *              <td>0</td>
+ *              <td>No compression</td>
+ *            </tr>
+ *            <tr>
+ *              <td>1</td>
+ *              <td>Best compression speed; least compression</td>
+ *            </tr>
+ *           <tr>
+ *             <td>2 through 8</td>
+ *             <td>Compression improves; speed degrades</td>
+ *           </tr>
+ *           <tr>
+ *             <td>9</td>
+ *             <td>Best compression ratio; slowest speed</td>
+ *           </tr>
+ *          </table>
+ *
+ *          Note that setting the compression level to 0 (zero) does not turn
+ *          off use of the gzip filter; it simply sets the filter to perform
+ *          no compression as it processes the data.
+ *
+ *          HDF5 relies on GNU gzip for this compression.
+ *
+ * \version 1.8.5 Function extended to work with group creation property lists.
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pset_deflate(hid_t plist_id, unsigned level);
+/**
+ * \ingroup OCPL
+ *
+ * \brief Adds a filter to the filter pipeline
+ *
+ * \ocpl_id{plist_id}
+ * \param[in] filter    Filter identifier for the filter to be added to the
+ *                      pipeline
+ * \param[in] flags     Bit vector specifying certain general properties of
+ *                      the filter
+ * \param[in] cd_nelmts Number of elements in \p c_values
+ * \param[in] c_values  Auxiliary data for the filter
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_filter() adds the specified \p filter identifier and
+ *          corresponding properties to the end of an output filter
+ *          pipeline.
+ *
+ *          \p plist_id must be either a dataset creation property list or
+ *          group creation property list identifier. If \p plist_id is a
+ *          dataset creation property list identifier, the filter is added
+ *          to the raw data filter pipeline.
+ *
+ *          If \p plist_id is a group creation property list identifier,
+ *          the filter is added to the link filter pipeline, which filters
+ *          the fractal heap used to store most of the link metadata in
+ *          certain types of groups. The only predefined filters that can
+ *          be set in a group creation property list are the gzip filter
+ *          (#H5Z_FILTER_DEFLATE) and the Fletcher32 error detection filter
+ *          (#H5Z_FILTER_FLETCHER32).
+ *
+ *          The array \p cd_values contains \p cd_nelmts unsigned integers
+ *          which are auxiliary data for the filter. The values are typically
+ *          used as parameters to control the filter. In a filter's
+ *          \p set_local method (called from \p H5Dcreate), the values are
+ *          interpreted and possibly modified before they are used to control
+ *          the filter. These, possibly modified values, are then stored in
+ *          the dataset object header as auxiliary data for the filter.
+ *
+ *          The \p flags argument is a bit vector with the following
+ *          fields specifying certain general properties of the filter:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>#H5Z_FLAG_OPTIONAL</td>
+ *            <td>If this bit is set then the filter is optional. If the
+ *                filter fails (see below) during an H5Dwrite() operation
+ *                then the filter is just excluded from the pipeline for
+ *                the chunk for which it failed; the filter will not
+ *                participate in the pipeline during an H5Dread() of the
+ *                chunk. This is commonly used for compression filters:
+ *                if the filter result would be larger than the input,
+ *                then the compression filter returns failure and the
+ *                uncompressed data is stored in the file.<br /><br />
+ *                This flag should not be set for the Fletcher32 checksum
+ *                filter as it will bypass the checksum filter without
+ *                reporting checksum errors to an application.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5Z_FLAG_MANDATORY</td>
+ *            <td>If the filter is required, that is, set to mandatory,
+ *                and the filter fails, the library's behavior depends
+ *                on whether the chunk cache is in use:
+ *                \li If the chunk cache is enabled, data chunks will
+ *                    be flushed to the file during H5Dclose() and the
+ *                    library will return the failure in H5Dclose().
+ *                \li When the chunk cache is disabled or not big enough,
+ *                    or the chunk is being evicted from the cache, the
+ *                    failure will happen during H5Dwrite().
+ *
+ *                In each case, the library will still write to the file
+ *                all data chunks that were processed by the filter
+ *                before the failure occurred.<br /><br />
+ *                For example, assume that an application creates a
+ *                dataset of four chunks, the chunk cache is enabled and
+ *                is big enough to hold all four chunks, and the filter
+ *                fails when it tries to write the fourth chunk. The
+ *                actual flush of the chunks will happen during
+ *                H5Dclose(), not H5Dwrite(). By the time H5Dclose()
+ *                fails, the first three chunks will have been written
+ *                to the file. Even though H5Dclose() fails, all the
+ *                resources will be released and the file can be closed
+ *                properly. <br /><br />
+ *                If, however, the filter fails on the second chunk, only
+ *                the first chunk will be written to the file as nothing
+ *                further can be written once the filter fails.</td>
+ *           </tr>
+ *          </table>
+ *          The \p filter parameter specifies the filter to be set. Valid
+ *          pre-defined filter identifiers are as follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>#H5Z_FILTER_DEFLATE</td>
+ *            <td>Data compression filter, employing the gzip
+ *                algorithm</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5Z_FILTER_SHUFFLE</td>
+ *            <td>Data shuffling filter</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5Z_FILTER_FLETCHER32</td>
+ *            <td>Error detection filter, employing the Fletcher32
+ *                checksum algorithm</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5Z_FILTER_SZIP</td>
+ *            <td>Data compression filter, employing the SZIP
+ *                algorithm</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5Z_FILTER_NBIT</td>
+ *            <td>Data compression filter, employing the N-Bit
+ *                algorithm</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5Z_FILTER_SCALEOFFSET</td>
+ *            <td>Data compression filter, employing the scale-offset
+ *                algorithm</td>
+ *           </tr>
+ *          </table>
+ *          Also see H5Pset_edc_check() and H5Pset_filter_callback().
+ *
+ * \note When a non-empty filter pipeline is used with a group creation
+ *       property list, the group will be created with the new group file
+ *       format. The filters will come into play only when dense storage
+ *       is used (see H5Pset_link_phase_change()) and will be applied to
+ *       the group's fractal heap. The fractal heap will contain most of
+ *       the group's link metadata, including link names.
+ *
+ * \note When working with group creation property lists, if you are
+ *       adding a filter that is not in HDF5's set of predefined filters,
+ *       i.e., a user-defined or third-party filter, you must first
+ *       determine that the filter will work for a group. See the
+ *       discussion of the set local and can apply callback functions
+ *       in H5Zregister().
+ *
+ * \note If multiple filters are set for a property list, they will be
+ *       applied to each chunk of raw data for datasets or each block
+ *       of the fractal heap for groups in the order in which they were
+ *       set.
+ *
+ * \note Filters can be applied only to chunked datasets; they cannot be
+ *       used with other dataset storage methods, such as contiguous,
+ *       compact, or external datasets.
+ *
+ * \note Dataset elements of variable-length and dataset region
+ *       reference datatypes are stored in separate structures in the
+ *       file called heaps. Filters cannot currently be applied to
+ *       these heaps.
+ *
+ * \note <b>Filter Behavior in HDF5:</b><br />
+ *       Filters can be inserted into the HDF5 pipeline to perform
+ *       functions such as compression and conversion. As such, they are
+ *       a very flexible aspect of HDF5; for example, a user-defined
+ *       filter could provide encryption for an HDF5 dataset.
+ *
+ * \note A filter can be declared as either required or optional.
+ *       Required is the default status; optional status must be
+ *       explicitly declared.
+ *
+ * \note A required filter that fails or is not defined causes an
+ *       entire output operation to fail; if it was applied when the
+ *       data was written, such a filter will cause an input operation
+ *       to fail.
+ *
+ * \note The following table summarizes required filter behavior.
+ *          <table>
+ *           <tr>
+ *            <th></th>
+ *            <th>Required FILTER_X not available</th>
+ *            <th>FILTER_X available</th>
+ *           </tr>
+ *           <tr>
+ *            <td>H5Pset_<FILTER_X></td>
+ *            <td>Will fail.</td>
+ *            <td>Will succeed.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>H5Dwrite with FILTER_X set</td>
+ *            <td>Will fail.</td>
+ *            <td>Will succeed; FILTER_X will be applied to
+ *                the data.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>H5Dread with FILTER_X set</td>
+ *            <td>Will fail.</td>
+ *            <td>Will succeed.</td>
+ *           </tr>
+ *          </table>
+ * \note An optional filter can be set for an HDF5 dataset even when
+ *       the filter is not available. Such a filter can then be
+ *       applied to the dataset when it becomes available on the
+ *       original system or when the file containing the dataset is
+ *       processed on a system on which it is available.
+ *
+ * \note A filter can be declared as optional through the use of the
+ *       #H5Z_FLAG_OPTIONAL flag with H5Pset_filter().
+ *
+ * \note Consider a situation where one is creating files that will
+ *       normally be used only on systems where the optional (and
+ *       fictional) filter FILTER_Z is routinely available. One can
+ *       create those files on system A, which lacks FILTER_Z, create
+ *       chunked datasets in the files with FILTER_Z defined in the
+ *       dataset creation property list, and even write data to those
+ *       datasets. The dataset object header will indicate that FILTER_Z
+ *       has been associated with this dataset. But since system A does
+ *       not have FILTER_Z, dataset chunks will be written without it
+ *       being applied.
+ *
+ * \note HDF5 has a mechanism for determining whether chunks are
+ *       actually written with the filters specified in the object
+ *       header, so while the filter remains unavailable, system A will
+ *       be able to read the data. Once the file is moved to system B,
+ *       where FILTER_Z is available, HDF5 will apply FILTER_Z to any
+ *       data rewritten or new data written in these datasets. Dataset
+ *       chunks that have been written on system B will then be
+ *       unreadable on system A; chunks that have not been re-written
+ *       since being written on system A will remain readable on system
+ *       A. All chunks will be readable on system B.
+ *
+ * \note The following table summarizes optional filter behavior.
+ *          <table>
+ *           <tr>
+ *            <th></th>
+ *            <th>FILTER_Z not available</th>
+ *            <th>FILTER_Z available<br /> with encode and decode</th>
+ *            <th>FILTER_Z available decode only</th>
+ *           </tr>
+ *           <tr>
+ *            <td>H5Pset_<FILTER_Z></td>
+ *            <td>Will succeed.</td>
+ *            <td>Will succeed.</td>
+ *            <td>Will succeed.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>H5Dread with FILTER_Z set</td>
+ *            <td>Will succeed if FILTER_Z has not actually<br />
+ *                been applied to data.</td>
+ *            <td>Will succeed.</td>
+ *            <td>Will succeed.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>H5Dwrite with FILTER_Z set</td>
+ *            <td>Will succeed;<br />
+ *                FILTER_Z will not be applied to the data.</td>
+ *            <td>Will succeed;<br />
+ *            FILTER_Z will be applied to the data.</td>
+ *            <td>Will succeed;<br />
+ *            FILTER_Z will not be applied to the data.</td>
+ *           </tr>
+ *          </table>
+ * \note The above principles apply generally in the use of HDF5
+ *       optional filters insofar as HDF5 does as much as possible to
+ *       complete an operation when an optional filter is unavailable.
+ *       (The SZIP filter is an exception to this rule; see H5Pset_szip()
+ *       for details.)
+ *
+ * \see \ref_filter_pipe, \ref_group_impls
+ *
+ * \version 1.8.5 Function applied to group creation property lists.
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pset_filter(hid_t plist_id, H5Z_filter_t filter, unsigned int flags, size_t cd_nelmts,
+                            const unsigned int c_values[]);
+/**
+ * \ingroup OCPL
+ *
+ * \brief Sets up use of the Fletcher32 checksum filter
+ *
+ * \ocpl_id{plist_id}
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_fletcher32() sets the Fletcher32 checksum filter in the
+ *          dataset or group creation property list \p plist_id.
+ *
+ * \attention The Fletcher32 EDC checksum filter was added in HDF5 Release
+ *            1.6.0. In the original implementation, however, the checksum
+ *            value was calculated incorrectly on little-endian systems.
+ *            The error was fixed in HDF5 Release 1.6.3.
+ *
+ * \attention As a result of this fix, an HDF5 library of Release 1.6.0
+ *            through Release 1.6.2 cannot read a dataset created or written
+ *            with Release 1.6.3 or later if the dataset was created with
+ *            the checksum filter and the filter is enabled in the reading
+ *            library. (Libraries of Release 1.6.3 and later understand the
+ *            earlier error and compensate appropriately.)
+ *
+ * \attention \b Work-around: An HDF5 library of Release 1.6.2 or earlier
+ *            will be able to read a dataset created or written with the
+ *            checksum filter by an HDF5 library of Release 1.6.3 or later
+ *            if the checksum filter is disabled for the read operation.
+ *            This can be accomplished via a call to H5Pset_edc_check()
+ *            with the value #H5Z_DISABLE_EDC in the second parameter.
+ *            This has the obvious drawback that the application will be
+ *            unable to verify the checksum, but the data does remain
+ *            accessible.
+ *
+ * \version 1.8.5 Function extended to work with group creation property
+ *                lists.
+ * \version 1.6.3 Error in checksum calculation on little-endian systems
+ *                corrected in this release.
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pset_fletcher32(hid_t plist_id);
+/**
+ * \ingroup OCPL
+ *
+ * \brief Sets the recording of times associated with an object
+ *
+ * \param[in] plist_id    Object creation property list identifier
+ * \param[in] track_times Boolean value, 1 or 0, specifying whether object
+ *                        times are to be tracked
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_obj_track_times() sets a property in the object creation
+ *          property list, \p plist_id, that governs the recording of times
+ *          associated with an object.
+ *
+ *          If \p track_times is set to 1, time data will be recorded. If
+ *          \p track_times is set to 0, time data will not be recorded.
+ *
+ *          Time data can be retrieved with H5Oget_info(), which will
+ *          return it in the #H5O_info_t struct.
+ *
+ *          If times are not tracked, they will be reported as follows when queried:
+ *            \Code{ 12:00 AM UDT, Jan. 1, 1970}
+ *
+ *          That date and time are commonly used to represent the beginning of the UNIX epoch.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_obj_track_times(hid_t plist_id, hbool_t track_times);
+
+/* File creation property list (FCPL) routines */
+/**
+ * \ingroup FCPL
+ *
+ * \brief Retrieves the file space page size for a file creation property
+ *        list
+ *
+ * \fcpl_id{plist_id}
+ * \param[out] fsp_size  File space page size
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_file_space_page_size() retrieves the file space page
+ *          size for paged aggregation in the parameter \p fsp_size.
+ *
+ *          The library default is 4KB (4096) if \p fsp_size is not
+ *          previously set via a call to H5Pset_file_space_page_size().
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5Pget_file_space_page_size(hid_t plist_id, hsize_t *fsp_size);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Retrieves the file space handling strategy, persisting free-space
+ *        condition and threshold value for a file creation property list
+ *
+ * \fcpl_id{plist_id}
+ * \param[out] strategy  The file space handling strategy
+ * \param[out] persist   The boolean value indicating whether free space is
+ *                       persistent or not
+ * \param[out] threshold The free-space section size threshold value
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_file_space_strategy() retrieves the file space handling
+ *          strategy, the persisting free-space condition and the threshold
+ *          value in the parameters \p strategy, \p persist and
+ *          \p threshold respectively.
+ *
+ *          The library default values returned when
+ *          H5Pset_file_space_strategy() has not been called are:
+ *
+ *          \li \p strategy  - #H5F_FSPACE_STRATEGY_FSM_AGGR
+ *          \li \p persist   - 0
+ *          \li \p threshold - 1
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5Pget_file_space_strategy(hid_t plist_id, H5F_fspace_strategy_t *strategy, hbool_t *persist,
+                                         hsize_t *threshold);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Queries the 1/2 rank of an indexed storage B-tree
+ *
+ * \fcpl_id{plist_id}
+ * \param[out] ik Pointer to location to return the chunked storage B-tree
+ *                1/2 rank (<em>Default value of B-tree 1/2 rank: 32</em>)
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_istore_k() queries the 1/2 rank of an indexed storage
+ *          B-tree.
+ *
+ *          The argument \p ik may be the null pointer (NULL).
+ *          This function is valid only for file creation property lists.
+ *
+ * \see H5Pset_istore_k()
+ *
+ * \version 1.6.4 \p ik parameter type changed to \em unsigned.
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pget_istore_k(hid_t plist_id, unsigned *ik /*out*/);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Retrieves the configuration settings for a shared message index
+ *
+ * \fcpl_id{plist_id}
+ * \param[in]  index_num       Index being configured
+ * \param[out] mesg_type_flags Types of messages that may be stored in
+ *                             this index
+ * \param[out] min_mesg_size   Minimum message size
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_shared_mesg_index() retrieves the message type and
+ *          minimum message size settings from the file creation property
+ *          list \p plist_id for the shared object header message index
+ *          specified by \p index_num.
+ *
+ *          \p index_num specifies the index. \p index_num is zero-indexed,
+ *          so in a file with three indexes, they will be numbered 0, 1,
+ *          and 2.
+ *
+ *          \p mesg_type_flags and \p min_mesg_size will contain,
+ *          respectively, the types of messages and the minimum size, in
+ *          bytes, of messages that can be stored in this index.
+ *
+ *          Valid message types are described in H5Pset_shared_mesg_index().
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_shared_mesg_index(hid_t plist_id, unsigned index_num, unsigned *mesg_type_flags,
+                                       unsigned *min_mesg_size);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Retrieves the number of shared object header message indexes in file
+ *        creation property list
+ *
+ * \fcpl_id{plist_id}
+ * \param[out] nindexes  Number of shared object header message indexes
+ *                       available in files created with this property list
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_shared_mesg_nindexes() retrieves the number of shared
+ *          object header message indexes in the specified file creation
+ *          property list \p plist_id.
+ *
+ *          If the value of \p nindexes is 0 (zero), shared object header
+ *          messages are disabled in files created with this property list.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_shared_mesg_nindexes(hid_t plist_id, unsigned *nindexes);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Retrieves shared object header message phase change information
+ *
+ * \fcpl_id{plist_id}
+ * \param[out] max_list  Threshold above which storage of a shared object
+ *                       header message index shifts from list to B-tree
+ * \param[out] min_btree Threshold below which storage of a shared object
+ *                       header message index reverts to list format
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_shared_mesg_phase_change() retrieves the threshold values
+ *          for storage of shared object header message indexes in a file.
+ *          These phase change thresholds determine the point at which the
+ *          index storage mechanism changes from a more compact list format
+ *          to a more performance-oriented B-tree format, and vice-versa.
+ *
+ *          By default, a shared object header message index is initially
+ *          stored as a compact list. When the number of messages in an
+ *          index exceeds the specified \p max_list threshold, storage
+ *          switches to a B-tree format for improved performance. If the
+ *          number of messages subsequently falls below the \p min_btree
+ *          threshold, the index will revert to the list format.
+ *
+ *          If \p max_list is set to 0 (zero), shared object header message
+ *          indexes in the file will always be stored as B-trees.
+ *
+ *          \p plist_id specifies the file creation property list.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_shared_mesg_phase_change(hid_t plist_id, unsigned *max_list, unsigned *min_btree);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Retrieves the size of the offsets and lengths used in an HDF5
+ *        file
+ *
+ * \fcpl_id{plist_id}
+ * \param[out] sizeof_addr Pointer to location to return offset size in
+ *             bytes
+ * \param[out] sizeof_size Pointer to location to return length size in
+ *             bytes
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_sizes() retrieves the size of the offsets and lengths
+ *          used in an HDF5 file. This function is only valid for file
+ *          creation property lists.
+ *
+ * \since  1.0.0
+ *
+ */
+H5_DLL herr_t H5Pget_sizes(hid_t plist_id, size_t *sizeof_addr /*out*/, size_t *sizeof_size /*out*/);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Retrieves the size of the symbol table B-tree 1/2 rank and the
+ *        symbol table leaf node 1/2 size
+ *
+ * \fcpl_id{plist_id}
+ * \param[out] ik Pointer to location to return the symbol table's B-tree
+ *                1/2 rank (<em>Default value of B-tree 1/2 rank: 16</em>)
+ * \param[out] lk Pointer to location to return the symbol table's leaf
+ *                node 1/2 size (<em>Default value of leaf node 1/2
+ *                size: 4</em>)
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_sym_k() retrieves the size of the symbol table B-tree
+ *          1/2 rank and the symbol table leaf node 1/2 size.
+ *
+ *          This function is valid only for file creation property lists.
+ *
+ *          If a parameter value is set to NULL, that parameter is not
+ *          retrieved.
+ *
+ * \see H5Pset_sym_k()
+ *
+ * \version 1.6.4 \p ik parameter type changed to \em unsigned
+ * \version 1.6.0 The \p ik parameter has changed from type int to
+ *                \em unsigned
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pget_sym_k(hid_t plist_id, unsigned *ik /*out*/, unsigned *lk /*out*/);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Retrieves the size of a user block
+ *
+ * \fcpl_id{plist_id}
+ * \param[out] size  Pointer to location to return user-block size
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_userblock() retrieves the size of a user block in a
+ *          file creation property list.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pget_userblock(hid_t plist_id, hsize_t *size);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Sets the file space page size for a file creation property list
+ *
+ * \fcpl_id{plist_id}
+ * \param[in]   fsp_size    File space page size
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_file_space_page_size() sets the file space page size
+ *          \p fsp_size used in paged aggregation and paged buffering.
+ *
+ *          \p fsp_size has a minimum size of 512. Setting a value less
+ *          than 512 will return an error. The library default size for
+ *          the file space page size when not set is 4096.
+ *
+ *          The size set via this routine may not be changed for the life
+ *          of the file.
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5Pset_file_space_page_size(hid_t plist_id, hsize_t fsp_size);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Sets the file space handling strategy and persisting free-space
+ *        values for a file creation property list
+ *
+ * \fcpl_id{plist_id}
+ * \param[in] strategy  The file space handling strategy to be used. See:
+ *                      #H5F_fspace_strategy_t
+ * \param[in] persist   A boolean value to indicate whether free space
+ *                      should be persistent or not
+ * \param[in] threshold The smallest free-space section size that the free
+ *                      space manager will track
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_file_space_strategy() sets the file space handling
+ *          \p strategy, specifies persisting free-space or not (\p persist),
+ *          and sets the free-space section size \p threshold in the file
+ *          creation property list \p plist_id.
+ *
+ *          #H5F_fspace_strategy_t is a struct defined in H5Fpublic.h as
+ *          follows:
+ *
+ *          \snippet H5Fpublic.h H5F_fspace_strategy_t_snip
+ *
+ *          This setting cannot be changed for the life of the file.
+ *
+ *          As the #H5F_FSPACE_STRATEGY_AGGR and #H5F_FSPACE_STRATEGY_NONE
+ *          strategies do not use the free-space managers, the \p persist
+ *          and \p threshold settings will be ignored for those strategies.
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5Pset_file_space_strategy(hid_t plist_id, H5F_fspace_strategy_t strategy, hbool_t persist,
+                                         hsize_t threshold);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Sets the size of the parameter used to control the B-trees for
+ *        indexing chunked datasets
+ *
+ * \fcpl_id{plist_id}
+ * \param[in]  ik 1/2 rank of chunked storage B-tree
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_istore_k() sets the size of the parameter used to
+ *          control the B-trees for indexing chunked datasets. This
+ *          function is valid only for file creation property lists.
+ *
+ *          \p ik is one half the rank of a tree that stores chunked
+ *          raw data. On average, such a tree will be 75% full, or have
+ *          an average rank of 1.5 times the value of \p ik.
+ *
+ *          The HDF5 library uses (\p ik*2) as the maximum # of entries
+ *          before splitting a B-tree node. Since only 2 bytes are used
+ *          in storing # of entries for a B-tree node in an HDF5 file,
+ *          (\p ik*2) cannot exceed 65536. The default value for
+ *          \p ik is 32.
+ *
+ * \version 1.6.4 \p ik parameter type changed to \p unsigned.
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pset_istore_k(hid_t plist_id, unsigned ik);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Configures the specified shared object header message index
+ *
+ * \fcpl_id{plist_id}
+ * \param[in] index_num       Index being configured
+ * \param[in] mesg_type_flags Types of messages that should be stored in
+ *                            this index
+ * \param[in] min_mesg_size   Minimum message size
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_shared_mesg_index() is used to configure the specified
+ *          shared object header message index, setting the types of
+ *          messages that may be stored in the index and the minimum size
+ *          of each message.
+ *
+ *          \p plist_id specifies the file creation property list.
+ *
+ *          \p index_num specifies the index to be configured.
+ *          \p index_num is zero-indexed, so in a file with three indexes,
+ *          they will be numbered 0, 1, and 2.
+ *
+ *          \p mesg_type_flags and \p min_mesg_size specify, respectively,
+ *          the types and minimum size of messages that can be stored in
+ *          this index.
+ *
+ *          Valid message types are as follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>#H5O_SHMESG_NONE_FLAG</td>
+ *            <td>No shared messages</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5O_SHMESG_SDSPACE_FLAG</td>
+ *            <td>Simple dataspace message</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5O_SHMESG_DTYPE_FLAG</td>
+ *            <td>Datatype message</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5O_SHMESG_FILL_FLAG</td>
+ *            <td>Fill value message</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5O_SHMESG_PLINE_FLAG</td>
+ *            <td>Filter pipeline message</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5O_SHMESG_ATTR_FLAG</td>
+ *            <td>Attribute message</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5O_SHMESG_ALL_FLAG</td>
+ *            <td>All message types; i.e., equivalent to the following:
+ *            (#H5O_SHMESG_SDSPACE_FLAG | #H5O_SHMESG_DTYPE_FLAG |
+ *             #H5O_SHMESG_FILL_FLAG | #H5O_SHMESG_PLINE_FLAG |
+ *             #H5O_SHMESG_ATTR_FLAG)</td>
+ *           </tr>
+ *          </table>
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_shared_mesg_index(hid_t plist_id, unsigned index_num, unsigned mesg_type_flags,
+                                       unsigned min_mesg_size);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Sets number of shared object header message indexes
+ *
+ * \fcpl_id{plist_id}
+ * \param[in] nindexes Number of shared object header message indexes to be
+ *                     available in files created with this property list
+ *                     (\p nindexes must be <= #H5O_SHMESG_MAX_NINDEXES (8))
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_shared_mesg_nindexes() sets the number of shared object
+ *          header message indexes in the specified file creation property
+ *          list.
+ *
+ *          This setting determines the number of shared object header
+ *          message indexes, \p nindexes, that will be available in files
+ *          created with this property list. These indexes can then be
+ *          configured with H5Pset_shared_mesg_index().
+ *
+ *          If \p nindexes is set to 0 (zero), shared object header messages
+ *          are disabled in files created with this property list.
+ *
+ *          There is a limit of #H5O_SHMESG_MAX_NINDEXES (8) that can be set
+ *          with H5Pset_shared_mesg_nindexes(). An error will occur if
+ *          specifying a value of \p nindexes that is greater than this value.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_shared_mesg_nindexes(hid_t plist_id, unsigned nindexes);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Sets shared object header message storage phase change thresholds
+ *
+ * \fcpl_id{plist_id}
+ * \param[in] max_list  Threshold above which storage of a shared object
+ *                      header message index shifts from list to B-tree
+ * \param[in] min_btree Threshold below which storage of a shared object
+ *                      header message index reverts to list format
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_shared_mesg_phase_change() sets threshold values for
+ *          storage of shared object header message indexes in a file.
+ *          These phase change thresholds determine the point at which the
+ *          index storage mechanism changes from a more compact list format
+ *          to a more performance-oriented B-tree format, and vice-versa.
+ *
+ *          By default, a shared object header message index is initially
+ *          stored as a compact list. When the number of messages in an
+ *          index exceeds the threshold value of \p max_list, storage
+ *          switches to a B-tree for improved performance. If the number
+ *          of messages subsequently falls below the \p min_btree threshold,
+ *          the index will revert to the list format.
+ *
+ *          If \p max_list is set to 0 (zero), shared object header message
+ *          indexes in the file will be created as B-trees and will never
+ *          revert to lists.
+ *
+ *          \p plist_id specifies the file creation property list.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_shared_mesg_phase_change(hid_t plist_id, unsigned max_list, unsigned min_btree);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Sets the byte size of the offsets and lengths used to address
+ *        objects in an HDF5 file
+ *
+ * \fcpl_id{plist_id}
+ * \param[in] sizeof_addr Size of an object offset in bytes
+ * \param[in] sizeof_size Size of an object length in bytes
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_sizes() sets the byte size of the offsets and lengths
+ *          used to address objects in an HDF5 file. This function is only
+ *          valid for file creation property lists. Passing in a value
+ *          of 0 for one of the parameters retains the current value. The
+ *          default value for both values is the same as sizeof(hsize_t)
+ *          in the library (normally 8 bytes). Valid values currently
+ *          are 2, 4, 8 and 16.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pset_sizes(hid_t plist_id, size_t sizeof_addr, size_t sizeof_size);
+/**
+ * \ingroup FCPL
+ *
+ * \brief
+ *
+ * \fcpl_id{plist_id}
+ * \param[in] ik Symbol table tree rank
+ * \param[in] lk Symbol table node size
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_sym_k() sets the size of parameters used to control the
+ *          symbol table nodes.
+ *
+ *          This function is valid only for file creation property lists.
+ *          Passing in a value of zero (0) for one of the parameters retains
+ *          the current value.
+ *
+ *          \p ik is one half the rank of a B-tree that stores a symbol
+ *          table for a group. Internal nodes of the symbol table are on
+ *          average 75% full. That is, the average rank of the tree is
+ *          1.5 times the value of \p ik. The HDF5 library uses (\p ik*2) as
+ *          the maximum # of entries before splitting a B-tree node. Since
+ *          only 2 bytes are used in storing # of entries for a B-tree node
+ *          in an HDF5 file, (\p ik*2) cannot exceed 65536. The default value
+ *          for \p ik is 16.
+ *
+ *          \p lk is one half of the number of symbols that can be stored in
+ *          a symbol table node. A symbol table node is the leaf of a symbol
+ *          table tree which is used to store a group. When symbols are
+ *          inserted randomly into a group, the group's symbol table nodes are
+ *          75% full on average. That is, they contain 1.5 times the number of
+ *          symbols specified by \p lk. The default value for \p lk is 4.
+ *
+ * \version 1.6.4 \p ik parameter type changed to \em unsigned.
+ * \version 1.6.0 The \p ik parameter has changed from type int to
+ *          \em unsigned.
+ *
+ * \since  1.0.0
+ *
+ */
+H5_DLL herr_t H5Pset_sym_k(hid_t plist_id, unsigned ik, unsigned lk);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Sets user block size
+ *
+ * \fcpl_id{plist_id}
+ * \param[in] size Size of the user-block in bytes
+ *
+ * \return  \herr_t
+ *
+ * \details H5Pset_userblock() sets the user block size of a file creation
+ *          property list. The default user block size is 0; it may be set
+ *          to any power of 2 equal to 512 or greater (512, 1024, 2048, etc.).
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pset_userblock(hid_t plist_id, hsize_t size);
+
+/* File access property list (FAPL) routines */
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves the current settings for alignment properties from a
+ *        file access property list
+ *
+ * \fapl_id
+ * \param[out] threshold Pointer to location of return threshold value
+ * \param[out] alignment Pointer to location of return alignment value
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_alignment() retrieves the current settings for
+ *          alignment properties from a file access property list. The
+ *          \p threshold and/or \p alignment pointers may be null
+ *          pointers (NULL).
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pget_alignment(hid_t fapl_id, hsize_t *threshold /*out*/, hsize_t *alignment /*out*/);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Queries the raw data chunk cache parameters
+ *
+ * \fapl_id{plist_id}
+ * \param[in,out] mdc_nelmts  <i>No longer used</i>
+ * \param[in,out] rdcc_nslots Number of elements (objects) in the raw data
+ *                            chunk cache
+ * \param[in,out] rdcc_nbytes Total size of the raw data chunk cache, in
+ *                            bytes
+ * \param[in,out] rdcc_w0     Preemption policy
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_cache() retrieves the maximum possible number of
+ *          elements in the raw data chunk cache, the maximum possible
+ *          number of bytes in the raw data chunk cache, and the
+ *          preemption policy value.
+ *
+ *          Any (or all) arguments may be null pointers, in which case
+ *          the corresponding datum is not returned.
+ *
+ *          Note that the \p mdc_nelmts parameter is no longer used.
+ *
+ * \version 1.8.0 Use of the \p mdc_nelmts parameter discontinued.
+ *                Metadata cache configuration is managed with
+ *                H5Pset_mdc_config() and H5Pget_mdc_config()
+ * \version 1.6.0 The \p rdcc_nbytes and \p rdcc_nslots parameters changed
+ *                from type int to size_t.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pget_cache(hid_t plist_id, int *mdc_nelmts, /* out */
+                           size_t *rdcc_nslots /*out*/, size_t *rdcc_nbytes /*out*/, double *rdcc_w0);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Gets information about the write tracking feature used by
+ *        the core VFD
+ *
+ * \fapl_id
+ * \param[out] is_enabled Whether the feature is enabled
+ * \param[out] page_size  Size, in bytes, of write aggregation pages
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_core_write_tracking() retrieves information about the
+ *          write tracking feature used by the core VFD.
+ *
+ *          When a file is created or opened for writing using the core
+ *          virtual file driver (VFD) with the backing store option turned
+ *          on, the VFD can be configured to track changes to the file
+ *          and only write out the modified bytes. To avoid a large number
+ *          of small writes, the changes can be aggregated into pages of
+ *          a user-specified size. The core VFD is also known as the
+ *          memory VFD. The driver identifier is #H5FD_CORE.
+ *
+ * \note This function is only for use with the core VFD and must be used
+ *       after the call to H5Pset_fapl_core(). It is an error to use this
+ *       function with any other VFD.
+ *
+ * \note This function only applies to the backing store write operation,
+ *       which typically occurs when the file is flushed or closed. This
+ *       function has no relationship to the increment parameter passed
+ *       to H5Pset_fapl_core().
+ *
+ * \note For optimum performance, the \p page_size parameter should be
+ *       a power of two.
+ *
+ * \since 1.8.13
+ *
+ */
+H5_DLL herr_t H5Pget_core_write_tracking(hid_t fapl_id, hbool_t *is_enabled, size_t *page_size);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Returns low-lever driver identifier
+ *
+ * \plist_id
+ *
+ * \return \hid_t{low level driver}
+ *
+ * \details H5Pget_driver() returns the identifier of the low-level file
+ *          driver associated with the file access property list or
+ *          data transfer property list \p plist_id.
+ *
+ *          Valid driver identifiers distributed with HDF5 are listed and
+ *          described in the following table.
+ *
+ *          \snippet{doc} tables/fileDriverLists.dox supported_file_driver_table
+ *
+ *          This list does not include custom drivers that might be
+ *          defined and registered by a user.
+ *
+ *          The returned driver identifier is only valid as long as the
+ *          file driver remains registered.
+ *
+ *
+ * \since 1.4.0
+ *
+ */
+H5_DLL hid_t H5Pget_driver(hid_t plist_id);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Returns a pointer to file driver information
+ *
+ * \param[in] plist_id File access or data transfer property list
+ *                     identifier
+ *
+ * \return Returns a pointer to a struct containing low-level driver
+ *         information. Otherwise returns NULL. NULL is also returned if
+ *         no driver-specific properties have been registered. No error
+ *         is pushed on the stack in this case.
+ *
+ * \details H5Pget_driver_info() returns a pointer to file driver-specific
+ *          information for the low-level driver associated with the file
+ *          access or data transfer property list \p plist_id.
+ *
+ *          The pointer returned by this function points to an uncopied
+ *          struct. Driver-specific versions of that struct are defined
+ *          for each low-level driver in the relevant source code file
+ *          H5FD*.c. For example, the struct used for the MULTI driver is
+ *          \c H5FD_multi_fapl_t defined in H5FDmulti.c.
+ *
+ *          If no driver-specific properties have been registered,
+ *          H5Pget_driver_info() returns NULL.
+ *
+ * \note H5Pget_driver_info() and H5Pset_driver() are used only when
+ *       creating a virtual file driver (VFD) in the virtual file
+ *       layer (VFL).
+ *
+ * \version 1.10.1 Return value was changed from \em void * to
+ *                 \em const \em void *.
+ * \version 1.8.2 Function publicized in this release; previous releases
+ *                described this function only in the virtual file driver
+ *                documentation.
+ *
+ */
+H5_DLL const void *H5Pget_driver_info(hid_t plist_id);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves a string representation of the configuration for
+ *        the driver set on the given FAPL. The returned string can
+ *        be used to configure the same driver in an identical way.
+ *
+ * \fapl_id
+ * \param[out] config_buf Driver configuration string output buffer
+ * \param[in]  buf_size Size of driver configuration string output buffer
+ *
+ * \return Returns the length of the driver configuration string on
+ *         success (not including the NUL terminator). Returns negative
+ *         on failure.
+ *
+ * \details H5Pget_driver_config_str() retrieves a string representation
+ *          of the configuration for the driver set on the given FAPL. The
+ *          returned string can be used to configure the same driver in
+ *          an identical way.
+ *
+ *          If \p config_buf is NULL, the length of the driver configuration
+ *          string is simply returned. The caller can then allocate a buffer
+ *          of the appropriate size and call this routine again.
+ *
+ * \version 1.14.0 Function publicized in this release.
+ *
+ */
+H5_DLL ssize_t H5Pget_driver_config_str(hid_t fapl_id, char *config_buf, size_t buf_size);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves the size of the external link open file cache
+ *
+ * \fapl_id{plist_id}
+ * \param[out] efc_size External link open file cache size in number of files
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_elink_file_cache_size() retrieves the number of files that
+ *          can be held open in an external link open file cache.
+ *
+ * \since 1.8.7
+ *
+ */
+H5_DLL herr_t H5Pget_elink_file_cache_size(hid_t plist_id, unsigned *efc_size);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves the file access property list setting that determines
+ *        whether an HDF5 object will be evicted from the library's metadata
+ *        cache when it is closed
+ *
+ * \fapl_id
+ * \param[out] evict_on_close Pointer to a variable that will indicate if
+ *                            the object will be evicted on close
+ *
+ * \return \herr_t
+ *
+ * \details The library's metadata cache is fairly conservative about holding on
+ *          to HDF5 object metadata (object headers, chunk index structures,
+ *          etc.), which can cause the cache size to grow, resulting in memory
+ *          pressure on an application or system. When enabled, the "evict on
+ *          close" property will cause all metadata for an object to be
+ *          immediately evicted from the cache as long as it is not referenced
+ *          by any other open object.
+ *
+ *          See H5Pset_evict_on_close() for additional notes on behavior.
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5Pget_evict_on_close(hid_t fapl_id, hbool_t *evict_on_close);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves a data offset from the file access property list
+ *
+ * \fapl_id
+ * \param[out] offset Offset in bytes within the HDF5 file
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_family_offset() retrieves the value of offset from the
+ *          file access property list \p fapl_id so that the user
+ *          application can retrieve a file handle for low-level access to
+ *          a particular member of a family of files. The file handle is
+ *          retrieved with a separate call to H5Fget_vfd_handle() (or,
+ *          in special circumstances, to H5FDget_vfd_handle(), see \ref VFL).
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pget_family_offset(hid_t fapl_id, hsize_t *offset);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Returns the file close degree
+ *
+ * \fapl_id
+ * \param[out] degree Pointer to a location to which to return the file
+ *                    close degree property, the value of \p degree
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_fclose_degree() returns the current setting of the file
+ *          close degree property \p degree in the file access property
+ *          list \p fapl_id. The value of \p degree determines how
+ *          aggressively H5Fclose() deals with objects within a file that
+ *          remain open when H5Fclose() is called to close that file.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pget_fclose_degree(hid_t fapl_id, H5F_close_degree_t *degree);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves a copy of the file image designated as the initial content
+ *        and structure of a file
+ *
+ * \fapl_id
+ * \param[in,out] buf_ptr_ptr On input, \c NULL or a pointer to a
+ *                pointer to a buffer that contains the
+ *                file image.\n On successful return, if \p buf_ptr_ptr is not
+ *                \c NULL, \Code{*buf_ptr_ptr} will contain a pointer to a copy
+ *                of the initial image provided in the last call to
+ *                H5Pset_file_image() for the supplied \p fapl_id. If no initial
+ *                image has been set, \Code{*buf_ptr_ptr} will be \c NULL.
+ * \param[in,out] buf_len_ptr On input, \c NULL or a pointer to a buffer
+ *                specifying the required size of the buffer to hold the file
+ *                image.\n On successful return, if \p buf_len_ptr was not
+ *                passed in as \c NULL, \p buf_len_ptr will return the required
+ *                size in bytes of the buffer to hold the initial file image in
+ *                the supplied file access property list, \p fapl_id. If no
+ *                initial image is set, the value of \Code{*buf_len_ptr} will be
+ *                set to 0 (zero)
+ * \return \herr_t
+ *
+ * \details H5Pget_file_image() allows an application to retrieve a copy of the
+ *          file image designated for a VFD to use as the initial contents of a file.
+ *
+ *          If file image callbacks are defined, H5Pget_file_image() will use
+ *          them when allocating and loading the buffer to return to the
+ *          application (see H5Pset_file_image_callbacks()). If file image
+ *          callbacks are not defined, the function will use \c malloc and \c
+ *          memcpy. When \c malloc and \c memcpy are used, it is the caller's
+ *          responsibility to discard the returned buffer with a call to \c
+ *          free.
+ *
+ *          It is the responsibility of the calling application to free the
+ *          buffer whose address is returned in \p buf_ptr_ptr. This can be
+ *          accomplished with \c free if file image callbacks have not been set
+ *          (see H5Pset_file_image_callbacks()) or with the appropriate method
+ *          if file image callbacks have been set.
+ *
+ * \see H5LTopen_file_image(), H5Fget_file_image(), H5Pset_file_image(),
+ *      H5Pset_file_image_callbacks(), H5Pget_file_image_callbacks(),
+ *      \ref H5FD_file_image_callbacks_t, \ref H5FD_file_image_op_t,
+ *      <a href="https://portal.hdfgroup.org/display/HDF5/HDF5+File+Image+Operations">
+ *      HDF5 File Image Operations</a>.
+ *
+ *
+ * \since 1.8.9
+ *
+ */
+H5_DLL herr_t H5Pget_file_image(hid_t fapl_id, void **buf_ptr_ptr, size_t *buf_len_ptr);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves callback routines for working with file images
+ *
+ * \fapl_id
+ * \param[in,out] callbacks_ptr Pointer to the instance of the
+ *                #H5FD_file_image_callbacks_t struct in which the callback
+ *                routines are to be returned\n
+ *                Struct fields must be initialized to NULL before the call
+ *                is made.\n
+ *                Struct field contents upon return will match those passed in
+ *                in the last H5Pset_file_image_callbacks() call for the file
+ *                access property list \p fapl_id.
+ * \return \herr_t
+ *
+ * \details H5Pget_file_image_callbacks() retrieves the callback routines set for
+ *          working with file images opened with the file access property list
+ *          \p fapl_id.
+ *
+ *          The callbacks must have been previously set with
+ *          H5Pset_file_image_callbacks() in the file access property list.
+ *
+ *          Upon the successful return of H5Pset_file_image_callbacks(), the
+ *          fields in the instance of the #H5FD_file_image_callbacks_t struct
+ *          pointed to by \p callbacks_ptr will contain the same values as were
+ *          passed in the most recent H5Pset_file_image_callbacks() call for the
+ *          file access property list \p fapl_id.
+ *
+ * \see H5LTopen_file_image(), H5Fget_file_image(), H5Pset_file_image(),
+ *      H5Pset_file_image_callbacks(), H5Pget_file_image_callbacks(),
+ *      \ref H5FD_file_image_callbacks_t, \ref H5FD_file_image_op_t,
+ *      <a href="https://portal.hdfgroup.org/display/HDF5/HDF5+File+Image+Operations">
+ *      HDF5 File Image Operations</a>.
+ *
+ * \since 1.8.9
+ *
+ */
+H5_DLL herr_t H5Pget_file_image_callbacks(hid_t fapl_id, H5FD_file_image_callbacks_t *callbacks_ptr);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves the file locking property values
+ *
+ * \fapl_id
+ * \param[out] use_file_locking File locking flag
+ * \param[out] ignore_when_disabled Ignore when disabled flag
+ * \return \herr_t
+ *
+ * \details H5Pget_file_locking() retrieves the file locking property values for
+ *          the file access property list specified by \p fapl_id.
+ *
+ * \since 1.10.7
+ *
+ */
+H5_DLL herr_t H5Pget_file_locking(hid_t fapl_id, hbool_t *use_file_locking, hbool_t *ignore_when_disabled);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Returns garbage collecting references setting
+ *
+ * \fapl_id
+ * \param[out] gc_ref Flag returning the state of reference garbage
+ *                    collection. A returned value of 1 indicates that
+ *                    garbage collection is on while 0 indicates that
+ *                    garbage collection is off.
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_gc_references() returns the current setting for the
+ *          garbage collection references property from the specified
+ *          file access property list. The garbage collection references
+ *          property is set by H5Pset_gc_references().
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Pget_gc_references(hid_t fapl_id, unsigned *gc_ref /*out*/);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves library version bounds settings that indirectly control
+ *        the format versions used when creating objects
+ *
+ * \fapl_id{plist_id}
+ * \param[out] low  The earliest version of the library that will be used
+ *                  for writing objects
+ * \param[out] high The latest version of the library that will be used for
+ *                  writing objects
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_libver_bounds() retrieves the lower and upper bounds on
+ *          the HDF5 library release versions that indirectly determine the
+ *          object format versions used when creating objects in the file.
+ *
+ *          This property is retrieved from the file access property list
+ *          specified by the parameter \p fapl_id.
+ *
+ *          The value returned in the parameters \p low and \p high is one
+ *          of the enumerated values in the #H5F_libver_t struct, which is
+ *          defined in H5Fpublic.h.
+ *
+ * \version 1.10.2 Add #H5F_LIBVER_V18 to the enumerated defines in
+ *                 #H5F_libver_t
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_libver_bounds(hid_t plist_id, H5F_libver_t *low, H5F_libver_t *high);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Get the current initial metadata cache configuration from the
+ *        provided file access property list
+ *
+ * \fapl_id{plist_id}
+ * \param[in,out] config_ptr Pointer to the instance of #H5AC_cache_config_t
+ *                in which the current metadata cache configuration is to be
+ *                reported
+ * \return \herr_t
+ *
+ * \note The \c in direction applies only to the \ref H5AC_cache_config_t.version
+ *       field. All other fields are \c out parameters.
+ *
+ * \details The fields of the #H5AC_cache_config_t structure are shown
+ *           below:
+ *           \snippet H5ACpublic.h H5AC_cache_config_t_snip
+ *           \click4more
+ *
+ *          H5Pget_mdc_config() gets the initial metadata cache configuration
+ *          contained in a file access property list and loads it into the
+ *          instance of #H5AC_cache_config_t pointed to by the \p config_ptr
+ *          parameter. This configuration is used when the file is opened.
+ *
+ *          Note that the version field of \Code{*config_ptr} must be
+ *          initialized; this allows the library to support earlier versions of
+ *          the #H5AC_cache_config_t structure.
+ *
+ *          See the overview of the metadata cache in the special topics section
+ *          of the user guide for details on the configuration data returned. If
+ *          you haven't read and understood that documentation, the results of
+ *          this call will not make much sense.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_mdc_config(hid_t plist_id, H5AC_cache_config_t *config_ptr); /* out */
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves the metadata cache image configuration values for a file
+ *        access property list
+ *
+ * \fapl_id{plist_id}
+ * \param[out] config_ptr Pointer to metadata cache image configuration values
+ * \return \herr_t
+ *
+ * \details H5Pget_mdc_image_config() retrieves the metadata cache image values
+ *          into \p config_ptr for the file access property list specified in \p
+ *          plist_id.
+ *
+ *          #H5AC_cache_image_config_t is defined as follows:
+ *          \snippet H5ACpublic.h H5AC_cache_image_config_t_snip
+ *          \click4more
+ *
+ * \since 1.10.1
+ */
+H5_DLL herr_t H5Pget_mdc_image_config(hid_t plist_id, H5AC_cache_image_config_t *config_ptr /*out*/);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Gets metadata cache logging options
+ *
+ * \fapl_id{plist_id}
+ * \param[out] is_enabled Flag whether logging is enabled
+ * \param[out] location Location of log in UTF-8/ASCII (file path/name) (On
+ *             Windows, this must be ASCII)
+ * \param[out] location_size Size in bytes of the location string
+ * \param[out] start_on_access Whether the logging begins as soon as the file is
+ *             opened or created
+ * \return \herr_t
+ *
+ * \details The metadata cache is a central part of the HDF5 library through
+ *          which all file metadata reads and writes take place. File metadata
+ *          is normally invisible to the user and is used by the library for
+ *          purposes such as locating and indexing data. File metadata should
+ *          not be confused with user metadata, which consists of attributes
+ *          created by users and attached to HDF5 objects such as datasets via
+ *          \ref H5A API calls.
+ *
+ *          Due to the complexity of the cache, a trace/logging feature has been
+ *          created that can be used by HDF5 developers for debugging and
+ *          performance analysis. The functions that control this functionality
+ *          will normally be of use to a very limited number of developers
+ *          outside of The HDF Group. The functions have been documented to help
+ *          users create logs that can be sent with bug reports.
+ *
+ *          Control of the log functionality is straightforward. Logging is
+ *          enabled via the H5Pset_mdc_log_options() function, which will modify
+ *          the file access property list used to open or create a file. This
+ *          function has a flag that determines whether logging begins at file
+ *          open or starts in a paused state. Log messages can then be
+ *          controlled via the H5Fstart_mdc_logging() / H5Fstop_mdc_logging()
+ *          functions. H5Pget_mdc_log_options() can be used to examine a file
+ *          access property list, and H5Fget_mdc_logging_status() will return
+ *          the current state of the logging flags.
+ *
+ *          The log format is described in the
+ *           <a href="https://bit.ly/2PG6fNv">Metadata Cache Logging</a> document.
+ *
+ * \since 1.10.0
+ */
+H5_DLL herr_t H5Pget_mdc_log_options(hid_t plist_id, hbool_t *is_enabled, char *location,
+                                     size_t *location_size, hbool_t *start_on_access);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Returns the current metadata block size setting
+ *
+ * \fapl_id{fapl_id}
+ * \param[out] size Minimum size, in bytes, of metadata block allocations
+ *
+ * \return \herr_t
+ *
+ * \details Returns the current minimum size, in bytes, of new
+ *          metadata block allocations. This setting is retrieved from the
+ *          file access property list \p fapl_id.
+ *
+ *          This value is set by H5Pset_meta_block_size() and is
+ *          retrieved from the file access property list \p fapl_id.
+ *
+ * \since 1.4.0
+ */
+H5_DLL herr_t H5Pget_meta_block_size(hid_t fapl_id, hsize_t *size);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves the number of read attempts from a file access
+ *        property list
+ *
+ * \fapl_id{plist_id}
+ * \param[out] attempts The number of read attempts
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_metadata_read_attempts() retrieves the number of read
+ *          attempts that is set in the file access property list \p plist_id.
+ *
+ *          For a default file access property list, the value retrieved
+ *          will depend on whether the user sets the number of attempts via
+ *          H5Pset_metadata_read_attempts():
+ *
+ *          <ul>
+ *
+ *          <li>If the number of attempts is set to N, the value
+ *          returned will be N.
+ *          <li>If the number of attempts is not set, the value returned
+ *          will be the default for non-SWMR access (1). SWMR is short
+ *          for single-writer/multiple-reader.
+ *          </ul>
+ *
+ *          For the file access property list of a specified HDF5 file,
+ *          the value retrieved will depend on how the file is opened
+ *          and whether the user sets the number of read attempts via
+ *          H5Pset_metadata_read_attempts():
+ *
+ *          <ul>
+ *          <li>For a file opened with SWMR access:
+ *
+ *          <ul>
+ *              <li> If the number of attempts is set to N, the value
+ *              returned will be N.
+ *              <li> If the number of attempts is not set, the value
+ *              returned will be the default for SWMR access (100).
+ *          </ul>
+ *          <li>For a file opened without SWMR access, the value
+ *          retrieved will always be the default for non-SWMR access
+ *          (1). The value set via H5Pset_metadata_read_attempts() does
+ *          not have any effect on non-SWMR access.
+ *          </ul>
+ *
+ * \par Failure Modes
+ * \parblock
+ *
+ * When the input property list is not a file access property list.
+ *
+ * When the library is unable to retrieve the number of read attempts from
+ * the file access property list.
+ *
+ * \endparblock
+ *
+ * \par Examples
+ * \parblock
+ *
+ * The first example illustrates the two cases for retrieving the number
+ * of read attempts from a default file access property list.
+ *
+ * \include H5Pget_metadata_read_attempts.1.c
+ *
+ * The second example illustrates the two cases for retrieving the
+ * number of read attempts from the file access property list of a file
+ * opened with SWMR access.
+ *
+ * \include H5Pget_metadata_read_attempts.2.c
+ *
+ * The third example illustrates the two cases for retrieving the number
+ * of read attempts from the file access property list of a file opened
+ * with non-SWMR access.
+ *
+ * \include H5Pget_metadata_read_attempts.3.c
+ *
+ * \endparblock
+ *
+ * \since 1.10.0
+ */
+H5_DLL herr_t H5Pget_metadata_read_attempts(hid_t plist_id, unsigned *attempts);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves type of data property for MULTI driver
+ *
+ * \param[in]  fapl_id File access property list or data transfer property
+ *                     list identifier
+ * \param[out] type    Type of data
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_multi_type() retrieves the type of data setting from
+ *          the file access or data transfer property list \p fapl_id.
+ *          This enables a user application to specify the type of data
+ *          the application wishes to access so that the application can
+ *          retrieve a file handle for low-level access to the particular
+ *          member of a set of MULTI files in which that type of data is
+ *          stored. The file handle is retrieved with a separate call to
+ *          H5Fget_vfd_handle() (or, in special circumstances, to
+ *          H5FDget_vfd_handle(); see the Virtual File Layer documentation
+ *          for more information.
+ *
+ *          The type of data returned in \p type will be one of those
+ *          listed in the discussion of the \p type parameter in the
+ *          description of the function H5Pset_multi_type().
+ *
+ *          Use of this function is only appropriate for an HDF5 file
+ *          written as a set of files with the MULTI file driver.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pget_multi_type(hid_t fapl_id, H5FD_mem_t *type);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves the object flush property values from the file access property list
+ *
+ * \fapl_id{plist_id}
+ * \param[in] func The user-defined callback function
+ * \param[in] udata The user-defined input data for the callback function
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_object_flush_cb() gets the user-defined callback
+ *          function that is set in the file access property list
+ *          \p fapl_id and stored in the parameter \p func. The callback is
+ *          invoked whenever an object flush occurs in the file. This
+ *          routine also obtains the user-defined input data that is
+ *          passed along to the callback function in the parameter
+ *          \p udata.
+ *
+ * \par Example
+ * \parblock
+ * The example below illustrates the usage of this routine to obtain the
+ * object flush property values.
+ *
+ * \include H5Pget_object_flush_cb.c
+ * \endparblock
+ *
+ * \since 1.10.0
+ */
+H5_DLL herr_t H5Pget_object_flush_cb(hid_t plist_id, H5F_flush_cb_t *func, void **udata);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves the maximum size for the page buffer and the minimum
+          percentage for metadata and raw data pages
+ *
+ * \fapl_id{plist_id}
+ * \param[out] buf_size Maximum size, in bytes, of the page buffer
+ * \param[out] min_meta_perc Minimum metadata percentage to keep in the
+ *             page buffer before allowing pages containing metadata to
+ *             be evicted
+ *
+ * \param[out] min_raw_perc Minimum raw data percentage to keep in the
+ *             page buffer before allowing pages containing raw data to
+ *             be evicted
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_page_buffer_size() retrieves \p buf_size, the maximum
+ *          size in bytes of the page buffer, \p min_meta_perc, the
+ *          minimum metadata percentage, and \p min_raw_perc, the
+ *          minimum raw data percentage.
+ *
+ * \since 1.10.1
+ */
+H5_DLL herr_t H5Pget_page_buffer_size(hid_t plist_id, size_t *buf_size, unsigned *min_meta_perc,
+                                      unsigned *min_raw_perc);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Returns maximum data sieve buffer size
+ *
+ * \fapl_id{fapl_id}
+ * \param[out] size Maximum size, in bytes, of data sieve buffer
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_sieve_buf_size() retrieves, size, the current maximum
+ *          size of the data sieve buffer.
+ *
+ *          This value is set by H5Pset_sieve_buf_size() and is retrieved
+ *          from the file access property list fapl_id.
+ *
+ * \version 1.6.0 The \p size parameter has changed from type \c hsize_t
+ *                to \c size_t
+ * \since 1.4.0
+ */
+H5_DLL herr_t H5Pget_sieve_buf_size(hid_t fapl_id, size_t *size /*out*/);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves the current small data block size setting
+ *
+ * \fapl_id{fapl_id}
+ * \param[out] size Maximum size, in bytes, of the small data block
+ *
+ * \result \herr_t
+ *
+ * \details H5Pget_small_data_block_size() retrieves the current setting
+ *          for the size of the small data block.
+ *
+ *          If the returned value is zero (0), the small data block
+ *          mechanism has been disabled for the file.
+ *
+ * \since 1.4.4
+ */
+H5_DLL herr_t H5Pget_small_data_block_size(hid_t fapl_id, hsize_t *size /*out*/);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Returns the identifier of the current VOL connector
+ *
+ * \fapl_id{plist_id}
+ * \param[out] vol_id  Current VOL connector identifier
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_vol_id() returns the VOL connector identifier \p vol_id for
+ *          the file access property list \p plist_id. This identifier should
+ *          be closed with H5VLclose().
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Pget_vol_id(hid_t plist_id, hid_t *vol_id);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Returns a copy of the VOL information for a connector
+ *
+ * \fapl_id{plist_id}
+ * \param[out]  vol_info  The VOL information for a connector
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_vol_info() returns a copy of the VOL information \p vol_info
+ *          for a connector specified by the file access property list
+ *          \p plist_id.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Pget_vol_info(hid_t plist_id, void **vol_info);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets alignment properties of a file access property list
+ *
+ * \fapl_id
+ * \param[in] threshold Threshold value. Note that setting the threshold
+ *                      value to 0 (zero) has the effect of a special case,
+ *                      forcing everything to be aligned
+ * \param[in] alignment Alignment value
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_alignment() sets the alignment properties of a
+ *          file access property list so that any file object greater
+ *          than or equal in size to \p threshold bytes will be aligned
+ *          on an address that is a multiple of \p alignment. The
+ *          addresses are relative to the end of the user block; the
+ *          alignment is calculated by subtracting the user block size
+ *          from the absolute file address and then adjusting the address
+ *          to be a multiple of \p alignment.
+ *
+ *          Default values for \p threshold and \p alignment are one,
+ *          implying no alignment. Generally the default values will
+ *          result in the best performance for single-process access to
+ *          the file. For MPI IO and other parallel systems, choose an
+ *          alignment that is a multiple of the disk block size.
+ *
+ *          If the file space handling strategy is set to
+ *          #H5F_FSPACE_STRATEGY_PAGE, then the alignment set via this
+ *          routine is ignored. The file space handling strategy is set
+ *          by H5Pset_file_space_strategy().
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pset_alignment(hid_t fapl_id, hsize_t threshold, hsize_t alignment);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the raw data chunk cache parameters
+ *
+ * \fapl_id{plist_id}
+ * \param[in] mdc_nelmts No longer used; any value passed is ignored
+ * \param[in] rdcc_nslots The number of chunk slots in the raw data chunk
+ *                        cache for this dataset. Increasing this value
+ *                        reduces the number of cache collisions, but
+ *                        slightly increases the memory used. Due to the
+ *                        hashing strategy, this value should ideally be a
+ *                        prime number. As a rule of thumb, this value
+ *                        should be at least 10 times the number of chunks
+ *                        that can fit in \p rdcc_nbytes bytes. For
+ *                        maximum performance, this value should be set
+ *                        approximately 100 times that number of chunks.
+ *                        The default value is 521.
+ * \param[in] rdcc_nbytes Total size of the raw data chunk cache in bytes.
+ *                        The default size is 1 MB per dataset.
+ * \param[in] rdcc_w0     The chunk preemption policy for all datasets.
+ *                        This must be between 0 and 1 inclusive and
+ *                        indicates the weighting according to which chunks
+ *                        which have been fully read or written are
+ *                        penalized when determining which chunks to flush
+ *                        from cache. A value of 0 means fully read or
+ *                        written chunks are treated no differently than
+ *                        other chunks (the preemption is strictly LRU),
+ *                        while a value of 1 means fully read or written
+ *                        chunks are always preempted before other chunks.
+ *                        If your application only reads or writes data once,
+ *                        this can be safely set to 1. Otherwise, this should
+ *                        be set lower depending on how often you re-read or
+ *                        re-write the same data. The default value is 0.75.
+ *                        If the value passed is #H5D_CHUNK_CACHE_W0_DEFAULT,
+ *                        then the property will not be set on the dataset
+ *                        access property list, and the parameter will come
+ *                        from the file access property list.
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_cache() sets the number of elements, the total number of
+ *          bytes, and the preemption policy value for all datasets in a file
+ *          on the file's file access property list.
+ *
+ *          The raw data chunk cache inserts chunks into the cache by first
+ *          computing a hash value using the address of a chunk and then by
+ *          using that hash value as the chunk's index into the table of
+ *          cached chunks. In other words, the size of this hash table and the
+ *          number of possible hash values are determined by the \p rdcc_nslots
+ *          parameter. If a different chunk in the cache has the same hash value,
+ *          a collision will occur, which will reduce efficiency. If inserting
+ *          the chunk into the cache would cause the cache to be too big, then
+ *          the cache will be pruned according to the \p rdcc_w0 parameter.
+ *
+ *          The \p mdc_nelmts parameter is no longer used; any value passed
+ *          in that parameter will be ignored.
+ *
+ *      \b Motivation: Setting raw data chunk cache parameters
+ *       can be done with H5Pset_cache(), H5Pset_chunk_cache(),
+ *       or a combination of both. H5Pset_cache() is used to
+ *       adjust the chunk cache parameters for all datasets via
+ *       a global setting for the file, and H5Pset_chunk_cache()
+ *       is used to adjust the chunk cache parameters for
+ *       individual datasets. When both are used, parameters
+ *       set with H5Pset_chunk_cache() will override any parameters
+ *       set with H5Pset_cache().
+ *
+ * \note Optimum chunk cache parameters may vary widely depending
+ *       on different data layout and access patterns. For datasets
+ *       with low performance requirements for example, changing
+ *       the cache settings can save memory.
+ *
+ * \note Note: Raw dataset chunk caching is not currently
+ *       supported when using the MPI I/O and MPI POSIX file drivers
+ *       in read/write mode; see H5Pset_fapl_mpio(). When using this
+ *       file driver, all calls to H5Dread() and H5Dwrite() will access
+ *       the disk directly, and H5Pset_cache() will have no effect on
+ *       performance.
+ *
+ * \note Raw dataset chunk caching is supported when these drivers are
+ *       used in read-only mode.
+ *
+ * \version 1.8.0 The use of the \p mdc_nelmts parameter was discontinued.
+ *                Metadata cache configuration is managed with
+ *                H5Pset_mdc_config() and H5Pget_mdc_config().
+ * \version 1.6.0 The \p rdcc_nbytes and \p rdcc_nelmts parameters
+ *                changed from type int to size_t.
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pset_cache(hid_t plist_id, int mdc_nelmts, size_t rdcc_nslots, size_t rdcc_nbytes,
+                           double rdcc_w0);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets write tracking information for core driver, #H5FD_CORE
+ *
+ * \fapl_id{fapl_id}
+ * \param[in] is_enabled Boolean value specifying whether feature is
+                         enabled
+ * \param[in] page_size Positive integer specifying size, in bytes, of
+ *                      write aggregation pages Value of 1 (one) enables
+ *                      tracking with no paging.
+ *
+ * \return \herr_t
+ *
+ * \details When a file is created or opened for writing using the core
+ *          virtual file driver (VFD) with the backing store option
+ *          turned on, the core driver can be configured to track
+ *          changes to the file and write out only the modified bytes.
+ *
+ *          This write tracking feature is enabled and disabled with \p
+ *          is_enabled. The default setting is that write tracking is
+ *          disabled, or off.
+ *
+ *          To avoid a large number of small writes, changes can
+ *          be aggregated into pages of a user-specified size, \p
+ *          page_size.
+ *
+ *          Setting \p page_size to 1 enables tracking with no page
+ *          aggregation.
+ *
+ *          The backing store option is set via the function
+ *          H5Pset_fapl_core.
+ *
+ * \attention
+ * \parblock
+ *            This function is only for use with the core VFD and must
+ *            be used after the call to H5Pset_fapl_core(). It is an error
+ *            to use this function with any other VFD.
+ *
+ *            It is an error to use this function when the backing store
+ *            flag has not been set using H5Pset_fapl_core().
+ *
+ *            This function only applies to the backing store write
+ *            operation which typically occurs when the file is flushed
+ *            or closed. This function has no relationship to the
+ *            increment parameter passed to H5Pset_fapl_core().
+ *
+ *            For optimum performance, the \p page_size parameter should be
+ *            a power of two.
+ *
+ *            It is an error to set the page size to 0.
+ * \endparblock
+ *
+ * \version 1.8.14 C function modified in this release to return error
+ *                 if \p page_size is set to 0 (zero).
+ * \since 1.8.13
+ *
+ */
+H5_DLL herr_t H5Pset_core_write_tracking(hid_t fapl_id, hbool_t is_enabled, size_t page_size);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets a file driver
+ *
+ * \plist_id
+ * \param[in] driver_id   The new driver identifier
+ * \param[in] driver_info Optional struct containing driver properties
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_driver() sets the file driver, driver_id, for a file
+ *          access or data transfer property list, \p plist_id, and
+ *          supplies an optional struct containing the driver-specific
+ *          properties, \p driver_info.
+ *
+ *          The driver properties will be copied into the property list
+ *          and the reference count on the driver will be incremented,
+ *          allowing the caller to close the driver identifier but still
+ *          use the property list.
+ *
+ * \version 1.8.2 Function publicized in this release; previous releases
+ *                described this function only in the virtual file driver
+ *                documentation.
+ *
+ */
+H5_DLL herr_t H5Pset_driver(hid_t plist_id, hid_t driver_id, const void *driver_info);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets a file driver according to a given driver name
+ *
+ * \plist_id
+ * \param[in] driver_name   The new driver name
+ * \param[in] driver_config Optional string containing driver properties
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_driver_by_name() sets the file driver, by the name
+ *          driver_name, for a file access or data transfer property list,
+ *          \p plist_id, and supplies an optional string containing the
+ *          driver-specific properties, \p driver_config. The driver
+ *          properties string will be copied into the property list.
+ *
+ *          If the driver specified by \p driver_name is not currently
+ *          registered, an attempt will be made to load the driver as a
+ *          plugin.
+ *
+ * \version 1.14.0 Function publicized in this release.
+ *
+ */
+H5_DLL herr_t H5Pset_driver_by_name(hid_t plist_id, const char *driver_name, const char *driver_config);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets a file driver according to a given driver value (ID).
+ *
+ * \plist_id
+ * \param[in] driver_value  The new driver value (ID)
+ * \param[in] driver_config Optional string containing driver properties
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_driver_by_value() sets the file driver, by the value
+ *          driver_value, for a file access or data transfer property list,
+ *          \p plist_id, and supplies an optional string containing the
+ *          driver-specific properties, \p driver_config. The driver
+ *          properties string will be copied into the property list.
+ *
+ *          If the driver specified by \p driver_value is not currently
+ *          registered, an attempt will be made to load the driver as a
+ *          plugin.
+ *
+ * \version 1.14.0 Function publicized in this release.
+ *
+ */
+H5_DLL herr_t H5Pset_driver_by_value(hid_t plist_id, H5FD_class_value_t driver_value,
+                                     const char *driver_config);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the number of files that can be held open in an external
+ *        link open file cache
+ *
+ * \par Motivation
+ * \parblock
+ * The <em>external link open file cache</em> holds files open after
+ * they have been accessed via an external link. This cache reduces
+ * the number of times such files are opened when external links are
+ * accessed repeatedly and can significantly improves performance in
+ * certain heavy-use situations and when low-level file opens or closes
+ * are expensive.
+ *
+ * H5Pset_elink_file_cache_size() sets the number of files
+ * that will be held open in an external link open file
+ * cache. H5Pget_elink_file_cache_size() retrieves the size of an existing
+ * cache; and H5Fclear_elink_file_cache() clears an existing cache without
+ * closing it.
+ * \endparblock
+ *
+ * \fapl_id{plist_id}
+ * \param[in] efc_size External link open file cache size in number of files
+ *                     <em>Default setting is 0 (zero).</em>
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_elink_file_cache_size() specifies the number of files
+ *          that will be held open in an external link open file cache.
+ *
+ *          The default external link open file cache size is 0 (zero),
+ *          meaning that files accessed via an external link are not
+ *          held open. Setting the cache size to a positive integer
+ *          turns on the cache; setting the size back to zero turns it
+ *          off.
+ *
+ *          With this property set, files are placed in the external
+ *          link open file cache cache when they are opened via an
+ *          external link. Files are then held open until either
+ *          they are evicted from the cache or the parent file is
+ *          closed. This property setting can improve performance when
+ *          external links are repeatedly accessed.
+ *
+ *          When the cache is full, files will be evicted using a least
+ *          recently used (LRU) scheme; the file which has gone the
+ *          longest time without being accessed through the parent file
+ *          will be evicted and closed if nothing else is holding that
+ *          file open.
+ *
+ *          Files opened through external links inherit the parent
+ *          file's file access property list by default, and therefore
+ *          inherit the parent file's external link open file cache
+ *          setting.
+ *
+ *          When child files contain external links of their own, the
+ *          caches can form a graph of cached external files. Closing
+ *          the last external reference to such a graph will recursively
+ *          close all files in the graph, even if cycles are present.
+ * \par Example
+ * \parblock
+ * The following code sets up an external link open file cache that will
+ * hold open up to 8 files reached through external links:
+ *
+ * \code
+ * status = H5Pset_elink_file_cache_size(fapl_id, 8);
+ * \endcode
+ * \endparblock
+ *
+ * \since 1.8.7
+ */
+H5_DLL herr_t H5Pset_elink_file_cache_size(hid_t plist_id, unsigned efc_size);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Controls the library's behavior of evicting metadata associated with
+ *        a closed object
+ *
+ * \fapl_id
+ * \param[in] evict_on_close Whether the HDF5 object should be evicted on close
+ *
+ * \return \herr_t
+ *
+ * \details The library's metadata cache is fairly conservative about holding
+ *          on to HDF5 object metadata(object headers, chunk index structures,
+ *          etc.), which can cause the cache size to grow, resulting in memory
+ *          pressure on an application or system. When enabled, the "evict on
+ *          close" property will cause all metadata for an object to be evicted
+ *          from the cache as long as metadata is not referenced by any other
+ *          open object.
+ *
+ *          This function only applies to file access property lists.
+ *
+ *          The default library behavior is to not evict on object or file
+ *          close.
+ *
+ *          When applied to a file access property list, any subsequently opened
+ *          object will inherit the "evict on close" property and will have
+ *          its metadata evicted when the object is closed.
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5Pset_evict_on_close(hid_t fapl_id, hbool_t evict_on_close);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets offset property for low-level access to a file in a family of
+ *        files
+ *
+ * \fapl_id
+ * \param[in] offset Offset in bytes within the HDF5 file
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_family_offset() sets the offset property in the file access
+ *          property list \p fapl_id so that the user application can
+ *          retrieve a file handle for low-level access to a particular member
+ *          of a family of files. The file handle is retrieved with a separate
+ *          call to H5Fget_vfd_handle() (or, in special circumstances, to
+ *          H5FDget_vfd_handle(); see \ref VFL).
+ *
+ *          The value of \p offset is an offset in bytes from the beginning of
+ *          the HDF5 file, identifying a user-determined location within the
+ *          HDF5 file.
+ *          The file handle the user application is seeking is for the specific
+ *          member-file in the associated family of files to which this offset
+ *          is mapped.
+ *
+ *          Use of this function is only appropriate for an HDF5 file written as
+ *          a family of files with the \c FAMILY file driver.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pset_family_offset(hid_t fapl_id, hsize_t offset);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the file close degree
+ *
+ * \fapl_id
+ * \param[in] degree Pointer to a location containing the file close
+ *           degree property, the value of \p degree
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_fclose_degree() sets the file close degree property
+ *          \p degree in the file access property list \p fapl_id.
+ *
+ *          The value of \p degree determines how aggressively
+ *          H5Fclose() deals with objects within a file that remain open
+ *          when H5Fclose() is called to close that file. \p degree can
+ *          have any one of four valid values:
+ *
+ *          <table>
+ *           <tr>
+ *            <th>Degree name</th>
+ *            <th>H5Fclose behavior with no open object in file</th>
+ *            <th>H5Fclose behavior with open object(s) in file</th>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5F_CLOSE_WEAK</td>
+ *            <td>Actual file is closed.</td>
+ *            <td>Access to file identifier is terminated; actual file
+ *                close is delayed until all objects in file are closed
+ *            </td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5F_CLOSE_SEMI</td>
+ *            <td>Actual file is closed.</td>
+ *            <td>Function returns FAILURE</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5F_CLOSE_STRONG</td>
+ *            <td>Actual file is closed.</td>
+ *            <td>All open objects remaining in the file are closed then
+ *                file is closed</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5F_CLOSE_DEFAULT</td>
+ *            <td>The VFL driver chooses the behavior. Currently, all VFL
+ *            drivers set this value to #H5F_CLOSE_WEAK, except for the
+ *            MPI-I/O driver, which sets it to #H5F_CLOSE_SEMI.</td>
+ *            <td></td>
+ *           </tr>
+ *
+ *          </table>
+ * \warning If a file is opened multiple times without being closed, each
+ *          open operation must use the same file close degree setting.
+ *          For example, if a file is already open with #H5F_CLOSE_WEAK,
+ *          an H5Fopen() call with #H5F_CLOSE_STRONG will fail.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pset_fclose_degree(hid_t fapl_id, H5F_close_degree_t degree);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets an initial file image in a memory buffer
+ *
+ * \fapl_id
+ * \param[in] buf_ptr Pointer to the initial file image, or
+ *                    NULL if no initial file image is desired
+ * \param[in] buf_len Size of the supplied buffer, or
+ *                    0 (zero) if no initial image is desired
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_file_image() allows an application to provide a file image
+ *          to be used as the initial contents of a file.
+ *          Calling H5Pset_file_image()makes a copy of the buffer specified in
+ *          \p buf_ptr of size \p buf_len.
+ *
+ *          \par Motivation:
+ *          H5Pset_file_image() and other elements of HDF5 are
+ *          used to load an image of an HDF5 file into system memory and open
+ *          that image as a regular HDF5 file. An application can then use the
+ *          file without the overhead of disk I/O.
+ *
+ *          \par Recommended Reading:
+ *          This function is part of the file image
+ *          operations feature set. It is highly recommended to study the guide
+ *          [<em>HDF5 File Image Operations</em>]
+ *          (https://portal.hdfgroup.org/display/HDF5/HDF5+File+Image+Operations
+ *          ) before using this feature set. See the See Also section below
+ *          for links to other elements of HDF5 file image operations.
+ *
+ * \see
+ *    \li H5LTopen_file_image()
+ *    \li H5Fget_file_image()
+ *    \li H5Pget_file_image()
+ *    \li H5Pset_file_image_callbacks()
+ *    \li H5Pget_file_image_callbacks()
+ *
+ *    \li [HDF5 File Image Operations]
+ *        (https://portal.hdfgroup.org/display/HDF5/HDF5+File+Image+Operations)
+ *        in [Advanced Topics in HDF5]
+ *        (https://portal.hdfgroup.org/display/HDF5/Advanced+Topics+in+HDF5)
+ *
+ *    \li Within H5Pset_file_image_callbacks():
+ *    \li Callback #H5FD_file_image_callbacks_t
+ *    \li Callback #H5FD_file_image_op_t
+ *
+ * \version 1.8.13 Fortran subroutine added in this release.
+ * \since 1.8.9
+ *
+ */
+H5_DLL herr_t H5Pset_file_image(hid_t fapl_id, void *buf_ptr, size_t buf_len);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the callbacks for working with file images
+ *
+ * \note      **Motivation:** H5Pset_file_image_callbacks() and other elements
+ *            of HDF5 are used to load an image of an HDF5 file into system
+ *            memory and open that image as a regular HDF5 file. An application
+ *            can then use the file without the overhead of disk I/O.\n
+ *            **Recommended Reading:** This function is part of the file
+ *            image operations feature set. It is highly recommended to study
+ *            the guide [HDF5 File Image Operations]
+ *            (https://portal.hdfgroup.org/display/HDF5/HDF5+File+Image+Operations
+ *            ) before using this feature set. See the See Also section below
+ *            for links to other elements of HDF5 file image operations.
+ *
+ * \fapl_id
+ * \param[in,out] callbacks_ptr Pointer to the instance of the
+ *                #H5FD_file_image_callbacks_t structure
+ *
+ * \return \herr_t \n
+ *         **Failure Modes**: Due to interactions between this function and
+ *         H5Pset_file_image() and H5Pget_file_image(),
+ *         H5Pset_file_image_callbacks() will fail if a file image has
+ *         already been set in the target file access property list, \p fapl_id.
+ *
+ * \details H5Pset_file_image_callbacks() sets callback functions for working
+ *          with file images in memory.
+ *
+ *          H5Pset_file_image_callbacks() allows an application to control the
+ *          management of file image buffers through user defined callbacks.
+ *          These callbacks can be used in the management of file image buffers
+ *          in property lists and with certain file drivers.
+ *
+ *          H5Pset_file_image_callbacks() must be used before any file image has
+ *          been set in the file access property list. Once a file image has
+ *          been set, the function will fail.
+ *
+ *          The callback routines set up by H5Pset_file_image_callbacks() are
+ *          invoked when a new file image buffer is allocated, when an existing
+ *          file image buffer is copied or resized, or when a file image buffer
+ *          is released from use.
+ *
+ *          Some file drivers allow the use of user-defined callback functions
+ *          for allocating, freeing, and copying the driver's internal buffer,
+ *          potentially allowing optimizations such as avoiding large \c malloc
+ *          and \c memcpy operations, or to perform detailed logging.
+ *
+ *          From the perspective of the HDF5 library, the operations of the
+ *          \ref H5FD_file_image_callbacks_t.image_malloc "image_malloc",
+ *          \ref H5FD_file_image_callbacks_t.image_memcpy "image_memcpy",
+ *          \ref H5FD_file_image_callbacks_t.image_realloc "image_realloc", and
+ *          \ref H5FD_file_image_callbacks_t.image_free "image_free" callbacks
+ *          must be identical to those of the
+ *          corresponding C standard library calls (\c malloc, \c memcpy,
+ *          \c realloc, and \c free). While the operations must be identical,
+ *          the file image callbacks have more parameters. The return values
+ *          of \ref H5FD_file_image_callbacks_t.image_malloc "image_malloc" and
+ *          \ref H5FD_file_image_callbacks_t.image_realloc "image_realloc" are identical to
+ *          the return values of \c malloc and \c realloc. The return values of
+ *          \ref H5FD_file_image_callbacks_t.image_malloc "image_malloc" and
+ *          \ref H5FD_file_image_callbacks_t.image_free "image_free" differ from the return
+ *          values of \c memcpy and \c free in that the return values of
+ *          \ref H5FD_file_image_callbacks_t.image_memcpy "image_memcpy" and
+ *          \ref H5FD_file_image_callbacks_t.image_free "image_free" can also indicate failure.
+ *
+ *          The callbacks and their parameters, along with a struct and
+ *          an \c ENUM required for their use, are described below.
+ *
+ *          <b>Callback struct and \c ENUM:</b>
+ *
+ *          The callback functions set up by H5Pset_file_image_callbacks() use
+ *          a struct and an \c ENUM that are defined as follows
+ *
+ *          The struct #H5FD_file_image_callbacks_t serves as a container
+ *          for the callback functions and a pointer to user-supplied data.
+ *          The struct is defined as follows:
+ *          \snippet H5FDpublic.h H5FD_file_image_callbacks_t_snip
+ *
+ *          Elements of the #H5FD_file_image_op_t are used by the
+ *          callbacks to invoke certain operations on file images. The ENUM is
+ *          defined as follows:
+ *          \snippet H5FDpublic.h H5FD_file_image_op_t_snip
+ *
+ *          The elements of the #H5FD_file_image_op_t are used in the following
+ *          callbacks:
+ *
+ *          - The \ref H5FD_file_image_callbacks_t.image_malloc "image_malloc" callback
+ *          contains a pointer to a function that must appear to HDF5 to have
+ *          functionality identical to that of the standard C library \c malloc() call.
+ *
+ *          - Signature in #H5FD_file_image_callbacks_t:
+ *          \snippet H5FDpublic.h image_malloc_snip
+ *          \n
+ *          - The \ref H5FD_file_image_callbacks_t.image_memcpy "image_memcpy"
+ *          callback contains a pointer to a function
+ *          that must appear to HDF5 to have functionality identical to that
+ *          of the standard C library \c memcopy() call, except that it returns
+ *          a \p NULL on failure. (The \c memcpy C Library routine is defined
+ *          to return the \p dest parameter in all cases.)
+ *
+ *          - Setting \ref H5FD_file_image_callbacks_t.image_memcpy "image_memcpy"
+ *          to \c NULL indicates that HDF5 should invoke
+ *          the standard C library \c memcpy() routine when copying buffers.
+ *
+ *          - Signature in #H5FD_file_image_callbacks_t:
+ *          \snippet H5FDpublic.h image_memcpy_snip
+ *          \n
+ *          - The \ref H5FD_file_image_callbacks_t.image_realloc "image_realloc" callback
+ *          contains a pointer to a function that must appear to HDF5 to have
+ *          functionality identical to that of the standard C library \c realloc() call.
+ *
+ *          - Setting \ref H5FD_file_image_callbacks_t.image_realloc "image_realloc"
+ *          to \p NULL indicates that HDF5 should
+ *          invoke the standard C library \c realloc() routine when resizing
+ *          file image buffers.
+ *
+ *          - Signature in #H5FD_file_image_callbacks_t:
+ *          \snippet H5FDpublic.h image_realloc_snip
+ *          \n
+ *          - The \ref H5FD_file_image_callbacks_t.image_free "image_free" callback contains
+ *          a pointer to a function that must appear to HDF5 to have functionality
+ *          identical to that of the standard C library \c free() call, except
+ *          that it will return \c 0 (\c SUCCEED) on success and \c -1 (\c FAIL) on failure.
+ *
+ *          - Setting \ref H5FD_file_image_callbacks_t.image_free "image_free"
+ *          to \c NULL indicates that HDF5 should invoke
+ *          the standard C library \c free() routine when releasing file image
+ *          buffers.
+ *
+ *          - Signature in #H5FD_file_image_callbacks_t:
+ *          \snippet H5FDpublic.h image_free_snip
+ *          \n
+ *          - The  \ref H5FD_file_image_callbacks_t.udata_copy "udata_copy"
+ *          callback contains a pointer to a function
+ *          that, from the perspective of HDF5, allocates a buffer of suitable
+ *          size, copies the contents of the supplied \p udata into the new
+ *          buffer, and returns the address of the new buffer. The function
+ *          returns NULL on failure. This function is necessary if a non-NULL
+ *          \p udata parameter is supplied, so that property lists containing
+ *          the image callbacks can be copied. If the \p udata parameter below
+ *          is \c NULL, then this parameter should be \c NULL as well.
+ *
+ *          - Signature in #H5FD_file_image_callbacks_t:
+ *          \snippet H5FDpublic.h udata_copy_snip
+ *          \n
+ *          - The \ref H5FD_file_image_callbacks_t.udata_free "udata_free"
+ *          callback contains a pointer to a function
+ *          that, from the perspective of HDF5, frees a user data block. This
+ *          function is necessary if a non-NULL udata parameter is supplied so
+ *          that property lists containing image callbacks can be discarded
+ *          without a memory leak. If the udata parameter below is \c NULL,
+ *          this parameter should be \c NULL as well.
+ *
+ *          - Signature in #H5FD_file_image_callbacks_t:
+ *          \snippet H5FDpublic.h udata_free_snip
+ *
+ *          - \p **udata**, the final field in the #H5FD_file_image_callbacks_t
+ *          struct, provides a pointer to user-defined data. This pointer will
+ *          be passed to the
+ *          \ref H5FD_file_image_callbacks_t.image_malloc "image_malloc",
+ *          \ref H5FD_file_image_callbacks_t.image_memcpy "image_memcpy",
+ *          \ref H5FD_file_image_callbacks_t.image_realloc "image_realloc", and
+ *          \ref H5FD_file_image_callbacks_t.image_free "image_free" callbacks.
+ *          Define udata as \c NULL if no user-defined data is provided.
+ *
+ * \since 1.8.9
+ *
+ */
+H5_DLL herr_t H5Pset_file_image_callbacks(hid_t fapl_id, H5FD_file_image_callbacks_t *callbacks_ptr);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the file locking property values
+ *
+ * \fapl_id
+ * \param[in] use_file_locking Toggle to specify file locking (or not)
+ * \param[in] ignore_when_disabled Toggle to ignore when disabled (or not)
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_file_locking() overrides the default file locking flag
+ *          setting that was set when the library was configured.
+ *
+ *          This setting can be overridden by the \c HDF5_USE_FILE_LOCKING
+ *          environment variable.
+ *
+ *          File locking is used when creating/opening a file to prevent
+ *          problematic file accesses.
+ *
+ * \since 1.10.7
+ *
+ */
+H5_DLL herr_t H5Pset_file_locking(hid_t fapl_id, hbool_t use_file_locking, hbool_t ignore_when_disabled);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets garbage collecting references flag
+ *
+ * \fapl_id
+ * \param[in] gc_ref Flag setting reference garbage collection to on (1) or off (0)
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_gc_references() sets the flag for garbage collecting
+ *          references for the file.
+ *
+ *          Dataset region references and other reference types use space in an
+ *          HDF5 file's global heap. If garbage collection is on and the user
+ *          passes in an uninitialized value in a reference structure, the heap
+ *          might get corrupted. When garbage collection is off, however, and
+ *          the user re-uses a reference, the previous heap block will be
+ *          orphaned and not returned to the free heap space.
+ *
+ *          When garbage collection is on, the user must initialize the
+ *          reference structures to 0 or risk heap corruption.
+ *
+ *          The default value for garbage collecting references is off.
+ *
+ */
+H5_DLL herr_t H5Pset_gc_references(hid_t fapl_id, unsigned gc_ref);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Controls the range of library release versions used when creating
+ *        objects in a file
+ *
+ * \fapl_id{plist_id}
+ * \param[in] low  The earliest version of the library that will be used
+ *                 for writing objects
+ * \param[in] high The latest version of the library that will be used for
+ *                 writing objects
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_libver_bounds() controls the range of library release
+ *          versions that will be used when creating objects in a file.
+ *          The object format versions are determined indirectly from the
+ *          library release versions specified in the call.
+ *
+ *          This property is set in the file access property list
+ *          specified by the parameter \p fapl_id.
+ *
+ *          The parameter \p low sets the earliest possible format
+ *          versions that the library will use when creating objects in
+ *          the file.  Note that earliest possible is different from
+ *          earliest, as some features introduced in library versions
+ *          later than 1.0.0 resulted in updates to object formats.
+ *          The parameter \p high sets the latest format versions that
+ *          the library will be allowed to use when creating objects in
+ *          the file.
+ *
+ *          The parameters \p low and \p high must be one of the
+ *          enumerated values in the #H5F_libver_t struct, which is
+ *          defined in H5Fpublic.h.
+ *
+ *          The macro #H5F_LIBVER_LATEST is aliased to the highest
+ *          enumerated value in #H5F_libver_t, indicating that this is
+ *          currently the latest format available.
+ *
+ *          The library supports the following pairs of (\p low, \p high)
+ *          combinations as derived from the values in #H5F_libver_t:
+ *
+ *          <table>
+ *           <tr>
+ *            <th>Value of \p low and \p high</th>
+ *            <th>Result</th>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_EARLIEST<br />
+ *                \p high=#H5F_LIBVER_V18</td>
+ *            <td>
+ *             \li The library will create objects with the earliest
+ *                 possible format versions.
+ *             \li The library will allow objects to be created with the
+ *                 latest format versions available to library release 1.8.x.
+ *             \li API calls that create objects or features that are
+ *                 available to versions of the library greater than 1.8.x
+ *                 release will fail.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_EARLIEST<br />
+ *                \p high=#H5F_LIBVER_V110</td>
+ *            <td>
+ *             \li The library will create objects with the earliest possible
+ *                 format versions.
+ *             \li The library will allow objects to be created with the latest
+ *                 format versions available to library release 1.10.x.
+ *             \li API calls that create objects or features that are
+ *                 available to versions of the library greater than 1.10.x
+ *                 release will fail.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_EARLIEST<br />
+ *                \p high=#H5F_LIBVER_V112</td>
+ *            <td>
+ *             \li The library will create objects with the earliest possible
+ *                 format versions.
+ *             \li The library will allow objects to be created with the latest
+ *                 format versions available to library release 1.12.x.
+ *             \li API calls that create objects or features that are
+ *                 available to versions of the library greater than 1.12.x
+ *                 release will fail.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_EARLIEST<br />
+ *                \p high=#H5F_LIBVER_V114</td>
+ *            <td>
+ *             \li The library will create objects with the earliest possible
+ *                 format versions.
+ *             \li The library will allow objects to be created with the latest
+ *                 format versions available to library release 1.14.x.
+ *             \li API calls that create objects or features that are
+ *                 available to versions of the library greater than 1.14.x
+ *                 release will fail.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_EARLIEST<br />
+ *                \p high=#H5F_LIBVER_V116</td>
+ *            <td>
+ *             \li The library will create objects with the earliest possible
+ *                 format versions.
+ *             \li The library will allow objects to be created with the latest
+ *                 format versions available to library release 1.16.x.  See
+ *                 note *H5F_LIBVER_LATEST* below the table.
+ *             \li This is the library default setting and provides the greatest
+ *                 format compatibility.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V18<br />
+ *                \p high=#H5F_LIBVER_V18</td>
+ *            <td>
+ *             \li The library will create objects with the latest format
+ *                 versions available to library release 1.8.x.
+ *             \li The library will allow objects to be created with the latest
+ *                 format versions available to library release 1.8.x.
+ *             \li The objects written with this setting may be
+ *                 accessible to a smaller range of library versions than
+ *                 would be the case if low is set to #H5F_LIBVER_EARLIEST.
+ *             \li API calls that create objects or features that are available
+ *                 to versions of the library greater than 1.8.x release will
+ *                 fail.
+ *             \li Earlier versions of the library may not be able to access
+ *                 objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V18<br />
+ *                \p high=#H5F_LIBVER_V110</td>
+ *            <td>
+ *             \li The library will create objects with the latest format
+ *                 versions available to library release 1.8.x.
+ *             \li The library will allow objects to be created with the latest
+ *                 format versions available to library release 1.10.x.
+ *             \li API calls that create objects or features that are
+ *                 available to versions of the library greater than 1.10.x
+ *                 release will fail.
+ *             \li Earlier versions of the library may not be able to access
+ *                 objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V18<br />
+ *                \p high=#H5F_LIBVER_V112</td>
+ *            <td>
+ *             \li The library will create objects with the latest format
+ *                 versions available to library release 1.8.x.
+ *             \li The library will allow objects to be created with the latest
+ *                 format versions available to library release 1.12.x.
+ *             \li API calls that create objects or features that are
+ *                 available to versions of the library greater than 1.12.x
+ *                 release will fail.
+ *             \li Earlier versions of the library may not be able to access
+ *                 objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V18<br />
+ *                \p high=#H5F_LIBVER_V114</td>
+ *            <td>
+ *             \li The library will create objects with the latest format
+ *                 versions available to library release 1.8.x.
+ *             \li The library will allow objects to be created with the latest
+ *                 format versions available to library release 1.14.x.
+ *             \li API calls that create objects or features that are
+ *                 available to versions of the library greater than 1.14.x
+ *                 release will fail.
+ *             \li Earlier versions of the library may not be able to access
+ *                 objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V18<br />
+ *                \p high=#H5F_LIBVER_V116</td>
+ *            <td>
+ *             \li The library will create objects with the latest format
+ *                 versions available to library release 1.8.x.
+ *             \li The library will allow objects to be created with the latest
+ *                 format versions available to library release 1.16.x.  See
+ *                 note *H5F_LIBVER_LATEST* below the table.
+ *             \li This setting allows users to take advantage of the latest
+ *                 features and performance enhancements in the library.
+ *             \li Earlier versions of the library may not be able to access
+ *                 objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V110<br />
+ *                \p high=#H5F_LIBVER_V110</td>
+ *             <td>
+ *              \li The library will create objects with the latest format
+ *                  versions available to library release 1.10.x.
+ *              \li The library will allow objects to be created with the latest
+ *                  format versions available to library release 1.10.x.
+ *              \li The objects written with this setting may be
+ *                  accessible to a smaller range of library versions than
+ *                  would be the case if low is set to #H5F_LIBVER_EARLIEST.
+ *              \li API calls that create objects or features that are available
+ *                  to versions of the library greater than 1.10.x release will
+ *                  fail.
+ *              \li Earlier versions of the library may not be able to access
+ *                  objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V110<br />
+ *                \p high=#H5F_LIBVER_V112</td>
+ *             <td>
+ *              \li The library will create objects with the latest format
+ *                  versions available to library release 1.10.x.
+ *              \li The library will allow objects to be created with the latest
+ *                  format versions available to library release 1.12.x.
+ *              \li API calls that create objects or features that are available
+ *                  to versions of the library greater than 1.12.x release will
+ *                  fail.
+ *              \li Earlier versions of the library may not be able to access
+ *                  objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V110<br />
+ *                \p high=#H5F_LIBVER_V114</td>
+ *             <td>
+ *              \li The library will create objects with the latest format
+ *                  versions available to library release 1.10.x.
+ *              \li The library will allow objects to be created with the latest
+ *                  format versions available to library release 1.14.x.
+ *              \li API calls that create objects or features that are available
+ *                  to versions of the library greater than 1.14.x release will
+ *                  fail.
+ *              \li Earlier versions of the library may not be able to access
+ *                  objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V110<br />
+ *                \p high=#H5F_LIBVER_V116</td>
+ *             <td>
+ *              \li The library will create objects with the latest format
+ *                  versions available to library release 1.10.x.
+ *              \li The library will allow objects to be created with the latest
+ *                  format versions available to library release 1.16.x.  See
+ *                  note *H5F_LIBVER_LATEST* below the table.
+ *              \li This setting allows users to take advantage of the latest
+ *                  features and performance enhancements in the library.
+ *              \li Earlier versions of the library may not be able to access
+ *                  objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V112<br />
+ *                \p high=#H5F_LIBVER_V112</td>
+ *             <td>
+ *              \li The library will create objects with the latest format
+ *                  versions available to library release 1.12.x.
+ *              \li The library will allow objects to be created with the latest
+ *                  format versions available to library release 1.12.x.
+ *              \li The objects written with this setting may be
+ *                  accessible to a smaller range of library versions than
+ *                  would be the case if low is set to #H5F_LIBVER_EARLIEST.
+ *              \li API calls that create objects or features that are available
+ *                  to versions of the library greater than 1.12.x release will
+ *                  fail.
+ *              \li Earlier versions of the library may not be able to access
+ *                  objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V112<br />
+ *                \p high=#H5F_LIBVER_V114</td>
+ *             <td>
+ *              \li The library will create objects with the latest format
+ *                  versions available to library release 1.12.x.
+ *              \li The library will allow objects to be created with the latest
+ *                  format versions available to library release 1.14.x.
+ *              \li API calls that create objects or features that are available
+ *                  to versions of the library greater than 1.14.x release will
+ *                  fail.
+ *              \li Earlier versions of the library may not be able to access
+ *                  objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V112<br />
+ *                \p high=#H5F_LIBVER_V116</td>
+ *             <td>
+ *              \li The library will create objects with the latest format
+ *                  versions available to library release 1.12.x.
+ *              \li The library will allow objects to be created with the latest
+ *                  format versions available to library release 1.16.x.  See
+ *                  note *H5F_LIBVER_LATEST* below the table.
+ *              \li This setting allows users to take advantage of the latest
+ *                  features and performance enhancements in the library.
+ *              \li Earlier versions of the library may not be able to access
+ *                  objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V114<br />
+ *                \p high=#H5F_LIBVER_V114</td>
+ *             <td>
+ *              \li The library will create objects with the latest format
+ *                  versions available to library release 1.14.x.
+ *              \li The library will allow objects to be created with the latest
+ *                  format versions available to library release 1.14.x.
+ *              \li The objects written with this setting may be
+ *                  accessible to a smaller range of library versions than
+ *                  would be the case if low is set to #H5F_LIBVER_EARLIEST.
+ *              \li API calls that create objects or features that are available
+ *                  to versions of the library greater than 1.14.x release will
+ *                  fail.
+ *              \li Earlier versions of the library may not be able to access
+ *                  objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V114<br />
+ *                \p high=#H5F_LIBVER_V116</td>
+ *             <td>
+ *              \li The library will create objects with the latest format
+ *                  versions available to library release 1.14.x.
+ *              \li The library will allow objects to be created with the latest
+ *                  format versions available to library release 1.16.x.  See
+ *                  note *H5F_LIBVER_LATEST* below the table.
+ *              \li This setting allows users to take advantage of the latest
+ *                  features and performance enhancements in the library.
+ *              \li Earlier versions of the library may not be able to access
+ *                  objects created with this setting.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>\p low=#H5F_LIBVER_V116<br />
+ *                \p high=#H5F_LIBVER_V116</td>
+ *             <td>
+ *              \li The library will create objects with the latest format
+ *                  versions available to library release 1.16.x.
+ *              \li The library will allow objects to be created with the latest
+ *                  format versions available to library release 1.16.x.  See
+ *                  note *H5F_LIBVER_LATEST* below the table.
+ *              \li This setting allows users to take advantage of the latest
+ *                  features and performance enhancements in the library.
+ *                  However, objects written with this setting may be
+ *                  accessible to a smaller range of library versions than
+ *                  would be the case if low is set to #H5F_LIBVER_EARLIEST.
+ *              \li Earlier versions of the library may not be able to access
+ *                  objects created with this setting.</td>
+ *           </tr>
+ *          </table>
+ *
+ * \note *H5F_LIBVER_LATEST*:<br />
+ *                 Since 1.16.x is also #H5F_LIBVER_LATEST, there is no upper
+ *                 limit on the format versions to use.  That is, if a
+ *                 newer format version is required to support a feature
+ *                 in 1.16.x series, this setting will allow the object to be
+ *                 created.
+ *
+ * \version 1.10.2 #H5F_LIBVER_V18 added to the enumerated defines in
+ *                 #H5F_libver_t.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_libver_bounds(hid_t plist_id, H5F_libver_t low, H5F_libver_t high);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Set the initial metadata cache configuration in the indicated File
+ *        Access Property List to the supplied value
+ *
+ * \fapl_id{plist_id}
+ * \param[in] config_ptr  Pointer to the instance of \p H5AC_cache_config_t
+ *            containing the desired configuration
+ * \return \herr_t
+ *
+ *  \details The fields of the #H5AC_cache_config_t structure are shown
+ *           below:
+ *           \snippet H5ACpublic.h H5AC_cache_config_t_snip
+ *           \click4more
+ *
+ * \details H5Pset_mdc_config() attempts to set the initial metadata cache
+ *          configuration to the supplied value.  It will fail if an invalid
+ *          configuration is detected.  This configuration is used when the file
+ *          is opened.
+ *
+ *          See the overview of the metadata cache in the special topics section
+ *          of the user manual for details on what is being configured. If you
+ *          have not read and understood that documentation, you really should
+ *          not be using this API call.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_mdc_config(hid_t plist_id, H5AC_cache_config_t *config_ptr);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets metadata cache logging options
+ *
+ * \fapl_id{plist_id}
+ * \param[in] is_enabled  Whether logging is enabled
+ * \param[in] location Location of log in UTF-8/ASCII (file path/name)
+ *            (On Windows, this must be ASCII)
+ * \param[in] start_on_access  Whether the logging will begin as soon as the
+ *            file is opened or created
+ *
+ * \return \herr_t
+ *
+ * \details The metadata cache is a central part of the HDF5 library through
+ *          which all file metadata reads and writes take place. File metadata
+ *          is normally invisible to the user and is used by the library for
+ *          purposes such as locating and indexing data. File metadata should
+ *          not be confused with user metadata, which consists of attributes
+ *          created by users and attached to HDF5 objects such as datasets via
+ *          H5A API calls.
+ *
+ *          Due to the complexity of the cache, a trace/logging feature has
+ *          been created that can be used by HDF5 developers for debugging and
+ *          performance analysis. The functions that control this functionality
+ *          will normally be of use to a very limited number of developers
+ *          outside of The HDF Group. The functions have been documented to
+ *          help users create logs that can be sent with bug reports.
+ *
+ *          Control of the log functionality is straightforward. Logging is
+ *          enabled via the H5Pset_mdc_log_options() function,
+ *          which will modify the file access property list used to open or
+ *          create a file. This function has a flag that determines whether
+ *          logging begins at file open or starts in a paused state. Log
+ *          messages can then be controlled via the H5Fstart_mdc_logging()
+ *          and H5Fstop_mdc_logging() function.
+ *
+ *          H5Pget_mdc_log_options() can be used to examine a file access
+ *          property list, and H5Fget_mdc_logging_status() will return the
+ *          current state of the logging flags.
+ *
+ *          The log format is described in [<em>Metadata Cache Logging</em>]
+ *          (https://portal.hdfgroup.org/display/HDF5/Fine-tuning+the+Metadata+Cache).
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Pset_mdc_log_options(hid_t plist_id, hbool_t is_enabled, const char *location,
+                                     hbool_t start_on_access);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the minimum metadata block size
+ *
+ * \fapl_id{fapl_id}
+ * \param[in] size Minimum size, in bytes, of metadata block allocations
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_meta_block_size() sets the minimum size, in bytes, of
+ *          metadata block allocations when #H5FD_FEAT_AGGREGATE_METADATA is set by a VFL
+ *          driver.
+
+ *          Each raw metadata block is initially allocated to be of the given size.
+ *          Specific metadata objects (e.g., object headers, local heaps, B-trees) are then
+ *          sub-allocated from this block.
+ *
+ *          The default setting is 2048 bytes, meaning that the library will
+ *          attempt to aggregate metadata in at least 2K blocks in the file.
+ *          Setting the value to zero (\Code{0}) with this function will turn
+ *          off metadata aggregation, even if the VFL driver attempts to use the
+ *          metadata aggregation strategy.
+ *
+ *          Metadata aggregation reduces the number of small data objects in the file that
+ *          would otherwise be required for metadata. The aggregated block of metadata is
+ *          usually written in a single write action and always in a contiguous block,
+ *          potentially significantly improving library and application performance.
+ *
+ * \since 1.4.0
+ */
+H5_DLL herr_t H5Pset_meta_block_size(hid_t fapl_id, hsize_t size);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the number of read attempts in a file access property list
+ *
+ * \fapl_id{plist_id}
+ * \param[in] attempts The number of read attempts. Must be a value greater than \Code{0}
+ *
+ * \return \herr_t
+ *
+ * \return Failure Modes:
+ *         - When the user sets the number of read attempts to \Code{0}.
+ *         - When the input property list is not a file access property list.
+ *         - When the library is unable to set the number of read attempts in the file access property list.
+ *
+ * \details H5Pset_metadata_read_attempts() sets the number of reads that the
+ *          library will try when reading checksummed metadata in an HDF5 file opened
+ *          with SWMR access. When reading such metadata, the library will compare the
+ *          checksum computed for the metadata just read with the checksum stored within
+ *          the piece of checksum. When performing SWMR operations on a file, the
+ *          checksum check might fail when the library reads data on a system that is not
+ *          atomic. To remedy such situations, the library will repeatedly read the piece
+ *          of metadata until the check passes or finally fails the read when the allowed
+ *          number of attempts is reached.
+ *
+ *          The number of read attempts used by the library will depend on how the file is
+ *          opened and whether the user sets the number of read attempts via this routine:
+
+ *          - For a file opened with SWMR access:
+ *            - If the user sets the number of attempts to \Code{N}, the library will use \Code{N}.
+ *            - If the user does not set the number of attempts, the library will use the
+ *              default for SWMR access (\Code{100}).
+ *          - For a file opened with non-SWMR access, the library will always use the default
+ *            for non-SWMR access (\Code{1}). The value set via this routine does not have any effect
+ *            during non-SWMR access.
+ *
+ * \b Example: The first example illustrates the case in setting the number of read attempts for a file
+ *             opened with SWMR access.
+ *
+ * \snippet H5Pset_metadata_read_attempts.c SWMR Access
+ *
+ * \b Example: The second example illustrates the case in setting the number of
+ *             read attempts for a file opened with non-SWMR access. The value
+ *             set in the file access property list does not have any effect.
+ *
+ * \snippet H5Pset_metadata_read_attempts.c non-SWMR Access
+ *
+ * \note \b Motivation: On a system that is not atomic, the library might
+ *       possibly read inconsistent metadata with checksum when performing
+ *       single-writer/multiple-reader (SWMR) operations for an HDF5 file. Upon
+ *       encountering such situations, the library will try reading the metadata
+ *       again to obtain consistent data. This routine provides the means to set
+ *       the number of read attempts other than the library default.
+ *
+ * \since 1.10.0
+ */
+H5_DLL herr_t H5Pset_metadata_read_attempts(hid_t plist_id, unsigned attempts);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Specifies type of data to be accessed via the \Code{MULTI} driver,
+ *        enabling more direct access
+ *
+ * \fapl_id{fapl_id}
+ * \param[in] type Type of data to be accessed
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_multi_type() sets the \Emph{type of data} property in the file
+ *          access property list \p fapl_id. This setting enables a user
+ *          application to specify the type of data the application wishes to
+ *          access so that the application can retrieve a file handle for
+ *          low-level access to the particular member of a set of \Code{MULTI}
+ *          files in which that type of data is stored. The file handle is
+ *          retrieved with a separate call to H5Fget_vfd_handle() (or, in special
+ *          circumstances, to H5FDget_vfd_handle(); see \ref VFL.
+ *
+ * The type of data specified in \p type may be one of the following:
+ *
+ * <table>
+ *   <tr>
+ *     <td>#H5FD_MEM_SUPER</td>    <td>Super block data</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5FD_MEM_BTREE</td>    <td>B-tree data</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5FD_MEM_DRAW</td>    <td>Dataset raw data</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5FD_MEM_GHEAP</td>    <td>Global heap data</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5FD_MEM_LHEAP</td>    <td>Local Heap data</td>
+ *   </tr>
+ *   <tr>
+ *     <td>#H5FD_MEM_OHDR</td>    <td>Object header data</td>
+ *   </tr>
+ * </table>
+ *
+ * This function is for use only when accessing an HDF5 file written as a set of
+ * files with the \Code{MULTI} file driver.
+ *
+ * \since 1.6.0
+ */
+H5_DLL herr_t H5Pset_multi_type(hid_t fapl_id, H5FD_mem_t type);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets a callback function to invoke when an object flush occurs in the file
+ *
+ * \fapl_id{plist_id}
+ * \op{func}
+ * \op_data_in{udata}
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_object_flush_cb() sets the callback function to invoke in the
+ *          file access property list \p plist_id whenever an object flush occurs in
+ *          the file. Library objects are group, dataset, and committed
+ *          datatype.
+ *
+ *          The callback function \p func must conform to the prototype defined below:
+ *          \code
+ *          typedef herr_t (*H5F_flush_cb_t)(hid_t object_id, void *user_data)
+ *          \endcode
+ *
+ *          The parameters of the callback function, per the above prototypes, are defined as follows:
+ *            - \Code{object_id} is the identifier of the object which has just been flushed.
+ *            - \Code{user_data} is the user-defined input data for the callback function.
+ *
+ * \b Example: The example below illustrates the usage of this routine to set
+ *             the callback function to invoke when an object flush occurs.
+ *
+ * \include H5Pset_object_flush_cb.c
+ *
+ * \since 1.10.0
+ */
+H5_DLL herr_t H5Pset_object_flush_cb(hid_t plist_id, H5F_flush_cb_t func, void *udata);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the maximum size of the data sieve buffer
+ *
+ * \fapl_id{fapl_id}
+ * \param[in] size Maximum size, in bytes, of data sieve buffer
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_sieve_buf_size() sets \p size, the maximum size in bytes of the
+ *          data sieve buffer, which is used by file drivers that are capable of
+ *          using data sieving.
+ *
+ *          The data sieve buffer is used when performing I/O on datasets in the
+ *          file. Using a buffer which is large enough to hold several pieces of
+ *          the dataset being read in for hyperslab selections boosts
+ *          performance by quite a bit.
+ *
+ *          The default value is set to 64KB, indicating that file I/O for raw
+ *          data reads and writes will occur in at least 64KB blocks. Setting
+ *          the value to zero (\Code{0}) with this API function will turn off
+ *          the data sieving, even if the VFL driver attempts to use that
+ *          strategy.
+ *
+ *          Internally, the library checks the storage sizes of the datasets in
+ *          the file. It picks the smaller one between the size from the file
+ *          access property and the size of the dataset to allocate the sieve
+ *          buffer for the dataset in order to save memory usage.
+ *
+ * \version 1.6.0 The \p size parameter has changed from type \Code{hsize_t} to \Code{size_t}.
+ *
+ * \since 1.4.0
+ */
+H5_DLL herr_t H5Pset_sieve_buf_size(hid_t fapl_id, size_t size);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the size of a contiguous block reserved for small data
+ *
+ * \fapl_id{fapl_id}
+ * \param[in] size Maximum size, in bytes, of the small data block.
+                   The default size is \Code{2048}.
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_small_data_block_size() reserves blocks of \p size bytes for the
+ *          contiguous storage of the raw data portion of \Emph{small} datasets. The
+ *          HDF5 library then writes the raw data from small datasets to this
+ *          reserved space, thus reducing unnecessary discontinuities within
+ *          blocks of meta data and improving I/O performance.
+ *
+ *          A small data block is actually allocated the first time a qualifying
+ *          small dataset is written to the file. Space for the raw data portion
+ *          of this small dataset is suballocated within the small data block.
+ *          The raw data from each subsequent small dataset is also written to
+ *          the small data block until it is filled; additional small data
+ *          blocks are allocated as required.
+ *
+ *          The HDF5 library employs an algorithm that determines whether I/O
+ *          performance is likely to benefit from the use of this mechanism with
+ *          each dataset as storage space is allocated in the file. A larger
+ *          \p size will result in this mechanism being employed with larger
+ *          datasets.
+ *
+ *          The small data block size is set as an allocation property in the
+ *          file access property list identified by \p fapl_id.
+ *
+ *          Setting \p size to zero (\Code{0}) disables the small data block mechanism.
+ *
+ * \since 1.4.4
+ */
+H5_DLL herr_t H5Pset_small_data_block_size(hid_t fapl_id, hsize_t size);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Set the file VOL connector for a file access property list
+ *
+ * \fapl_id{plist_id}
+ * \param[in]  new_vol_id     VOL connector identifier
+ * \param[in]  new_vol_info   Optional VOL information
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_vol() sets the VOL connector \p new_vol_id for a file access
+ *          property list \p plist_id using the (optional) VOL information in
+ *          \p new_vol_info.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Pset_vol(hid_t plist_id, hid_t new_vol_id, const void *new_vol_info);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Query the capability flags for the VOL connector that will be used
+ *              with this file access property list (FAPL).
+ *
+ * \fapl_id{plist_id}
+ * \param[out]  cap_flags  Flags that indicate the VOL connector capabilities
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_vol_cap_flags() queries the current VOL connector information
+ *              for a FAPL to retrieve the capability flags for the VOL
+ *              connector stack, as will be used by a file open or create
+ *              operation that uses this FAPL.
+ *
+ * \note This routine supports the use of the HDF5_VOL_CONNECTOR environment
+ *       variable to override the VOL connector set programmatically for the
+ *       FAPL (with H5Pset_vol).
+ *
+ * \note The H5VL_CAP_FLAG_ASYNC flag can be checked to see if asynchronous
+ *              operations are supported by the VOL connector stack.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5Pget_vol_cap_flags(hid_t plist_id, uint64_t *cap_flags);
+
+#ifdef H5_HAVE_PARALLEL
+/**
+ * \ingroup GAPL
+ *
+ * \brief Sets metadata I/O mode for read operations to be collective or independent (default)
+ *
+ * \gacpl_id
+ * \param[in] is_collective Boolean value indicating whether metadata reads are collective
+ *                          (\Code{1}) or independent (\Code{0}).
+ *                          Default mode: Independent (\Code{0})
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_all_coll_metadata_ops() sets the metadata I/O mode for read
+ *          operations in the access property list \p plist_id.
+ *
+ *          When engaging in parallel I/O, all metadata write operations must be
+ *          collective. If \p is_collective is \Code{1}, this property specifies
+ *          that the HDF5 library will perform all metadata read operations
+ *          collectively; if \p is_collective is \Code{0}, such operations may
+ *          be performed independently.
+ *
+ *          Users must be aware that several HDF5 operations can potentially
+ *          issue metadata reads. These include opening a dataset, datatype, or
+ *          group; reading an attribute; or issuing a \Emph{get info} call such
+ *          as getting information for a group with H5Fget_info(). Collective
+ *          I/O requirements must be kept in mind when issuing such calls in the
+ *          context of parallel I/O.
+ *
+ *          If this property is collective on a file access property list that
+ *          is used in creating or opening a file, then the HDF5 library will
+ *          assume that all metadata read operations issued on that file
+ *          identifier will be issued collectively from all ranks irrespective
+ *          of the individual setting of a particular operation. If this
+ *          assumption is not adhered to, corruption will be introduced in the
+ *          metadata cache and HDF5's behavior will be undefined.
+ *
+ *          Alternatively, a user may wish to avoid setting this property
+ *          globally on the file access property list, and individually set it
+ *          on particular object access property lists (dataset, group, link,
+ *          datatype, attribute access property lists) for certain operations.
+ *          This will indicate that only the operations issued with such an
+ *          access property list will be called collectively and other
+ *          operations may potentially be called independently. There are,
+ *          however, several HDF5 operations that can issue metadata reads but
+ *          have no property list in their function signatures to allow passing
+ *          the collective requirement property. For those operations, the only
+ *          option is to set the global collective requirement property on the
+ *          file access property list; otherwise the metadata reads that can be
+ *          triggered from those operations will be done independently by each
+ *          process.
+ *
+ *          Functions that do not accommodate an access property list but that
+ *          might issue metadata reads are listed in \ref maybe_metadata_reads.
+ *
+ * \attention As noted above, corruption will be introduced into the metadata
+ *            cache and HDF5 library behavior will be undefined when both of the following
+ *            conditions exist:
+ *              - A file is created or opened with a file access property list in which the
+ *                collective metadata I/O property is set to \Code{1}.
+ *              - Any function is called that triggers an independent metadata read while the
+ *                file remains open with that file access property list.
+ *
+ * \attention An approach that avoids this corruption risk is described above.
+ *
+ * \sa_metadata_ops
+ *
+ * \since 1.10.0
+ */
+H5_DLL herr_t H5Pset_all_coll_metadata_ops(hid_t plist_id, hbool_t is_collective);
+/**
+ * \ingroup GAPL
+ *
+ * \brief Retrieves metadata read mode setting
+ *
+ * \gacpl_id
+ * \param[out] is_collective Pointer to a buffer containing the Boolean value indicating whether metadata
+ *                           reads are collective (\Code{>0}) or independent (\Code{0}).
+ *                           Default mode: Independent (\Code{0})
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_all_coll_metadata_ops() retrieves the collective metadata read setting from the access
+ *          property list \p plist_id into \p is_collective.
+ *
+ * \sa_metadata_ops
+ *
+ * \since 1.10.0
+ */
+H5_DLL herr_t H5Pget_all_coll_metadata_ops(hid_t plist_id, hbool_t *is_collective);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets metadata write mode to be collective or independent (default)
+ *
+ * \fapl_id{plist_id}
+ * \param[out] is_collective Boolean value indicating whether metadata
+ *             writes are collective (\Code{>0}) or independent (\Code{0}).
+ *             \Emph{Default mode:} Independent (\Code{0})
+ * \return \herr_t
+ *
+ * \details H5Pset_coll_metadata_write() tells the HDF5 library whether to
+ *          perform metadata writes collectively (1) or independently (0).
+ *
+ *          If collective access is selected, then on a flush of the metadata
+ *          cache, all processes will divide the metadata cache entries to be
+ *          flushed evenly among themselves and issue a single MPI-IO collective
+ *          write operation. This is the preferred method when the size of the
+ *          metadata created by the application is large.
+ *
+ *          If independent access is selected, the library uses the default
+ *          method for doing metadata I/O either from process zero or
+ *          independently from each process.
+ *
+ * \sa_metadata_ops
+ *
+ * \since 1.10.0
+ */
+H5_DLL herr_t H5Pset_coll_metadata_write(hid_t plist_id, hbool_t is_collective);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Retrieves metadata write mode setting
+ *
+ * \fapl_id{plist_id}
+ * \param[out] is_collective Pointer to a boolean value indicating whether
+ *             metadata writes are collective (\Code{>0}) or independent (\Code{0}).
+ *             \Emph{Default mode:} Independent (\Code{0})
+ * \return \herr_t
+ *
+ * \details H5Pget_coll_metadata_write() retrieves the collective metadata write
+ *          setting from the file access property into \p is_collective.
+ *
+ * \sa_metadata_ops
+ *
+ * \since 1.10.0
+ */
+H5_DLL herr_t H5Pget_coll_metadata_write(hid_t plist_id, hbool_t *is_collective);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Get the MPI communicator and info
+ *
+ * \fapl_id
+ * \param[out] comm MPI communicator
+ * \param[out] info MPI info object
+ * \return \herr_t
+ *
+ * \details H5Pget_mpi_params() gets the MPI communicator and info stored in
+ *          the file access property list \p fapl_id.
+ *
+ * \todo When was this introduced?
+ *
+ */
+H5_DLL herr_t H5Pget_mpi_params(hid_t fapl_id, MPI_Comm *comm, MPI_Info *info);
+
+/**
+ * \ingroup FAPL
+ *
+ * \brief Set the MPI communicator and info
+ *
+ * \fapl_id
+ * \param[in] comm MPI communicator
+ * \param[in] info MPI info object
+ * \return \herr_t
+ *
+ * \details H5Pset_mpi_params() sets the MPI communicator and info stored in
+ *          the file access property list \p fapl_id.
+ *
+ * \todo When was this introduced?
+ *
+ */
+H5_DLL herr_t H5Pset_mpi_params(hid_t fapl_id, MPI_Comm comm, MPI_Info info);
+#endif /* H5_HAVE_PARALLEL */
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the metadata cache image option for a file access property list
+ *
+ * \fapl_id{plist_id}
+ * \param[out] config_ptr Pointer to metadata cache image configuration values
+ * \return \herr_t
+ *
+ * \details H5Pset_mdc_image_config() sets the metadata cache image option with
+ *          configuration values specified by \p config_ptr for the file access
+ *          property list specified in \p plist_id.
+ *
+ *          #H5AC_cache_image_config_t is defined as follows:
+ *          \snippet H5ACpublic.h H5AC_cache_image_config_t_snip
+ *          \click4more
+ *
+ * \par Limitations: While it is an obvious error to request a cache image when
+ *      opening the file read only, it is not in general possible to test for
+ *      this error in the H5Pset_mdc_image_config() call. Rather than fail the
+ *      subsequent file open, the library silently ignores the file image
+ *      request in this case.\n It is also an error to request a cache image on
+ *      a file that does not support superblock extension messages (i.e. a
+ *      superblock version less than 2). As above, it is not always possible to
+ *      detect this error in the H5Pset_mdc_image_config() call, and thus the
+ *      request for a cache image will fail silently in this case as well.\n
+ *      Creation of cache images is currently disabled in parallel -- as above,
+ *      any request for a cache image in this context will fail silently.\n
+ *      Files with cache images may be read in parallel applications, but note
+ *      that the load of the cache image is a collective operation triggered by
+ *      the first operation that accesses metadata after file open (or, if
+ *      persistent free space managers are enabled, on the first allocation or
+ *      deallocation of file space, or read of file space manager status,
+ *      whichever comes first). Thus the parallel process may deadlock if any
+ *      process does not participate in this access.\n
+ *      In long sequences of file  closes and opens, infrequently accessed
+ *      metadata can accumulate in the cache image to the point where the cost
+ *      of storing and restoring this metadata exceeds the benefit of retaining
+ *      frequently used metadata in the cache image. When implemented, the
+ *      #H5AC_cache_image_config_t::entry_ageout should address this problem. In
+ *      the interim, not requesting a cache image every n file close/open cycles
+ *      may be an acceptable work around. The choice of \c n will be driven by
+ *      application behavior, but \Code{n = 10} seems a good starting point.
+ *
+ * \since 1.10.1
+ */
+H5_DLL herr_t H5Pset_mdc_image_config(hid_t plist_id, H5AC_cache_image_config_t *config_ptr);
+/**
+ * \ingroup FAPL
+ *
+ * \brief Sets the maximum size for the page buffer and the minimum percentage
+ *        for metadata and raw data pages
+ *
+ * \fapl_id{plist_id}
+ * \param[in] buf_size Maximum size, in bytes, of the page buffer
+ * \param[in] min_meta_per Minimum metadata percentage to keep in the page buffer
+ *            before allowing pages containing metadata to be evicted (Default is 0)
+ * \param[in] min_raw_per Minimum raw data percentage to keep in the page buffer
+ *            before allowing pages containing raw data to be evicted (Default is 0)
+ * \return \herr_t
+ *
+ * \details H5Pset_page_buffer_size() sets buf_size, the maximum size in bytes
+ *          of the page buffer. The default value is zero, meaning that page
+ *          buffering is disabled. When a non-zero page buffer size is set, the
+ *          library will enable page buffering if that size is larger or equal
+ *          than a single page size if a paged file space strategy is enabled
+ *          using the functions H5Pset_file_space_strategy() and
+ *          H5Pset_file_space_page_size().
+ *
+ *          The page buffer layer captures all I/O requests before they are
+ *          issued to the VFD and "caches" them in fixed sized pages. Once the
+ *          total number of pages exceeds the page buffer size, the library
+ *          evicts pages from the page buffer by writing them to the VFD. At
+ *          file close, the page buffer is flushed writing all the pages to the
+ *          file.
+ *
+ *          If a non-zero page buffer size is set, and the file space strategy
+ *          is not set to paged or the page size for the file space strategy is
+ *          larger than the page buffer size, the subsequent call to H5Fcreate()
+ *          or H5Fopen() using the \p plist_id will fail.
+ *
+ *          The function also allows setting the minimum percentage of pages for
+ *          metadata and raw data to prevent a certain type of data to evict hot
+ *          data of the other type.
+ *
+ * \since 1.10.1
+ *
+ */
+H5_DLL herr_t H5Pset_page_buffer_size(hid_t plist_id, size_t buf_size, unsigned min_meta_per,
+                                      unsigned min_raw_per);
+
+/* Dataset creation property list (DCPL) routines */
+/**
+ * \ingroup DCPL
+ *
+ * \brief Determines whether fill value is defined
+ *
+ * \dcpl_id{plist}
+ * \param[out] status Status of fill value in property list
+ *
+ * \return \herr_t
+ *
+ * \details H5Pfill_value_defined() determines whether a fill value is
+ *          defined in the dataset creation property list \p plist. Valid
+ *          values returned in status are as follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>#H5D_FILL_VALUE_UNDEFINED</td>
+ *            <td>Fill value is undefined.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5D_FILL_VALUE_DEFAULT</td>
+ *            <td>Fill value is the library default.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5D_FILL_VALUE_USER_DEFINED</td>
+ *            <td>Fill value is defined by the application.</td>
+ *           </tr>
+ *          </table>
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pfill_value_defined(hid_t plist, H5D_fill_value_t *status);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Retrieves the timing for storage space allocation
+ *
+ * \dcpl_id{plist_id}
+ * \param[out] alloc_time The timing setting for allocating dataset
+ *                        storage space
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_alloc_time() retrieves the timing for allocating storage
+ *          space for a dataset's raw data. This property is set in the
+ *          dataset creation property list \p plist_id. The timing setting
+ *          is returned in \p alloc_time as one of the following values:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>#H5D_ALLOC_TIME_DEFAULT<br />&nbsp;</td>
+ *            <td>Uses the default allocation time, based on the dataset
+ *                storage method. <br />See the \p alloc_time description in
+ *                H5Pset_alloc_time() for default allocation times for
+ *                various storage methods.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5D_ALLOC_TIME_EARLY</td>
+ *            <td>All space is allocated when the dataset is created.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5D_ALLOC_TIME_INCR</td>
+ *            <td>Space is allocated incrementally as data is written
+ *                to the dataset.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5D_ALLOC_TIME_LATE</td>
+ *            <td>All space is allocated when data is first written to
+ *                the dataset.</td>
+ *           </tr>
+ *          </table>
+ *
+ * \note H5Pget_alloc_time() is designed to work in concert with the
+ *       dataset fill value and fill value write time properties, set
+ *       with the functions H5Pget_fill_value() and H5Pget_fill_time().
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pget_alloc_time(hid_t plist_id, H5D_alloc_time_t *alloc_time /*out*/);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Retrieves the size of chunks for the raw data of a chunked
+ *        layout dataset
+ *
+ * \dcpl_id{plist_id}
+ * \param[in]  max_ndims Size of the \p dims array
+ * \param[out] dim Array to store the chunk dimensions
+ *
+ * \return Returns chunk dimensionality if successful;
+ *         otherwise returns a negative value.
+ *
+ * \details H5Pget_chunk() retrieves the size of chunks for the raw data
+ *          of a chunked layout dataset. This function is only valid for
+ *          dataset creation property lists. At most, \p max_ndims elements
+ *          of \p dim will be initialized.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL int H5Pget_chunk(hid_t plist_id, int max_ndims, hsize_t dim[] /*out*/);
+/**
+ *
+ * \ingroup DCPL
+ *
+ * \brief Retrieves the edge chunk option setting from a dataset creation
+ *        property list
+ *
+ * \dcpl_id{plist_id}
+ * \param[out] opts  Edge chunk option flag. Valid values are described in
+ *                   H5Pset_chunk_opts(). The option status can be
+ *                   retrieved using the bitwise AND operator ( & ). For
+ *                   example, the expression
+ *                   (opts&#H5D_CHUNK_DONT_FILTER_PARTIAL_CHUNKS) will
+ *                   evaluate to #H5D_CHUNK_DONT_FILTER_PARTIAL_CHUNKS if
+ *                   that option has been enabled. Otherwise, it will
+ *                   evaluate to 0 (zero).
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_chunk_opts() retrieves the edge chunk option setting
+ *          stored in the dataset creation property list \p plist_id.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Pget_chunk_opts(hid_t plist_id, unsigned *opts);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Retrieves the setting for whether or not to create minimized
+ *        dataset object headers
+ *
+ * \dcpl_id
+ * \param[out] minimize  Flag indicating whether the library will or will
+ *                       not create minimized dataset object headers
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_dset_no_attrs_hint() retrieves the
+ *          <i>no dataset attributes</i> hint setting for the dataset
+ *          creation property list \p dcpl_id. This setting is used to
+ *          inform the library to create minimized dataset object headers
+ *          when true. The setting value is returned in the boolean pointer
+ *          \p minimize.
+ *
+ * \since 1.10.5
+ *
+ */
+H5_DLL herr_t H5Pget_dset_no_attrs_hint(hid_t dcpl_id, hbool_t *minimize);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Returns information about an external file
+ *
+ * \dcpl_id{plist_id}
+ * \param[in]  idx       External file index
+ * \param[in]  name_size Maximum length of \p name array
+ * \param[out] name      Name of the external file
+ * \param[out] offset    Pointer to a location to return an offset value
+ * \param[out] size      Pointer to a location to return the size of the
+ *                       external file data
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_external() returns information about an external file.
+ *          The external file is specified by its index, \p idx, which
+ *          is a number from zero to N-1, where N is the value returned
+ *          by H5Pget_external_count(). At most \p name_size characters
+ *          are copied into the \p name array. If the external file name
+ *          is longer than \p name_size with the null terminator, the
+ *          return value is not null terminated (similar to strncpy()).
+ *
+ *          If \p name_size is zero or \p name is the null pointer, the
+ *          external file name is not returned. If \p offset or \p size
+ *          are null pointers then the corresponding information is not
+ *          returned.
+ *
+ * \note On Windows, off_t is typically a 32-bit signed long value, which
+ *       limits the valid offset that can be returned to 2 GiB.
+ *
+ * \version 1.6.4 \p idx parameter type changed to unsigned.
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pget_external(hid_t plist_id, unsigned idx, size_t name_size, char *name /*out*/,
+                              off_t *offset /*out*/, hsize_t *size /*out*/);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Returns the number of external files for a dataset
+ *
+ * \dcpl_id{plist_id}
+ *
+ * \return Returns the number of external files if successful; otherwise
+ *         returns a negative value.
+ *
+ * \details H5Pget_external_count() returns the number of external files
+ *          for the specified dataset.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL int H5Pget_external_count(hid_t plist_id);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Retrieves the time when fill values are written to a dataset
+ *
+ * \dcpl_id{plist_id}
+ * \param[out] fill_time Setting for the timing of writing fill values to
+ *                       the dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_fill_time() examines the dataset creation property list
+ *          \p plist_id to determine when fill values are to be written to
+ *          a dataset. Valid values returned in \p fill_time are as
+ *          follows:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>#H5D_FILL_TIME_IFSET</td>
+ *            <td>Fill values are written to the dataset when storage
+ *                space is allocated only if there is a user-defined fill
+ *                value, i.e., one set with H5Pset_fill_value(). (Default)
+ *             </td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5D_FILL_TIME_ALLOC</td>
+ *            <td>Fill values are written to the dataset when storage
+ *                space is allocated.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5D_FILL_TIME_NEVER</td>
+ *            <td>Fill values are never written to the dataset.</td>
+ *           </tr>
+ *          </table>
+ *
+ * \note H5Pget_fill_time() is designed to work in coordination with the
+ *       dataset fill value and dataset storage allocation time properties,
+ *       retrieved with the functions H5Pget_fill_value() and
+ *       H5Pget_alloc_time().type == H5FD_MEM_DRAW
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pget_fill_time(hid_t plist_id, H5D_fill_time_t *fill_time /*out*/);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Retrieves a dataset fill value
+ *
+ * \dcpl_id{plist_id}
+ * \param[in]  type_id Datatype identifier for the value passed via
+ *                     \p value
+ * \param[out] value   Pointer to buffer to contain the returned
+ *                     fill value
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_fill_value() returns the dataset fill value defined in
+ *          the dataset creation property list \p plist_id. The fill value
+ *          is returned through the \p value pointer and will be converted
+ *          to the datatype specified  by \p type_id. This datatype may
+ *          differ from the fill value datatype in the property list, but
+ *          the HDF5 library must be able to convert between the two
+ *          datatypes.
+ *
+ *          If the fill value is undefined, i.e., set to NULL in the
+ *          property list, H5Pget_fill_value() will return an error.
+ *          H5Pfill_value_defined() should be used to check for this
+ *          condition before H5Pget_fill_value() is called.
+ *
+ *          Memory must be allocated by the calling application.
+ *
+ * \note H5Pget_fill_value() is designed to coordinate with the dataset
+ *       storage allocation time and fill value write time properties,
+ *       which can be retrieved with the functions H5Pget_alloc_time()
+ *       and H5Pget_fill_time(), respectively.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pget_fill_value(hid_t plist_id, hid_t type_id, void *value /*out*/);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Returns the layout of the raw data for a dataset
+ *
+ * \dcpl_id{plist_id}
+ *
+ * \return Returns the layout type (a non-negative value) of a dataset
+ *         creation property list if successful. Valid return values are:
+ *         - #H5D_COMPACT: Raw data is stored in the object header in the
+ *                        file.
+ *         - #H5D_CONTIGUOUS: Raw data is stored separately from the object
+ *                           header in one contiguous chunk in the file.
+ *         - #H5D_CHUNKED: Raw data is stored separately from the object
+ *                        header in chunks in separate locations in the
+ *                        file.
+ *         - #H5D_VIRTUAL: Raw data is drawn from multiple datasets in
+ *                        different files.
+ * \return
+ *         Otherwise, returns a negative value indicating failure.
+ *
+ * \details H5Pget_layout() returns the layout of the raw data for a
+ *          dataset. This function is only valid for dataset creation
+ *          property lists.
+ *
+ *          Note that a compact storage layout may affect writing data to
+ *          the dataset with parallel applications. See the H5Dwrite()
+ *          documentation for details.
+ *
+ * \version 1.10.0 #H5D_VIRTUAL added in this release.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL H5D_layout_t H5Pget_layout(hid_t plist_id);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Gets the number of mappings for the virtual dataset
+ *
+ * \dcpl_id
+ * \param[out] count The number of mappings
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_virtual_count() gets the number of mappings for a
+ *          virtual dataset that has the creation property list specified
+ *          by \p dcpl_id.
+ *
+ * \see_virtual
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Pget_virtual_count(hid_t dcpl_id, size_t *count /*out*/);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Gets the name of a source dataset used in the mapping
+ *
+ * \dcpl_id
+ * \param[in]  index Mapping index. The value of \p index is 0 (zero) or
+ *                   greater and less than \p count
+ *                   (0  \p index < \p count), where \p count is the
+ *                   number of mappings returned by H5Pget_virtual_count().
+ * \param[out] name  A buffer containing the name of the source dataset
+ * \param[in]  size  The size, in bytes, of the name buffer. Must be the
+ *                   size of the dataset name in bytes plus 1 for a NULL
+ *                   terminator
+ *
+ * \return Returns the length of the dataset name if successful;
+ *         otherwise returns a negative value.
+ *
+ * \details H5Pget_virtual_dsetname() takes the dataset creation property
+ *          list for the virtual dataset, \p dcpl_id, the mapping index,
+ *          \p index, the size of the dataset name for a source dataset,
+ *          \p size, and retrieves the name of the source dataset used in
+ *          the mapping.
+ *
+ *          Up to \p size characters of the dataset name are returned in
+ *          \p name; additional characters, if any, are not returned to
+ *          the user application.
+ *
+ *          If the length of the dataset name, which determines the
+ *          required value of \p size, is unknown, a preliminary call
+ *          to H5Pget_virtual_dsetname() with the last two parameters
+ *          set to NULL and zero respectively can be made. The return
+ *          value of this call will be the size in bytes of the dataset
+ *          name. That value, plus 1 for a NULL terminator, must then be
+ *          assigned to \p size for a second H5Pget_virtual_dsetname()
+ *          call, which will retrieve the actual dataset name.
+ *
+ * \see_virtual
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL ssize_t H5Pget_virtual_dsetname(hid_t dcpl_id, size_t index, char *name /*out*/, size_t size);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Gets the filename of a source dataset used in the mapping
+ *
+ * \dcpl_id
+ * \param[in]  index Mapping index. The value of \p index is 0 (zero) or
+ *                   greater and less than \p count
+ *                   (0  \p index < \p count), where \p count is the
+ *                   number of mappings returned by H5Pget_virtual_count().
+ * \param[out] name  A buffer containing the name of the file containing
+ *                   the source dataset
+ * \param[in]  size  The size, in bytes, of the name buffer. Must be the
+ *                   size of the filename in bytes plus 1 for a NULL
+ *                   terminator
+ *
+ * \return Returns the length of the filename if successful; otherwise
+ *         returns a negative value.
+ *
+ * \details H5Pget_virtual_filename() takes the dataset creation property
+ *          list for the virtual dataset, \p dcpl_id, the mapping index,
+ *          \p index, the size of the filename for a source dataset,
+ *          \p size, and retrieves the name of the file for a source dataset
+ *          used in the mapping.
+ *
+ *          Up to \p size characters of the filename are returned in
+ *          \p name; additional characters, if any, are not returned to
+ *          the user application.
+ *
+ *          If the length of the filename, which determines the required
+ *          value of \p size, is unknown, a preliminary call to
+ *          H5Pget_virtual_filename() with the last two parameters set
+ *          to NULL and zero respectively can be made. The return value
+ *          of this call will be the size in bytes of the filename. That
+ *          value, plus 1 for a NULL terminator, must then be assigned to
+ *          \p size for a second H5Pget_virtual_filename() call, which
+ *          will retrieve the actual filename.
+ *
+ * \see_virtual
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL ssize_t H5Pget_virtual_filename(hid_t dcpl_id, size_t index, char *name /*out*/, size_t size);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Gets a dataspace identifier for the selection within the source
+ *        dataset used in the mapping
+ *
+ * \dcpl_id
+ * \param[in] index Mapping index. The value of \p index is 0 (zero) or
+ *                  greater and less than \p count
+ *                  (0  \p index < \p count), where \p count is the number
+ *                  of mappings returned by H5Pget_virtual_count().
+ *
+ * \return \hid_t{valid dataspace identifier}
+ *
+ * \details H5Pget_virtual_srcspace() takes the dataset creation property
+ *          list for the virtual dataset, \p dcpl_id, and the mapping
+ *          index, \p index, and returns a dataspace identifier for the
+ *          selection within the source dataset used in the mapping.
+ *
+ * \see_virtual
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL hid_t H5Pget_virtual_srcspace(hid_t dcpl_id, size_t index);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Gets a dataspace identifier for the selection within the virtual
+ *        dataset used in the mapping
+ *
+ * \dcpl_id
+ * \param[in] index Mapping index. The value of \p index is 0 (zero) or
+ *                  greater and less than \p count
+ *                  (0  \p index < \p count), where \p count is the number
+ *                  of mappings returned by H5Pget_virtual_count()
+ *
+ * \return \hid_t{valid dataspace identifier}
+ *
+ * \details H5Pget_virtual_vspace() takes the dataset creation property
+ *          list for the virtual dataset, \p dcpl_id, and the mapping
+ *          index, \p index, and returns a dataspace identifier for the
+ *          selection within the virtual dataset used in the mapping.
+ *
+ * \see_virtual
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL hid_t H5Pget_virtual_vspace(hid_t dcpl_id, size_t index);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Sets the timing for storage space allocation
+ *
+ * \dcpl_id{plist_id}
+ * \param[in] alloc_time When to allocate dataset storage space
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_alloc_time() sets up the timing for the allocation of
+ *          storage space for a dataset's raw data. This property is set
+ *          in the dataset creation property list \p plist_id. Timing is
+ *          specified in \p alloc_time with one of the following values:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>#H5D_ALLOC_TIME_DEFAULT</td>
+ *            <td>Allocate dataset storage space at the default time<br />
+ *                (Defaults differ by storage method.)</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5D_ALLOC_TIME_EARLY</td>
+ *            <td>Allocate all space when the dataset is created<br />
+ *            (Default for compact datasets.)</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5D_ALLOC_TIME_INCR</td>
+ *            <td>Allocate space incrementally, as data is written to
+ *                the dataset<br />(Default for chunked storage datasets.)
+ *
+ *                \li Chunked datasets: Storage space allocation for each
+ *                    chunk is deferred until data is written to the chunk.
+ *                \li Contiguous datasets: Incremental storage space
+ *                    allocation for contiguous data is treated as late
+ *                    allocation.
+ *                \li Compact datasets: Incremental allocation is not
+ *                    allowed with compact datasets; H5Pset_alloc_time()
+ *                    will return an error.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5D_ALLOC_TIME_LATE</td>
+ *            <td>Allocate all space when data is first written to the
+ *                dataset<br />
+ *                (Default for contiguous datasets.)</td>
+ *           </tr>
+ *          </table>
+ *
+ * \note H5Pset_alloc_time() is designed to work in concert with the
+ *       dataset fill value and fill value write time properties, set
+ *       with the functions H5Pset_fill_value() and H5Pset_fill_time().
+ *
+ * \note See H5Dcreate() for further cross-references.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pset_alloc_time(hid_t plist_id, H5D_alloc_time_t alloc_time);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Sets the size of the chunks used to store a chunked layout
+ *        dataset
+ *
+ * \dcpl_id{plist_id}
+ * \param[in] ndims  The number of dimensions of each chunk
+ * \param[in] dim    An array defining the size, in dataset elements, of
+ *                   each chunk
+ *
+ * \return \herr_t
+ * \details H5Pset_chunk() sets the size of the chunks used to store a
+ *          chunked layout dataset. This function is only valid for dataset
+ *          creation property lists.
+ *
+ *          The \p ndims parameter currently must be the same size as the
+ *          rank of the dataset.
+ *
+ *          The values of the \p dim array define the size of the chunks
+ *          to store the dataset's raw data. The unit of measure for \p dim
+ *          values is dataset elements.
+ *
+ *          As a side-effect of this function, the layout of the dataset is
+ *          changed to #H5D_CHUNKED, if it is not already so set.
+ *
+ * \note Chunk size cannot exceed the size of a fixed-size dataset. For
+ *       example, a dataset consisting of a 5x4 fixed-size array cannot be
+ *       defined with 10x10 chunks. Chunk maximums:
+ *       - The maximum number of elements in a chunk is 2<sup>32</sup>-1 which
+ *         is equal to 4,294,967,295. If the number of elements in a chunk is
+ *         set via H5Pset_chunk() to a value greater than 2<sup>32</sup>-1,
+ *         then H5Pset_chunk() will fail.
+ *       - The maximum size for any chunk is 4GB. If a chunk that is larger
+ *         than 4GB attempts to be written with H5Dwrite(), then H5Dwrite()
+ *         will fail.
+ *
+ * \see H5Pset_layout(), H5Dwrite()
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pset_chunk(hid_t plist_id, int ndims, const hsize_t dim[/*ndims*/]);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Sets the edge chunk option in a dataset creation property list
+ *
+ * \dcpl_id{plist_id}
+ * \param[in] opts Edge chunk option flag. Valid values are:
+ *                 \li #H5D_CHUNK_DONT_FILTER_PARTIAL_CHUNKS
+ *                     When enabled, filters are not applied to partial
+ *                     edge chunks. When disabled, partial edge chunks are
+ *                     filtered. Enabling this option will improve
+ *                     performance when appending to the dataset and, when
+ *                     compression filters are used, prevent reallocation
+ *                     of these chunks. Datasets created with this option
+ *                     enabled will be inaccessible with HDF5 library
+ *                     versions before Release 1.10. Default: \e Disabled
+ *                 \li 0 (zero) Disables option; partial edge chunks
+ *                     will be compressed.
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_chunk_opts() sets the edge chunk option in the
+ *          dataset creation property list \p dcpl_id.
+ *
+ *          The available option is detailed in the parameters section.
+ *          Only chunks that are not completely filled by the dataset's
+ *          dataspace are affected by this option. Such chunks are
+ *          referred to as partial edge chunks.
+ *
+ *      \b Motivation: H5Pset_chunk_opts() is used to specify storage
+ *       options for chunks on the edge of a dataset's dataspace. This
+ *       capability allows the user to tune performance in cases where
+ *       the dataset size may not be a multiple of the chunk size and
+ *       the handling of partial edge chunks can impact performance.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Pset_chunk_opts(hid_t plist_id, unsigned opts);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Sets the flag to create minimized dataset object headers
+ *
+ * \dcpl_id
+ * \param[in] minimize Flag for indicating whether or not a dataset's
+ *                     object header will be minimized
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_dset_no_attrs_hint() sets the no dataset attributes
+ *          hint setting for the dataset creation property list \p dcpl_id.
+ *          Datasets created with the dataset creation property list
+ *          \p dcpl_id will have their object headers minimized if the
+ *          boolean flag \p minimize is set to true. By setting \p minimize
+ *          to true, the library expects that no attributes will be added
+ *          to the dataset. Attributes can be added, but they are appended
+ *          with a continuation message, which can reduce performance.
+ *
+ *          This setting interacts with H5Fset_dset_no_attrs_hint(): if
+ *          either is set to true, then the created dataset's object header
+ *          will be minimized.
+ *
+ * \since 1.10.5
+ *
+ */
+H5_DLL herr_t H5Pset_dset_no_attrs_hint(hid_t dcpl_id, hbool_t minimize);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Adds an external file to the list of external files
+ *
+ * \dcpl_id{plist_id}
+ * \param[in] name   Name of an external file
+ * \param[in] offset Offset, in bytes, from the beginning of the file to
+ *                   the location in the file where the data starts
+ * \param[in] size   Number of bytes reserved in the file for the data
+ *
+ * \return \herr_t
+ *
+ * \details The first call to H5Pset_external() sets the external
+ *          storage property in the property list, thus designating that
+ *          the dataset will be stored in one or more non-HDF5 file(s)
+ *          external to the HDF5 file. This call also adds the file
+ *          \p name as the first file in the list of external files.
+ *          Subsequent calls to the function add the named file as the
+ *          next file in the list.
+ *
+ *          If a dataset is split across multiple files, then the files
+ *          should be defined in order. The total size of the dataset is
+ *          the sum of the \p size arguments for all the external files.
+ *          If the total size is larger than the size of a dataset then
+ *          the dataset can be extended (provided the data space also
+ *          allows the extending).
+ *
+ *         The \p size argument specifies the number of bytes reserved
+ *         for data in the external file. If \p size is set to
+ *         #H5F_UNLIMITED, the external file can be of unlimited size
+ *         and no more files can be added to the external files list.
+ *         If \p size is set to 0 (zero), no external file will actually
+ *         be created.
+ *
+ *         All of the external files for a given dataset must be specified
+ *         with H5Pset_external() before H5Dcreate() is called to create
+ *         the dataset. If one these files does not exist on the system
+ *         when H5Dwrite() is called to write data to it, the library
+ *         will create the file.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pset_external(hid_t plist_id, const char *name, off_t offset, hsize_t size);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Sets the time when fill values are written to a dataset
+ *
+ * \dcpl_id{plist_id}
+ * \param[in] fill_time When to write fill values to a dataset
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_fill_time() sets up the timing for writing fill values
+ *          to a dataset. This property is set in the dataset creation
+ *          property list \p plist_id. Timing is specified in \p fill_time
+ *          with one of the following values:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>#H5D_FILL_TIME_IFSET</td>
+ *            <td>Write fill values to the dataset when storage space is
+ *                allocated only if there is a user-defined fill value,
+ *                i.e.,one set with H5Pset_fill_value(). (Default)</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5D_FILL_TIME_ALLOC</td>
+ *            <td>Write fill values to the dataset when storage space is
+ *                allocated.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5D_FILL_TIME_NEVER</td>
+ *            <td>Never write fill values to the dataset.</td>
+ *           </tr>
+ *          </table>
+ *
+ * \note H5Pset_fill_time() is designed for coordination with the dataset
+ *      fill value and dataset storage allocation time properties, set
+ *      with the functions H5Pset_fill_value() and H5Pset_alloc_time().
+ *      See H5Dcreate() for further cross-references.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pset_fill_time(hid_t plist_id, H5D_fill_time_t fill_time);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Sets the fill value for a dataset
+ *
+ * \dcpl_id{plist_id}
+ * \param[in] type_id Datatype of \p value
+ * \param[in] value Pointer to buffer containing value to use as
+ *            fill value
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_fill_value() sets the fill value for a dataset in the
+ *          dataset creation property list. \p value is interpreted as
+ *          being of datatype \p type_id. This datatype may differ from
+ *          that of the dataset, but the HDF5 library must be able to
+ *          convert \p value to the dataset datatype when the dataset is
+ *          created.
+ *
+ *          The default fill value is 0 (zero), which is interpreted
+ *          according to the actual dataset datatype.
+ *
+ *          Setting \p value to NULL indicates that the fill value is to
+ *          be undefined.
+ *
+ * \note Applications sometimes write data only to portions of an allocated
+ *       dataset. It is often useful in such cases to fill the unused space
+ *       with a known fill value. This function allows the user application
+ *       to set that fill value; the functions H5Dfill() and
+ *       H5Pset_fill_time(), respectively, provide the ability to apply the
+ *       fill value on demand or to set up its automatic application.
+ *
+ * \note A fill value should be defined so that it is appropriate for the
+ *       application. While the HDF5 default fill value is 0 (zero), it is
+ *       often appropriate to use another value. It might be useful, for
+ *       example, to use a value that is known to be impossible for the
+ *       application to legitimately generate.
+ *
+ * \note H5Pset_fill_value() is designed to work in concert with
+ *       H5Pset_alloc_time() and H5Pset_fill_time(). H5Pset_alloc_time()
+ *       and H5Pset_fill_time() govern the timing of dataset storage
+ *       allocation and fill value write operations and can be important in
+ *       tuning application performance.
+ *
+ * \note See H5Dcreate() for further cross-references.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pset_fill_value(hid_t plist_id, hid_t type_id, const void *value);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Sets up use of the shuffle filter
+ *
+ * \dcpl_id{plist_id}
+ *
+ * \return \herr_t
+ *
+ * \par_compr_note
+ *
+ * \details H5Pset_shuffle() sets the shuffle filter, #H5Z_FILTER_SHUFFLE,
+ *          in the dataset creation property list \p plist_id. The shuffle
+ *          filter de-interlaces a block of data by reordering the bytes.
+ *          All the bytes from one consistent byte position of each data
+ *          element are placed together in one block; all bytes from a
+ *          second consistent byte position of each data element are placed
+ *          together a second block; etc. For example, given three data
+ *          elements of a 4-byte datatype stored as 012301230123, shuffling
+ *          will re-order data as 000111222333. This can be a valuable step
+ *          in an effective compression algorithm because the bytes in each
+ *          byte position are often closely related to each other and
+ *          putting them together can increase the compression ratio.
+ *
+ *          As implied above, the primary value of the shuffle filter lies
+ *          in its coordinated use with a compression filter; it does not
+ *          provide data compression when used alone. When the shuffle
+ *          filter is applied to a dataset immediately prior to the use of
+ *          a compression filter, the compression ratio achieved is often
+ *          superior to that achieved by the use of a compression filter
+ *          without the shuffle filter.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pset_shuffle(hid_t plist_id);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Sets the type of storage used to store the raw data for a dataset
+ *
+ * \dcpl_id{plist_id}
+ * \param[in] layout Type of storage layout for raw data
+ *
+ * \return \herr_t
+ * \details H5Pset_layout() sets the type of storage used to store the raw
+ *          data for a dataset. This function is only valid for dataset
+ *          creation property lists.
+ *
+ *          Valid values for \p layout are:
+ *           - #H5D_COMPACT: Store raw data in the dataset object header
+ *                           in file. This should only be used for datasets
+ *                           with small amounts of raw data. The raw data
+ *                           size limit is 64K (65520 bytes). Attempting
+ *                           to create a dataset with raw data larger than
+ *                           this limit will cause the H5Dcreate() call to
+ *                           fail.
+ *           - #H5D_CONTIGUOUS: Store raw data separately from the object
+ *                              header in one large chunk in the file.
+ *           - #H5D_CHUNKED: Store raw data separately from the object header
+ *                           as chunks of data in separate locations in
+ *                           the file.
+ *           - #H5D_VIRTUAL: Draw raw data from multiple datasets in
+ *                           different files.
+ *
+ *          Note that a compact storage layout may affect writing data to
+ *          the dataset with parallel applications. See the note in
+ *          H5Dwrite() documentation for details.
+ * \version 1.10.0 #H5D_VIRTUAL added in this release.
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pset_layout(hid_t plist_id, H5D_layout_t layout);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Sets up the use of the N-Bit filter
+ *
+ * \dcpl_id{plist_id}
+ *
+ * \return \herr_t
+ *
+ * \par_compr_note
+ *
+ * \details H5Pset_nbit() sets the N-Bit filter, #H5Z_FILTER_NBIT, in the
+ *          dataset creation property list \p plist_id.
+ *
+ *          The HDF5 user can create an N-Bit datatype with the following
+ *          code:
+ *          <pre>
+ *          hid_t nbit_datatype = H5Tcopy(H5T_STD_I32LE);
+ *          H5Tset_precision(nbit_datatype, 16);
+ *          H5Tset_offset(nbit_datatype, 4);
+ *          </pre>
+ *
+ *          In memory, one value of the N-Bit datatype in the above example
+ *          will be stored on a little-endian machine as follows:
+ *
+ *          <table>
+ *          <tr>
+ *            <td>byte 3</td>
+ *            <td>byte 2</td>
+ *            <td>byte 1</td>
+ *            <td>byte 0</td>
+ *          </tr>
+ *          <tr>
+ *            <td> ???????? </td>
+ *            <td> ????SPPP </td>
+ *            <td> PPPPPPPP </td>
+ *            <td> PPPP???? </td>
+ *          </tr>
+ *          </table>
+ *          Note: S - sign bit, P - significant bit, ? - padding bit; For
+ *          signed integer, the sign bit is included in the precision.
+ *
+ *          When data of the above datatype is stored on disk using the
+ *          N-bit filter, all padding bits are chopped off and only
+ *          significant bits are stored. The values on disk will be
+ *          something like:
+ *
+ *          <table>
+ *          <tr>
+ *           <td>1st value</td>
+ *           <td>2nd value</td>
+ *           <td>...</td>
+ *          </tr>
+ *          <tr>
+ *           <td>SPPPPPPPPPPPPPPP</td>
+ *           <td>SPPPPPPPPPPPPPPP</td>
+ *           <td>...</td>
+ *          </tr>
+ *          </table>
+ *          The N-Bit filter is used effectively for compressing data of
+ *          an N-Bit datatype as well as a compound and an array
+ *          datatype with N-Bit fields. However, the datatype classes of
+ *          the N-Bit datatype or the N-Bit field of the compound
+ *          datatype or the array datatype are limited to integer or
+ *          floating-point.
+ *
+ *          The N-Bit filter supports complex situations where a compound
+ *          datatype contains member(s) of a compound datatype or an array
+ *          datatype that has a compound datatype as the base type.
+ *          However, it does not support the situation where an array
+ *          datatype has a variable-length or variable-length string as
+ *          its base datatype. The filter does support the situation where
+ *          a variable-length or variable-length string is a member of a
+ *          compound datatype.
+ *
+ *          The N-Bit filter allows all other HDF5 datatypes (such as
+ *          time, string, bitfield, opaque, reference, enum, and variable
+ *          length) to pass through as a no-op.
+ *
+ *          Like other I/O filters supported by the HDF5 library,
+ *          application using the N-Bit filter must store data with
+ *          chunked storage.
+ *
+ *          By nature, the N-Bit filter should not be used together with
+ *          other I/O filters.
+ *
+ * \version 1.8.8 Fortran subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_nbit(hid_t plist_id);
+/**
+ * \ingroup DCPL
+ *
+ * \brief  Sets up the use of the scale-offset filter
+ *
+ * \dcpl_id{plist_id}
+ * \param[in] scale_type   Flag indicating compression method
+ * \param[in] scale_factor Parameter related to scale. Must be
+ *                         non-negative
+ *
+ * \return \herr_t
+ *
+ * \par_compr_note
+ *
+ * \details H5Pset_scaleoffset() sets the scale-offset filter,
+ *          #H5Z_FILTER_SCALEOFFSET, for a dataset.
+ *
+ *          Generally speaking, scale-offset compression performs a scale and/or
+ *          offset operation on each data value and truncates the resulting
+ *          value to a minimum number of bits (MinBits) before storing it. The
+ *          current scale-offset filter supports integer and floating-point
+ *          datatypes.
+ *
+ *          For an integer datatype, the parameter \p scale_type should be set
+ *          to #H5Z_SO_INT (2). The parameter \p scale_factor denotes MinBits.
+ *          If the user sets it to H5Z_SO_INT_MINBITS_DEFAULT (0), the filter
+ *          will calculate MinBits. If \p scale_factor is set to a positive
+ *          integer, the filter does not do any calculation and just uses the
+ *          number as MinBits. However, if the user gives a MinBits that is less
+ *          than what would be generated by the filter, the compression will be
+ *          lossy. Also, the MinBits supplied by the user cannot exceed the
+ *          number of bits to store one value of the dataset datatype.
+ *
+ *          For a floating-point datatype, the filter adopts the GRiB data
+ *          packing mechanism, which offers two alternate methods: E-scaling and
+ *          D-scaling. Both methods are lossy compression. If the parameter
+ *          \p scale_type is set to #H5Z_SO_FLOAT_DSCALE (0), the filter will
+ *          use the D-scaling method; if it is set to #H5Z_SO_FLOAT_ESCALE (1),
+ *          the filter will use the E-scaling method. Since only the D-scaling
+ *          method is implemented, \p scale_type should be set to
+ *          #H5Z_SO_FLOAT_DSCALE or 0.
+ *
+ *          When the D-scaling method is used, the original data is "D" scaled
+ *           multiplied by 10 to the power of \p scale_factor, and the
+ *          "significant" part of the value is moved to the left of the decimal
+ *          point. Care should be taken in setting the decimal \p scale_factor
+ *          so that the integer part will have enough precision to contain the
+ *          appropriate information of the data value. For example, if
+ *          \p scale_factor is set to 2, the number 104.561 will be 10456.1
+ *          after "D" scaling. The last digit 1 is not "significant" and is
+ *          thrown off in the process of rounding. The user should make sure that
+ *          after "D" scaling and rounding, the data values are within the range
+ *          that can be represented by the integer (same size as the
+ *          floating-point type).
+ *
+ *          Valid values for scale_type are as follows:
+ *
+ *          <table>
+ *          <tr>
+ *            <td>#H5Z_SO_FLOAT_DSCALE (0)</td>
+ *            <td>Floating-point type, using variable MinBits method</td>
+ *          </tr>
+ *          <tr>
+ *            <td>#H5Z_SO_FLOAT_ESCALE (1)</td>
+ *            <td>Floating-point type, using fixed MinBits method</td>
+ *          </tr>
+ *          <tr>
+ *            <td>#H5Z_SO_INT (2)</td>
+ *            <td>Integer type</td>
+ *          </tr>
+ *          </table>
+ *
+ *          The meaning of \p scale_factor varies according to the value
+ *          assigned to \p scale_type:
+ *
+ *          <table>
+ *          <tr>
+ *            <th>\p scale_type value</th>
+ *            <th>\p scale_factor description</th>
+ *          </tr>
+ *          <tr>
+ *            <td>#H5Z_SO_FLOAT_DSCALE</td>
+ *            <td>Denotes the decimal scale factor for D-scaling and can be
+ *                positive, negative or zero. This is the current
+ *                implementation of the library.</td>
+ *          </tr>
+ *          <tr>
+ *            <td>#H5Z_SO_FLOAT_ESCALE</td>
+ *            <td>Denotes MinBits for E-scaling and must be a positive integer.
+ *                This is not currently implemented by the library.</td>
+ *          </tr>
+ *          <tr>
+ *            <td>#H5Z_SO_INT</td>
+ *            <td>Denotes MinBits and it should be a positive integer or
+ *                #H5Z_SO_INT_MINBITS_DEFAULT (0). If it is less than 0, the
+ *                library will reset it to 0 since it is not implemented.
+ *            </td>
+ *          </tr>
+ *          </table>
+ *          Like other I/O filters supported by the HDF5 library, an
+ *          application using the scale-offset filter must store data with
+ *          chunked storage.
+ *
+ * \version 1.8.8 Fortran90 subroutine introduced in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_scaleoffset(hid_t plist_id, H5Z_SO_scale_type_t scale_type, int scale_factor);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Sets up use of the SZIP compression filter
+ *
+ * \dcpl_id{plist_id}
+ * \param[in] options_mask A bit-mask conveying the desired SZIP options;
+ *                         Valid values are #H5_SZIP_EC_OPTION_MASK and
+ *                         #H5_SZIP_NN_OPTION_MASK.
+ * \param[in] pixels_per_block The number of pixels or data elements in each
+ *            data block
+ *
+ * \return \herr_t
+ *
+ * \par_compr_note
+ *
+ * \details H5Pset_szip() sets an SZIP compression filter, #H5Z_FILTER_SZIP,
+ *          for a dataset. SZIP is a compression method designed for use with
+ *          scientific data.
+ *
+ *          Before proceeding, all users should review the Limitations
+ *          section below.
+ *
+ *          Users familiar with SZIP outside the HDF5 context may benefit
+ *          from reviewing the Note For Users Familiar with SZIP in Other
+ *          Contexts below.
+ *
+ *          In the text below, the term pixel refers to an HDF5 data element.
+ *          This terminology derives from SZIP compression's use with image
+ *          data, where pixel referred to an image pixel.
+ *
+ *          The SZIP \p bits_per_pixel value (see Note, below) is automatically
+ *          set, based on the HDF5 datatype. SZIP can be used with atomic
+ *          datatypes that may have size of 8, 16, 32, or 64 bits.
+ *          Specifically, a dataset with a datatype that is 8-, 16-, 32-, or
+ *          64-bit signed or unsigned integer; char; or 32- or 64-bit float
+ *          can be compressed with SZIP. See Note, below, for further
+ *          discussion of the SZIP \p bits_per_pixel setting.
+ *
+ *          SZIP options are passed in an options mask, \p options_mask,
+ *          as follows.
+ *
+ *          <table>
+ *            <tr>
+ *             <th>Option</th>
+ *             <th>Description (Mutually exclusive; select one.)</th>
+ *            </tr>
+ *            <tr>
+ *             <td>#H5_SZIP_EC_OPTION_MASK</td>
+ *             <td>Selects entropy coding method</td>
+ *            </tr>
+ *            <tr>
+ *             <td>#H5_SZIP_NN_OPTION_MASK</td>
+ *             <td>Selects nearest neighbor coding method</td>
+ *            </tr>
+ *           </table>
+ *
+ *           The following guidelines can be used in determining which
+ *           option to select:
+ *
+ *           - The entropy coding method, the EC option specified by
+ *             #H5_SZIP_EC_OPTION_MASK, is best suited for data that has been
+ *             processed. The EC method works best for small numbers.
+ *           - The nearest neighbor coding method, the NN option specified
+ *             by #H5_SZIP_NN_OPTION_MASK, preprocesses the data then the
+ *             applies EC method as above.
+ *
+ *           Other factors may affect results, but the above criteria
+ *           provides a good starting point for optimizing data compression.
+ *
+ *           SZIP compresses data block by block, with a user-tunable block
+ *           size. This block size is passed in the parameter
+ *           \p pixels_per_block and must be even and not greater than 32,
+ *           with typical values being 8, 10, 16, or 32. This parameter
+ *           affects compression ratio; the more pixel values vary, the
+ *           smaller this number should be to achieve better performance.
+ *
+ *           In HDF5, compression can be applied only to chunked datasets.
+ *           If \p pixels_per_block is bigger than the total number of
+ *           elements in a dataset chunk, H5Pset_szip() will succeed but
+ *           the subsequent call to H5Dcreate() will fail; the conflict
+ *           can be detected only when the property list is used.
+ *
+ *           To achieve optimal performance for SZIP compression, it is
+ *           recommended that a chunk's fastest-changing dimension be equal
+ *           to N times \p pixels_per_block where N is the maximum number of
+ *           blocks per scan line allowed by the SZIP library. In the
+ *           current version of SZIP, N is set to 128.
+ *
+ *           SZIP compression is an optional HDF5 filter.
+ *
+ *           \b Limitations:
+ *
+ *           - SZIP compression cannot be applied to compound, array,
+ *             variable-length, enumeration, or any other user-defined
+ *             datatypes. If an SZIP filter is set in a dataset creation
+ *             property list used to create a dataset containing a
+ *             non-allowed datatype, the call to H5Dcreate() will fail; the
+ *             conflict can be detected only when the property list is used.
+ *           - Users should be aware that there are factors that affect one's
+ *             rights and ability to use SZIP compression by reviewing the
+ *             SZIP copyright notice.
+ *
+ * \note \b For \b Users \b Familiar \b with \b SZIP \b in \b Other \b Contexts:
+ *
+ * \note  The following notes are of interest primarily to those who have
+ *        used SZIP compression outside of the HDF5 context.
+ *        In non-HDF5 applications, SZIP typically requires that the user
+ *        application supply additional parameters:
+ *        - \p pixels_in_object, the number of pixels in the object to
+ *          be compressed
+ *        - \p bits_per_pixel, the number of bits per pixel
+ *        - \p pixels_per_scanline, the number of pixels per scan line
+ *
+ * \note  These values need not be independently supplied in the HDF5
+ *        environment as they are derived from the datatype and dataspace,
+ *        which are already known. In particular, HDF5 sets
+ *        \p pixels_in_object to the number of elements in a chunk and
+ *        \p bits_per_pixel to the size of the element or pixel datatype.
+ *
+ * \note  The following algorithm is used to set \p pixels_per_scanline:
+ *        - If the size of a chunk's fastest-changing dimension, size,
+ *          is greater than 4K, set \p pixels_per_scanline to 128 times
+ *          \p pixels_per_block.
+ *        - If size is less than 4K but greater than \p pixels_per_block,
+ *          set \p pixels_per_scanline to the minimum of size and 128
+ *          times \p pixels_per_block.
+ *        - If size is less than \p pixels_per_block but greater than the
+ *          number elements in the chunk, set \p pixels_per_scanline to
+ *          the minimum of the number elements in the chunk and 128 times
+ *          \p pixels_per_block.
+ *
+ * \note  The HDF5 datatype may have precision that is less than the full
+ *        size of the data element, e.g., an 11-bit integer can be defined
+ *        using H5Tset_precision(). To a certain extent, SZIP can take
+ *        advantage of the precision of the datatype to improve compression:
+ *        - If the HDF5 datatype size is 24-bit or less and the offset of
+ *          the bits in the HDF5 datatype is zero (see H5Tset_offset() or
+ *          H5Tget_offset()), the data is the in lowest N bits of the data
+ *          element. In this case, the SZIP \p bits_per_pixel is set to the
+ *          precision of the HDF5 datatype.
+ *        - If the offset is not zero, the SZIP \p bits_per_pixel will be
+ *          set to the number of bits in the full size of the data element.
+ *        - If the HDF5 datatype precision is 25-bit to 32-bit, the SZIP
+ *          \p bits_per_pixel will be set to 32.
+ *        - If the HDF5 datatype precision is 33-bit to 64-bit, the SZIP
+ *          \p bits_per_pixel will be set to 64.
+ *
+ * \note HDF5 always modifies the options mask provided by the user to set up
+ *       usage of RAW_OPTION_MASK, ALLOW_K13_OPTION_MASK, and one of
+ *       LSB_OPTION_MASK or MSB_OPTION_MASK, depending on endianness of the
+ *       datatype.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pset_szip(hid_t plist_id, unsigned options_mask, unsigned pixels_per_block);
+
+/**
+ * \ingroup DCPL
+ *
+ * \brief Sets the mapping between virtual and source datasets
+ *
+ * \dcpl_id
+ * \param[in] vspace_id The dataspace identifier with the selection within the
+ *            virtual dataset applied, possibly an unlimited selection
+ * \param[in] src_file_name The name of the HDF5 file where the source dataset is
+ *            located or a \Code{"."} (period) for a source dataset in the same
+ *            file. The file might not exist yet. The name can be specified using
+ *            a C-style \c printf statement as described below.
+ * \param[in] src_dset_name The path to the HDF5 dataset in the file specified by
+ *            \p src_file_name. The dataset might not exist yet. The dataset name
+ *            can be specified using a C-style \c printf statement as described below.
+ * \param[in] src_space_id The source dataset's dataspace identifier with a
+ *            selection applied, possibly an unlimited selection
+ * \return \herr_t
+ *
+ * \details H5Pset_virtual() maps elements of the virtual dataset (VDS)
+ *          described by the virtual dataspace identifier \p vspace_id to the
+ *          elements of the source dataset described by the source dataset
+ *          dataspace identifier \p src_space_id. The source dataset is
+ *          identified by the name of the file where it is located,
+ *          \p src_file_name, and the name of the dataset, \p src_dset_name.
+ *
+ * \par C-style \c printf Formatting Statements:
+ *      C-style \c printf formatting allows a pattern to be specified in the name
+ *      of a source file or dataset. Strings for the file and dataset names are
+ *      treated as literals except for the following substitutions:
+ *      <table>
+ *      <tr>
+ *      <td>\Code{"%%"}</td>
+ *      <td>Replaced with a single \Code{"%"} (percent) character.</td>
+ *      </tr>
+ *      <tr>
+ *      <td><code>"%<d>b"</code></td>
+ *      <td>Where <code>"<d>"</code> is the virtual dataset dimension axis (0-based)
+ *          and \Code{"b"} indicates that the block count of the selection in that
+ *          dimension should be used. The full expression (for example, \Code{"%0b"})
+ *          is replaced with a single numeric value when the mapping is evaluated at
+ *          VDS access time. Example code for many source and virtual dataset mappings
+ *          is available in the "Examples of Source to Virtual Dataset Mapping"
+ *          chapter in the
+ *          <a href="https://portal.hdfgroup.org/display/HDF5/RFC+HDF5+Virtual+Dataset">
+ *            RFC: HDF5 Virtual Dataset</a>.
+ *      </td>
+ *      </tr>
+ *      </table>
+ *      If the printf form is used for the source file or dataset names, the
+ *      selection in the source dataset's dataspace must be fixed-size.
+ *
+ * \par Source File Resolutions:
+ *      When a source dataset residing in a different file is accessed, the
+ *      library will search for the source file \p src_file_name as described
+ *      below:
+ *      \li If \p src_file_name is a \Code{"."} (period) then it refers to the
+ *          file containing the virtual dataset.
+ *      \li If \p src_file_name is a relative pathname, the following steps are
+ *          performed:
+ *          - The library will get the prefix(es) set in the environment
+ *            variable \c HDF5_VDS_PREFIX and will try to prepend each prefix
+ *            to \p src_file_name to form a new \p src_file_name. If the new
+ *            \p src_file_name does not exist or if \c HDF5_VDS_PREFIX is not
+ *            set, the library will get the prefix set via H5Pset_virtual_prefix()
+ *            and prepend it to \p src_file_name to form a new \p src_file_name.
+ *            If the new \p src_file_name does not exist or no prefix is being
+ *            set by H5Pset_virtual_prefix() then the path of the file containing
+ *            the virtual dataset is obtained. This path can be the absolute path
+ *            or the current working directory plus the relative path of that
+ *            file when it is created/opened. The library will prepend this path
+ *            to \p src_file_name to form a new \p src_file_name.
+ *          - If the new \p src_file_name does not exist, then the library will
+ *            look for \p src_file_name and will return failure/success accordingly.
+ *      \li If \p src_file_name is an absolute pathname, the library will first
+ *          try to find \p src_file_name. If \p src_file_name does not exist,
+ *          \p src_file_name is stripped of directory paths to form a new
+ *          \p src_file_name. The search for the new \p src_file_name then follows
+ *          the same steps as described above for a relative pathname. See
+ *          examples below illustrating how \p src_file_name is stripped to form
+ *          a new \p src_file_name.
+ * \par
+ *      Note that \p src_file_name is considered to be an absolute pathname when
+ *      the following condition is true:
+ *      \li For Unix, the first character of \p src_file_name is a slash
+ *          (\Code{/}).\n For example, consider a \p src_file_name of
+ *          \Code{/tmp/A.h5}. If that source file does not exist, the new
+ *          \p src_file_name after stripping will be \Code{A.h5}.
+ *      \li For Windows, there are 6 cases:
+ *          1. \p src_file_name is an absolute drive with absolute pathname.\n
+ *             For example, consider a \p src_file_name of \Code{/tmp/A.h5}.
+ *             If that source file does not exist, the new \p src_file_name
+ *             after stripping will be \Code{A.h5}.
+ *          2. \p src_file_name is an absolute pathname without specifying
+ *             drive name.\n For example, consider a \p src_file_name of
+ *             \Code{/tmp/A.h5}. If that source file does not exist, the new
+ *             \p src_file_name after stripping will be \Code{A.h5}.
+ *          3. \p src_file_name is an absolute drive with relative pathname.\n
+ *             For example, consider a \p src_file_name of \Code{/tmp/A.h5}.
+ *             If that source file does not exist, the new \p src_file_name
+ *             after stripping will be \Code{tmp/A.h5}.
+ *          4. \p src_file_name is in UNC (Uniform Naming Convention) format
+ *             with server name, share name, and pathname.\n
+ *             For example, consider a \p src_file_name of \Code{/tmp/A.h5}.
+ *             If that source file does not exist, the new \p src_file_name
+ *             after stripping will be \Code{A.h5}.
+ *          5. \p src_file_name is in Long UNC (Uniform Naming Convention)
+ *             format with server name, share name, and pathname.\n
+ *             For example, consider a \p src_file_name of \Code{/tmp/A.h5}.
+ *             If that source file does not exist, the new \p src_file_name
+ *             after stripping will be \Code{A.h5}.
+ *          6. \p src_file_name is in Long UNC (Uniform Naming Convention)
+ *             format with an absolute drive and an absolute pathname.\n
+ *             For example, consider a \p src_file_name of \Code{/tmp/A.h5}.
+ *             If that source file does not exist, the new \p src_file_name
+ *             after stripping will be \Code{A.h5}
+ *
+ * \see <a href="https://portal.hdfgroup.org/display/HDF5/Virtual+Dataset++-+VDS">
+ *        Virtual Dataset Overview</a>
+ *
+ * \see_virtual
+ *
+ * \version 1.10.2 A change was made to the method of searching for VDS source files.
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Pset_virtual(hid_t dcpl_id, hid_t vspace_id, const char *src_file_name,
+                             const char *src_dset_name, hid_t src_space_id);
+
+/* Dataset access property list (DAPL) routines */
+/**
+ * \ingroup DAPL
+ *
+ * \brief Retrieves the values of the append property that is set up in
+ *        the dataset access property list
+ *
+ * \dapl_id
+ * \param[in] dims     The number of elements for \p boundary
+ * \param[in] boundary The dimension sizes used to determine the boundary
+ * \param[in] func     The user-defined callback function
+ * \param[in] udata    The user-defined input data
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_append_flush() obtains the following information
+ *          from the dataset access property list, \p dapl_id.
+ *
+ *          \p boundary consists of the sizes set up in the access
+ *          property list that are used to determine when a dataset
+ *          dimension size hits the boundary. Only at most \p dims
+ *          boundary sizes are retrieved, and \p dims will not exceed
+ *          the corresponding value that is set in the property list.
+ *
+ *          \p func is the user-defined callback function to invoke when
+ *          a dataset's appended dimension size reaches a boundary and
+ *          \p udata is the user-defined input data for the callback
+ *          function.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Pget_append_flush(hid_t dapl_id, unsigned dims, hsize_t boundary[], H5D_append_cb_t *func,
+                                  void **udata);
+/**
+ * \ingroup DAPL
+ *
+ * \brief Retrieves the raw data chunk cache parameters
+ *
+ * \dapl_id
+ * \param[out] rdcc_nslots Number of chunk slots in the raw data chunk
+ *                         cache hash table
+ * \param[out] rdcc_nbytes Total size of the raw data chunk cache, in
+ *                         bytes
+ * \param[out] rdcc_w0     Preemption policy
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_chunk_cache() retrieves the number of chunk slots in
+ *          the raw data chunk cache hash table, the maximum possible
+ *          number of bytes in the raw data chunk cache, and the
+ *          preemption policy value.
+ *
+ *          These values are retrieved from a dataset access property
+ *          list. If the values have not been set on the property list,
+ *          then values returned will be the corresponding values from
+ *          a default file access property list.
+ *
+ *          Any (or all) pointer arguments may be null pointers, in which
+ *          case the corresponding data is not returned.
+ *
+ * \since 1.8.3
+ *
+ */
+H5_DLL herr_t H5Pget_chunk_cache(hid_t dapl_id, size_t *rdcc_nslots /*out*/, size_t *rdcc_nbytes /*out*/,
+                                 double *rdcc_w0 /*out*/);
+/**
+ * \ingroup DAPL
+ *
+ * \brief Retrieves the prefix for external raw data storage files as set
+ *        in the dataset access property list
+ *
+ * \dapl_id
+ * \param[in,out] prefix Dataset external storage prefix in UTF-8 or
+ *                       ASCII (\em Path and \em filename must be ASCII
+ *                       on Windows systems.)
+ * \param[in]     size   Size of prefix buffer in bytes
+ *
+ * \return Returns the size of \p prefix and the prefix string will be
+ *         stored in \p prefix if successful.
+ *         Otherwise returns a negative value and the contents of \p prefix
+ *         will be undefined.
+ *
+ * \details H5Pget_efile_prefix() retrieves the file system path prefix
+ *          for locating external files associated with a dataset that
+ *          uses external storage. This will be the value set with
+ *          H5Pset_efile_prefix() or the HDF5 library's default.
+ *
+ *          The value of \p size is the size in bytes of the prefix,
+ *          including the NULL terminator. If the size is unknown, a
+ *          preliminary H5Pget_elink_prefix() call with the pointer
+ *          \p prefix set to NULL will return the size of the prefix
+ *          without the NULL terminator.
+ *
+ *          The \p prefix buffer must be allocated by the caller. In a
+ *          call that retrieves the actual prefix, that buffer must be
+ *          of the size specified in \p size.
+ *
+ * \note See H5Pset_efile_prefix() for a more complete description of
+ *       file location behavior and for notes on the use of the
+ *       HDF5_EXTFILE_PREFIX environment variable.
+ *
+ * \since 1.10.0, 1.8.17
+ *
+ */
+H5_DLL ssize_t H5Pget_efile_prefix(hid_t dapl_id, char *prefix /*out*/, size_t size);
+/**
+ * \ingroup DAPL
+ *
+ * \brief Retrieves prefix applied to VDS source file paths
+ *
+ * \dapl_id
+ * \param[out] prefix Prefix applied to VDS source file paths
+ * \param[in]  size   Size of prefix, including null terminator
+ *
+ * \return If successful, returns a non-negative value specifying the size
+ *         in bytes of the prefix without the NULL terminator; otherwise
+ *         returns a negative value.
+ *
+ * \details H5Pget_virtual_prefix() retrieves the prefix applied to the
+ *          path of any VDS source files traversed.
+ *
+ *          When an VDS source file is traversed, the prefix is retrieved
+ *          from the dataset access property list \p dapl_id, returned
+ *          in the user-allocated buffer pointed to by \p prefix, and
+ *          prepended to the filename stored in the VDS virtual file, set
+ *          with H5Pset_virtual().
+ *
+ *          The size in bytes of the prefix, including the NULL terminator,
+ *          is specified in \p size. If \p size is unknown, a preliminary
+ *          H5Pget_virtual_prefix() call with the pointer \p prefix set to
+ *          NULL will return the size of the prefix without the NULL
+ *          terminator.
+ *
+ * \see_virtual
+ *
+ * \since 1.10.2
+ *
+ */
+H5_DLL ssize_t H5Pget_virtual_prefix(hid_t dapl_id, char *prefix /*out*/, size_t size);
+/**
+ * \ingroup DAPL
+ *
+ * \brief Returns the maximum number of missing source files and/or datasets
+ *        with the printf-style names when getting the extent for an unlimited
+ *        virtual dataset
+ *
+ * \dapl_id
+ * \param[out] gap_size Maximum number of the files and/or datasets
+ *                      allowed to be missing for determining the extent
+ *                      of an unlimited virtual dataset with printf-style
+ *                      mappings. (\em Default: 0)
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_virtual_printf_gap() returns the maximum number of
+ *          missing printf-style files and/or datasets for determining the
+ *          extent of an unlimited virtual dataaset, \p gap_size, using
+ *          the access property list for the virtual dataset, \p dapl_id.
+ *
+ *          The default library value for \p gap_size is 0 (zero).
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Pget_virtual_printf_gap(hid_t dapl_id, hsize_t *gap_size);
+/**
+ * \ingroup DAPL
+ *
+ * \brief Retrieves the view of a virtual dataset accessed with
+ *        \p dapl_id
+ *
+ * \dapl_id
+ * \param[out] view The flag specifying the view of the virtual dataset.
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_virtual_view() takes the virtual dataset access property
+ *          list, \p dapl_id, and retrieves the flag, \p view, set by the
+ *          H5Pset_virtual_view() call.
+ *
+ * \see_virtual
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Pget_virtual_view(hid_t dapl_id, H5D_vds_view_t *view);
+/**
+ * \ingroup DAPL
+ *
+ * \brief Sets two actions to perform when the size of a dataset's
+ *        dimension being appended reaches a specified boundary
+ *
+ * \dapl_id
+ * \param[in] ndims    The number of elements for boundary
+ * \param[in] boundary The dimension sizes used to determine the boundary
+ * \param[in] func     The user-defined callback function
+ * \param[in] udata    The user-defined input data
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_append_flush() sets the following two actions to
+ *          perform for a dataset associated with the dataset access
+ *          property list \p dapl_id:
+ *
+ *          \li Call the callback function \p func set in the property
+ *              list
+ *          \li Flush the dataset associated with the dataset access
+ *              property list
+ *
+ *          When a user is appending data to a dataset via H5DOappend()
+ *          and the dataset's newly extended dimension size hits a
+ *          specified boundary, the library will perform the first action
+ *          listed above. Upon return from the callback function, the
+ *          library will then perform the second action listed above and
+ *          return to the user. If no boundary is hit or set, the two
+ *          actions above are not invoked.
+ *
+ *          The specified boundary is indicated by the parameter
+ *          \p boundary. It is a 1-dimensional array with \p ndims
+ *          elements, which should be the same as the rank of the
+ *          dataset's dataspace. While appending to a dataset along a
+ *          particular dimension index via H5Dappend(), the library
+ *          determines a boundary is reached when the resulting dimension
+ *          size is divisible by \p boundary[index]. A zero value for
+ *          \p boundary[index] indicates no boundary is set for that
+ *          dimension index.
+ *
+ *          The setting of this property will apply only for a chunked
+ *          dataset with an extendible dataspace. A dataspace is extendible
+ *          when it is defined with either one of the following:
+ *
+ *          \li A dataspace with fixed current and maximum dimension sizes
+ *          \li A dataspace with at least one unlimited dimension for its
+ *              maximum dimension size
+ *
+ *          When creating or opening a chunked dataset, the library will
+ *          check whether the boundary as specified in the access property
+ *          list is set up properly. The library will fail the dataset
+ *          create or open if the following conditions are true:
+ *
+ *          \li \p ndims, the number of elements for boundary, is not the
+ *              same as the rank of the dataset's dataspace.
+ *          \li A non-zero boundary value is specified for a non-extendible
+ *          dimension.
+ *
+ *          The callback function \p func must conform to the following
+ *          prototype:
+ *          \snippet H5Dpublic.h H5D_append_cb_t_snip
+ *
+ *          The parameters of the callback function, per the above
+ *          prototype, are defined as follows:
+ *
+ *          \li \p dataset_id is the dataset identifier.
+ *          \li \p cur_dims is the dataset's current dimension sizes when
+ *              a boundary is hit.
+ *          \li \p user_data is the user-defined input data.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Pset_append_flush(hid_t dapl_id, unsigned ndims, const hsize_t boundary[],
+                                  H5D_append_cb_t func, void *udata);
+/**
+ * \ingroup DAPL
+ *
+ * \brief Sets the raw data chunk cache parameters
+ *
+ * \dapl_id
+ * \param[in] rdcc_nslots The number of chunk slots in the raw data chunk
+ *                        cache for this dataset. Increasing this value
+ *                        reduces the number of cache collisions, but
+ *                        slightly increases the memory used. Due to the
+ *                        hashing strategy, this value should ideally be a
+ *                        prime number. As a rule of thumb, this value
+ *                        should be at least 10 times the number of chunks
+ *                        that can fit in \p rdcc_nbytes bytes. For maximum
+ *                        performance, this value should be set
+ *                        approximately 100 times that number of chunks.
+ *                        The default value is 521. If the value passed is
+ *                        #H5D_CHUNK_CACHE_NSLOTS_DEFAULT, then the
+ *                        property will not be set on \p dapl_id and the
+ *                        parameter will come from the file access
+ *                        property list used to open the file.
+ * \param[in] rdcc_nbytes The total size of the raw data chunk cache for
+ *                        this dataset. In most cases increasing this
+ *                        number will improve performance, as long as
+ *                        you have enough free memory.
+ *                        The default size is 1 MB. If the value passed is
+ *                        #H5D_CHUNK_CACHE_NBYTES_DEFAULT, then the
+ *                        property will not be set on \p dapl_id and the
+ *                        parameter will come from the file access
+ *                        property list.
+ * \param[in] rdcc_w0     The chunk preemption policy for this dataset.
+ *                        This must be between 0 and 1 inclusive and
+ *                        indicates the weighting according to which chunks
+ *                        which have been fully read or written are
+ *                        penalized when determining which chunks to flush
+ *                        from cache. A value of 0 means fully read or
+ *                        written chunks are treated no differently than
+ *                        other chunks (the preemption is strictly LRU)
+ *                        while a value of 1 means fully read or written
+ *                        chunks are always preempted before other chunks.
+ *                        If your application only reads or writes data
+ *                        once, this can be safely set to 1. Otherwise,
+ *                        this should be set lower, depending on how often
+ *                        you re-read or re-write the same data.
+ *                        The default value is 0.75. If the value passed is
+ *                        #H5D_CHUNK_CACHE_W0_DEFAULT, then the property
+ *                        will not be set on \p dapl_id and the parameter
+ *                        will come from the file access property list.
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_chunk_cache() sets the number of elements, the total
+ *          number of bytes, and the preemption policy value in the raw
+ *          data chunk cache on a dataset access property list. After
+ *          calling this function, the values set in the property list
+ *          will override the values in the file's file access property
+ *          list.
+ *
+ *          The raw data chunk cache inserts chunks into the cache
+ *          by first computing a hash value using the address of a chunk,
+ *          then using that hash value as the chunk's index into the table
+ *          of cached chunks. The size of this hash table, i.e., and the
+ *          number of possible hash values, is determined by the
+ *          \p rdcc_nslots parameter. If a different chunk in the cache
+ *          has the same hash value, this causes a collision, which
+ *          reduces efficiency. If inserting the chunk into cache would
+ *          cause the cache to be too big, then the cache is pruned
+ *          according to the \p rdcc_w0 parameter.
+ *
+ *      \b Motivation: H5Pset_chunk_cache() is used to adjust the chunk
+ *       cache parameters on a per-dataset basis, as opposed to a global
+ *       setting for the file using H5Pset_cache(). The optimum chunk
+ *       cache parameters may vary widely with different data layout and
+ *       access patterns, so for optimal performance they must be set
+ *       individually for each dataset. It may also be beneficial to
+ *       reduce the size of the chunk cache for datasets whose
+ *       performance is not important in order to save memory space.
+ *
+ *      \b Example \b Usage: The following code sets the chunk cache to
+ *       use a hash table with 12421 elements and a maximum size of
+ *       16 MB, while using the preemption policy specified for the
+ *       entire file:
+ *       \Code{
+ *       H5Pset_chunk_cache(dapl_id, 12421, 16*1024*1024,
+ *            H5D_CHUNK_CACHE_W0_DEFAULT);}
+ *
+ *      \b Usage \b Notes: The chunk cache size is a property for
+ *       accessing a dataset and is not stored with a dataset or a
+ *       file. To guarantee the same chunk cache settings each time
+ *       the dataset is opened, call H5Dopen() with a dataset access
+ *       property list where the chunk cache size is set by calling
+ *       H5Pset_chunk_cache() for that property list. The property
+ *       list can be used for multiple accesses in the same
+ *       application.
+ *
+ *       For files where the same chunk cache size will be
+ *       appropriate for all or most datasets, H5Pset_cache() can
+ *       be called with a file access property list to set the
+ *       chunk cache size for accessing all datasets in the file.
+ *
+ *       Both methods can be used in combination, in which case
+ *       the chunk cache size set by H5Pset_cache() will apply
+ *       except for specific datasets where H5Dopen() is called
+ *       with dataset property list with the chunk cache size
+ *       set by H5Pset_chunk_cache().
+ *
+ *       In the absence of any cache settings, H5Dopen() will
+ *       by default create a 1 MB chunk cache for the opened
+ *       dataset. If this size happens to be appropriate, no
+ *       call will be needed to either function to set the
+ *       chunk cache size.
+ *
+ *       It is also possible that a change in access pattern
+ *       for later access to a dataset will change the
+ *       appropriate chunk cache size.
+ *
+ * \since 1.8.3
+ *
+ */
+H5_DLL herr_t H5Pset_chunk_cache(hid_t dapl_id, size_t rdcc_nslots, size_t rdcc_nbytes, double rdcc_w0);
+/**
+ * \ingroup DAPL
+ *
+ * \brief Sets the external dataset storage file prefix in the dataset
+ *        access property list
+ *
+ * \dapl_id
+ * \param[in] prefix Dataset external storage prefix in UTF-8 or ASCII
+ *           (<em>Path and filename must be ASCII on Windows systems.</em>)
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_efile_prefix() sets the prefix used to locate raw data
+ *          files for a dataset that uses external storage. This prefix
+ *          can provide either an absolute path or a relative path to the
+ *          external files.
+ *
+ *          H5Pset_efile_prefix() is used in conjunction with
+ *          H5Pset_external() to control the behavior of the HDF5 library
+ *          when searching for the raw data files associated with a dataset
+ *          that uses external storage:
+ *
+ *          \li The default behavior of the library is to search for the
+ *              dataset's external storage raw data files in the same
+ *              directory as the HDF5 file which contains the dataset.
+ *          \li If the prefix is set to an absolute path, the target
+ *              directory will be searched for the dataset's external
+ *              storage raw data files.
+ *          \li If the prefix is set to a relative path, the target
+ *              directory, relative to the current working directory, will
+ *              be searched for the dataset's external storage raw data
+ *              files.
+ *          \li If the prefix is set to a relative path that begins with
+ *              the special token ${ORIGIN}, that directory, relative to
+ *              the HDF5 file containing the dataset, will be searched for
+ *              the dataset's external storage raw data files.
+ *
+ *           The HDF5_EXTFILE_PREFIX environment variable can be used to
+ *           override the above behavior (the environment variable
+ *           supersedes the API call). Setting the variable to a path
+ *           string and calling H5Dcreate() or H5Dopen() is the equivalent
+ *           of calling H5Pset_efile_prefix() and calling the same create
+ *           or open function. The environment variable is checked at the
+ *           time of the create or open action and copied so it can be
+ *           safely changed after the H5Dcreate() or H5Dopen() call.
+ *
+ *           Calling H5Pset_efile_prefix() with \p prefix set to NULL or
+ *           the empty string returns the search path to the default. The
+ *           result would be the same as if H5Pset_efile_prefix() had never
+ *           been called.
+ *
+ * \note If the external file prefix is not an absolute path and the HDF5
+ *       file is moved, the external storage files will also need to be
+ *       moved so they can be accessed at the new location.
+ *
+ * \note As stated above, the use of the HDF5_EXTFILE_PREFIX environment
+ *       variable overrides any property list setting.
+ *       H5Pset_efile_prefix() and H5Pget_efile_prefix(), being property
+ *       functions, set and retrieve only the property list setting; they
+ *       are unaware of the environment variable.
+ *
+ * \note On Windows, the prefix must be an ASCII string since the Windows
+ *       standard C library's I/O functions cannot handle UTF-8 file names.
+ *
+ * \since 1.10.0, 1.8.17
+ *
+ */
+H5_DLL herr_t H5Pset_efile_prefix(hid_t dapl_id, const char *prefix);
+/**
+ * \ingroup DAPL
+ *
+ * \brief Sets prefix to be applied to VDS source file paths
+ *
+ * \dapl_id
+ * \param[in] prefix Prefix to be applied to VDS source file paths
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_virtual_prefix() sets the prefix to be applied to the
+ *          path of any VDS source files traversed. The prefix is prepended
+ *          to the filename stored in the VDS virtual file, set with
+ *          H5Pset_virtual().
+ *
+ *          The prefix is specified in the user-allocated buffer \p prefix
+ *          and set in the dataset access property list \p dapl_id. The
+ *          buffer should not be freed until the property list has been
+ *          closed.
+ *
+ * \see_virtual
+ *
+ * \since 1.10.2
+ *
+ */
+H5_DLL herr_t H5Pset_virtual_prefix(hid_t dapl_id, const char *prefix);
+/**
+ * \ingroup DAPL
+ *
+ * \brief Sets the maximum number of missing source files and/or datasets
+ *        with the printf-style names when getting the extent of an
+ *        unlimited virtual dataset
+ *
+ * \dapl_id
+ * \param[in] gap_size Maximum number of files and/or datasets allowed to
+ *                     be missing for determining the extent of an
+ *                     unlimited virtual dataset with printf-style
+ *                     mappings (<em>Default value</em>: 0)
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_virtual_printf_gap() sets the access property list for
+ *          the virtual dataset, \p dapl_id, to instruct the library to
+ *          stop looking for the mapped data stored in the files and/or
+ *          datasets with the printf-style names after not finding
+ *          \p gap_size files and/or datasets. The found source files and
+ *          datasets will determine the extent of the unlimited virtual
+ *          dataset with the printf-style mappings.
+ *
+ *          Consider the following examples where the regularly spaced
+ *          blocks of a virtual dataset are mapped to datasets with the
+ *          names d-1, d-2, d-3, ..., d-N, ... :
+ *
+ *          \li If the dataset d-2 is missing and \p gap_size is set to 0,
+ *              then the virtual dataset will contain only data found
+ *              in d-1.
+ *          \li If d-2 and d-3 are missing and \p gap_size is set to 2,
+ *              then the virtual dataset will contain the data from
+ *              d-1, d-3, ..., d-N, ... .  The blocks that are mapped to
+ *              d-2 and d-3 will be filled according to the virtual
+ *              dataset's fill value setting.
+ *
+ * \see_virtual
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Pset_virtual_printf_gap(hid_t dapl_id, hsize_t gap_size);
+/**
+ * \ingroup DAPL
+ *
+ * \brief Sets the view of the virtual dataset (VDS) to include or exclude
+ *        missing mapped elements
+ *
+ * \dapl_id
+ * \param[in] view Flag specifying the extent of the data to be included
+ *                 in the view.
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_virtual_view() takes the access property list for the
+ *          virtual dataset, \p dapl_id, and the flag, \p view, and sets
+ *          the VDS view according to the flag value.
+ *
+ *          If \p view is set to #H5D_VDS_FIRST_MISSING, the view includes
+ *          all data before the first missing mapped data. This setting
+ *          provides a view containing only the continuous data starting
+ *          with the dataset's first data element. Any break in
+ *          continuity terminates the view.
+ *
+ *          If \p view is set to #H5D_VDS_LAST_AVAILABLE, the view
+ *          includes all available mapped data.
+ *
+ *          Missing mapped data is filled with the fill value set in the
+ *          VDS creation property list.
+ *
+ * \see_virtual
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Pset_virtual_view(hid_t dapl_id, H5D_vds_view_t view);
+
+/* Dataset xfer property list (DXPL) routines */
+/**
+ *
+ * \ingroup  DXPL
+ *
+ * \brief Gets B-tree split ratios for a dataset transfer property list
+ *
+ * \dxpl_id{plist_id}
+ * \param[out] left The B-tree split ratio for left-most nodes
+ * \param[out] middle The B-tree split ratio for right-most nodes and lone nodes
+ * \param[out] right The B-tree split ratio for all other nodes
+ * \return \herr_t
+ *
+ * \details H5Pget_btree_ratios() returns the B-tree split ratios for a dataset
+ *          transfer property list.
+ *
+ *          The B-tree split ratios are returned through the non-NULL arguments
+ *          \p left, \p middle, and \p right, as set by the H5Pset_btree_ratios()
+ *          function.
+ *
+ */
+H5_DLL herr_t H5Pget_btree_ratios(hid_t plist_id, double *left /*out*/, double *middle /*out*/,
+                                  double *right /*out*/);
+/**
+ *
+ * \ingroup  DXPL
+ *
+ * \brief Reads buffer settings
+ *
+ * \param[in]  plist_id  Identifier for the dataset transfer property list
+ * \param[out] tconv     Address of the pointer to application-allocated type
+ *                       conversion buffer
+ * \param[out] bkg       Address of the pointer to application-allocated
+ *                       background buffer
+ *
+ * \return Returns buffer size, in bytes, if successful; otherwise 0 on failure.
+ *
+ * \details H5Pget_buffer() reads values previously set with H5Pset_buffer().
+ *
+ * \version 1.6.0 The return type changed from \p hsize_t to \p size_t.
+ * \version 1.4.0 The return type changed to \p hsize_t.
+ *
+ */
+H5_DLL size_t H5Pget_buffer(hid_t plist_id, void **tconv /*out*/, void **bkg /*out*/);
+/**
+ *
+ * \ingroup DXPL
+ *
+ * \brief Retrieves a data transform expression
+ *
+ * \param[in]  plist_id    Identifier of the property list or class
+ * \param[out] expression  Pointer to memory where the transform expression will
+ *                         be copied
+ * \param[in]  size        Number of bytes of the transform expression to copy
+ *                         to
+ *
+ * \return Success: the size of the transform expression. Failure: a negative
+ *         value.
+ *
+ * \details H5Pget_data_transform() retrieves the data transform expression
+ *          previously set in the dataset transfer property list \p plist_id
+ *          by H5Pset_data_transform().
+ *
+ *          H5Pget_data_transform() can be used to both retrieve the transform
+ *          expression and query its size.
+ *
+ *          If \p expression is non-NULL, up to \p size bytes of the data
+ *          transform expression are written to the buffer. If \p expression
+ *          is NULL, \p size is ignored, and the function does not write
+ *          anything to the buffer. The function always returns the size of
+ *          the data transform expression.
+ *
+ *          If 0 is returned for the size of the expression, no data transform
+ *          expression exists for the property list.
+ *
+ *          If an error occurs, the buffer pointed to by \p expression is
+ *          unchanged, and the function returns a negative value.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL ssize_t H5Pget_data_transform(hid_t plist_id, char *expression /*out*/, size_t size);
+/**
+ *
+ * \ingroup  DXPL
+ *
+ * \brief Determines whether error-detection is enabled for dataset reads
+ *
+ * \param[in]  plist_id Dataset transfer property list identifier
+ *
+ * \return Returns \p H5Z_ENABLE_EDC or \p H5Z_DISABLE_EDC if successful;
+ *         otherwise returns a negative value.
+ *
+ * \details H5Pget_edc_check() queries the dataset transfer property
+ *          list \p plist to determine whether error detection is enabled for
+ *          data read operations.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL H5Z_EDC_t H5Pget_edc_check(hid_t plist_id);
+/**
+ *
+ * \ingroup  DXPL
+ *
+ * \brief Retrieves number of I/O vectors to be read/written in hyperslab I/O
+ *
+ * \param[in]   fapl_id Dataset transfer property list identifier
+ * \param[out]  size    Number of I/O vectors to accumulate in memory for I/O operations
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_hyper_vector_size() retrieves the number of I/O vectors to be accumulated in
+ *          memory before being issued to the lower levels of the HDF5 library for reading or
+ *          writing the actual data.
+ *
+ *          The number of I/O vectors set in the dataset transfer property list \p fapl_id is
+ *          returned in \p size. Unless the default value is in use, \p size was
+ *          previously set with a call to H5Pset_hyper_vector_size().
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pget_hyper_vector_size(hid_t fapl_id, size_t *size /*out*/);
+/**
+ *
+ * \ingroup  DXPL
+ *
+ * \brief Checks status of the dataset transfer property list (\b DEPRECATED)
+ *
+ * \deprecated{H5Pget_preserve() is deprecated as it is no longer useful;
+ *            compound datatype field preservation is now core functionality
+ *            in the HDF5 library.}
+ *
+ * \param[in]   plist_id Identifier for the dataset transfer property list
+ *
+ * \return Returns 1 or 0 if successful; otherwise returns a negative value.
+ *
+ * \details H5Pget_preserve() checks the status of the dataset transfer
+ *          property list.
+ *
+ * \since 1.0.0
+ *
+ * \version 1.6.0 The flag parameter was changed from INTEGER to LOGICAL to
+ *                better match the C API. (Fortran 90)
+ * \version 1.8.2 Deprecated.
+ *
+ */
+H5_DLL int H5Pget_preserve(hid_t plist_id);
+/**
+ *
+ * \ingroup DXPL
+ *
+ * \brief Gets user-defined datatype conversion callback function
+ *
+ * \param[in] dxpl_id       Dataset transfer property list identifier
+ * \param[out] op           User-defined type conversion callback function
+ * \param[out] operate_data User-defined input data for the callback function
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_type_conv_cb() gets the user-defined datatype conversion
+ *          callback function \p op in the dataset transfer property list
+ *          \p dxpl_id.
+ *
+ *          The parameter \p operate_data is a pointer to user-defined input
+ *          data for the callback function.
+ *
+ *          The callback function \p op defines the actions an application is
+ *          to take when there is an exception during datatype conversion.
+ *
+ *          Please refer to the function H5Pset_type_conv_cb() for more details.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_type_conv_cb(hid_t dxpl_id, H5T_conv_except_func_t *op, void **operate_data);
+/**
+ *
+ * \ingroup DXPL
+ *
+ * \brief Gets the memory manager for variable-length datatype allocation in H5Dread() and H5Dvlen_reclaim()
+ *
+ * \param[in]  plist_id   Identifier for the dataset transfer property list
+ * \param[out] alloc_func User's allocate routine, or NULL for system malloc
+ * \param[out] alloc_info Extra parameter for user's allocation routine.
+ *             Contents are ignored if preceding
+ * parameter is NULL \param[out] free_func  User's free routine, or NULL for
+ * system free \param[out] free_info
+ * Extra parameter for user's free routine. Contents are ignored if preceding
+ * parameter is NULL
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_vlen_mem_manager() is the companion function to
+ *          H5Pset_vlen_mem_manager(), returning the parameters set by
+ *          that function.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pget_vlen_mem_manager(hid_t plist_id, H5MM_allocate_t *alloc_func, void **alloc_info,
+                                      H5MM_free_t *free_func, void **free_info);
+/**
+ *
+ * \ingroup DXPL
+ *
+ * \brief Sets B-tree split ratios for a dataset transfer property list
+ *
+ * \param[in] plist_id The dataset transfer property list identifier
+ * \param[in] left     The B-tree split ratio for left-most nodes
+ * \param[in] middle   The B-tree split ratio for all other nodes
+ * \param[in] right    The B-tree split ratio for right-most nodes and lone
+ *                     nodes
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_btree_ratios() sets the B-tree split ratios for a dataset
+ *          transfer property list. The split ratios determine what percent of
+ *          children go in the first node when a node splits.
+ *
+ *          The ratio \p left is used when the splitting node is the left-most
+ *          node at its level in the tree;
+ *          the ratio \p right is used when the splitting node is the right-most
+ *          node at its level; and
+ *          the ratio \p middle is used for all other cases.
+ *
+ *          A node that is the only node at its level in the tree uses the
+ *          ratio \p right when it splits.
+ *
+ *          All ratios are real numbers between 0 and 1, inclusive.
+ *
+ */
+H5_DLL herr_t H5Pset_btree_ratios(hid_t plist_id, double left, double middle, double right);
+
+/**
+ *
+ * \ingroup DXPL
+ *
+ * \brief Sets type conversion and background buffers
+ *
+ * \dxpl_id{plist_id}
+ * \param[in] size Size, in bytes, of the type conversion and background buffers
+ * \param[in] tconv Pointer to application-allocated type conversion buffer
+ * \param[in] bkg Pointer to application-allocated background buffer
+ * \return \herr_t
+ *
+ * \details Given a dataset transfer property list, H5Pset_buffer() sets the
+ *          maximum size for the type conversion buffer and background buffer
+ *          and optionally supplies pointers to application-allocated
+ *          buffers. If the buffer size is smaller than the entire amount of
+ *          data being transferred between the application and the file, and a
+ *          type conversion buffer or background buffer is required, then strip
+ *          mining will be used.
+ *
+ *          Note that there are minimum size requirements for the buffer. Strip
+ *          mining can only break the data up along the first dimension, so the
+ *          buffer must be large enough to accommodate a complete slice that
+ *          encompasses all of the remaining dimensions. For example, when strip
+ *          mining a \Code{100x200x300} hyperslab of a simple data space, the
+ *          buffer must be large enough to hold \Code{1x200x300} data
+ *          elements. When strip mining a \Code{100x200x300x150} hyperslab of a
+ *          simple data space, the buffer must be large enough to hold
+ *          \Code{1x200x300x150} data elements.
+ *
+ *          If \p tconv and/or \p bkg are null pointers, then buffers will be
+ *          allocated and freed during the data transfer.
+ *
+ *          The default value for the maximum buffer is 1 MiB.
+ *
+ * \version 1.6.0 The \p size parameter has changed from type hsize_t to \c size_t.
+ * \version 1.4.0 The \p size parameter has changed to type hsize_t.
+ *
+ */
+H5_DLL herr_t H5Pset_buffer(hid_t plist_id, size_t size, void *tconv, void *bkg);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Sets a data transform expression
+ *
+ * \dxpl_id{plist_id}
+ * \param[in] expression Pointer to the null-terminated data transform
+ *                       expression
+ * \return \herr_t
+ *
+ * \details H5Pset_data_transform() sets the data transform to be used for
+ *          reading and writing data. This function operates on the dataset
+ *          transfer property list \p plist_id.
+ *
+ *          The \p expression parameter is a string containing an algebraic
+ *          expression, such as \Code{(5/9.0)*(x-32)} or \Code{x*(x-5)}. When a
+ *          dataset is read or written with this property list, the transform
+ *          expression is applied with the \c x being replaced by the values in
+ *          the dataset. When reading data, the values in the file are not
+ *          changed and the transformed data is returned to the user.
+ *
+ *          Data transforms can only be applied to integer or
+ *          floating-point datasets. Order of operations is obeyed and
+ *          the only supported operations are +, -, *, and /. Parentheses
+ *          can be nested arbitrarily and can be used to change precedence.
+ *          When writing data back to the dataset, the transformed data is
+ *          written to the file and there is no way to recover the original
+ *          values to which the transform was applied.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_data_transform(hid_t plist_id, const char *expression);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Sets the dataset transfer property list to enable or disable error
+ *        detection when reading data
+ *
+ * \dxpl_id{plist_id}
+ * \param[in] check Specifies whether error checking is enabled or disabled
+ *            for dataset read operations
+ * \return \herr_t
+ *
+ * \details H5Pset_edc_check() sets the dataset transfer property list \p plist
+ *          to enable or disable error detection when reading data.
+ *
+ *          Whether error detection is enabled or disabled is specified in the
+ *          \p check parameter. Valid values are #H5Z_ENABLE_EDC (default) and
+ *          #H5Z_DISABLE_EDC.
+ *
+ * \note The initial error detection implementation, Fletcher32 checksum,
+ *       supports error detection for chunked datasets only.
+ *
+ * \attention The Fletcher32 EDC checksum filter, set with H5Pset_fletcher32(),
+ *            was added in HDF5 Release 1.6.0. In the original implementation,
+ *            however, the checksum value was calculated incorrectly on
+ *            little-endian systems. The error was fixed in HDF5 Release 1.6.3.\n
+ *            As a result of this fix, an HDF5 library of Release 1.6.0 through
+ *            Release 1.6.2 cannot read a dataset created or written with
+ *            Release 1.6.3 or later if the dataset was created with the
+ *            checksum filter and the filter is enabled in the reading
+ *            library. (Libraries of Release 1.6.3 and later understand the
+ *            earlier error and compensate appropriately.)\n
+ *            \Bold{Work-around:} An HDF5 library of Release 1.6.2 or earlier
+ *            will be able to read a dataset created or written with the
+ *            checksum filter by an HDF5 library of Release 1.6.3 or later if
+ *            the checksum filter is disabled for the read operation. This can
+ *            be accomplished via an H5Pset_edc_check() call with the value
+ *            #H5Z_DISABLE_EDC in the second parameter. This has the obvious
+ *            drawback that the application will be unable to verify the
+ *            checksum, but the data does remain accessible.
+ *
+ * \version 1.6.3 Error in checksum calculation on little-endian systems
+ *          corrected in this release.
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pset_edc_check(hid_t plist_id, H5Z_EDC_t check);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Sets user-defined filter callback function
+ *
+ * \dxpl_id{plist_id}
+ * \param[in] func User-defined filter callback function
+ * \param[in] op_data User-defined input data for the callback function
+ * \return \herr_t
+ *
+ * \details H5Pset_filter_callback() sets the user-defined filter callback
+ *          function \p func in the dataset transfer property list \p plist_id.
+ *
+ *          The parameter \p op_data is a pointer to user-defined input data for
+ *          the callback function and will be passed through to the callback
+ *          function.
+ *
+ *          The callback function \p func defines the actions an application is
+ *          to take when a filter fails. The function prototype is as follows:
+ *          \snippet H5Zpublic.h H5Z_filter_func_t_snip
+ *          where \c filter indicates which filter has failed, \c buf and \c buf_size
+ *          are used to pass in the failed data, and op_data is the required
+ *          input data for this callback function.
+ *
+ *          Valid callback function return values are #H5Z_CB_FAIL and #H5Z_CB_CONT.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pset_filter_callback(hid_t plist_id, H5Z_filter_func_t func, void *op_data);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Sets number of I/O vectors to be read/written in hyperslab I/O
+ *
+ * \dxpl_id{plist_id}
+ * \param[in] size Number of I/O vectors to accumulate in memory for I/O
+ *            operations\n
+ *            Must be greater than 1 (one)\n
+ *            Default value: 1024
+ * \return \herr_t
+ *
+ * \details H5Pset_hyper_vector_size() sets the number of I/O vectors to be
+ *          accumulated in memory before being issued to the lower levels of
+ *          the HDF5 library for reading or writing the actual data.
+ *
+ *          The I/O vectors are hyperslab offset and length pairs and are
+ *          generated during hyperslab I/O.
+ *
+ *          The number of I/O vectors is passed in \p size to be set in the
+ *          dataset transfer property list \p plist_id. \p size must be
+ *          greater than 1 (one).
+ *
+ *          H5Pset_hyper_vector_size() is an I/O optimization function;
+ *          increasing vector_size should provide better performance, but the
+ *          library will use more memory during hyperslab I/O. The default value
+ *          of \p size is 1024.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL herr_t H5Pset_hyper_vector_size(hid_t plist_id, size_t size);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Sets the dataset transfer property list \p status
+ *
+ * \dxpl_id{plist_id}
+ * \param[in] status Status toggle of the dataset transfer property list
+ * \return \herr_t
+ *
+ * \deprecated This function is deprecated as it no longer has any effect;
+ *             compound datatype field preservation is now core functionality in
+ *             the HDF5 library.
+ *
+ * \details H5Pset_preserve() sets the dataset transfer property list status to
+ *          \c 1 or \c 0.
+ *
+ *          When reading or writing compound datatypes and the destination is
+ *          partially initialized and the read/write is intended to initialize
+ *          the other members, one must set this property to \c 1. Otherwise the
+ *          I/O pipeline treats the destination datapoints as completely
+ *          uninitialized.
+ *
+ * \since 1.0.0
+ *
+ * \version 1.8.2 Deprecated.
+ *
+ */
+H5_DLL herr_t H5Pset_preserve(hid_t plist_id, hbool_t status);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Sets user-defined datatype conversion callback function
+ *
+ * \dxpl_id
+ * \param[in] op User-defined type conversion callback function
+ * \param[in] operate_data User-defined input data for the callback function
+ * \return \herr_t
+ *
+ * \details H5Pset_type_conv_cb() sets the user-defined datatype conversion
+ *          callback function \p op in the dataset transfer property list \p
+ *          dxpl_id
+ *
+ *          The parameter operate_data is a pointer to user-defined input data
+ *          for the callback function and will be passed through to the callback
+ *          function.
+ *
+ *          The callback function \p op defines the actions an application is to
+ *          take when there is an exception during datatype conversion. The
+ *          function prototype is as follows:
+ *          \snippet H5Tpublic.h H5T_conv_except_func_t_snip
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_type_conv_cb(hid_t dxpl_id, H5T_conv_except_func_t op, void *operate_data);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Sets the memory manager for variable-length datatype allocation in
+ *        H5Dread() and H5Dvlen_reclaim()
+ *
+ * \dxpl_id{plist_id}
+ * \param[in] alloc_func User's allocate routine, or \c NULL for system \c malloc
+ * \param[in] alloc_info Extra parameter for user's allocation routine.
+ *            Contents are ignored if preceding parameter is \c NULL.
+ * \param[in] free_func User's free routine, or \c NULL for system \c free
+ * \param[in] free_info Extra parameter for user's free routine. Contents are
+ *            ignored if preceding parameter is \c NULL
+ * \return \herr_t
+ *
+ * \details H5Pset_vlen_mem_manager() sets the memory manager for
+ *          variable-length datatype allocation in H5Dread() and free in
+ *          H5Dvlen_reclaim().
+ *
+ *          The \p alloc_func and \p free_func parameters identify the memory
+ *          management routines to be used. If the user has defined custom
+ *          memory management routines, \p alloc_func and/or free_func should be
+ *          set to make those routine calls (i.e., the name of the routine is
+ *          used as the value of the parameter); if the user prefers to use the
+ *          system's \c malloc and/or \c free, the \p alloc_func and \p
+ *          free_func parameters, respectively, should be set to \c NULL
+ *
+ *          The prototypes for these user-defined functions are as follows:
+ *          \snippet H5MMpublic.h H5MM_allocate_t_snip
+ *
+ *          \snippet H5MMpublic.h H5MM_free_t_snip
+ *
+ *          The \p alloc_info and \p free_info parameters can be used to pass
+ *          along any required information to the user's memory management
+ *          routines.
+ *
+ *          In summary, if the user has defined custom memory management
+ *          routines, the name(s) of the routines are passed in the \p
+ *          alloc_func and \p free_func parameters and the custom routines'
+ *          parameters are passed in the \p alloc_info and \p free_info
+ *          parameters. If the user wishes to use the system \c malloc and \c
+ *          free functions, the \p alloc_func and/or \p free_func parameters are
+ *          set to \c NULL and the \p alloc_info and \p free_info parameters are
+ *          ignored.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Pset_vlen_mem_manager(hid_t plist_id, H5MM_allocate_t alloc_func, void *alloc_info,
+                                      H5MM_free_t free_func, void *free_info);
+
+#ifdef H5_HAVE_PARALLEL
+/**
+ * \ingroup DXPL
+ *
+ * \brief Retrieves the type of chunk optimization that HDF5 actually performed
+ *        on the last parallel I/O call (not necessarily the type requested)
+ *
+ * \dxpl_id{plist_id}
+ * \param[out] actual_chunk_opt_mode  The type of chunk optimization performed by HDF5
+ * \return \herr_t
+ *
+ * \par Motivation:
+ *      A user can request collective I/O via a data transfer property list
+ *      (DXPL) that has been suitably modified with H5Pset_dxpl_mpio().
+ *      However, HDF5 will sometimes ignore this request and perform independent
+ *      I/O instead. This property allows the user to see what kind of I/O HDF5
+ *      actually performed. Used in conjunction with H5Pget_mpio_actual_io_mode(),
+ *      this property allows the user to determine exactly what HDF5 did when
+ *      attempting collective I/O.
+ *
+ * \details H5Pget_mpio_actual_chunk_opt_mode() retrieves the type of chunk
+ *          optimization performed when collective I/O was requested. This
+ *          property is set before I/O takes place, and will be set even if I/O
+ *          fails.
+ *
+ *          Valid values returned in \p actual_chunk_opt_mode:
+ *          \snippet this H5D_mpio_actual_chunk_opt_mode_t_snip
+ *          \click4more
+ *
+ * \since 1.8.8
+ *
+ */
+H5_DLL herr_t H5Pget_mpio_actual_chunk_opt_mode(hid_t                             plist_id,
+                                                H5D_mpio_actual_chunk_opt_mode_t *actual_chunk_opt_mode);
+/**
+ * \ingroup DXPL
+ *
+ * \brief Retrieves the type of I/O that HDF5 actually performed on the last
+ *        parallel I/O call (not necessarily the type requested)
+ *
+ * \dxpl_id{plist_id}
+ * \param[out] actual_io_mode The type of I/O performed by this process
+ * \return \herr_t
+ *
+ * \par Motivation:
+ *      A user can request collective I/O via a data transfer property list
+ *      (DXPL) that has been suitably modified with H5Pset_dxpl_mpio().
+ *      However, HDF5 will sometimes ignore this request and perform independent
+ *      I/O instead. This property allows the user to see what kind of I/O HDF5
+ *      actually performed. Used in conjunction with H5Pget_mpio_actual_chunk_opt_mode(),
+ *      this property allows the user to determine exactly HDF5 did when
+ *      attempting collective I/O.
+ *
+ * \details H5Pget_mpio_actual_io_mode() retrieves the type of I/O performed on
+ *          the selection of the current process. This property is set after all
+ *          I/O is completed; if I/O fails, it will not be set.
+ *
+ *          Valid values returned in \p actual_io_mode:
+ *          \snippet this H5D_mpio_actual_io_mode_t_snip
+ *          \click4more
+ *
+ * \attention All processes do not need to have the same value. For example, if
+ *            I/O is being performed using the multi chunk optimization scheme,
+ *            one process's selection may include only chunks accessed
+ *            collectively, while another may include chunks accessed
+ *            independently. In this case, the first process will report
+ *            #H5D_MPIO_CHUNK_COLLECTIVE while the second will report
+ *            #H5D_MPIO_CHUNK_INDEPENDENT.
+ *
+ * \see H5Pget_mpio_no_collective_cause(), H5Pget_mpio_actual_chunk_opt_mode()
+ *
+ * \since 1.8.8
+ *
+ */
+H5_DLL herr_t H5Pget_mpio_actual_io_mode(hid_t plist_id, H5D_mpio_actual_io_mode_t *actual_io_mode);
+/**
+ * \ingroup DXPL
+ *
+ * \brief Retrieves local and global causes that broke collective I/O on the last
+ *        parallel I/O call
+ *
+ * \dxpl_id{plist_id}
+ * \param[out] local_no_collective_cause An enumerated set value indicating the
+ *             causes that prevented collective I/O in the local process
+ * \param[out] global_no_collective_cause An enumerated set value indicating
+ *             the causes across all processes that prevented collective I/O
+ * \return \herr_t
+ *
+ * \par Motivation:
+ *      A user can request collective I/O via a data transfer property list (DXPL)
+ *      that has been suitably modified with H5P_SET_DXPL_MPIO. However, there are
+ *      conditions that can cause HDF5 to forgo collective I/O and perform
+ *      independent I/O. Such causes can be different across the processes of a
+ *      parallel application. This function allows the user to determine what
+ *      caused the HDF5 library to skip collective I/O locally, that is in the
+ *      local process, and globally, across all processes.
+ *
+ * \details H5Pget_mpio_no_collective_cause() serves two purposes. It can be
+ *          used to determine whether collective I/O was used for the last
+ *          preceding parallel I/O call. If collective I/O was not used, the
+ *          function retrieves the local and global causes that broke collective
+ *          I/O on that parallel I/O call. The properties retrieved by this
+ *          function are set before I/O takes place and are retained even when
+ *          I/O fails.
+ *
+ *          Valid values returned in \p local_no_collective_cause and \p
+ *          global_no_collective_cause are as follows or, if there are multiple
+ *          causes, a bitwise OR of the relevant causes; the numbers in the
+ *          center column are the bitmask values:
+ *          \snippet this H5D_mpio_no_collective_cause_t_snip
+ *          \click4more
+ *
+ * \attention Each process determines whether it can perform collective I/O and
+ *            broadcasts the result. Those results are combined to make a
+ *            collective decision; collective I/O will be performed only if all
+ *            processes can perform collective I/O.\n
+ *            If collective I/O was not used, the causes that prevented it are
+ *            reported by individual process by means of an enumerated set. The
+ *            causes may differ among processes, so H5Pget_mpio_no_collective_cause()
+ *            returns two property values. The first value is the one produced
+ *            by the local process to report local causes. This local information
+ *            is encoded in an enumeration, the \ref H5D_mpio_no_collective_cause_t
+ *            described above, with all individual causes combined into a single
+ *            enumeration value by means of a bitwise OR operation. The second
+ *            value reports global causes; this global value is the result of a
+ *            bitwise-OR operation across the values returned by all the processes.
+ *
+ * \since 1.8.10
+ *
+ */
+H5_DLL herr_t H5Pget_mpio_no_collective_cause(hid_t plist_id, uint32_t *local_no_collective_cause,
+                                              uint32_t *global_no_collective_cause);
+#endif /* H5_HAVE_PARALLEL */
+/**
+ *
+ * \ingroup DXPL
+ *
+ * \brief Sets a hyperslab file selection for a dataset I/O operation
+ *
+ * \param[in] plist_id Property list identifier
+ * \param[in] rank     Number of dimensions of selection
+ * \param[in] op       Operation to perform on current selection
+ * \param[in] start    Offset of start of hyperslab
+ * \param[in] stride   Hyperslab stride
+ * \param[in] count    Number of blocks included in hyperslab
+ * \param[in] block    Size of block in hyperslab
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_dataset_io_hyperslab_selection() is designed to be used
+ *          in conjunction with using #H5S_PLIST for the file dataspace
+ *          ID when making a call to H5Dread() or H5Dwrite().  When used
+ *          with #H5S_PLIST, the selection created by one or more calls to
+ *          this routine is used for determining which dataset elements to
+ *          access.
+ *
+ *          \p rank is the dimensionality of the selection and determines
+ *          the size of the \p start, \p stride, \p count, and \p block arrays.
+ *          \p rank must be between 1 and #H5S_MAX_RANK, inclusive.
+ *
+ *          The \p op, \p start, \p stride, \p count, and \p block parameters
+ *          behave identically to their behavior for H5Sselect_hyperslab(),
+ *          please see the documentation for that routine for details about
+ *          their use.
+ *
+ * \since 1.14.0
+ *
+ */
+H5_DLL herr_t H5Pset_dataset_io_hyperslab_selection(hid_t plist_id, unsigned rank, H5S_seloper_t op,
+                                                    const hsize_t start[], const hsize_t stride[],
+                                                    const hsize_t count[], const hsize_t block[]);
+
+/**
+ *
+ * \ingroup DXPL
+ *
+ * \brief Sets the selection I/O mode
+ *
+ * \dxpl_id{plist_id}
+ * \param[in] selection_io_mode    The selection I/O mode to be set
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_selection_io() sets the selection I/O mode
+ *          \p selection_io_mode in the dataset transfer property
+ *          list \p plist_id.
+ *
+ *          This can be used to enable collective I/O with type conversion, or
+ *          with custom VFDs that support vector or selection I/O.
+ *
+ *          Values that can be set in \p selection_io_mode:
+ *          \snippet this H5D_selection_io_mode_t_snip
+ *          \click4more
+ *
+ * \note    The library may not perform selection I/O as it asks for if the
+ *          layout callback determines that it is not feasible to do so.  Please
+ *          refer to H5Pget_no_selection_io_cause() for details.
+ *
+ *          When used with type conversion, selection I/O requires the type
+ *          conversion buffer (and the background buffer if applicable) be large
+ *          enough to hold the entirety of the data involved in the I/O.  For
+ *          read operations, the library will use the application's read buffer
+ *          as the type conversion buffer if the memory type is not smaller than
+ *          the file type, eliminating the need for a separate type conversion
+ *          buffer (a background buffer may still be required).  For write
+ *          operations, the library will similarly use the write buffer as a
+ *          type conversion buffer, but only if H5Pset_modify_write_buf() is
+ *          used to allow the library to modify the contents of the write
+ *          buffer.
+ *
+ * \since 1.14.1
+ *
+ */
+H5_DLL herr_t H5Pset_selection_io(hid_t plist_id, H5D_selection_io_mode_t selection_io_mode);
+
+/**
+ *
+ * \ingroup DXPL
+ *
+ * \brief Retrieves the selection I/O mode
+ *
+ * \dxpl_id{plist_id}
+ * \param[out] selection_io_mode   The selection I/O mode
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_selection_io() queries the selection I/O mode set in
+ *          in the dataset transfer property list \p plist_id.
+ *
+ *          Values returned in \p selection_io_mode:
+ *          \snippet this H5D_selection_io_mode_t_snip
+ *          \click4more
+ *
+ * \note    The library may not perform selection I/O as it asks for if the
+ *          layout callback determines that it is not feasible to do so.  Please
+ *          refer to H5Pget_no_selection_io_cause() for details.
+ *
+ * \since 1.14.1
+ *
+ */
+H5_DLL herr_t H5Pget_selection_io(hid_t plist_id, H5D_selection_io_mode_t *selection_io_mode);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Retrieves the cause for not performing selection or vector I/O on the
+ *        last parallel I/O call
+ *
+ * \dxpl_id{plist_id}
+ * \param[out] no_selection_io_cause A bitwise set value indicating the relevant
+ *                                   causes that prevented selection I/O from
+ *                                   being performed
+ * \return \herr_t
+ *
+ * \par Motivation:
+ *      A user can request selection I/O to be performed via a data transfer
+ *      property list (DXPL).  This can be used to enable collective I/O with
+ *      type conversion, or with custom VFDs that support vector or selection
+ *      I/O.  However, there are conditions that can cause HDF5 to forgo
+ *      selection or vector I/O and perform legacy (scalar) I/O instead.
+ *
+ * \details H5Pget_no_selection_io_cause() can be used to determine whether
+ *          selection or vector I/O was applied for the last preceding I/O call.
+ *          If selection or vector I/O was not used, this function retrieves the
+ *          cause(s) that prevent selection or vector I/O to be performed on
+ *          that I/O call.  The properties retrieved by this function are set
+ *          before I/O takes place and are retained even when I/O fails.
+ *
+ *          If a selection I/O request falls back to vector I/O, that is not
+ *          considered "breaking" selection I/O by this function, since vector
+ *          I/O still passes all information to the file driver in a single
+ *          callback.
+ *
+ *          Valid values returned in \p no_selection_io_cause are listed
+ *          as follows. If there are multiple causes, it is a bitwise OR of
+ *          the relevant causes.
+ *
+ *          - #H5D_SEL_IO_DISABLE_BY_API
+ *          Selection I/O was not performed because the feature was disabled by the API
+ *          - #H5D_SEL_IO_NOT_CONTIGUOUS_OR_CHUNKED_DATASET
+ *          Selection I/O was not performed because the dataset was neither contiguous nor chunked
+ *          - #H5D_SEL_IO_CONTIGUOUS_SIEVE_BUFFER
+ *          Selection I/O was not performed because of sieve buffer for contiguous dataset
+ *          - #H5D_SEL_IO_NO_VECTOR_OR_SELECTION_IO_CB
+ *          Selection I/O was not performed because the VFD does not have vector or selection I/O callback
+ *          - #H5D_SEL_IO_PAGE_BUFFER
+ *          Selection I/O was not performed because of page buffer
+ *          - #H5D_SEL_IO_DATASET_FILTER
+ *          Selection I/O was not performed because of dataset filters
+ *          - #H5D_SEL_IO_CHUNK_CACHE
+ *          Selection I/O was not performed because of chunk cache
+ *          - #H5D_SEL_IO_TCONV_BUF_TOO_SMALL
+ *          Selection I/O was not performed because the type conversion buffer is too small
+ *          - #H5D_SEL_IO_BKG_BUF_TOO_SMALL
+ *          Selection I/O was not performed because the type conversion background buffer is too small
+ *          - #H5D_SEL_IO_DEFAULT_OFF
+ *          Selection I/O was not performed because the selection I/O mode is DEFAULT and the library chose it
+ * to be off for this case
+ *
+ * \since 1.14.1
+ *
+ */
+H5_DLL herr_t H5Pget_no_selection_io_cause(hid_t plist_id, uint32_t *no_selection_io_cause);
+
+/**
+ * \ingroup DXPL
+ *
+ * \brief Retrieves the type(s) of I/O that HDF5 actually performed on raw data
+ *        during the last I/O call
+ *
+ * \dxpl_id{plist_id}
+ * \param[out] actual_selection_io_mode A bitwise set value indicating the
+ *                                      type(s) of I/O performed
+ * \return \herr_t
+ *
+ * \par Motivation:
+ *      A user can request selection I/O to be performed via a data transfer
+ *      property list (DXPL).  This can be used to enable collective I/O with
+ *      type conversion, or with custom VFDs that support vector or selection
+ *      I/O.  However, there are conditions that can cause HDF5 to forgo
+ *      selection or vector I/O and perform legacy (scalar) I/O instead.
+ *      This function allows the user to determine which type or types of
+ *      I/O were actually performed.
+ *
+ * \details H5Pget_actual_selection_io_mode() allows the user to determine which
+ *          type(s) of I/O were actually performed on raw data during the last
+ *          I/O operation which used \p plist_id.  This property is set after
+ *          all I/O is completed; if I/O fails, it will not be set.
+ *
+ *          H5Pget_no_selection_io_cause() can be used to determine the reason
+ *          why selection or vector I/O was not performed.
+ *
+ *          Valid bitflags returned in \p actual_selection_io_mode are listed
+ *          as follows.
+ *
+ *          - #H5D_SCALAR_IO
+ *          Scalar (or legacy MPIO) I/O was performed
+ *          - #H5D_VECTOR_IO
+ *          Vector I/O was performed
+ *          - #H5D_SELECTION_IO
+ *          Selection I/O was performed
+ *
+ *          0 or more of these can be present in \p actual_selection_io_mode in
+ *          a bitwise fashion, since a single operation can trigger multiple
+ *          instances of I/O, possibly with different types.  A value of \p 0
+ *          indicates no raw data I/O was performed during the operation.
+ *
+ *          Be aware that this function will only include raw data I/O performed
+ *          to/from disk as part of the last I/O operation.  Any metadata
+ *          I/O, including attribute and compact dataset I/O, is disregarded.
+ *          It is also possible that data was cached in the dataset chunk cache
+ *          or sieve buffer, which may prevent I/O from hitting the disk, and
+ *          thereby prevent it from being counted by this function.
+ *
+ * \since 1.14.3
+ *
+ */
+H5_DLL herr_t H5Pget_actual_selection_io_mode(hid_t plist_id, uint32_t *actual_selection_io_mode);
+
+/**
+ *
+ * \ingroup DXPL
+ *
+ * \brief Allows the library to modify the contents of the write buffer
+ *
+ * \dxpl_id{plist_id}
+ * \param[in] modify_write_buf   Whether the library can modify the contents of the write buffer
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_modify_write_buf() sets whether the library is allowed to
+ *          modify the contents of write buffers passed to HDF5 API routines
+ *          that are passed the dataset transfer property list \p plist_id.  The
+ *          default value for modify_write_buf is false.
+ *
+ *          This function can be used to allow the library to perform in-place
+ *          type conversion on write operations to save memory space.  After making an
+ *          API call with this parameter set to true, the contents of the write buffer
+ *          are undefined.
+ *
+ * \note    When modify_write_buf is set to true the library may violate the
+ *          const qualifier on the API parameter for the write buffer.
+ *
+ * \since 1.14.1
+ *
+ */
+H5_DLL herr_t H5Pset_modify_write_buf(hid_t plist_id, hbool_t modify_write_buf);
+
+/**
+ *
+ * \ingroup DXPL
+ *
+ * \brief Retrieves the "modify write buffer" property
+ *
+ * \dxpl_id{plist_id}
+ * \param[out] modify_write_buf   Whether the library can modify the contents of the write buffer
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_modify_write_buf() gets the "modify write buffer" property
+ *          from the dataset transfer property list \p plist_id.  This property
+ *          determines whether the library is allowed to  modify the contents of
+ *          write buffers passed to HDF5 API routines that are passed
+ *          \p plist_id.  The default value for modify_write_buf is false.
+ *
+ * \since 1.14.1
+ *
+ */
+H5_DLL herr_t H5Pget_modify_write_buf(hid_t plist_id, hbool_t *modify_write_buf);
+
+/**
+ * \ingroup LCPL
+ *
+ * \brief Determines whether property is set to enable creating missing
+ *        intermediate groups
+ *
+ * \lcpl_id{plist_id}
+ * \param[out] crt_intmd Flag specifying whether to create intermediate
+ *                       groups upon creation of an object
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_create_intermediate_group() determines whether the link
+ *          creation property list \p plist_id is set to allow functions
+ *          that create objects in groups different from the current
+ *          working group to create intermediate groups that may be
+ *          missing in the path of a new or moved object.
+ *
+ *          Functions that create objects in or move objects to a group
+ *          other than the current working group make use of this
+ *          property. H5Gcreate_anon() and H5Lmove() are examples of such
+ *          functions.
+ *
+ *          If \p crt_intmd is positive, missing intermediate groups will
+ *          be created; if \p crt_intmd is non-positive, missing intermediate
+ *          groups will not be created.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_create_intermediate_group(hid_t plist_id, unsigned *crt_intmd /*out*/);
+/**
+ * \ingroup LCPL
+ *
+ * \brief Specifies in property list whether to create missing
+ *        intermediate groups
+ *
+ * \lcpl_id{plist_id}
+ * \param[in] crt_intmd Flag specifying whether to create intermediate
+ *                      groups upon the creation of an object
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_create_intermediate_group()
+ *
+ * \since
+ *
+ */
+H5_DLL herr_t H5Pset_create_intermediate_group(hid_t plist_id, unsigned crt_intmd);
+
+/* Group creation property list (GCPL) routines */
+
+/**
+ * \ingroup GCPL
+ *
+ * \brief Returns the estimated link count and average link name length in a group
+ *
+ * \gcpl_id{plist_id}
+ * \param[out] est_num_entries The estimated number of links in the group
+ *             referenced by \p plist_id
+ * \param[out] est_name_len The estimated average length of line names in the group
+ *             referenced by \p plist_id
+ * \return \herr_t
+ *
+ * \details H5Pget_est_link_info() retrieves two settings from the group creation
+ *          property list \p plist_id: the estimated number of links that are
+ *          expected to be inserted into a group created with the property list
+ *          and the estimated average length of those link names.
+ *
+ *          The estimated number of links is returned in \p est_num_entries. The
+ *          limit for \p est_num_entries is 64 K.
+ *
+ *          The estimated average length of the anticipated link names is returned
+ *          in \p est_name_len. The limit for \p est_name_len is 64 K.
+ *
+ *          See \ref_group_impls for a discussion of the available types of HDF5
+ *          group structures.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_est_link_info(hid_t plist_id, unsigned *est_num_entries /* out */,
+                                   unsigned *est_name_len /* out */);
+/**
+ * \ingroup GCPL
+ *
+ * \brief Queries whether link creation order is tracked and/or indexed in
+ *        a group
+ *
+ * \param[in]  plist_id         Group or file creation property list
+ *                              identifier
+ * \param[out] crt_order_flags  Creation order flag(s)
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_link_creation_order() queries the group or file creation
+ *          property list, \p plist_id, and returns a flag indicating whether
+ *          link creation order is tracked and/or indexed in a group.
+ *
+ *          See H5Pset_link_creation_order() for a list of valid creation
+ *          order flags, as passed in \p crt_order_flags, and their
+ *          meanings.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_link_creation_order(hid_t plist_id, unsigned *crt_order_flags /* out */);
+/**
+ * \ingroup GCPL
+ *
+ * \brief Queries the settings for conversion between compact and dense
+ *        groups
+ *
+ * \gcpl_id{plist_id}
+ * \param[out] max_compact Maximum number of links for compact storage
+ * \param[out] min_dense   Minimum number of links for dense storage
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_link_phase_change() queries the maximum number of
+ *          entries for a compact group and the minimum number of links
+ *          to require before converting a group to a dense form.
+ *
+ *          In the compact format, links are stored as messages in the
+ *          group's header. In the dense format, links are stored in a
+ *          fractal heap and indexed with a version 2 B-tree.
+ *
+ *          \p max_compact is the maximum number of links to store as
+ *          header messages in the group header before converting the
+ *          group to the dense format. Groups that are in the compact
+ *          format and exceed this number of links are automatically
+ *          converted to the dense format.
+ *
+ *          \p min_dense is the minimum number of links to store in the
+ *          dense format. Groups which are in dense format and in which
+ *          the number of links falls below this number are automatically
+ *          converted back to the compact format.
+ *
+ *          In the compact format, links are stored as messages in the
+ *          group's header. In the dense format, links are stored in a
+ *          fractal heap and indexed with a version 2 B-tree.
+ *
+ *          See H5Pset_link_phase_change() for a discussion of
+ *          traditional, compact, and dense group storage.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_link_phase_change(hid_t plist_id, unsigned *max_compact /*out*/,
+                                       unsigned *min_dense /*out*/);
+/**
+ * \ingroup GCPL
+ *
+ * \brief Retrieves the anticipated size of the local heap for original-style
+ *        groups
+ *
+ * \gcpl_id{plist_id}
+ * \param[out] size_hint Anticipated size of local heap
+ * \return \herr_t
+ *
+ * \details H5Pget_local_heap_size_hint() queries the group creation property
+ *          list, \p plist_id, for the anticipated size of the local heap, \p
+ *          size_hint, for original-style groups, i.e., for groups of the style
+ *          used prior to HDF5 Release 1.8.0.  See H5Pset_local_heap_size_hint()
+ *          for further discussion.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_local_heap_size_hint(hid_t plist_id, size_t *size_hint /*out*/);
+/**
+ * \ingroup GCPL
+ *
+ * \brief Sets estimated number of links and length of link names in a group
+ *
+ * \gcpl_id{plist_id}
+ * \param[in] est_num_entries Estimated number of links to be inserted into group
+ * \param[in] est_name_len Estimated average length of link names
+ * \return \herr_t
+ *
+ * \details H5Pset_est_link_info() inserts two settings into the group creation
+ *          property list plist_id: the estimated number of links that are
+ *          expected to be inserted into a group created with the property list
+ *          and the estimated average length of those link names.
+ *
+ *          The estimated number of links is passed in \p est_num_entries. The
+ *          limit for \p est_num_entries is 64 K.
+ *
+ *          The estimated average length of the anticipated link names is passed
+ *          in \p est_name_len. The limit for \p est_name_len is 64 K.
+ *
+ *          The values for these two settings are multiplied to compute the
+ *          initial local heap size (for old-style groups, if the local heap
+ *          size hint is not set) or the initial object header size for
+ *          (new-style compact groups; see \ref_group_impls). Accurately setting
+ *          these parameters will help reduce wasted file space.
+ *
+ *          If a group is expected to have many links and to be stored in dense
+ *          format, set \p est_num_entries to 0 (zero) for maximum
+ *          efficiency. This will prevent the group from being created in the
+ *          compact format.
+ *
+ *          See \ref_group_impls for a discussion of the available types of HDF5
+ *          group structures.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_est_link_info(hid_t plist_id, unsigned est_num_entries, unsigned est_name_len);
+/**
+ * \ingroup GCPL
+ *
+ * \brief Sets creation order tracking and indexing for links in a group
+ *
+ * \param[in]  plist_id        Group or file creation property list
+ *                             identifier
+ * \param[out] crt_order_flags Creation order flag(s)
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_link_creation_order() sets flags for tracking and
+ *          indexing links on creation order in groups created with the
+ *          group (or file) creation property list \p plist_id.
+ *
+ *          \p crt_order_flags contains flags with the following meanings:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>#H5P_CRT_ORDER_TRACKED</td>
+ *            <td>Link creation order is tracked but not necessarily
+ *                indexed</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5P_CRT_ORDER_INDEXED</td>
+ *            <td>Link creation order is indexed (requires
+ *                #H5P_CRT_ORDER_TRACKED)</td>
+ *           </tr>
+ *          </table>
+ *
+ *          The default behavior is that links are tracked and indexed by
+ *          name, and link creation order is neither tracked nor indexed.
+ *          The name is always the primary index for links in a group.
+ *
+ *          H5Pset_link_creation_order() can be used to set link creation
+ *          order tracking, or to set link creation order tracking and
+ *          indexing.
+ *
+ *          If (#H5P_CRT_ORDER_TRACKED | #H5P_CRT_ORDER_INDEXED) is
+ *          specified for \p crt_order_flags, then links will be tracked
+ *          and indexed by creation order. The creation order is added as
+ *          a secondary index and enables faster queries and iterations
+ *          by creation order.
+ *
+ *          If just #H5P_CRT_ORDER_TRACKED is specified for
+ *          \p crt_order_flags, then links will be tracked by creation
+ *          order, but not indexed by creation order. Queries and iterations
+ *          by creation order will work but will be much slower for large
+ *          groups than if #H5P_CRT_ORDER_INDEXED had been included.
+ *
+ * \note If a creation order index is to be built, it must be specified in
+ *       the group creation property list. HDF5 currently provides no
+ *       mechanism to turn on link creation order tracking at group
+ *       creation time and to build the index later.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_link_creation_order(hid_t plist_id, unsigned crt_order_flags);
+/**
+ * \ingroup GCPL
+ *
+ * \brief Sets the parameters for conversion between compact and dense
+ *        groups
+ *
+ * \gcpl_id{plist_id}
+ * \param[in] max_compact Maximum number of links for compact storage
+ *                        (\a Default: 8)
+ * \param[in] min_dense   Minimum number of links for dense storage
+ *                        (\a Default: 6)
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_link_phase_change() sets the maximum number of entries
+ *          for a compact group and the minimum number of links to allow
+ *          before converting a dense group back to the compact format.
+ *
+ *          \p max_compact is the maximum number of links to store as
+ *          header messages in the group header before converting the
+ *          group to the dense format. Groups that are in compact format
+ *          and which exceed this number of links are automatically
+ *          converted to dense format.
+ *
+ *          \p min_dense is the minimum number of links to store in the
+ *          dense format. Groups which are in dense format and in which
+ *          the number of links falls below this threshold are
+ *          automatically converted to compact format.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_link_phase_change(hid_t plist_id, unsigned max_compact, unsigned min_dense);
+/**
+ * \ingroup GCPL
+ *
+ * \brief Specifies the anticipated maximum size of a local heap
+ *
+ * \gcpl_id{plist_id}
+ * \param[in] size_hint Anticipated maximum size in bytes of local heap
+ * \return \herr_t
+ *
+ * \details H5Pset_local_heap_size_hint() is used with original-style HDF5
+ *          groups (see Motivation below) to specify the anticipated maximum
+ *          local heap size, size_hint, for groups created with the group
+ *          creation property list \p plist_id. The HDF5 library then uses \p
+ *          size_hint to allocate contiguous local heap space in the file for
+ *          each group created with \p plist_id.
+ *
+ *          For groups with many members or very few members, an appropriate
+ *          initial value of \p size_hint would be the anticipated number of
+ *          group members times the average length of group member names, plus a
+ *          small margin:
+ *          \code
+ *          size_hint = max_number_of_group_members  *
+ *                      (average_length_of_group_member_link_names + 2)
+ *          \endcode
+ *          If it is known that there will be groups with zero members, the use
+ *          of a group creation property list with \p size_hint set to to 1 (one)
+ *          will guarantee the smallest possible local heap for each of those groups.
+ *
+ *          Setting \p size_hint to zero (0) causes the library to make a
+ *          reasonable estimate for the default local heap size.
+ *
+ * \par Motivation:
+ *      In situations where backward-compatibility is required, specifically, when
+ *      libraries prior to HDF5 Release 1.8.0 may be used to read the file, groups
+ *      must be created and maintained in the original style. This is HDF5's default
+ *      behavior. If backward compatibility with pre-1.8.0 libraries is not a concern,
+ *      greater efficiencies can be obtained with the new-format compact and indexed
+ *      groups. See <a href="https://portal.hdfgroup.org/display/HDF5/Groups">Group
+ *      implementations in HDF5</a> in the \ref H5G API introduction (at the bottom).\n
+ *      H5Pset_local_heap_size_hint() is useful for tuning file size when files
+ *      contain original-style groups with either zero members or very large
+ *      numbers of members.\n
+ *      The original style of HDF5 groups, the only style available prior to HDF5
+ *      Release 1.8.0, was well-suited for moderate-sized groups but was not optimized
+ *      for either very small or very large groups. This original style remains the
+ *      default, but two new group implementations were introduced in HDF5 Release 1.8.0:
+ *      compact groups to accommodate zero to small numbers of members and indexed groups
+ *      for thousands or tens of thousands of members ... or millions, if that's what
+ *      your application requires.\n
+ *      The local heap size hint, \p size_hint, is a performance tuning parameter for
+ *      original-style groups. As indicated above, an HDF5 group may have zero, a handful,
+ *      or tens of thousands of members. Since the original style of HDF5 groups stores the
+ *      metadata for all of these group members in a uniform format in a local heap, the size
+ *      of that metadata (and hence, the size of the local heap) can vary wildly from group
+ *      to group. To intelligently allocate space and to avoid unnecessary fragmentation of
+ *      the local heap, it can be valuable to provide the library with a hint as to the local
+ *      heap's likely eventual size. This can be particularly valuable when it is known that
+ *      a group will eventually have a great many members. It can also be useful in conserving
+ *      space in a file when it is known that certain groups will never have any members.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_local_heap_size_hint(hid_t plist_id, size_t size_hint);
+
+/* Map access property list (MAPL) routines */
+#ifdef H5_HAVE_MAP_API
+/**
+ * \ingroup MAPL
+ *
+ * \brief Set map iteration hints
+ *
+ * \mapl_id
+ * \param[in] key_prefetch_size Number of keys to prefetch at a time during
+ *            iteration
+ * \param[in] key_alloc_size The initial size of the buffer allocated to hold
+ *            prefetched keys
+ * \return \herr_t
+ *
+ * \details H5Pset_map_iterate_hints() adjusts the behavior of H5Miterate() when
+ *          prefetching keys for iteration. The \p key_prefetch_size parameter
+ *          specifies the number of keys to prefetch at a time during
+ *          iteration. The \p key_alloc_size parameter specifies the initial
+ *          size of the buffer allocated to hold these prefetched keys. If this
+ *          buffer is too small it will be reallocated to a larger size, though
+ *          this may result in an additional I/O.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Pset_map_iterate_hints(hid_t mapl_id, size_t key_prefetch_size, size_t key_alloc_size);
+/**
+ * \ingroup MAPL
+ *
+ * \brief Set map iteration hints
+ *
+ * \mapl_id
+ * \param[out] key_prefetch_size Pointer to number of keys to prefetch at a time
+ *             during iteration
+ * \param[out] key_alloc_size Pointer to the initial size of the buffer allocated
+ *             to hold prefetched keys
+ * \return \herr_t
+ *
+ * \details H5Pget_map_iterate() returns the map iterate hints, \p key_prefetch_size
+ *          and \p key_alloc_size, as set by H5Pset_map_iterate_hints().
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Pget_map_iterate_hints(hid_t mapl_id, size_t *key_prefetch_size /*out*/,
+                                       size_t *key_alloc_size /*out*/);
+#endif /*  H5_HAVE_MAP_API */
+
+/**
+ * \ingroup ACPL
+ *
+ * \brief  Retrieves the character encoding used to create a link or
+ *         attribute name
+ *
+ * \param[in]  plist_id  Link creation or attribute creation property list
+ *                       identifier
+ * \param[out] encoding  String encoding character set
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_char_encoding() retrieves the character encoding used
+ *          to encode link or attribute names that are created with the
+ *          property list \p plist_id.
+ *
+ *          Valid values for \p encoding are defined in H5Tpublic.h and
+ *          include the following:
+ *
+ * \csets
+ *
+ * \note H5Pget_char_encoding() retrieves the character set used for an
+ *       HDF5 link or attribute name while H5Tget_cset() retrieves the
+ *       character set used in a character or string datatype.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_char_encoding(hid_t plist_id, H5T_cset_t *encoding /*out*/);
+/**
+ * \ingroup ACPL
+ *
+ * \brief Sets the character encoding used to encode link and attribute
+ *        names
+ *
+ * \param[in] plist_id Link creation or attribute creation property list
+ *                     identifier
+ * \param[in] encoding String encoding character set
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_char_encoding() sets the character encoding used for
+ *          the names of links (which provide the names by which objects
+ *          are referenced) or attributes created with the property list
+ *          \p plist_id.
+ *
+ *           Valid values for encoding include the following:
+ * \csets
+ * \details For example, if the character set for the property list
+ *          \p plist_id is set to #H5T_CSET_UTF8, link names pointing to
+ *          objects created with the link creation property list
+ *          \p plist_id will be encoded using the UTF-8 character set.
+ *          Similarly, names of attributes created with the attribute
+ *          creation property list \p plist_id will be encoded as UTF-8.
+ *
+ *          ASCII and UTF-8 Unicode are the only currently supported
+ *          character encodings. Extended ASCII encodings (for example,
+ *          ISO 8859) are not supported. This encoding policy is not
+ *          enforced by the HDF5 library. Using encodings other than
+ *          ASCII and UTF-8 can lead to compatibility and usability
+ *          problems.
+ *
+ * \note H5Pset_char_encoding() sets the character set used for an
+ *       HDF5 link or attribute name while H5Tset_cset() sets the
+ *       character set used in a character or string datatype.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_char_encoding(hid_t plist_id, H5T_cset_t encoding);
+
+/**
+ * \ingroup LAPL
+ *
+ * \brief Retrieves the external link traversal file access flag from the
+ *        specified link access property list
+ *
+ * \lapl_id
+ * \param[out] flags File access flag for link traversal
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_elink_acc_flags() retrieves the file access flag used
+ *          to open an external link target file from the specified link
+ *          access property list.
+ *
+ *          Valid values for \p flags include:
+ *          \li #H5F_ACC_RDWR - Files opened through external links will
+ *                             be opened with write access
+ *          \li #H5F_ACC_RDONLY - Files opened through external links will
+ *                               be opened with read-only access
+ *          \li #H5F_ACC_DEFAULT - Files opened through external links will
+ *                                be opened with the same access flag as
+ *                                the parent file
+ *
+ *          The value returned, if it is not #H5F_ACC_DEFAULT, will
+ *          override the default access flag, which is the access flag
+ *          used to open the parent file.
+ *
+ *       <b>Example Usage:</b>
+ *       The following code retrieves the external link access flag
+ *       settings on the link access property list \p lapl_id into a
+ *       local variable:
+ *       <pre>
+ *         unsigned acc_flags;
+ *         status = H5Pget_elink_acc_flags(lapl_id, &acc_flags);
+ *       </pre>
+ *
+ * \since 1.8.3
+ *
+ */
+H5_DLL herr_t H5Pget_elink_acc_flags(hid_t lapl_id, unsigned *flags);
+/**
+ * \ingroup LAPL
+ *
+ * \brief Retrieves the external link traversal callback function from the
+ *        specified link access property list
+ *
+ * \lapl_id
+ * \param[out] func    User-defined external link traversal callback
+ *                     function
+ * \param[out] op_data User-defined input data for the callback function
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_elink_cb() retrieves the user-defined external link
+ *          traversal callback function defined in the specified link
+ *          access property list.
+ *
+ *          The callback function may adjust the file access property
+ *          list and file access flag to use when opening a file through
+ *          an external link. The callback will be executed by the HDF5
+ *          library immediately before opening the target file.
+ *
+ *       <b>Failure Modes:</b> H5Pget_elink_cb() will fail if the link
+ *       access property list identifier, \p lapl_id, is invalid.
+ *
+ *       An invalid function pointer or data pointer, \p func or
+ *       \p op_data respectively, may cause a segmentation fault or an
+ *       invalid memory access.
+ *
+ *       <b>Example Usage:</b> The following code retrieves the external
+ *       link callback settings on the link access property list
+ *       \p lapl_id into local variables:
+ *       <pre>
+ *       H5L_elink_traverse_t elink_callback_func;
+ *       void *elink_callback_udata;
+ *       status = H5Pget_elink_cb (lapl_id, &elink_callback_func,
+ *                                 &elink_callback_udata);
+ *       </pre>
+ *
+ * \since 1.8.3
+ *
+ */
+H5_DLL herr_t H5Pget_elink_cb(hid_t lapl_id, H5L_elink_traverse_t *func, void **op_data);
+/**
+ * \ingroup LAPL
+ *
+ * \brief Retrieves the file access property list identifier associated
+ *        with the link access property list
+ *
+ * \lapl_id
+ *
+ * \return \hid_t{file access property list}
+ *
+ * \details H5Pget_elink_fapl() retrieves the file access property list
+ *          identifier that is set for the link access property list
+ *          identifier, \p lapl_id. The library uses this file access
+ *          property list identifier to open the target file for the
+ *          external link access. When no such identifier is set, this
+ *          routine returns #H5P_DEFAULT.
+ *
+ * \see H5Pset_elink_fapl() and H5Lcreate_external().
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Pget_elink_fapl(hid_t lapl_id);
+/**
+ * \ingroup LAPL
+ *
+ * \brief Retrieves prefix applied to external link paths
+ *
+ * \lapl_id{plist_id}
+ * \param[out] prefix Prefix applied to external link paths
+ * \param[in]  size   Size of prefix, including null terminator
+ *
+ * \return If successful, returns a non-negative value specifying the size
+ *         in bytes of the prefix without the NULL terminator; otherwise
+ *         returns a negative value.
+ *
+ * \details H5Pget_elink_prefix() retrieves the prefix applied to the
+ *          path of any external links traversed.
+ *
+ *          When an external link is traversed, the prefix is retrieved
+ *          from the link access property list \p plist_id, returned in
+ *          the user-allocated buffer pointed to by \p prefix, and
+ *          prepended to the filename stored in the external link.
+ *
+ *          The size in bytes of the prefix, including the NULL terminator,
+ *          is specified in \p size. If size is unknown, a preliminary
+ *          H5Pget_elink_prefix() call with the pointer \p prefix set to
+ *          NULL will return the size of the prefix without the NULL
+ *          terminator.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL ssize_t H5Pget_elink_prefix(hid_t plist_id, char *prefix, size_t size);
+/**
+ * \ingroup LAPL
+ *
+ * \brief Retrieves the maximum number of link traversals
+ *
+ * \lapl_id{plist_id}
+ * \param[out] nlinks Maximum number of links to traverse
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_nlinks() retrieves the maximum number of soft or
+ *          user-defined link traversals allowed, \p nlinks, before the
+ *          library assumes it has found a cycle and aborts the traversal.
+ *          This value is retrieved from the link access property list
+ *          \p plist_id.
+ *
+ *          The limit on the number of soft or user-defined link traversals
+ *          is designed to terminate link traversal if one or more links
+ *          form a cycle. User control is provided because some files may
+ *          have legitimate paths formed of large numbers of soft or
+ *          user-defined links. This property can be used to allow
+ *          traversal of as many links as desired.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_nlinks(hid_t plist_id, size_t *nlinks);
+/**
+ * \ingroup LAPL
+ *
+ * \brief Sets the external link traversal file access flag in a link
+ *        access property list
+ *
+ * \lapl_id
+ * \param[in] flags The access flag for external link traversal
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_elink_acc_flags() specifies the file access flag to use
+ *          to open the target file of an external link. This allows
+ *          read-only access of files reached through an external link in
+ *          a file opened with write access, or vice-versa.
+ *
+ *          Valid values for \p flags include:
+ *          \li #H5F_ACC_RDWR - Causes files opened through external links
+ *               to be opened with write access
+ *          \li #H5F_ACC_RDONLY - Causes files opened through external
+ *              links to be opened with read-only access
+ *          \li #H5F_ACC_DEFAULT - Removes any external link file access
+ *              flag setting from \p lapl_id, causing the file access flag
+ *              setting to be taken from the parent file
+ *
+ *          The library will normally use the file access flag used to
+ *          open the parent file as the file access flag for the target
+ *          file. This function provides a way to override that behavior.
+ *          The external link traversal callback function set by
+ *          H5Pset_elink_cb() can override the setting from
+ *          H5Pset_elink_acc_flags().
+ *
+ *       <b>Motivation:</b> H5Pset_elink_acc_flags() is used to adjust the
+ *       file access flag used to open files reached through external links.
+ *       This may be useful to, for example, prevent modifying files
+ *       accessed through an external link. Otherwise, the target file is
+ *       opened with whatever flag was used to open the parent.
+ *
+ *       <b>Example Usage:</b> The following code sets the link access
+ *       property list \p lapl_id to open external link target files with
+ *       read-only access:
+ *        <pre>
+ *         status = H5Pset_elink_acc_flags(lapl_id, H5F_ACC_RDONLY);
+ *        </pre>
+ *
+ * \since 1.8.3
+ *
+ */
+H5_DLL herr_t H5Pset_elink_acc_flags(hid_t lapl_id, unsigned flags);
+/**
+ * \ingroup LAPL
+ *
+ * \brief Sets the external link traversal callback function in a link
+ *        access property list
+ *
+ * \lapl_id
+ * \param[in] func    User-defined external link traversal callback
+ *                    function
+ * \param[in] op_data User-defined input data for the callback function
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_elink_cb() sets a user-defined external link traversal
+ *          callback function in the link access property list \p lapl_id.
+ *          The callback function \p func must conform to the prototype
+ *          specified in #H5L_elink_traverse_t.
+ *
+ *          The callback function may adjust the file access property
+ *          list and file access flags to use when opening a file through
+ *          an external link. The callback will be executed by the HDF5
+ *          library immediately before opening the target file.
+ *
+ *          The callback will be made after the file access property list
+ *          set by H5Pset_elink_fapl() and the file access flag set by
+ *          H5Pset_elink_acc_flags() are applied, so changes made by this
+ *          callback function will take precedence.
+ *
+ * \attention A file close degree property setting (H5Pset_fclose_degree())
+ *            in this callback function or an associated property list will
+ *            be ignored. A file opened by means of traversing an external
+ *            link is always opened with the weak file close degree
+ *            property setting, #H5F_CLOSE_WEAK.
+ *
+ *       <b>Motivation:</b> H5Pset_elink_cb() is used to specify a
+ *       callback function that is executed by the HDF5 library when
+ *       traversing an external link. This provides a mechanism to set
+ *       specific access permissions, modify the file access property
+ *       list, modify the parent or target file, or take any other
+ *       user-defined action. This callback function is used in
+ *       situations where the HDF5 library's default behavior is not
+ *       suitable.
+ *
+ *       <b>Failure Modes:</b> H5Pset_elink_cb() will fail if the link
+ *       access property list identifier, \p lapl_id, is invalid or if
+ *       the function pointer, \p func, is NULL.
+ *
+ *       An invalid function pointer, \p func, will cause a segmentation
+ *       fault or other failure when an attempt is subsequently made to
+ *       traverse an external link.
+ *
+ *       <b>Example Usage:</b>
+ *       This example defines a callback function that prints the name
+ *       of the target file every time an external link is followed, and
+ *       sets this callback function on \p lapl_id.
+ *       <pre>
+ *          herr_t elink_callback(const char *parent_file_name, const char
+ *                 *parent_group_name, const char *child_file_name, const char
+ *                 *child_object_name, unsigned *acc_flags, hid_t fapl_id, void *op_data) {
+ *              puts(child_file_name);
+ *              return 0;
+ *          }
+ *          int main(void) {
+ *              hid_t lapl_id = H5Pcreate(H5P_LINK_ACCESS);
+ *              H5Pset_elink_cb(lapl_id, elink_callback, NULL);
+ *                ...
+ *          }
+ *          </pre>
+ *
+ *
+ * \since 1.8.3
+ *
+ */
+H5_DLL herr_t H5Pset_elink_cb(hid_t lapl_id, H5L_elink_traverse_t func, void *op_data);
+/**
+ * \ingroup LAPL
+ *
+ * \brief Sets a file access property list for use in accessing a file
+ *        pointed to by an external link
+ *
+ * \lapl_id
+ * \fapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_elink_fapl() sets the file access property list,
+ *          \p fapl_id, to be used when accessing the target file of an
+ *          external link associated with \p lapl_id.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_elink_fapl(hid_t lapl_id, hid_t fapl_id);
+/**
+ * \ingroup LAPL
+ *
+ * \brief Sets prefix to be applied to external link paths
+ *
+ * \lapl_id{plist_id}
+ * \param[in] prefix Prefix to be applied to external link paths
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_elink_prefix() sets the prefix to be applied to the
+ *          path of any external links traversed. The prefix is prepended
+ *          to the filename stored in the external link.
+ *
+ *          The prefix is specified in the user-allocated buffer \p prefix
+ *          and set in the link access property list \p plist_id. The buffer
+ *          should not be freed until the property list has been closed.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_elink_prefix(hid_t plist_id, const char *prefix);
+/**
+ * \ingroup LAPL
+ *
+ * \brief Sets maximum number of soft or user-defined link traversals
+ *
+ * \lapl_id{plist_id}
+ * \param[in] nlinks Maximum number of links to traverse
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_nlinks() sets the maximum number of soft or user-defined
+ *          link traversals allowed, \p nlinks, before the library assumes
+ *          it has found a cycle and aborts the traversal. This value is
+ *          set in the link access property list \p plist_id.
+ *
+ *          The limit on the number of soft or user-defined link traversals
+ *          is designed to terminate link traversal if one or more links
+ *          form a cycle. User control is provided because some files may
+ *          have legitimate paths formed of large numbers of soft or
+ *          user-defined links. This property can be used to allow
+ *          traversal of as many links as desired.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_nlinks(hid_t plist_id, size_t nlinks);
+
+/* Object copy property list (OCPYPL) routines */
+/**
+ * \ingroup OCPYPL
+ *
+ * \brief Adds a path to the list of paths that will be searched in the
+ *        destination file for a matching committed datatype
+ *
+ * \param[in] plist_id Object copy property list identifier
+ * \param[in] path     The path to be added
+ *
+ * \return \herr_t
+ *
+ * \details H5Padd_merge_committed_dtype_path() adds a path, \p path,
+ *          which points to a committed datatype, to the current list of
+ *          suggested paths stored in the object copy property list
+ *          \p plist_id. The search as described in the next paragraph is
+ *          effective only if the #H5O_COPY_MERGE_COMMITTED_DTYPE_FLAG is
+ *          enabled in the object copy property list via
+ *          H5Pset_copy_object().
+ *
+ *          When copying a committed datatype, a dataset with a committed
+ *          datatype, or an object with an attribute of a committed
+ *          datatype, the default behavior of H5Ocopy() is to search for
+ *          a matching committed datatype:
+ *          <ol>
+ *          <li> First search the list of suggested paths in the object
+ *               copy property list.</li>
+ *          <li> Then, if no match has been found, search all the committed
+ *               datatypes in the destination file.
+ *          </ol>
+ *          The default Step 2 in this search process can be changed by
+ *          setting a callback function (see H5Pset_mcdt_search_cb()).
+ *
+ *          Two datatypes are determined equal if their descriptions are
+ *          identical, in a manner similar to H5Tequal(). If either
+ *          committed datatype has one or more attributes, then all
+ *          attributes must be present in both committed datatypes and they
+ *          must be identical. Two attributes are considered identical if
+ *          their datatype description, dataspace, and raw data values are
+ *          the same. However, if an attribute uses a committed datatype,
+ *          that committed datatype's attributes will not be compared.
+ *
+ *          If a match is found, H5Ocopy() will perform the following in
+ *          the destination file:
+ *          \li For a committed datatype, the library will create a hard
+ *              link to the found datatype.
+ *          \li For a dataset that uses a committed datatype, the library
+ *              will modify the copied dataset to use the found committed
+ *              datatype as its datatype.
+ *          \li For an object with an attribute of a committed datatype,
+ *              the library will modify the copied object's attribute to
+ *              use the found committed datatype as its datatype.
+ *
+ *          If no match is found, H5Ocopy() will perform the following in
+ *          the destination file:
+ *          \li For a committed datatype, the library will copy it as it
+ *              would any other object, creating a named committed
+ *              datatype at the destination. That is, the library will
+ *              create a committed datatype that is accessible in the
+ *              file by a unique path.
+ *          \li For a dataset that uses a committed datatype, the
+ *              library will copy the datatype as an anonymous
+ *              committed datatype and use that as the dataset's
+ *              datatype.
+ *          \li For an object with an attribute of a committed datatype,
+ *              the library will copy the datatype as an anonymous
+ *              committed datatype and use that as the attribute's
+ *              datatype.
+ *
+ *      \b Motivation: H5Padd_merge_committed_dtype_path() provides a
+ *       means to override the default behavior of H5Ocopy() when
+ *       #H5O_COPY_MERGE_COMMITTED_DTYPE_FLAG is set in an object
+ *       copy property list.
+ *       H5Padd_merge_committed_dtype_path() is the mechanism for
+ *       suggesting search paths where H5Ocopy() will look for a
+ *       matching committed datatype. This can be substantially
+ *       faster than the default approach of searching the entire
+ *       destination file for a match.
+ *
+ *       \b Example \b Usage: This example adds two paths to the object
+ *          copy property list. H5Ocopy() will search the two suggested
+ *          paths for a match before searching all the committed datatypes
+ *          in the destination file.
+ *
+ *     <pre>
+ *     int main(void) {
+ *     hid_t ocpypl_id = H5Pcreate(H5P_OBJECT_COPY);
+ *
+ *        H5Pset_copy_object(ocpypl_id, H5O_COPY_MERGE_COMMITTED_DTYPE_FLAG);
+ *        H5Padd_merge_committed_dtype_path(ocpypl_id, "/group/committed_dtypeA");
+ *        H5Padd_merge_committed_dtype_path(ocpypl_id, "/group2/committed_dset");
+ *        H5Ocopy(...ocpypl_id...);
+ *        ...
+ *        ...
+ *     }
+ *     </pre>
+ *
+ * \note H5Padd_merge_committed_dtype_path() will fail if the object
+ *       copy property list is invalid.
+ *       It will also fail if there is insufficient memory when
+ *       duplicating \p path.
+ *
+ * \see
+ *    \li H5Ocopy()
+ *    \li #H5O_mcdt_search_cb_t
+ *    \li H5Padd_merge_committed_dtype_path()
+ *    \li H5Pfree_merge_committed_dtype_paths()
+ *    \li H5Pget_mcdt_search_cb()
+ *    \li H5Pset_copy_object()
+ *    \li H5Pset_mcdt_search_cb()
+ *    \li \ref_h5ocopy
+ *
+ * \since 1.8.9
+ *
+ */
+H5_DLL herr_t H5Padd_merge_committed_dtype_path(hid_t plist_id, const char *path);
+/**
+ * \ingroup OCPYPL
+ *
+ * \brief Clears the list of paths stored in the object copy property list
+ *
+ * \param[in] plist_id Object copy property list identifier
+ *
+ * \return \herr_t
+ *
+ * \details H5Pfree_merge_committed_dtype_paths() clears the suggested
+ *          paths stored in the object copy property list \p plist_id.
+ *          These are the suggested paths previously set with
+ *          H5Padd_merge_committed_dtype_path().
+ *
+ *          \b Example \b Usage: This example adds a suggested path to the
+ *          object copy property list, does the copy, clears the list, and
+ *          then adds a new suggested path to the list for another copy.
+ *
+ *       <pre>
+ *       int main(void) {
+ *           hid_t ocpypl_id = H5Pcreate(H5P_OBJECT_COPY);
+ *
+ *           H5Pset_copy_object(ocpypl_id, H5O_COPY_MERGE_COMMITTED_DTYPE_FLAG);
+ *           H5Padd_merge_committed_dtype_path(ocpypl_id, "/group/committed_dtypeA");
+ *           H5Ocopy(...ocpypl_id...);
+ *           ...
+ *           ...
+ *           H5Pfree_merge_committed_dtype_paths(ocpypl_id);
+ *           H5Padd_merge_committed_dtype_path(ocpypl_id, "/group2/committed_dtypeB");
+ *           H5Ocopy(...ocpypl_id...);
+ *           ...
+ *           ...
+ *       }
+ *       </pre>
+ *
+ * \note H5Pfree_merge_committed_dtype_paths() will fail if the
+ *       object copy property list is invalid.
+ *
+ * \see
+ *    \li H5Ocopy()
+ *    \li #H5O_mcdt_search_cb_t
+ *    \li H5Padd_merge_committed_dtype_path()
+ *    \li H5Pfree_merge_committed_dtype_paths()
+ *    \li H5Pget_mcdt_search_cb()
+ *    \li H5Pset_copy_object()
+ *    \li H5Pset_mcdt_search_cb()
+ *
+ * \since 1.8.9
+ *
+ */
+H5_DLL herr_t H5Pfree_merge_committed_dtype_paths(hid_t plist_id);
+/**
+ * \ingroup OCPYPL
+ *
+ * \brief Retrieves the properties to be used when an object is copied
+ *
+ * \param[in]  plist_id     Object copy property list identifier
+ * \param[out] copy_options Copy option(s) set in the object copy property
+ *                          list
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_copy_object() retrieves the properties currently
+ *          specified in the object copy property list \p plist_id, which
+ *          will be invoked when a new copy is made of an existing object.
+ *
+ *          \p copy_options is a bit map indicating the flags, or
+ *          properties, governing object copying that are set in the
+ *          property list \p plist_id.
+ *
+ *          The available flags are described in H5Pset_copy_object().
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pget_copy_object(hid_t plist_id, unsigned *copy_options /*out*/);
+/**
+ * \ingroup OCPYPL
+ *
+ * \brief Retrieves the callback function from the specified object copy
+ *        property list
+ *
+ * \param[in]  plist_id     Object copy property list identifier
+ * \param[out] func         User-defined callback function
+ * \param[out] op_data      User-defined data for the callback
+ *                          function
+ *
+ * \return \herr_t
+ *
+ * \details H5Pget_mcdt_search_cb() retrieves the user-defined callback
+ *          function and the user data that are set via
+ *          H5Pset_mcdt_search_cb() in the object copy property list
+ *          \p plist_id.
+ *
+ *          The callback function will be returned in the parameter \p func
+ *          and the user data will be returned in the parameter \p op_data.
+ *
+ * \note H5Pget_mcdt_search_cb() will fail if the object copy property
+ *       list is invalid.
+ *
+ * \see
+ *    \li H5Ocopy()
+ *    \li #H5O_mcdt_search_cb_t
+ *    \li H5Padd_merge_committed_dtype_path()
+ *    \li H5Pfree_merge_committed_dtype_paths()
+ *    \li H5Pget_mcdt_search_cb()
+ *    \li H5Pset_copy_object()
+ *    \li H5Pset_mcdt_search_cb()
+ *    \li \ref_h5ocopy
+ *
+ * \since 1.8.9
+ *
+ */
+H5_DLL herr_t H5Pget_mcdt_search_cb(hid_t plist_id, H5O_mcdt_search_cb_t *func, void **op_data);
+/**
+ * \ingroup OCPYPL
+ *
+ * \brief Sets properties to be used when an object is copied
+ *
+ * \param[in]  plist_id     Object copy property list identifier
+ * \param[out] copy_options Copy option(s) to be set
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_copy_object() sets properties in the object copy
+ *          property list \p plist_id. When an existing object is copied,
+ *          that property list will determine how the new copy is created.
+ *
+ *          The following flags are available for use in an object copy
+ *          property list:
+ *
+ *          <table>
+ *           <tr>
+ *            <td>#H5O_COPY_SHALLOW_HIERARCHY_FLAG</td>
+ *            <td>Copy only immediate members of a group<br />
+ *                <em>Default behavior, without flag:</em> Recursively
+ *                copy all objects in and below the group.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5O_COPY_EXPAND_SOFT_LINK_FLAG</td>
+ *            <td>Expand soft links into new objects<br />
+ *                <em>Default behavior, without flag:</em> Copy soft
+ *                links as they are.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5O_COPY_EXPAND_EXT_LINK_FLAG</td>
+ *            <td>Expand external link into new objects<br />
+ *                <em>Default behavior, without flag:</em> Copy external
+ *                    links as they are.</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5O_COPY_EXPAND_REFERENCE_FLAG</td>
+ *            <td>Copy objects that are pointed to by references and
+ *                update reference values in destination file<br />
+ *                <em>Default behavior, without flag:</em> Set reference
+ *                    values in destination file to zero (0)</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5O_COPY_WITHOUT_ATTR_FLAG</td>
+ *            <td>Copy object without copying attributes<br />
+ *                <em>Default behavior, without flag:</em> Copy object
+ *                    with all its attributes</td>
+ *           </tr>
+ *           <tr>
+ *            <td>#H5O_COPY_MERGE_COMMITTED_DTYPE_FLAG</td>
+ *            <td>Use a matching committed datatype in the destination
+ *                file when copying a committed datatype, a dataset with
+ *                a committed datatype, or an object with an attribute
+ *                of committed datatype <br />
+ *                <em>Default behavior without flag:</em>
+ *
+ *                \li A committed datatype in the source will be copied to
+ *                    the destination as a committed datatype.
+ *                \li If a dataset in the source uses a committed
+ *                    datatype or an object in the source has an attribute
+ *                    of a committed datatype, that committed datatype will
+ *                    be written to the destination as an anonymous
+ *                    committed datatype.
+ *                    If copied in a single H5Ocopy() operation, objects
+ *                    that share a committed datatype in the source will
+ *                    share an anonymous committed datatype in the
+ *                    destination copy. Subsequent H5Ocopy() operations,
+ *                    however, will be unaware of prior anonymous committed
+ *                    datatypes and will create new ones.
+ *
+ *                    See the See Also section immediately below for
+ *                    functions related to the use of this flag.</td>
+ *           </tr>
+ *          </table>
+ *
+ * \see
+ *    Functions and a callback function used to tune committed datatype
+ *    copying behavior:
+ *    \li #H5O_mcdt_search_cb_t
+ *    \li H5Padd_merge_committed_dtype_path()
+ *    \li H5Pfree_merge_committed_dtype_paths()
+ *    \li H5Pget_mcdt_search_cb()
+ *    \li H5Pset_copy_object()
+ *    \li H5Pset_mcdt_search_cb()
+ *    \li \ref_h5ocopy
+ *
+ * \version 1.8.9 #H5O_COPY_MERGE_COMMITTED_DTYPE_FLAG added in this release.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Pset_copy_object(hid_t plist_id, unsigned copy_options);
+/**
+ * \ingroup OCPYPL
+ *
+ * \brief Sets the callback function that H5Ocopy() will invoke before
+ *        searching the entire destination file for a matching committed
+ *        datatype
+ *
+ * \param[in] plist_id Object copy property list identifier
+ * \param[in] func     User-defined callback function
+ * \param[in] op_data  User-defined input data for the callback function
+ *
+ * \return \herr_t
+ *
+ * \details H5Pset_mcdt_search_cb() allows an application to set a
+ *          callback function, \p func, that will be invoked before
+ *          searching the destination file for a matching committed
+ *          datatype. The default, global search process is described in
+ *          H5Padd_merge_committed_dtype_path().
+ *
+ *          The callback function must conform to the #H5O_mcdt_search_cb_t
+ *          prototype and will return an instruction for one of the
+ *          following actions:
+ *
+ *          \li Continue the search for a matching committed datatype in
+ *              the destination file.
+ *          \li Discontinue the search for a matching committed datatype.
+ *              H5Ocopy() will then apply the default behavior of creating
+ *              an anonymous committed datatype.
+ *          \li Abort the copy operation and exit H5Ocopy().
+ *
+ *       \b Motivation: H5Pset_mcdt_search_cb() provides the means to
+ *       define a callback function. An application can then use that
+ *       callback to take an additional action before the default search
+ *       of all committed datatypes in the destination file or to take an
+ *       action that replaces the default search. This mechanism is
+ *       intended to improve performance when the global search might
+ *       take a long time.
+ *
+ * \b Example \b Usage: This example defines a callback function in
+ * the object copy property list.
+ *
+ * <pre>
+ * static H5O_mcdt_search_ret_t
+ * mcdt_search_cb(void *_udata)
+ * {
+ *     H5O_mcdt_search_ret_t action = *((H5O_mcdt_search_ret_t *)_udata);
+ *
+ *      return(action);
+ *  }
+ *
+ *  int main(void) {
+ *      hid_t ocpypl_id = H5Pcreate(H5P_OBJECT_COPY);
+ *
+ *      H5Pset_copy_object(ocpypl_id, H5O_COPY_MERGE_COMMITTED_DTYPE_FLAG);
+ *      H5Padd_merge_committed_dtype_path(ocpypl_id, "/group/committed_dtypeA");
+ *
+ *      action = H5O_MCDT_SEARCH_STOP;
+ *      H5Pset_mcdt_search_cb(ocpypl_id, mcdt_search_cb, &action);
+ *      H5Ocopy(...ocpypl_id...);
+ *      ...
+ *      ...
+ * }
+ * </pre>
+ *
+ * \note H5Pset_mcdt_search_cb() will fail if the
+ *       object copy property list is invalid.
+ *
+ * \warning If the callback function return value causes H5Ocopy() to
+ *          abort, the destination file may be left in an inconsistent or
+ *          corrupted state.
+ *
+ * \see
+ *    \li H5Ocopy()
+ *    \li #H5O_mcdt_search_cb_t
+ *    \li H5Padd_merge_committed_dtype_path()
+ *    \li H5Pfree_merge_committed_dtype_paths()
+ *    \li H5Pget_mcdt_search_cb()
+ *    \li H5Pset_copy_object()
+ *    \li H5Pset_mcdt_search_cb()
+ *    \li \ref_h5ocopy
+ *
+ * \since 1.8.9
+ *
+ */
+H5_DLL herr_t H5Pset_mcdt_search_cb(hid_t plist_id, H5O_mcdt_search_cb_t func, void *op_data);
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+
+/* We renamed the "root" of the property list class hierarchy */
+#define H5P_NO_CLASS H5P_ROOT
+
+/* Typedefs */
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Registers a permanent property with a property list class
+ *
+ * \plistcls_id{cls_id}
+ * \param[in] name       Name of property to register
+ * \param[in] size       Size of property in bytes
+ * \param[in] def_value  Default value for property in newly created
+ *                       property lists
+ * \param[in] prp_create Callback routine called when a property list is
+ *                       being created and the property value will be
+ *                       initialized
+ * \param[in] prp_set    Callback routine called before a new value is
+ *                       copied into the property's value
+ * \param[in] prp_get    Callback routine called when a property value is
+ *                       retrieved from the property
+ * \param[in] prp_del    Callback routine called when a property is deleted
+ *                       from a property list
+ * \param[in] prp_copy   Callback routine called when a property is copied
+ *                       from a property list
+ * \param[in] prp_close  Callback routine called when a property list is
+ *                       being closed and the property value will be
+ *                       disposed of
+ *
+ * \return  \herr_t
+ *
+ * \deprecated As of HDF5-1.8 this function was deprecated in favor of
+ *             H5Pregister2() or the macro H5Pregister().
+ *
+ * \details H5Pregister1() registers a new property with a property list
+ *          class. The property will exist in all property list objects
+ *          of that class after this routine is finished.  The name of
+ *          the property must not already exist.  The default property
+ *          value must be provided and all new property lists created
+ *          with this property will have the property value set to the
+ *          default provided.  Any of the callback routines may be set
+ *          to NULL if they are not needed.
+ *
+ *          Zero-sized properties are allowed and do not store any data in
+ *          the property list. These may be used as flags to indicate the
+ *          presence or absence of a particular piece of information. The
+ *          default pointer for a zero-sized property may be set to NULL.
+ *          The property \p prp_create and \p prp_close callbacks are called for
+ *          zero-sized properties, but the \p prp_set and \p prp_get callbacks
+ *          are never called.
+ *
+ *          The \p prp_create routine is called when a new property list with
+ *          this property is being created. The #H5P_prp_create_func_t
+ *          callback function is defined as #H5P_prp_cb1_t.
+ *
+ *          The \p prp_create routine may modify the value to be set and those
+ *          changes will be stored as the initial value of the property.
+ *          If the \p prp_create routine returns a negative value, the new
+ *          property value is not copied into the property and the
+ *          \p prp_create routine returns an error value.
+ *
+ *          The \p prp_set routine is called before a new value is copied into
+ *          the property. The #H5P_prp_set_func_t callback function is defined
+ *          as #H5P_prp_cb2_t.
+ *
+ *          The \p prp_set routine may modify the value pointer to be set and
+ *          those changes will be used when setting the property's value.
+ *          If the \p prp_set routine returns a negative value, the new property
+ *          value is not copied into the property and the \p prp_set routine
+ *          returns an error value. The \p prp_set routine will not be called
+ *          for the initial value; only the \p prp_create routine will be
+ *          called.
+ *
+ *          \b Note: The \p prp_set callback function may be useful to range
+ *          check the value being set for the property or may perform some
+ *          transformation or translation of the value set. The \p prp_get
+ *          callback would then reverse the transformation or translation.
+ *          A single \p prp_get or \p prp_set callback could handle multiple
+ *          properties by performing different actions based on the property
+ *          name or other properties in the property list.
+ *
+ *          The \p prp_get routine is called when a value is retrieved from a
+ *          property value. The #H5P_prp_get_func_t callback function is
+ *          defined as #H5P_prp_cb2_t.
+ *
+ *          The \p prp_get routine may modify the value to be returned from the
+ *          query and those changes will be returned to the calling routine.
+ *          If the \p prp_set routine returns a negative value, the query
+ *          routine returns an error value.
+ *
+ *          The \p prp_del routine is called when a property is being
+ *          deleted from a property list. The #H5P_prp_delete_func_t
+ *          callback function is defined as #H5P_prp_cb2_t.
+ *
+ *          The \p prp_del routine may modify the value passed in, but the
+ *          value is not used by the library when the \p prp_del routine
+ *          returns. If the \p prp_del routine returns a negative value,
+ *          the property list deletion routine returns an error value but
+ *          the property is still deleted.
+ *
+ *          The \p prp_copy routine is called when a new property list with
+ *          this property is being created through a \p prp_copy operation.
+ *          The #H5P_prp_copy_func_t callback function is defined as
+ *          #H5P_prp_cb1_t.
+ *
+ *          The \p prp_copy routine may modify the value to be set and those
+ *          changes will be stored as the new value of the property. If
+ *          the \p prp_copy routine returns a negative value, the new
+ *          property value is not copied into the property and the \p prp_copy
+ *          routine returns an error value.
+ *
+ *          The \p prp_close routine is called when a property list with this
+ *          property is being closed. The #H5P_prp_close_func_t callback
+ *          function is defined as #H5P_prp_cb1_t.
+ *
+ *          The \p prp_close routine may modify the value passed in, but the
+ *          value is not used by the library when the \p prp_close routine
+ *          returns. If the \p prp_close routine returns a negative value, the
+ *          property list close routine returns an error value but the property
+ *          list is still closed.
+ *
+ *          The #H5P_prp_cb1_t is as follows:
+ *          \snippet this H5P_prp_cb1_t_snip
+ *
+ *          The #H5P_prp_cb2_t is as follows:
+ *          \snippet this H5P_prp_cb2_t_snip
+ *
+ */
+
+/* Function prototypes */
+H5_DLL herr_t H5Pregister1(hid_t cls_id, const char *name, size_t size, void *def_value,
+                           H5P_prp_create_func_t prp_create, H5P_prp_set_func_t prp_set,
+                           H5P_prp_get_func_t prp_get, H5P_prp_delete_func_t prp_del,
+                           H5P_prp_copy_func_t prp_copy, H5P_prp_close_func_t prp_close);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Registers a temporary property with a property list
+ *
+ * \plist_id
+ * \param[in] name       Name of property to create
+ * \param[in] size       Size of property in bytes
+ * \param[in] value      Initial value for the property
+ * \param[in] prp_set    Callback routine called before a new value is copied
+ *                       into the property's value
+ * \param[in] prp_get    Callback routine called when a property value is
+ *                       retrieved from the property
+ * \param[in] prp_delete Callback routine called when a property is deleted
+ *                       from a property list
+ * \param[in] prp_copy   Callback routine called when a property is copied
+ *                       from an existing property list
+ * \param[in] prp_close  Callback routine called when a property list is
+ *                       being closed and the property value will be disposed
+ *                       of
+ *
+ * \return \herr_t
+ *
+ * \deprecated As of HDF5-1.8 this function was deprecated in favor of
+ *             H5Pinsert2() or the macro H5Pinsert().
+ *
+ * \details H5Pinsert1() creates a new property in a property
+ *          list. The property will exist only in this property list and
+ *          copies made from it.
+ *
+ *          The initial property value must be provided in \p value and
+ *          the property value will be set accordingly.
+ *
+ *          The name of the property must not already exist in this list,
+ *          or this routine will fail.
+ *
+ *          The \p prp_set and \p prp_get callback routines may be set to NULL
+ *          if they are not needed.
+ *
+ *          Zero-sized properties are allowed and do not store any data
+ *          in the property list. The default value of a zero-size
+ *          property may be set to NULL. They may be used to indicate the
+ *          presence or absence of a particular piece of information.
+ *
+ *          The \p prp_set routine is called before a new value is copied
+ *          into the property. The #H5P_prp_set_func_t callback function
+ *          is defined as #H5P_prp_cb2_t.
+ *          The \p prp_set routine may modify the value pointer to be set and
+ *          those changes will be used when setting the property's value.
+ *          If the \p prp_set routine returns a negative value, the new property
+ *          value is not copied into the property and the \p  set routine
+ *          returns an error value. The \p prp_set routine will be called for
+ *          the initial value.
+ *
+ *          \b Note: The \p prp_set callback function may be useful to range
+ *          check the value being set for the property or may perform some
+ *          transformation or translation of the value set. The \p prp_get
+ *          callback would then reverse the transformation or translation.
+ *          A single \p prp_get or \p prp_set callback could handle multiple
+ *          properties by performing different actions based on the
+ *          property name or other properties in the property list.
+ *
+ *          The \p prp_get routine is called when a value is retrieved from
+ *          a property value. The #H5P_prp_get_func_t callback function
+ *          is defined as #H5P_prp_cb2_t.
+ *
+ *          The \p prp_get routine may modify the value to be returned from
+ *          the query and those changes will be preserved. If the \p prp_get
+ *          routine returns a negative value, the query routine returns
+ *          an error value.
+ *
+ *          The \p prp_delete routine is called when a property is being
+ *          deleted from a property list. The #H5P_prp_delete_func_t
+ *          callback function is defined as #H5P_prp_cb2_t.
+ *
+ *          The \p prp_copy routine is called when a new property list with
+ *          this property is being created through a \p prp_copy operation.
+ *          The #H5P_prp_copy_func_t callback function is defined as
+ *          #H5P_prp_cb1_t.
+ *
+ *          The \p prp_copy routine may modify the value to be set and those
+ *          changes will be stored as the new value of the property. If the
+ *          \p prp_copy routine returns a negative value, the new property value
+ *          is not copied into the property and the prp_copy routine returns an
+ *          error value.
+ *
+ *          The \p prp_close routine is called when a property list with this
+ *          property is being closed.
+ *          The #H5P_prp_close_func_t callback function is defined as
+ *          #H5P_prp_cb1_t.
+ *
+ *          The \p prp_close routine may modify the value passed in, the
+ *          value is not used by the library when the close routine
+ *          returns. If the \p prp_close routine returns a negative value,
+ *          the property list \p prp_close routine returns an error value
+ *          but the property list is still closed.
+ *
+ *          \b Note: There is no \p prp_create callback routine for temporary
+ *          property list objects; the initial value is assumed to
+ *          have any necessary setup already performed on it.
+ *
+ *          The #H5P_prp_cb1_t is as follows:
+ *          \snippet this H5P_prp_cb1_t_snip
+ *
+ *          The #H5P_prp_cb2_t is as follows:
+ *          \snippet this H5P_prp_cb2_t_snip
+ *
+ */
+H5_DLL herr_t H5Pinsert1(hid_t plist_id, const char *name, size_t size, void *value,
+                         H5P_prp_set_func_t prp_set, H5P_prp_get_func_t prp_get,
+                         H5P_prp_delete_func_t prp_delete, H5P_prp_copy_func_t prp_copy,
+                         H5P_prp_close_func_t prp_close);
+/**
+ * \ingroup PLCRA
+ *
+ * \brief Encodes the property values in a property list into a binary
+ *        buffer
+ *
+ * \plist_id
+ * \param[out] buf    Buffer into which the property list will be encoded.
+ *                    If the provided buffer is NULL, the size of the
+ *                    buffer required is returned through \p nalloc; the
+ *                    function does nothing more.
+ * \param[out] nalloc The size of the required buffer
+ *
+ * \return \herr_t
+ *
+ * \deprecated  As of HDF5-1.12 this function has been deprecated in favor of
+ *              H5Pencode2() or the macro H5Pencode().
+ *
+ * \details H5Pencode1() encodes the property list \p plist_id into the
+ *          binary buffer \p buf.
+ *
+ *          If the required buffer size is unknown, \p buf can be passed
+ *          in as NULL and the function will set the required buffer size
+ *          in \p nalloc. The buffer can then be created and the property
+ *          list encoded with a subsequent H5Pencode1() call.
+ *
+ *          If the buffer passed in is not big enough to hold the encoded
+ *          properties, the H5Pencode1() call can be expected to fail with
+ *          a segmentation fault.
+ *
+ *          Properties that do not have encode callbacks will be skipped.
+ *          There is currently no mechanism to register an encode callback for
+ *          a user-defined property, so user-defined properties cannot currently
+ *          be encoded.
+ *
+ *          Some properties cannot be encoded, particularly properties that are
+ *          reliant on local context.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL herr_t H5Pencode1(hid_t plist_id, void *buf, size_t *nalloc);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Returns information about a filter in a pipeline (DEPRECATED)
+ *
+ *
+ *
+ * \plist_id{plist_id}
+ * \param[in] filter        Sequence number within the filter pipeline of
+ *                          the filter for which information is sought
+ * \param[out] flags        Bit vector specifying certain general properties
+ *                          of the filter
+ * \param[in,out] cd_nelmts Number of elements in \p cd_values
+ * \param[out] cd_values    Auxiliary data for the filter
+ * \param[in] namelen       Anticipated number of characters in \p name
+ * \param[out] name         Name of the filter
+ *
+ * \return Returns the filter identifier if successful;  Otherwise returns
+ *         a negative value. See: #H5Z_filter_t
+ *
+ * \deprecated When was this function deprecated?
+ *
+ * \details H5Pget_filter1() returns information about a filter, specified
+ *          by its filter number, in a filter pipeline, specified by the
+ *          property list with which it is associated.
+ *
+ *          \p plist_id must be a dataset or group creation property list.
+ *
+ *          \p filter is a value between zero and N-1, as described in
+ *          H5Pget_nfilters(). The function will return a negative value
+ *          if the filter number is out of range.
+ *
+ *          The structure of the \p flags argument is discussed in
+ *          H5Pset_filter().
+ *
+ *          On input, \p cd_nelmts indicates the number of entries in the
+ *          \p cd_values array, as allocated by the caller; on return,
+ *          \p cd_nelmts contains the number of values defined by the filter.
+ *
+ *          If \p name is a pointer to an array of at least \p namelen
+ *          bytes, the filter name will be copied into that array. The name
+ *          will be null terminated if \p namelen is large enough. The
+ *          filter name returned will be the name appearing in the file, the
+ *          name registered for the filter, or an empty string.
+ *
+ * \version 1.8.5 Function extended to work with group creation property
+ *                lists.
+ * \version 1.8.0 N-bit and scale-offset filters added.
+ * \version 1.8.0 Function H5Pget_filter() renamed to H5Pget_filter1() and
+ *                deprecated in this release.
+ * \version 1.6.4 \p filter parameter type changed to unsigned.
+ *
+ */
+H5_DLL H5Z_filter_t H5Pget_filter1(hid_t plist_id, unsigned filter, unsigned int *flags /*out*/,
+                                   size_t *cd_nelmts /*out*/, unsigned cd_values[] /*out*/, size_t namelen,
+                                   char name[]);
+/**
+ * \ingroup DCPL
+ *
+ * \brief Returns information about the specified filter
+ *
+ * \plist_id{plist_id}
+ * \param[in] id            Filter identifier
+ * \param[out] flags        Bit vector specifying certain general properties
+ *                          of the filter
+ * \param[in,out] cd_nelmts Number of elements in \p cd_values
+ * \param[out] cd_values    Auxiliary data for the filter
+ * \param[in] namelen       Anticipated number of characters in \p name
+ * \param[out] name         Name of the filter
+ *
+ *
+ * \return Returns a non-negative value if successful;  Otherwise returns
+ *         a negative value.
+ *
+ * \deprecated As of HDF5-1.8 this function was deprecated in favor of
+ *             H5Pget_filter_by_id2() or the macro H5Pget_filter_by_id().
+ *
+ * \details H5Pget_filter_by_id1() returns information about a filter, specified
+ *          in \p id, a filter identifier.
+ *
+ *          \p plist_id must be a dataset or group creation property list and
+ *          \p id must be in the associated filter pipeline.
+ *
+ *          The \p id and \p flags parameters are used in the same
+ *          manner as described in the discussion of H5Pset_filter().
+ *
+ *          Aside from the fact that they are used for output, the parameters
+ *          \p cd_nelmts and \p cd_values[] are used in the same manner as
+ *          described in the discussion of H5Pset_filter().
+ *          On input, the \p cd_nelmts parameter indicates the number of entries
+ *          in the \p cd_values[] array allocated by the calling program;
+ *          on exit it contains the number of values defined by the filter.
+ *
+ *          On input, the \p namelen parameter indicates the number of
+ *          characters allocated for the filter name by the calling program
+ *          in the array \p name[]. On exit \p name[] contains the name of the
+ *          filter with one character of the name in each element of the array.
+ *
+ *          If the filter specified in \p id is not set for the property
+ *          list, an error will be returned and this function will fail.
+ *
+ *
+ * \version 1.8.5 Function extended to work with group creation property
+ *                lists.
+ * \version 1.8.0 Function H5Pget_filter_by_id() renamed to
+ *                H5Pget_filter_by_id1() and deprecated in this release.
+ * \version 1.6.0 Function introduced in this release.
+ */
+H5_DLL herr_t H5Pget_filter_by_id1(hid_t plist_id, H5Z_filter_t id, unsigned int *flags /*out*/,
+                                   size_t *cd_nelmts /*out*/, unsigned cd_values[] /*out*/, size_t namelen,
+                                   char name[] /*out*/);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Retrieves the version information of various objects
+ *        for a file creation property list(deprecated)
+ *
+ * \plist_id
+ * \param[out]  boot     Pointer to location to return super block version number
+ * \param[out]  freelist Pointer to location to return global freelist version number
+ * \param[out]  stab     Pointer to location to return symbol table version number
+ * \param[out]  shhdr    Pointer to location to return shared object header version
+ *                       number
+ *
+ * \return \herr_t
+ *
+ * \deprecated Deprecated in favor of the function H5Fget_info()
+ *
+ * \details H5Pget_version() retrieves the version information of various objects
+ *          for a file creation property list. Any pointer parameters which are
+ *          passed as NULL are not queried.
+ *
+ * \version 1.6.4 \p boot, \p freelist, \p stab, \p shhdr parameter types
+ *                changed to unsigned.
+ *
+ */
+H5_DLL herr_t H5Pget_version(hid_t plist_id, unsigned *boot /*out*/, unsigned *freelist /*out*/,
+                             unsigned *stab /*out*/, unsigned *shhdr /*out*/);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Sets the file space handling strategy and the free-space section
+ *        size threshold.
+ *
+ * \fcpl_id{plist_id}
+ * \param[in] strategy  The file space handling strategy to be used. See:
+ *                      #H5F_fspace_strategy_t
+ * \param[in] threshold The smallest free-space section size that the free
+ *                      space manager will track
+ *
+ * \return \herr_t
+ *
+ * \deprecated When was this function deprecated?
+ *
+ * \details Maps to the function H5Pset_file_space_strategy().
+ *
+ */
+H5_DLL herr_t H5Pset_file_space(hid_t plist_id, H5F_file_space_type_t strategy, hsize_t threshold);
+/**
+ * \ingroup FCPL
+ *
+ * \brief Retrieves the file space handling strategy, and threshold value for
+ *        a file creation property list
+ *
+ * \fcpl_id{plist_id}
+ * \param[out] strategy  Pointer to the file space handling strategy
+ * \param[out] threshold Pointer to the free-space section size threshold value
+ *
+ *  \return \herr_t
+ *
+ * \deprecated When was this function deprecated?
+ *
+ * \details Maps to the function H5Pget_file_space_strategy()
+ *
+ *
+ */
+H5_DLL herr_t H5Pget_file_space(hid_t plist_id, H5F_file_space_type_t *strategy, hsize_t *threshold);
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* H5Ppublic_H */
diff --git a/install/include/H5Rpublic.h b/install/include/H5Rpublic.h
new file mode 100644
index 0000000000..3f63d59742
--- /dev/null
+++ b/install/include/H5Rpublic.h
@@ -0,0 +1,942 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5R module.
+ */
+#ifndef H5Rpublic_H
+#define H5Rpublic_H
+
+#include "H5public.h"  /* Generic Functions                        */
+#include "H5Gpublic.h" /* Groups                                   */
+#include "H5Ipublic.h" /* Identifiers                              */
+#include "H5Opublic.h" /* Object Headers                           */
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* Deprecated reference buffer sizes that are kept for backward compatibility */
+#define H5R_OBJ_REF_BUF_SIZE      sizeof(haddr_t)
+#define H5R_DSET_REG_REF_BUF_SIZE (sizeof(haddr_t) + 4)
+
+/**
+ * Default reference buffer size.
+ *
+ * \internal Note! Be careful with the sizes of the references because they
+ *           should really depend on the run-time values in the file.
+ */
+#define H5R_REF_BUF_SIZE (64)
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+//! <!-- [H5R_type_t_snip] -->
+/**
+ * Reference types allowed.
+ *
+ * \internal DO NOT CHANGE THE ORDER or VALUES as reference type values are
+ *           encoded into the datatype message header.
+ */
+typedef enum {
+    H5R_BADTYPE         = (-1), /**< Invalid reference type           */
+    H5R_OBJECT1         = 0,    /**< Backward compatibility (object)  */
+    H5R_DATASET_REGION1 = 1,    /**< Backward compatibility (region)  */
+    H5R_OBJECT2         = 2,    /**< Object reference                 */
+    H5R_DATASET_REGION2 = 3,    /**< Region reference                 */
+    H5R_ATTR            = 4,    /**< Attribute Reference              */
+    H5R_MAXTYPE         = 5     /**< Highest type (invalid)           */
+} H5R_type_t;
+//! <!-- [H5R_type_t_snip] -->
+
+/* Deprecated types are kept for backward compatibility with previous versions */
+
+//! <!-- [hobj_ref_t_snip] -->
+/**
+ * \deprecated Deprecated object reference type that is used with deprecated
+ *             reference APIs.
+ *
+ * \note This type can only be used with the "native" HDF5 VOL connector.
+ */
+typedef haddr_t hobj_ref_t;
+//! <!-- [hobj_ref_t_snip] -->
+
+//! <!-- [hdset_reg_ref_t_snip] -->
+/**
+ * Buffer to store heap ID and index
+ *
+ * This needs to be large enough to store largest #haddr_t in a worst case
+ * machine (8 bytes currently) plus an int.
+ *
+ * \deprecated Dataset region reference type that is used with deprecated
+ *             reference APIs.
+ *
+ * \note This type can only be used with the "native" HDF5 VOL connector.
+ */
+typedef struct {
+    uint8_t __data[H5R_DSET_REG_REF_BUF_SIZE];
+} hdset_reg_ref_t;
+//! <!-- [hdset_reg_ref_t_snip] -->
+
+//! <!-- [H5R_ref_t_snip] -->
+/**
+ * Opaque reference type. The same reference type is used for object,
+ * dataset region and attribute references. This is the type that
+ * should always be used with the current reference API.
+ */
+typedef struct {
+    union {
+        uint8_t __data[H5R_REF_BUF_SIZE]; /**< opaque data */
+        int64_t align;                    /**< ensures alignment */
+    } u;
+} H5R_ref_t;
+//! <!-- [H5R_ref_t_snip] -->
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Constructors */
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Creates an object reference
+ *
+ * \fgdta_loc_id
+ * \param[in] name      Name of object
+ * \oapl_id
+ * \param[out] ref_ptr  Pointer to reference
+ *
+ * \return \herr_t
+ *
+ * \details H5Rcreate_object() creates a reference pointing to the
+ *          object named \p name located at \p loc_id. The parameters \p
+ *          loc_id and \p name are used to locate the object.
+ *
+ *          The parameter \p oapl_id is an object access property list
+ *          identifier for the referenced object. The access property list
+ *          must be of the same type as the object being referenced, that is
+ *          a group, dataset or committed datatype property list.
+ *
+ *          \ref H5R_ref_t is defined in H5Rpublic.h as:
+ *          \snippet this H5R_ref_t_snip
+ *
+ *          H5Rdestroy() should be used to release the resource from the
+ *          reference.
+ *
+ */
+H5_DLL herr_t H5Rcreate_object(hid_t loc_id, const char *name, hid_t oapl_id, H5R_ref_t *ref_ptr);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Creates a region reference
+ *
+ * \fgdta_loc_id
+ * \param[in] name      Name of object
+ * \space_id
+ * \oapl_id
+ * \param[out] ref_ptr  Pointer to reference
+ *
+ * \return \herr_t
+ *
+ * \details H5Rcreate_region() creates the reference, \p ref_ptr,
+ *          pointing to the region represented by \p space_id within the
+ *          object named name located at \p loc_id.
+ *
+ *          The parameters \p loc_id and \p name are used to locate the
+ *          object. The parameter \p space_id identifies the dataset region
+ *          that a dataset region reference points to.
+ *
+ *          The parameter \p oapl_id is an object access property list
+ *          identifier for the referenced object. The access property list
+ *          must be of the same type as the object being referenced, that is
+ *          a dataset property list in this case.
+ *
+ *          \ref H5R_ref_t is defined in H5Rpublic.h as:
+ *          \snippet this H5R_ref_t_snip
+ *
+ *          H5Rdestroy() should be used to release the resource from the
+ *          reference.
+ *
+ */
+H5_DLL herr_t H5Rcreate_region(hid_t loc_id, const char *name, hid_t space_id, hid_t oapl_id,
+                               H5R_ref_t *ref_ptr);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Creates an attribute reference
+ *
+ * \fgdta_loc_id
+ * \param[in] name      Name of object
+ * \param[in] attr_name Name of attribute
+ * \oapl_id
+ * \param[out] ref_ptr  Pointer to reference
+ *
+ * \return \herr_t
+ *
+ * \details H5Rcreate_attr() creates the reference, \p ref_ptr, pointing
+ *          to the attribute named \p attr_name and attached to the object
+ *          named \p name located at \p loc_id.
+ *
+ *          The parameters \p loc_id and \p name locate the object. The
+ *          parameter \p attr_name specifies the attribute within the object.
+ *
+ *          The parameter \p oapl_id is an object access property list
+ *          identifier for the object that the referenced attribute is
+ *          attached to. The access property list must be of the same type
+ *          as that object, that is a group, dataset or committed datatype
+ *          property list.
+ *
+ *          \ref H5R_ref_t is defined in H5Rpublic.h as:
+ *          \snippet this H5R_ref_t_snip
+ *
+ *          H5Rdestroy() should be used to release the resource from the
+ *          reference.
+ *
+ */
+H5_DLL herr_t H5Rcreate_attr(hid_t loc_id, const char *name, const char *attr_name, hid_t oapl_id,
+                             H5R_ref_t *ref_ptr);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Closes a reference
+ *
+ * \param[in] ref_ptr  Pointer to reference
+ *
+ * \return \herr_t
+ *
+ * \details Given a reference, \p ref_ptr, to an object, region or attribute
+ *          attached to an object, H5Rdestroy() releases allocated resources
+ *          from a previous create call.
+ *
+ *          \ref H5R_ref_t is defined in H5Rpublic.h as:
+ *          \snippet this H5R_ref_t_snip
+ *
+ */
+H5_DLL herr_t H5Rdestroy(H5R_ref_t *ref_ptr);
+
+/* Info */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Retrieves the type of a reference
+ *
+ * \param[in] ref_ptr  Pointer to reference
+ *
+ * \return Returns a valid reference type if successful; otherwise returns #H5R_BADTYPE .
+ *
+ * \details Given a reference, \p ref_ptr, H5Rget_type() returns the
+ *          type of the reference.
+ *
+ *          Valid returned reference types are:
+ *          \snippet this H5R_type_t_snip
+ *
+ *          Note that #H5R_OBJECT1 and #H5R_DATASET_REGION1 can never be
+ *          associated with an \ref H5R_ref_t reference and can, therefore, never be
+ *          returned through that function.
+ *
+ *          \ref H5R_ref_t is defined in H5Rpublic.h as:
+ *          \snippet this H5R_ref_t_snip
+ *
+ */
+H5_DLL H5R_type_t H5Rget_type(const H5R_ref_t *ref_ptr);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Determines whether two references are equal
+ *
+ * \param[in]  ref1_ptr  Pointer to reference to compare
+ * \param[in]  ref2_ptr  Pointer to reference to compare
+ *
+ * \return Returns a positive value if the references are equal. Returns
+ *          0 if the references are not equal. Returns a negative value when the
+ *          function fails.
+ *
+ * \details H5Requal() determines whether two references point to the
+ *          same object, region or attribute.
+ *
+ *          \ref H5R_ref_t is defined in H5Rpublic.h as:
+ *          \snippet this H5R_ref_t_snip
+ *
+ */
+H5_DLL htri_t H5Requal(const H5R_ref_t *ref1_ptr, const H5R_ref_t *ref2_ptr);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Copies an existing reference
+ *
+ * \param[in]  src_ref_ptr  Pointer to reference to copy
+ * \param[out] dst_ref_ptr  Pointer to output reference
+ *
+ * \return \herr_t
+ *
+ * \details H5Rcopy() creates a copy of an existing reference.
+ *          \p src_ref_ptr points to the reference to copy, and \p dst_ref_ptr is the
+ *          pointer to the destination reference.
+ *
+ */
+H5_DLL herr_t H5Rcopy(const H5R_ref_t *src_ref_ptr, H5R_ref_t *dst_ref_ptr);
+
+/* Dereference */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Opens the HDF5 object referenced
+ *
+ * \param[in] ref_ptr  Pointer to reference to open
+ * \rapl_id
+ * \oapl_id
+ *
+ * \return \hid_t{object}
+ *
+ * \details Given a reference, \p ref_ptr, to an object, a region in
+ *          an object, or an attribute attached to an object, H5Ropen_object()
+ *          opens that object and returns an identifier.
+ *
+ *          The parameter \p oapl_id is an object access property list
+ *          identifier for the referenced object. The access property list
+ *          must be of the same type as the object being referenced, that is
+ *          a group or dataset property list.
+ *
+ *          \ref H5R_ref_t is defined in H5Rpublic.h as:
+ *          \snippet this H5R_ref_t_snip
+ *
+ *          The object opened with this function should be closed when it
+ *          is no longer needed so that resource leaks will not develop. Use
+ *          the appropriate close function, such as H5Oclose() or H5Dclose()
+ *          for datasets.
+ *
+ */
+H5_DLL hid_t H5Ropen_object(H5R_ref_t *ref_ptr, hid_t rapl_id, hid_t oapl_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Ropen_object}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Ropen_object_async(const char *app_file, const char *app_func, unsigned app_line,
+                                  H5R_ref_t *ref_ptr, hid_t rapl_id, hid_t oapl_id, hid_t es_id);
+#else
+H5_DLL hid_t H5Ropen_object_async(unsigned app_line, H5R_ref_t *ref_ptr, hid_t rapl_id, hid_t oapl_id,
+                                  hid_t es_id);
+#endif
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Sets up a dataspace and selection as specified by a region reference.
+ *
+ * \param[in] ref_ptr  Pointer to reference to open
+ * \rapl_id
+ * \oapl_id
+ *
+ * \return \hid_t{dataspace}
+ *
+ * \details H5Ropen_region() creates a copy of the dataspace of the
+ *          dataset pointed to by a region reference, \p ref_ptr, and defines
+ *          a selection matching the selection pointed to by \p ref_ptr within
+ *          the dataspace copy.
+ *
+ *          The parameter \p rapl id is a reference access property list
+ *          identifier for the reference. The access property list can
+ *          be used to access external files that the reference points to
+ *          (through a file access property list).
+ *
+ *          The parameter \p oapl id is an object access property list
+ *          identifier for the referenced object. The access property list
+ *          must be of the same type as the object being referenced, that is
+ *          a dataset property list in that case.
+ *
+ *          Use H5Sclose() to release the dataspace identifier returned by
+ *          this function when the identifier is no longer needed.
+ *
+ */
+H5_DLL hid_t H5Ropen_region(H5R_ref_t *ref_ptr, hid_t rapl_id, hid_t oapl_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Ropen_region}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Ropen_region_async(const char *app_file, const char *app_func, unsigned app_line,
+                                  H5R_ref_t *ref_ptr, hid_t rapl_id, hid_t oapl_id, hid_t es_id);
+#else
+H5_DLL hid_t H5Ropen_region_async(H5R_ref_t *ref_ptr, hid_t rapl_id, hid_t oapl_id, hid_t es_id);
+#endif
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Opens the HDF5 attribute referenced
+ *
+ * \param[in] ref_ptr  Pointer to reference to open
+ * \rapl_id
+ * \aapl_id
+ *
+ * \return \hid_t{attribute}
+ *
+ * \details Given a reference, \p ref_ptr, to an attribute attached to
+ *          an object, H5Ropen_attr() opens the attribute attached to that
+ *          object and returns an identifier.
+ *
+ *          The parameter \p rapl id is a reference access property list
+ *          identifier for the reference. The access property list can
+ *          be used to access external files that the reference points to
+ *          (through a file access property list).
+ *
+ *          The parameter \p aapl_id is an attribute access property list
+ *          identifier for the referenced attribute.
+ *
+ *          The attribute opened with this function should be closed with
+ *          H5Aclose() when it is no longer needed.
+ *
+ */
+H5_DLL hid_t H5Ropen_attr(H5R_ref_t *ref_ptr, hid_t rapl_id, hid_t aapl_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ASYNC
+ * \async_variant_of{H5Ropen_attr}
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Ropen_attr_async(const char *app_file, const char *app_func, unsigned app_line,
+                                H5R_ref_t *ref_ptr, hid_t rapl_id, hid_t aapl_id, hid_t es_id);
+#else
+H5_DLL hid_t H5Ropen_attr_async(H5R_ref_t *ref_ptr, hid_t rapl_id, hid_t aapl_id, hid_t es_id);
+#endif
+
+/* Get type */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Retrieves the type of object that an object reference points to
+ *
+ * \param[in] ref_ptr  Pointer to reference to query
+ * \rapl_id
+ * \param[out] obj_type Type of referenced object
+ *
+ * \return \herr_t
+ *
+ * \details Given a reference, \p ref_ptr, H5Rget_obj_type3() retrieves
+ *          the type of the referenced object in \p obj_type.
+ *
+ *          The parameter \p rapl id is a reference access property list
+ *          identifier for the reference. The access property list can
+ *          be used to access external files that the reference points to
+ *          (through a file access property list).
+ *
+ *          Upon success, the function returns in \p obj_type the type of
+ *          the object that the reference points to.  Valid values for this
+ *          referenced object type are as followed (defined in H5Opublic.h):
+ *          \snippet H5Opublic.h H5O_type_t_snip
+ *
+ */
+H5_DLL herr_t H5Rget_obj_type3(H5R_ref_t *ref_ptr, hid_t rapl_id, H5O_type_t *obj_type);
+
+/* Get name */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Retrieves the file name for a referenced object
+ *
+ * \param[in] ref_ptr  Pointer to reference to query
+ * \param[in,out] name Buffer to place the file name of the reference
+ * \param[in] size     Size of the \p name buffer
+ *
+ * \return Returns the length of the name if successful, otherwise, a negative value.
+ *
+ * \details H5Rget_file_name() retrieves the file name for the object,
+ *          region or attribute reference pointed to by \p ref_ptr.
+ *
+ *          Up to \p size characters of the name are returned in \p name;
+ *          additional characters, if any, are not returned to the user
+ *          application. If the length of the name, which determines
+ *          the required value of size, is unknown, a preliminary
+ *          H5Rget_file_name() call can be made. The return value of this
+ *          call will be the size of the file name. That value can then be
+ *          passed in for size in the second call to H5Rget_file_name(),
+ *          which will retrieve the actual name.
+ *
+ */
+H5_DLL ssize_t H5Rget_file_name(const H5R_ref_t *ref_ptr, char *name, size_t size);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Retrieves the object name for a referenced object
+ *
+ * \param[in] ref_ptr  Pointer to reference to query
+ * \rapl_id
+ * \param[in,out] name Buffer to place the file name of the reference
+ * \param[in] size     Size of the \p name buffer
+ *
+ * \return Returns the length of the name if successful, returning
+ *          0 (zero) if no name is associated with the identifier. Otherwise
+ *          returns a negative value.
+ *
+ * \details H5Rget_obj_name() retrieves the object name for the object,
+ *          region or attribute reference pointed to by \p ref_ptr.
+ *
+ *          The parameter \p rapl_id is a reference access property list
+ *          identifier for the reference. The access property list can
+ *          be used to access external files that the reference points to
+ *          (through a file access property list).
+ *
+ *          Up to size characters of the name are returned in \p name; additional
+ *          characters, if any, are not returned to the user application. If
+ *          the length of the name, which determines the required value of
+ *          \p size, is unknown, a preliminary call to H5Rget_obj_name() call
+ *          can be made. The return value of this call will be the size of the
+ *          object name. That value can then be passed in for \p size in the
+ *          second call to H5Rget_obj_name(), which will retrieve the actual
+ *          name. If there is no name associated with the object identifier
+ *          or if the name is NULL, H5Rget_obj_name() returns the size of
+ *          the name buffer (the size does not include the \c \0 terminator).
+ *
+ *          If \p ref_ptr is an object reference, \p name will be returned with
+ *          a name for the referenced object. If \p ref_ptr is a dataset region
+ *          reference, \p name will contain a name for the object containing
+ *          the referenced region. If \p ref_ptr is an attribute reference, \p
+ *          name will contain a name for the object the attribute is attached
+ *          to. Note that an object in an HDF5 file may have multiple paths
+ *          if there are multiple links pointing to it. This function may
+ *          return any one of these paths.
+ *
+ */
+H5_DLL ssize_t H5Rget_obj_name(H5R_ref_t *ref_ptr, hid_t rapl_id, char *name, size_t size);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Retrieves the attribute name for a referenced object
+ *
+ * \param[in] ref_ptr  Pointer to reference to query
+ * \param[in,out] name Buffer to place the attribute name of the reference
+ * \param[in] size     Size of the \p name buffer
+ *
+ * \return Returns the length of the name if successful, otherwise, a negative value.
+ *
+ * \details H5Rget_attr_name() retrieves the attribute name for the
+ *          attribute reference pointed to by \p ref_ptr.
+ *
+ *          Up to size characters of the name are returned in \p name;
+ *          additional characters, if any, are not returned to the user
+ *          application. If the length of the name, which determines
+ *          the required value of \p size, is unknown, a preliminary
+ *          H5Rget_attr_name() call can be made. The return value of this
+ *          call will be the size of the attribute name. That value can then
+ *          be passed in for size in the second call to H5Rget_attr_name(),
+ *          which will retrieve the actual name.
+ *
+ */
+H5_DLL ssize_t H5Rget_attr_name(const H5R_ref_t *ref_ptr, char *name, size_t size);
+
+/// \cond DEV
+/* API Wrappers for async routines */
+/* (Must be defined _after_ the function prototype) */
+/* (And must only defined when included in application code, not the library) */
+#ifndef H5R_MODULE
+#define H5Ropen_object_async(...) H5Ropen_object_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Ropen_region_async(...) H5Ropen_region_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Ropen_attr_async(...)   H5Ropen_attr_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+
+/* Define "wrapper" versions of function calls, to allow compile-time values to
+ * be passed in by language wrapper or library layer on top of HDF5. */
+#define H5Ropen_object_async_wrap H5_NO_EXPAND(H5Ropen_object_async)
+#define H5Ropen_region_async_wrap H5_NO_EXPAND(H5Ropen_region_async)
+#define H5Ropen_attr_async_wrap   H5_NO_EXPAND(H5Ropen_attr_async)
+#endif /* H5R_MODULE */
+/// \endcond
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is or will be deprecated.
+ */
+
+/* Macros */
+
+/* Versions for compatibility */
+#define H5R_OBJECT         H5R_OBJECT1
+#define H5R_DATASET_REGION H5R_DATASET_REGION1
+
+/* Function prototypes */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Retrieves the type of object that an object reference points to
+ *
+ * \param[in] id The dataset containing the reference object or the group
+ *            containing that dataset
+ * \param[in] ref_type Type of reference to query
+ * \param[in] ref Reference to query
+ *
+ * \return Returns a valid object type if successful; otherwise returns a
+ *         negative value (#H5G_UNKNOWN).
+ *
+ * \deprecated This function has been renamed from H5Rget_obj_type() and is
+ *             deprecated in favor of the macro H5Rget_obj_type() or the
+ *             function H5Rget_obj_type2().
+ *
+ * \details Given an object reference, \p ref, H5Rget_obj_type1() returns the
+ *          type of the referenced object.
+ *
+ *          A \Emph{reference type} is the type of reference, either an object
+ *          reference or a dataset region reference. An \Emph{object reference}
+ *          points to an HDF5 object, while a \Emph{dataset region reference}
+ *          points to a defined region within a dataset.
+ *
+ *          The \Emph{referenced object} is the object the reference points
+ *          to. The \Emph{referenced object type}, or the type of the referenced
+ *          object, is the type of the object that the reference points to.
+ *
+ *          The location identifier, \p id, is the identifier for either the
+ *          dataset containing the object reference or the group containing that
+ *          dataset.
+ *
+ *          Valid reference types, to pass in as \p ref_type, include the
+ *          following:
+ *          \snippet this H5R_type_t_snip
+ *
+ *          If the application does not already know the object reference type,
+ *          that can be determined with three preliminary calls:
+ *
+ *          \li Call H5Dget_type() on the dataset containing the reference to
+ *              get a datatype identifier for the dataset's datatype.
+ *          \li Using that datatype identifier, H5Tget_class() returns a datatype
+ *              class.\n If the datatype class is #H5T_REFERENCE, H5Tequal() can
+ *              then be used to determine whether the reference's datatype is
+ *              #H5T_STD_REF_OBJ or #H5T_STD_REF_DSETREG:
+ *              - If the datatype is #H5T_STD_REF_OBJ, the reference object type
+ *                is #H5R_OBJECT.
+ *              - If the datatype is #H5T_STD_REF_DSETREG, the reference object
+ *                type is #H5R_DATASET_REGION.
+ *
+ *          When the function completes successfully, it returns one of the
+ *          following valid object type values (defined in H5Gpublic.h):
+ *          \snippet H5Gpublic.h H5G_obj_t_snip
+ *
+ * \version 1.8.0 Function H5Rget_obj_type() renamed to H5Rget_obj_type1() and
+ *                deprecated in this release.
+ * \since 1.6.0
+ *
+ */
+H5_DLL H5G_obj_t H5Rget_obj_type1(hid_t id, H5R_type_t ref_type, const void *ref);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Opens the HDF5 object referenced
+ *
+ * \obj_id
+ * \param[in] ref_type The reference type of \p ref
+ * \param[in] ref Reference to open
+ *
+ * \return Returns identifier of referenced object if successful; otherwise
+ *         returns a negative value.
+ *
+ * \deprecated This function has been renamed from H5Rdereference() and is
+ *             deprecated in favor of the macro H5Rdereference() or the function
+ *             H5Rdereference2().
+ *
+ * \details Given a reference, \p ref, to an object or a region in an object,
+ *          H5Rdereference1() opens that object and returns an identifier.
+ *
+ *          The parameter \p obj_id must be a valid identifier for an object in
+ *          the HDF5 file containing the referenced object, including the file
+ *          identifier.
+ *
+ *          The parameter \p ref_type specifies the reference type of the
+ *          reference \p ref. \p ref_type may contain either of the following
+ *          values:
+ *          - #H5R_OBJECT
+ *          - #H5R_DATASET_REGION
+ *
+ *          The object opened with this function should be closed when it is no
+ *          longer needed so that resource leaks will not develop. Use the
+ *          appropriate close function, such as H5Oclose() or H5Dclose() for
+ *          datasets.
+ *
+ * \version 1.10.0 Function H5Rdereference() renamed to H5Rdereference1() and
+ *                 deprecated in this release.
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Rdereference1(hid_t obj_id, H5R_type_t ref_type, const void *ref);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Creates a reference
+ *
+ * \param[out] ref Reference created by the function call
+ * \param[in] loc_id Location identifier used to locate the object being pointed to
+ * \param[in] name Name of object at location \p loc_id
+ * \param[in] ref_type Type of reference
+ * \param[in] space_id Dataspace identifier with selection. Used only for
+ *                     dataset region references; pass as -1 if reference is
+ *                     an object reference, i.e., of type #H5R_OBJECT
+ *
+ * \return \herr_t
+ *
+ * \details H5Rcreate() creates the reference, \p ref, of the type specified in
+ *          \p ref_type, pointing to the object \p name located at \p loc_id.
+ *
+ *          The HDF5 library maps the void type specified above for \p ref to
+ *          the type specified in \p ref_type, which will be one of the following:
+ *          \snippet this H5R_type_t_snip
+ *
+ *          The parameters \p loc_id and \p name are used to locate the object.
+ *
+ *          The parameter \p space_id identifies the dataset region that a
+ *          dataset region reference points to. This parameter is used only with
+ *          dataset region references and should be set to -1 if the reference
+ *          is an object reference, #H5R_OBJECT.
+ *
+ * \since 1.8.0
+ */
+H5_DLL herr_t H5Rcreate(void *ref, hid_t loc_id, const char *name, H5R_type_t ref_type, hid_t space_id);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Retrieves the type of object that an object reference points to
+ *
+ * \param[in] id The dataset containing the reference object or the group
+ *            containing that dataset
+ * \param[in] ref_type Type of reference to query
+ * \param[in] ref Reference to query
+ * \param[out] obj_type Type of referenced object
+ *
+ * \return \herr_t
+ *
+ * \details Given an object reference, \p ref, H5Rget_obj_type2() returns the
+ *          type of the referenced object in \p obj_type.
+ *
+ *          A \Emph{reference type} is the type of reference, either an object
+ *          reference or a dataset region reference. An \Emph{object reference}
+ *          points to an HDF5 object while a \Emph{dataset region reference}
+ *          points to a defined region within a dataset.
+ *
+ *          The \Emph{referenced object} is the object the reference points
+ *          to. The \Emph{referenced object type}, or the type of the referenced
+ *          object, is the type of the object that the reference points to.
+ *
+ *          The location identifier, \p id, is the identifier for either the
+ *          dataset containing the object reference or the group containing that
+ *          dataset.
+ *
+ *          Valid reference types, to pass in as \p ref_type, include the
+ *          following:
+ *          \snippet this H5R_type_t_snip
+ *
+ *          If the application does not already know the object reference type,
+ *          that can be determined with three preliminary calls:
+ *
+ *          \li Call H5Dget_type() on the dataset containing the reference to
+ *              get a datatype identifier for the dataset's datatype.
+ *          \li Using that datatype identifier, H5Tget_class() returns a datatype
+ *              class.\n If the datatype class is #H5T_REFERENCE, H5Tequal() can
+ *              then be used to determine whether the reference's datatype is
+ *              #H5T_STD_REF_OBJ or #H5T_STD_REF_DSETREG:
+ *              - If the datatype is #H5T_STD_REF_OBJ, the reference object type
+ *                is #H5R_OBJECT.
+ *              - If the datatype is #H5T_STD_REF_DSETREG, the reference object
+ *                type is #H5R_DATASET_REGION.
+ *
+ *          When the function completes successfully, it returns one of the
+ *          following valid object type values (defined in H5Opublic.h):
+ *          \snippet H5Opublic.h H5O_type_t_snip
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Rget_obj_type2(hid_t id, H5R_type_t ref_type, const void *ref, H5O_type_t *obj_type);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Opens the HDF5 object referenced
+ *
+ * \obj_id
+ * \oapl_id
+ * \param[in] ref_type The reference type of \p ref
+ * \param[in] ref Reference to open
+ *
+ * \return Returns identifier of referenced object if successful; otherwise
+ *         returns a negative value.
+ *
+ * \details Given a reference, \p ref, to an object or a region in an object,
+ *          H5Rdereference2() opens that object and returns an identifier.
+ *
+ *          The parameter \p obj_id must be a valid identifier for the HDF5 file
+ *          containing the referenced object or for any object in that HDF5
+ *          file.
+ *
+ *          The parameter \p oapl_id is an object access property list
+ *          identifier for the referenced object. The access property list must
+ *          be of the same type as the object being referenced, that is a group,
+ *          dataset, or datatype property list.
+ *
+ *          The parameter \p ref_type specifies the reference type of the
+ *          reference \p ref. \p ref_type may contain either of the following
+ *          values:
+ *          - #H5R_OBJECT
+ *          - #H5R_DATASET_REGION
+ *
+ *          The object opened with this function should be closed when it is no
+ *          longer needed so that resource leaks will not develop. Use the
+ *          appropriate close function, such as H5Oclose() or H5Dclose() for
+ *          datasets.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL hid_t H5Rdereference2(hid_t obj_id, hid_t oapl_id, H5R_type_t ref_type, const void *ref);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Sets up a dataspace and selection as specified by a region reference
+ *
+ * \param[in] dataset File identifier or identifier for any object in the file
+ *                    containing the referenced region
+ * \param[in] ref_type Reference type of \p ref, which must be #H5R_DATASET_REGION
+ * \param[in] ref Region reference to open
+ *
+ * \return Returns a valid dataspace identifier if successful; otherwise returns
+ *         a negative value.
+ *
+ * \details H5Rget_region() creates a copy of the dataspace of the dataset
+ *          pointed to by a region reference, \p ref, and defines a selection
+ *          matching the selection pointed to by ref within the dataspace copy.
+ *
+ *          \p dataset is used to identify the file containing the referenced
+ *          region; it can be a file identifier or an identifier for any object
+ *          in the file.
+ *
+ *          The parameter \p ref_type specifies the reference type of \p ref and
+ *          must contain the value #H5R_DATASET_REGION.
+ *
+ *          Use H5Sclose() to release the dataspace identifier returned by this
+ *          function when the identifier is no longer needed.
+ *
+ */
+H5_DLL hid_t H5Rget_region(hid_t dataset, H5R_type_t ref_type, const void *ref);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5R
+ *
+ * \brief Retrieves a name for a referenced object
+ *
+ * \param[in] loc_id Identifier for the file containing the reference or for
+ *                   any object in that file
+ * \param[in] ref_type Type of reference
+ * \param[in] ref An object or dataset region reference
+ * \param[out] name A buffer to place the name of the referenced object or
+ *                  dataset region. If \c NULL, then this call will return the
+ *                  size in bytes of the name.
+ * \param[in] size The size of the \p name buffer. When the size is passed in,
+ *                 the \c NULL terminator needs to be included.
+ *
+ * \return Returns the length of the name if successful, returning 0 (zero) if
+ *         no name is associated with the identifier. Otherwise returns a
+ *         negative value.
+ *
+ * \details H5Rget_name() retrieves a name for the object identified by \p ref.\n
+ *          \p loc_id is used to identify the file containing the reference. It
+ *          can be the file identifier for the file containing the reference or
+ *          an identifier for any object in that file.
+ *
+ *          \ref H5R_type_t is the reference type of \p ref. Valid values
+ *          include the following:
+ *          \snippet this H5R_type_t_snip
+ *
+ *          \p ref is the reference for which the target object's name is
+ *          sought.
+ *
+ *          If \p ref is an object reference, \p name will be returned with a
+ *          name for the referenced object. If \p ref is a dataset region
+ *          reference, \p name will contain a name for the object containing the
+ *          referenced region.
+ *
+ *          Up to \p size characters of the name are returned in \p name;
+ *          additional characters, if any, are not returned to the user
+ *          application.
+ *
+ *          If the length of the name, which determines the required value of \p
+ *          size, is unknown, a preliminary H5Rget_name() call can be made. The
+ *          return value of this call will be the size of the object name. That
+ *          value can then be assigned to \p size for a second H5Rget_name()
+ *          call, which will retrieve the actual name.
+ *
+ *          If there is no name associated with the object identifier or if the
+ *          \p name is \c NULL, H5Rget_name() returns the size of the \p name
+ *          buffer (the size does not include the \p NULL terminator).
+ *
+ *          Note that an object in an HDF5 file may have multiple paths if there
+ *          are multiple links pointing to it. This function may return any one
+ *          of these paths.
+ *
+ * \since 1.8.0
+ */
+H5_DLL ssize_t H5Rget_name(hid_t loc_id, H5R_type_t ref_type, const void *ref, char *name, size_t size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5Rpublic_H */
diff --git a/install/include/H5Spublic.h b/install/include/H5Spublic.h
new file mode 100644
index 0000000000..2b6384f3db
--- /dev/null
+++ b/install/include/H5Spublic.h
@@ -0,0 +1,1412 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5S module.
+ */
+#ifndef H5Spublic_H
+#define H5Spublic_H
+
+#include "H5public.h"  /* Generic Functions                        */
+#include "H5Ipublic.h" /* Identifiers                              */
+
+/* Define special dataspaces for dataset I/O operations */
+
+/**
+ * Used with @ref H5Dread and @ref H5Dwrite to indicate that the entire
+ * dataspace will be selected. In the case of a file dataspace, this means
+ * that the entire file dataspace, as defined by the dataset's dimensions,
+ * will be selected. In the case of a memory dataspace, this means that
+ * the specified file dataspace will also be used for the memory dataspace.
+ * Used in place of a file or memory dataspace @ref hid_t value.
+ */
+#define H5S_ALL 0
+
+/**
+ * Indicates that the buffer provided in a call to @ref H5Dread or @ref H5Dwrite
+ * is a single contiguous block of memory, with the same number of elements
+ * as the file dataspace. Used in place of a memory dataspace @ref hid_t value.
+ */
+#define H5S_BLOCK 1
+
+/**
+ * Used with @ref H5Dread and @ref H5Dwrite to indicate that the file dataspace
+ * selection was set via @ref H5Pset_dataset_io_hyperslab_selection calls.
+ * Used in place of a file dataspace @ref hid_t value.
+ */
+#define H5S_PLIST 2
+
+#define H5S_UNLIMITED HSIZE_UNDEF /**< Value for 'unlimited' dimensions */
+
+/**
+ * The maximum dataspace rank or number of dimensions
+ */
+#define H5S_MAX_RANK 32
+
+/* Flags for selection iterators */
+#define H5S_SEL_ITER_GET_SEQ_LIST_SORTED                                                                     \
+    0x0001 /**< Retrieve elements from iterator in increasing offset order, for                              \
+            * each call to retrieve sequences. Currently, this only applies to                               \
+            * point selections, as hyperslab selections are always returned in                               \
+            * increasing offset order. Note that the order is only increasing                                \
+            * for each call to H5Sget_seq_list(), the next set of sequences                                  \
+            * could start with an earlier offset than the previous one.                                      \
+            */
+#define H5S_SEL_ITER_SHARE_WITH_DATASPACE                                                                    \
+    0x0002 /**< Don't copy the dataspace selection when creating the selection                               \
+            * iterator. This can improve performance of creating the iterator,                               \
+            * but the dataspace \Bold{MUST NOT} be modified or closed until the                              \
+            * selection iterator is closed or the iterator's behavior will be                                \
+            * undefined.                                                                                     \
+            */
+
+/**
+ * Types of dataspaces
+ */
+typedef enum H5S_class_t {
+    H5S_NO_CLASS = -1, /**< Error                                      */
+    H5S_SCALAR   = 0,  /**< Singleton (scalar)                         */
+    H5S_SIMPLE   = 1,  /**< Regular grid                               */
+    H5S_NULL     = 2   /**< Empty set                                  */
+} H5S_class_t;
+
+/**
+ * Different ways of combining selections
+ */
+typedef enum H5S_seloper_t {
+    H5S_SELECT_NOOP = -1, /**< Error                                     */
+    H5S_SELECT_SET  = 0,  /**< Select "set" operation 		             */
+    H5S_SELECT_OR,        /**< Binary "or" operation for hyperslabs
+                           * (add new selection to existing selection)
+                           * \code
+                           * Original region:  AAAAAAAAAA
+                           * New region:             BBBBBBBBBB
+                           * A or B:           CCCCCCCCCCCCCCCC
+                           * \endcode
+                           */
+    H5S_SELECT_AND,       /**< Binary "and" operation for hyperslabs
+                           * (only leave overlapped regions in selection)
+                           * \code
+                           * Original region:  AAAAAAAAAA
+                           * New region:             BBBBBBBBBB
+                           * A and B:                CCCC
+                           * \endcode
+                           */
+    H5S_SELECT_XOR,       /**< Binary "xor" operation for hyperslabs
+                           * (only leave non-overlapped regions in selection)
+                           * \code
+                           * Original region:  AAAAAAAAAA
+                           * New region:             BBBBBBBBBB
+                           * A xor B:          CCCCCC    CCCCCC
+                           * \endcode
+                           */
+    H5S_SELECT_NOTB,      /**< Binary "not" operation for hyperslabs
+                           * (only leave non-overlapped regions in original selection)
+                           * \code
+                           * Original region:  AAAAAAAAAA
+                           * New region:             BBBBBBBBBB
+                           * A not B:          CCCCCC
+                           * \endcode
+                           */
+    H5S_SELECT_NOTA,      /**< Binary "not" operation for hyperslabs
+                           * (only leave non-overlapped regions in new selection)
+                           * \code
+                           * Original region:  AAAAAAAAAA
+                           * New region:             BBBBBBBBBB
+                           * B not A:                    CCCCCC
+                           * \endcode
+                           */
+    H5S_SELECT_APPEND,    /**< Append elements to end of point selection */
+    H5S_SELECT_PREPEND,   /**< Prepend elements to beginning of point selection */
+    H5S_SELECT_INVALID    /**< Invalid upper bound on selection operations */
+} H5S_seloper_t;
+
+/**
+ * Selection type
+ */
+typedef enum {
+    H5S_SEL_ERROR      = -1, /**< Error                                 */
+    H5S_SEL_NONE       = 0,  /**< Empty selection                       */
+    H5S_SEL_POINTS     = 1,  /**< Set of points                         */
+    H5S_SEL_HYPERSLABS = 2,  /**< Hyperslab                             */
+    H5S_SEL_ALL        = 3,  /**< Everything	                        */
+    H5S_SEL_N                /**< Sentinel \internal THIS MUST BE LAST	*/
+} H5S_sel_type;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Operations on dataspaces, dataspace selections and selection iterators */
+
+/**
+ * \ingroup H5S
+ *
+ * \brief Releases and terminates access to a dataspace
+ *
+ * \space_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Sclose() releases a dataspace. Further access through the
+ *          dataspace identifier is illegal. Failure to release a dataspace with this
+ *          call will result in resource leaks.
+ *
+ * \version 1.4.0 Fortran subroutine introduced in this release.
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Sclose(hid_t space_id);
+/**
+ * \ingroup H5S
+ *
+ * \brief Performs an operation on a hyperslab and an existing selection and
+ *        returns the resulting selection
+ *
+ * \space_id
+ * \param[in] op      Operation to perform on the current selection
+ * \param[in] start   Offset of the start of of the hyperslab
+ * \param[in] stride  Hyperslab stride
+ * \param[in] count   Number of blocks included in the hyperslab
+ * \param[in] block   Size of a block in the hyperslab
+ *
+ * \return \hid_tv{dataspace}
+ *
+ * \details H5Scombine_hyperslab() combines a hyperslab selection specified
+ *          by \p start, \p stride, \p count and \p block with the current
+ *          selection for the dataspace \p space_id, creating a new dataspace
+ *          to return the generated selection.  If the current selection is
+ *          not a hyperslab, it is freed and the hyperslab parameters passed
+ *          in are combined with the #H5S_SEL_ALL hyperslab (ie. a selection
+ *          composing the entire current extent). If either \p stride or
+ *          \p block is NULL, then it will be set to \p 1.
+ *
+ * \since 1.10.6
+ *
+ */
+H5_DLL hid_t H5Scombine_hyperslab(hid_t space_id, H5S_seloper_t op, const hsize_t start[],
+                                  const hsize_t stride[], const hsize_t count[], const hsize_t block[]);
+/**
+ * \ingroup H5S
+ *
+ * \brief Combine two hyperslab selections with an operation, returning a
+ *        dataspace with the resulting selection
+ *
+ * \space_id{space1_id}
+ * \param[in] op  Selection operator
+ * \space_id{space2_id}
+ *
+ * \return \hid_t{dataspace}
+ *
+ * \details H5Scombine_select() combines two hyperslab selections
+ *          \p space1_id and \p space2_id with an operation, returning a
+ *          new dataspace with the resulting selection. The dataspace extent
+ *          from \p space1_id is copied for the dataspace extent of the
+ *          newly created dataspace.
+ *
+ * \since 1.10.6
+ *
+ */
+H5_DLL hid_t H5Scombine_select(hid_t space1_id, H5S_seloper_t op, hid_t space2_id);
+/**
+ * \ingroup H5S
+ *
+ * \brief Creates an exact copy of a dataspace
+ *
+ * \space_id
+ *
+ * \return \hid_tv{dataspace}
+ *
+ * \details H5Scopy() creates a new dataspace which is an exact copy of the
+ *          dataspace identified by \p space_id. The dataspace identifier
+ *          returned from this function should be released with H5Sclose()
+ *          or resource leaks will occur.
+ *
+ * \version 1.4.0   Fortran subroutine introduced.
+ * \since 1.0.0
+ *
+ */
+H5_DLL hid_t H5Scopy(hid_t space_id);
+/**
+ * \ingroup H5S
+ *
+ * \brief Creates a new dataspace of a specified type
+ *
+ * \param[in] type   Type of dataspace to be created
+ *
+ * \return \hid_t{dataspace}
+ *
+ * \details H5Screate() creates a new dataspace of a particular type. Currently
+ *          supported types are #H5S_SCALAR, #H5S_SIMPLE, and #H5S_NULL.
+ *
+ *          Further dataspace types may be added later.
+ *
+ *          A scalar dataspace, #H5S_SCALAR, has a single element, though that
+ *          element may be of a complex datatype, such as a compound or array
+ *          datatype. By convention, the rank of a scalar dataspace is always \p 0
+ *          (zero); think of it geometrically as a single, dimensionless point,
+ *          though that point can be complex.
+ *
+ *          A simple dataspace, #H5S_SIMPLE, consists of a regular array of elements.
+ *
+ *          A null dataspace, #H5S_NULL, has no data elements.
+ *
+ *          The dataspace identifier returned by this function can be released with
+ *          H5Sclose() so that resource leaks will not occur.
+ *
+ * \version 1.4.0 Fortran subroutine introduced.
+ * \since 1.0.0
+ *
+ */
+H5_DLL hid_t H5Screate(H5S_class_t type);
+/**
+ * \ingroup H5S
+ * \brief Creates a new simple dataspace and opens it for access
+ *
+ * \param[in] rank    Number of dimensions of dataspace
+ * \param[in] dims    Array specifying the size of each dimension
+ * \param[in] maxdims Array specifying the maximum size of each dimension
+ *
+ * \return \hid_t{dataspace}
+ *
+ * \details H5Screate_simple() creates a new simple dataspace and opens it
+ *          for access, returning a dataspace identifier.
+ *
+ *          \p rank is the number of dimensions used in the dataspace.
+ *
+ *          \p dims is a one-dimensional array of size rank specifying the
+ *          size of each dimension of the dataset. \p maxdims is an array of
+ *          the same size specifying the upper limit on the size of each
+ *          dimension.
+ *
+ *          Any element of \p dims can be \p 0 (zero). Note that no data can
+ *          be written to a dataset if the size of any dimension of its current
+ *          dataspace is \p 0. This is sometimes a useful initial state for
+ *          a dataset.
+ *
+ *          \p maxdims may be the null pointer, in which case the upper limit
+ *          is the same as \p dims. Otherwise, no element of \p maxdims
+ *          should be smaller than the corresponding element of \p dims.
+ *
+ *          If an element of \p maxdims is #H5S_UNLIMITED, the maximum size of
+ *          the corresponding dimension is unlimited.
+ *
+ *          Any dataset with an unlimited dimension must also be chunked; see
+ *          H5Pset_chunk(). Similarly, a dataset must be chunked if \p dims
+ *          does not equal \p maxdims.
+ *
+ *          The dataspace identifier returned from this function must be
+ *          released with H5Sclose() or resource leaks will occur.
+ *
+ * \note Once a dataspace has been created, specific regions or elements in
+ *       the dataspace can be selected and selections can be removed, as well.
+ *       For example, H5Sselect_hyperslab() selects a region in a dataspace and
+ *       H5Sselect_elements() selects array elements in a dataspace. These
+ *       functions are used for subsetting. H5Sselect_none() removes all
+ *       selections from a dataspace and is used in Parallel HDF5 when a process
+ *       does not have or need to write data.
+ *
+ * \version 1.4.0 Fortran subroutine introduced.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL hid_t H5Screate_simple(int rank, const hsize_t dims[], const hsize_t maxdims[]);
+/**
+ * \ingroup H5S
+ *
+ * \brief Decodes a binary object description of data space and returns a
+ *        new object handle
+ *
+ * \param[in] buf  Buffer for the data space object to be decoded
+ *
+ * \return \hid_t{dataspace}
+ *
+ * \details Given an object description of a dataspace in binary in a
+ *          buffer, H5Sdecode() reconstructs the HDF5 data type object and
+ *          returns a new object handle for it. The binary description of the
+ *          object is encoded by H5Sencode(). The user is responsible for
+ *          passing in the right buffer. The types of dataspace addressed
+ *          in this function are null, scalar, and simple space. For a
+ *          simple dataspace, the selection information (for example,
+ *          hyperslab selection) is also encoded and decoded. A complex
+ *          dataspace has not been implemented in the library.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Sdecode(const void *buf);
+/**
+ * \ingroup H5S
+ *
+ * \brief Encodes a data space object description into a binary buffer
+ *
+ * \space_id{obj_id}
+ * \param[in,out] buf      Buffer for the object to be encoded into;
+ *                         If the provided buffer is NULL, only the size
+ *                         of buffer needed is returned through \p nalloc.
+ * \param[in,out] nalloc   The size of the allocated buffer
+ * \fapl_id{fapl}
+ *
+ * \return \herr_t
+ *
+ * \details Given the data space identifier \p obj_id, H5Sencode2() converts
+ *          a data space description into binary form in a buffer. Using this
+ *          binary form in the buffer, a data space object can be
+ *          reconstructed with H5Sdecode() to return a new object handle
+ *          (#hid_t) for this data space.
+ *
+ *          A preliminary H5Sencode2() call can be made to determine the
+ *          size of the buffer needed. This value is returned in \p nalloc.
+ *          That value can then be assigned to \p nalloc for a second
+ *          H5Sencode2() call, which will retrieve the actual encoded object.
+ *
+ *          If the library determines that \p nalloc is not big enough for the
+ *          object, it simply returns the size of the buffer needed through
+ *          \p nalloc without encoding the provided buffer.
+ *
+ *          The file access property list \p fapl_id is used to control the
+ *          encoding via the \a libver_bounds property (see
+ *          H5Pset_libver_bounds()). If the \a libver_bounds property is missing,
+ *          H5Sencode2() proceeds as if the \a libver_bounds property were set to
+ *          (#H5F_LIBVER_EARLIEST, #H5F_LIBVER_LATEST). (Functionally,
+ *          H5Sencode1() is identical to H5Sencode2() with \a libver_bounds set to
+ *          (#H5F_LIBVER_EARLIEST, #H5F_LIBVER_LATEST).)
+ *
+ *          The types of data space that are addressed in this function are
+ *          null, scalar, and simple space. For a simple data space, the
+ *          information on the selection, for example, hyperslab selection,
+ *          is also encoded and decoded. A complex data space has not been
+ *          implemented in the library.
+ *
+ * \note Motivation: This function was introduced in HDF5-1.12 as part of the
+ *       H5Sencode() format change to enable 64-bit selection encodings and
+ *       a dataspace selection that is tied to a file. See the \ref_news_112
+ *       as well as the \ref_sencode_fmt_change.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Sencode2(hid_t obj_id, void *buf, size_t *nalloc, hid_t fapl);
+/**
+ * \ingroup H5S
+ *
+ * \brief Copies the extent of a dataspace
+ *
+ * \space_id{dst_id}
+ * \space_id{src_id}
+ *
+ * \return \herr_t
+ *
+ * \details H5Sextent_copy() copies the extent from \p src_id to \p dst_id.
+ *          This action may change the type of the dataspace.
+ *
+ * \version 1.4.0 Fortran subroutine was introduced.
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Sextent_copy(hid_t dst_id, hid_t src_id);
+/**
+ * \ingroup H5S
+ *
+ * \brief Determines whether two dataspace extents are equal
+ *
+ * \space_id{space1_id}
+ * \space_id{space2_id}
+ *
+ * \return \htri_t
+ *
+ * \details H5Sextent_equal() determines whether the dataspace extents of
+ *          two dataspaces, \p space1_id and \p space2_id, are equal.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL htri_t H5Sextent_equal(hid_t space1_id, hid_t space2_id);
+/**
+ * \ingroup H5S
+ *
+ * \brief Retrieves a regular hyperslab selection
+ *
+ * \space_id{spaceid}
+ * \param[out] start   Offset of the start of the regular hyperslab
+ * \param[out] stride  Stride of the regular hyperslab
+ * \param[out] count   Number of blocks in the regular hyperslab
+ * \param[out] block   Size of a block in the regular hyperslab
+ *
+ * \return \herr_t
+ *
+ * \details H5Sget_regular_hyperslab() takes the dataspace identifier,
+ *          \p spaceid, and retrieves the values of \p start, \p stride,
+ *          \p count, and \p block for the regular hyperslab selection.
+ *
+ *          A regular hyperslab selection is a hyperslab selection
+ *          described by setting the \p offset, \p stride, \p count, and
+ *          \p block parameters to the H5Sselect_hyperslab() call. If
+ *          several calls to H5Sselect_hyperslab() are needed, the
+ *          hyperslab selection is irregular.
+ *
+ *          See H5Sselect_hyperslab() for descriptions of \p offset,
+ *          \p stride, \p count, and \p block.
+ *
+ * \note If a hyperslab selection is originally regular, then becomes
+ *       irregular through selection operations, and then becomes regular
+ *       again, the final regular selection may be equivalent but not
+ *       identical to the original regular selection.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL htri_t H5Sget_regular_hyperslab(hid_t spaceid, hsize_t start[], hsize_t stride[], hsize_t count[],
+                                       hsize_t block[]);
+/**
+ * \ingroup H5S
+ *
+ * \brief Gets the bounding box containing the current selection
+ *
+ * \space_id{spaceid}
+ * \param[out] start  Starting coordinates of the bounding box
+ * \param[out] end    Ending coordinates of the bounding box, i.e., the
+ *                    coordinates of the diagonally opposite corner
+ *
+ * \return \herr_t
+ *
+ * \details H5Sget_select_bounds() retrieves the coordinates of the bounding
+ *          box containing the current selection and places them into
+ *          user-supplied buffers.
+ *
+ *          The \p start and \p end buffers must be large enough to hold
+ *          the dataspace rank number of coordinates.
+ *
+ *          The bounding box exactly contains the selection. I.e., if a
+ *          2-dimensional element selection is currently defined as containing
+ *          the points (4,5), (6,8), and (10,7), then the bounding box
+ *          will be (4, 5), (10, 8).
+ *
+ *          The bounding box calculation includes the current offset of the
+ *          selection within the dataspace extent.
+ *
+ *          Calling this function on a \a none selection will fail.
+ *
+ * \version 1.6.0 The \p start and \p end parameters have changed from type
+ *          \p hsize_t * to \p hssize_t *.
+ * \version 1.4.0 Fortran subroutine was introduced.
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Sget_select_bounds(hid_t spaceid, hsize_t start[], hsize_t end[]);
+/**
+ * \ingroup H5S
+ *
+ * \brief Gets the number of element points in the current selection
+ *
+ * \space_id{spaceid}
+ *
+ * \return Returns the number of element points in the current dataspace
+ *         selection if successful. Otherwise returns a negative value.
+ *
+ * \details H5Sget_select_elem_npoints() returns the number of element
+ *          points in the current dataspace selection, so that the element
+ *          points can be retrieved with H5Sget_select_elem_pointlist().
+ *          (This is similar to the way that H5Sget_select_hyper_nblocks()
+ *          and H5Sget_select_hyper_blocklist() work with hyperslab
+ *          selections.)
+ *
+ *          Coincidentally, H5Sget_select_npoints() and
+ *          H5Sget_select_elem_npoints() will always return the same value
+ *          when an element selection is queried, but
+ *          H5Sget_select_elem_npoints() does not work with other selection
+ *          types.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL hssize_t H5Sget_select_elem_npoints(hid_t spaceid);
+/**
+ * \ingroup H5S
+ *
+ * \brief Gets the list of element points currently selected
+ *
+ * \space_id{spaceid}
+ * \param[in] startpoint  Element point to start with
+ * \param[in] numpoints   Number of element points to get
+ * \param[out] buf        List of element points selected
+ *
+ * \details H5Sget_select_elem_pointlist() returns the list of element
+ *          points in the current dataspace selection \p space_id. Starting
+ *          with the \p startpoint in the list of points, \p numpoints
+ *          points are put into the user's buffer. If the user's buffer
+ *          fills up before \p numpoints points are inserted, the buffer
+ *          will contain only as many points as fit.
+ *
+ *          The element point coordinates have the same dimensionality
+ *          (rank) as the dataspace they are located within. The list of
+ *          element points is formatted as follows:\n
+ *              \<coordinate\>, followed by\n
+ *              the next coordinate,\n
+ *              etc.\n
+ *          until all of the selected element points have been listed.
+ *
+ *          The points are returned in the order they will be iterated
+ *          through when the selection is read/written from/to disk.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Sget_select_elem_pointlist(hid_t spaceid, hsize_t startpoint, hsize_t numpoints,
+                                           hsize_t buf[/*numpoints*/]);
+/**
+ * \ingroup H5S
+ *
+ * \brief Gets the list of hyperslab blocks currently selected
+ *
+ * \space_id{spaceid}
+ * \param[in]  startblock  Hyperslab block to start with
+ * \param[in]  numblocks   Number of hyperslab blocks to get
+ * \param[out] buf         List of hyperslab blocks selected
+ *
+ * \return \herr_t
+ *
+ * \details H5Sget_select_hyper_blocklist() returns a list of the hyperslab
+ *          blocks currently selected. Starting with the \p startblock-th block
+ *          in the list of blocks, \p numblocks blocks are put into the
+ *          user's buffer. If the user's buffer fills up before \p numblocks
+ *          blocks are inserted, the buffer will contain only as many blocks
+ *          as fit.
+ *
+ *          The block coordinates have the same dimensionality (rank) as the
+ *          dataspace they are located within. The list of blocks is
+ *          formatted as follows:\n
+ *              \<"start" coordinate\>, immediately followed by\n
+ *              \<"opposite" corner coordinate\>, followed by\n
+ *              the next "start" and "opposite" coordinates,\n
+ *              etc. until all of the selected blocks have been listed.\n
+ *          No guarantee of any order of the blocks is implied.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Sget_select_hyper_blocklist(hid_t spaceid, hsize_t startblock, hsize_t numblocks,
+                                            hsize_t buf[/*numblocks*/]);
+/**
+ * \ingroup H5S
+ *
+ * \brief Get number of hyperslab blocks
+ *
+ * \space_id{spaceid}
+ *
+ * \return Returns the number of hyperslab blocks in the current dataspace
+ *         selection if successful. Otherwise returns a negative value.
+ *
+ * \details H5Sget_select_hyper_nblocks() returns the number of hyperslab
+ *          blocks in the current dataspace selection.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL hssize_t H5Sget_select_hyper_nblocks(hid_t spaceid);
+/**
+ * \ingroup H5S
+ *
+ * \brief Determines the number of elements in a dataspace selection
+ *
+ * \space_id{spaceid}
+ *
+ * \return Returns the number of elements in the selection if successful;
+ *         otherwise returns a negative value.
+ *
+ * \details H5Sget_select_npoints() determines the number of elements in
+ *          the current selection of a dataspace. It works with any
+ *          selection type, and is the correct way to retrieve the number
+ *          of elements in a selection.
+ *
+ * \version 1.4.0 Fortran subroutine introduced in this release.
+ * \since 1.0.0
+ *
+ */
+H5_DLL hssize_t H5Sget_select_npoints(hid_t spaceid);
+/**
+ * \ingroup H5S
+ *
+ * \brief Determines the type of the dataspace selection
+ *
+ * \space_id{spaceid}
+ *
+ * \return Returns the dataspace selection type, a value of the enumerated
+ *         datatype #H5S_sel_type, if successful.
+ *
+ * \details H5Sget_select_type() retrieves the type of dataspace selection
+ *          currently defined for the dataspace \p space_id. Valid values
+ *          for the dataspace selection type are:
+ *
+ *         <table>
+ *           <tr>
+ *             <td>#H5S_SEL_NONE</td>
+ *             <td>No selection is defined</td>
+ *           </tr>
+ *           <tr>
+ *             <td>#H5S_SEL_POINTS</td>
+ *             <td>A sequence of points is selected</td>
+ *           </tr>
+ *           <tr>
+ *             <td>#H5S_SEL_HYPERSLABS</td>
+ *             <td>A hyperslab or compound hyperslab is selected</td>
+ *           </tr>
+ *           <tr>
+ *             <td>#H5S_SEL_ALL</td>
+ *             <td>The entire dataset is selected</td>
+ *           </tr>
+ *         </table>
+ *
+ *         Otherwise returns a negative value.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL H5S_sel_type H5Sget_select_type(hid_t spaceid);
+/**
+ * \ingroup H5S
+ *
+ * \brief Retrieves dataspace dimension size and maximum size
+ *
+ * \space_id
+ * \param[out] dims Pointer to array to store the size of each dimension
+ * \param[out] maxdims Pointer to array to store the maximum size of each
+ *                     dimension
+ *
+ * \return Returns the number of dimensions in the dataspace if successful;
+ *         otherwise returns a negative value.
+ *
+ * \details H5Sget_simple_extent_dims() returns the size and maximum sizes
+ *          of each dimension of a dataspace \p space_id through the \p dims
+ *          and \p maxdims parameters.
+ *
+ *          Either or both of \p dims and \p maxdims may be NULL.
+ *
+ *          If a value in the returned array \p maxdims is #H5S_UNLIMITED (-1),
+ *          the maximum size of that dimension is unlimited.
+ *
+ * \version 1.4.0 Fortran subroutine introduced.
+ * \since 1.0.0
+ *
+ */
+H5_DLL int H5Sget_simple_extent_dims(hid_t space_id, hsize_t dims[], hsize_t maxdims[]);
+/**
+ * \ingroup H5S
+ *
+ * \brief Determines the dimensionality of a dataspace
+ *
+ * \space_id
+ *
+ * \return Returns the number of dimensions in the dataspace if successful;
+ *         otherwise returns a negative value.
+ *
+ * \details H5Sget_simple_extent_ndims() determines the dimensionality (or
+ *          rank) of a dataspace.
+ *
+ * \version 1.4.0 Fortran subroutine introduced.
+ * \since 1.0.0
+ *
+ */
+H5_DLL int H5Sget_simple_extent_ndims(hid_t space_id);
+/**
+ * \ingroup H5S
+ *
+ * \brief Determines the number of elements in a dataspace
+ *
+ * \space_id
+ *
+ * \return Returns the number of elements in the dataspace if successful;
+ *         otherwise returns a negative value.
+ *
+ * \details H5Sget_simple_extent_npoints() determines the number of elements
+ *          in a dataspace \p space_id. For example, a simple 3-dimensional
+ *          dataspace with dimensions 2, 3, and 4 would have 24 elements.
+ *
+ * \version 1.4.0 Fortran subroutine introduced.
+ * \since 1.0.0
+ *
+ */
+H5_DLL hssize_t H5Sget_simple_extent_npoints(hid_t space_id);
+/**
+ * \ingroup H5S
+ *
+ * \brief  Determines the current class of a dataspace
+ *
+ * \space_id
+ *
+ * \return Returns a dataspace class name if successful;
+ *         otherwise #H5S_NO_CLASS (-1).
+ *
+ * \details H5Sget_simple_extent_type() determines the current class of a
+ *          dataspace \p space_id.
+ *
+ * \version 1.4.0 Fortran subroutine was introduced.
+ * \since 1.0.0
+ *
+ */
+H5_DLL H5S_class_t H5Sget_simple_extent_type(hid_t space_id);
+/**
+ * \ingroup H5S
+ *
+ * \brief Determines if a hyperslab selection is regular
+ *
+ * \space_id{spaceid}
+ *
+ * \return \htri_t
+ *
+ * \details H5Sis_regular_hyperslab() takes the dataspace identifier,
+ *          \p spaceid, and queries the type of the hyperslab selection.
+ *
+ *          A regular hyperslab selection is a hyperslab selection described
+ *          by setting the offset, stride, count, and block parameters for
+ *          a single H5Sselect_hyperslab() call. If several calls to
+ *          H5Sselect_hyperslab() are needed, then the hyperslab selection
+ *          is irregular.
+ *
+ * \since 1.10.0
+ *
+ */
+H5_DLL htri_t H5Sis_regular_hyperslab(hid_t spaceid);
+/**
+ * \ingroup H5S
+ *
+ * \brief Determines whether a dataspace is a simple dataspace
+ *
+ * \space_id
+ *
+ * \return \htri_t
+ *
+ * \details H5Sis_simple() determines whether or not a dataspace is a simple
+ *          dataspace.
+ *
+ * \note Currently, all dataspace objects are simple dataspaces; complex
+ *       dataspace support will be added in the future.
+ *
+ * \version 1.4.0 Fortran subroutine was introduced.
+ * \since 1.0.0
+ *
+ */
+H5_DLL htri_t H5Sis_simple(hid_t space_id);
+/**
+ * \ingroup H5S
+ *
+ * \brief Refines a hyperslab selection with an operation, using a second
+ *        hyperslab to modify it
+ *
+ * \space_id{space1_id}
+ * \param[in] op  Selection operator
+ * \space_id{space2_id}
+ *
+ * \return \herr_t
+ *
+ * \details H5Smodify_select() refines an existing hyperslab selection
+ *          \p space1_id with an operation \p op, using a second hyperslab
+ *          \p space2_id. The first selection is modified to contain the
+ *          result of \p space1_id operated on by \p space2_id.
+ *
+ * \since 1.10.6
+ *
+ */
+H5_DLL herr_t H5Smodify_select(hid_t space1_id, H5S_seloper_t op, hid_t space2_id);
+/**
+ * \ingroup H5S
+ *
+ * \brief Sets the offset of a simple dataspace
+ *
+ * \space_id
+ * \param[in] offset  The offset at which to position the selection
+ *
+ * \return \herr_t
+ *
+ * \details H5Soffset_simple() sets the offset of a simple dataspace
+ *          \p space_id. The offset array must be the same number of
+ *          elements as the number of dimensions for the dataspace. If the
+ *          \p offset array is set to NULL, the offset for the dataspace is
+ *          reset to 0.
+ *
+ *          This function allows the same shaped selection to be moved to
+ *          different locations within a dataspace without requiring it to
+ *          be redefined.
+ *
+ * \version 1.4.0 Fortran subroutine was introduced.
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Soffset_simple(hid_t space_id, const hssize_t *offset);
+/**
+ * \ingroup H5S
+ *
+ * \brief Closes a dataspace selection iterator
+ *
+ * \space_id{sel_iter_id}
+ *
+ * \return \herr_t
+ *
+ * \details H5Ssel_iter_close() closes a dataspace selection iterator
+ *          specified by \p sel_iter_id, releasing its state.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Ssel_iter_close(hid_t sel_iter_id);
+/**\ingroup H5S
+ *
+ * \brief Creates a dataspace selection iterator for a dataspace's selection
+ *
+ * \space_id{spaceid}
+ * \param[in] elmt_size  Size of element in the selection
+ * \param[in] flags      Selection iterator flag
+ *
+ * \return \hid_t{valid dataspace selection iterator}
+ *
+ * \details H5Ssel_iter_create() creates a selection iterator and initializes
+ *          it to start at the first element selected in the dataspace.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL hid_t H5Ssel_iter_create(hid_t spaceid, size_t elmt_size, unsigned flags);
+/**
+ * \ingroup H5S
+ *
+ * \brief Retrieves a list of offset / length sequences for the elements in
+ *        an iterator
+ *
+ * \space_id{sel_iter_id}
+ * \param[in]  maxseq   Maximum number of sequences to retrieve
+ * \param[in]  maxelmts Maximum number of elements to retrieve in sequences
+ * \param[out] nseq     Number of sequences retrieved
+ * \param[out] nelmts   Number of elements retrieved, in all sequences
+ * \param[out] off      Array of sequence offsets
+ * \param[out] len      Array of sequence lengths
+ *
+ * \return \herr_t
+ *
+ * \details H5Ssel_iter_get_seq_list() retrieves a list of offset / length
+ *          pairs (a list of "sequences") matching the selected elements for
+ *          an iterator \p sel_iter_id, according to the iteration order for
+ *          the iterator.  The lengths returned are in bytes, not elements.
+ *
+ *          Note that the iteration order for "all" and "hyperslab"
+ *          selections is row-major (i.e. "C-ordered"), but the iteration
+ *          order for "point" selections is "in order selected", unless the
+ *          #H5S_SEL_ITER_GET_SEQ_LIST_SORTED flag is passed to
+ *          H5Ssel_iter_create() for a point selection.
+ *
+ *          \p maxseq and \p maxelmts specify the most sequences or elements
+ *          possible to place into the \p off and \p len arrays. \p nseq and
+ *          \p nelmts return the actual number of sequences and elements put
+ *          into the arrays.
+ *
+ *          Each call to H5Ssel_iter_get_seq_list() will retrieve the next
+ *          set of sequences for the selection being iterated over.
+ *
+ *          The total number of bytes possible to retrieve from a selection
+ *          iterator is the \p elmt_size passed to H5Ssel_iter_create()
+ *          multiplied by the number of elements selected in the dataspace
+ *          the iterator was created from (which can be retrieved with
+ *          H5Sget_select_npoints().  When there are no further sequences of
+ *          elements to retrieve, calls to this routine will set \p nseq
+ *          and \p nelmts to zero.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Ssel_iter_get_seq_list(hid_t sel_iter_id, size_t maxseq, size_t maxelmts, size_t *nseq,
+                                       size_t *nelmts, hsize_t *off, size_t *len);
+/**
+ * \ingroup H5S
+ *
+ * \brief  Resets a dataspace selection iterator back to an initial state
+ *
+ * \param[in] sel_iter_id   Identifier of the dataspace selection iterator
+ *                          to reset
+ * \param[in] space_id      Identifier of the dataspace with selection to
+ *                          iterate over
+ *
+ * \return \herr_t
+ *
+ * \details H5Ssel_iter_reset() resets a dataspace selection iterator back to
+ *          an initial state so that the iterator may be used for iteration
+ *          once again.
+ *
+ * \since 1.12.1
+ *
+ */
+H5_DLL herr_t H5Ssel_iter_reset(hid_t sel_iter_id, hid_t space_id);
+/**
+ * \ingroup H5S
+ *
+ * \brief Adjusts a selection by subtracting an offset
+ *
+ * \space_id{spaceid}
+ * \param[in] offset  Offset to subtract
+ *
+ * \return \herr_t
+ *
+ * \details H5Sselect_adjust() shifts a dataspace selection by a specified
+ *          logical offset within the dataspace extent.
+ *
+ * \note This can be useful for VOL developers to implement chunked datasets.
+ *
+ * \since 1.10.6
+ */
+H5_DLL herr_t H5Sselect_adjust(hid_t spaceid, const hssize_t *offset);
+/**
+ * \ingroup H5S
+ *
+ * \brief Selects an entire dataspace
+ *
+ * \space_id{spaceid}
+ *
+ * \return \herr_t
+ *
+ * \details H5Sselect_all() selects the entire extent of the dataspace
+ *          \p dspace_id.
+ *
+ *          More specifically, H5Sselect_all() sets the selection type to
+ *          #H5S_SEL_ALL, which specifies the entire dataspace anywhere it
+ *          is applied.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Sselect_all(hid_t spaceid);
+/**
+ * \ingroup H5S
+ *
+ * \brief Copies a selection from one dataspace to another
+ *
+ * \space_id{dst_id}
+ * \space_id{src_id}
+ *
+ * \return \herr_t
+ *
+ * \details H5Sselect_copy() copies all selection information (including
+ *          offset) from the source dataspace \p src_id to the destination
+ *          dataspace \p dst_id.
+ *
+ * \since 1.10.6
+ *
+ */
+H5_DLL herr_t H5Sselect_copy(hid_t dst_id, hid_t src_id);
+/**
+ * \ingroup H5S
+ *
+ * \brief Selects array elements to be included in the selection for a
+ *        dataspace
+ *
+ * \space_id
+ * \param[in] op  Operator specifying how the new selection is to be
+ *                combined with the existing selection for the dataspace
+ * \param[in] num_elem  Number of elements to be selected
+ * \param[in] coord  A pointer to a buffer containing a serialized copy of
+ *                   a 2-dimensional array of zero-based values specifying
+ *                   the coordinates of the elements in the point selection
+ *
+ * \return \herr_t
+ *
+ * \details H5Sselect_elements() selects array elements to be included in
+ *          the selection for the \p space_id dataspace. This is referred
+ *          to as a point selection.
+ *
+ *          The number of elements selected is set in the \p num_elements
+ *          parameter.
+ *
+ *          The \p coord parameter is a pointer to a buffer containing a
+ *          serialized 2-dimensional array of size \p num_elements by the
+ *          rank of the dataspace. The array lists dataset elements in the
+ *          point selection; that is, it's a list of zero-based values
+ *          specifying the coordinates in the dataset of the selected
+ *          elements. The order of the element coordinates in the \p coord
+ *          array specifies the order in which the array elements are
+ *          iterated through when I/O is performed. Duplicate coordinate
+ *          locations are not checked for. See below for examples of the
+ *          mapping between the serialized contents of the buffer and the
+ *          point selection array that it represents.
+ *
+ *          The selection operator \p op determines how the new selection
+ *          is to be combined with the previously existing selection for
+ *          the dataspace. The following operators are supported:
+ *
+ *          <table>
+ *           <tr>
+ *             <td>#H5S_SELECT_SET</td>
+ *             <td>Replaces the existing selection with the parameters from
+ *                 this call. Overlapping blocks are not supported with this
+ *                 operator. Adds the new selection to the existing selection.
+ *                 </td>
+ *           </tr>
+ *           <tr>
+ *             <td>#H5S_SELECT_APPEND</td>
+ *             <td>Adds the new selection following the last element of the
+ *                 existing selection.</td>
+ *           </tr>
+ *           <tr>
+ *              <td>#H5S_SELECT_PREPEND</td>
+ *              <td>Adds the new selection preceding the first element of the
+ *                  existing selection.</td>
+ *           </tr>
+ *          </table>
+ *
+ *          <b>Mapping the serialized \p coord buffer to a 2-dimensional
+ *          point selection array:</b>
+ *          To illustrate the construction of the contents of the \p coord
+ *          buffer, consider two simple examples: a selection of 5 points in
+ *          a 1-dimensional array and a selection of 3 points in a
+ *          4-dimensional array.
+ *
+ *          In the 1D case, we will be selecting five points and a 1D
+ *          dataspace has rank 1, so the selection will be described in a
+ *          5-by-1 array. To select the 1st, 14th, 17th, 23rd and 8th elements
+ *          of the dataset, the selection array would be as follows
+ *          (remembering that point coordinates are zero-based):
+ *          \n      0
+ *          \n     13
+ *          \n     16
+ *          \n     22
+ *          \n      7
+ *
+ *          This point selection array will be serialized in the \p coord
+ *          buffer as:
+ *          \n      0 13 16 22 7
+ *
+ *          In the 4D case, we will be selecting three points and a 4D
+ *          dataspace has rank 4, so the selection will be described in a
+ *          3-by-4 array. To select the points (1,1,1,1), (14,6,12,18), and
+ *          (8,22,30,22), the point selection array would be as follows:
+ *          \n      0  0  0  0
+ *          \n     13  5 11 17
+ *          \n      7 21 29 21
+ *
+ *          This point selection array will be serialized in the \p coord
+ *          buffer as:
+ *          \n      0 0 0 0 13 5 11 17 7 21 29 21
+ *
+ * \version 1.6.4 C coord parameter type changed to \p const hsize_t.
+ * \version 1.6.4 Fortran \p coord parameter type changed to \p INTEGER(HSIZE_T).
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Sselect_elements(hid_t space_id, H5S_seloper_t op, size_t num_elem, const hsize_t *coord);
+/**
+ * \ingroup H5S
+ *
+ * \brief Selects a hyperslab region to add to the current selected region
+ *
+ * \space_id
+ * \param[in] op     Operation to perform on current selection
+ * \param[in] start  Offset of start of hyperslab
+ * \param[in] stride Hyperslab stride
+ * \param[in] count  Number of blocks included in hyperslab
+ * \param[in] block  Size of block in hyperslab
+ *
+ * \return \herr_t
+ *
+ * \details H5Sselect_hyperslab() selects a hyperslab region to add to the
+ *          current selected region for the dataspace specified by
+ *          \p space_id.
+ *
+ *          The \p start, \p stride, \p count, and \p block arrays must be the
+ *          same size as the rank of the dataspace. For example, if the
+ *          dataspace is 4-dimensional, each of these parameters must be a
+ *          1-dimensional array of size 4.
+ *
+ *          The selection operator \p op determines how the new selection
+ *          is to be combined with the already existing selection for the
+ *          dataspace. The following operators are supported:
+ *
+ *          <table>
+ *           <tr>
+ *             <td>#H5S_SELECT_SET</td>
+ *             <td>Replaces the existing selection with the
+ *              parameters from this call. Overlapping blocks
+ *             are not supported with this operator.</td>
+ *           </tr>
+ *           <tr>
+ *              <td>#H5S_SELECT_OR</td>
+ *              <td>Adds the new selection to the existing selection.
+ *              (Binary OR)</td>
+ *           </tr>
+ *           <tr>
+ *             <td>#H5S_SELECT_AND</td>
+ *             <td>Retains only the overlapping portions of the
+ *                new selection and the existing selection.
+ *               (Binary AND)</td>
+ *          </tr>
+ *          <tr>
+ *             <td>#H5S_SELECT_XOR</td>
+ *             <td>Retains only the elements that are members of
+ *                  the new selection or the existing selection,
+ *                  excluding elements that are members of both
+ *                  selections. (Binary exclusive-OR, XOR)
+ *                 </td>
+ *          </tr>
+ *          <tr>
+ *             <td>#H5S_SELECT_NOTB</td>
+ *             <td>Retains only elements of the existing selection
+ *               that are not in the new selection.</td>
+ *          </tr>
+ *          <tr>
+ *             <td>#H5S_SELECT_NOTA</td>
+ *             <td>Retains only elements of the new selection that
+ *              are not in the existing selection.</td>
+ *          </tr>
+ *          </table>
+ *
+ *          The \p start array specifies the offset of the starting element
+ *          of the specified hyperslab.
+ *
+ *          The \p stride array chooses array locations from the dataspace with
+ *          each value in the \p stride array determining how many elements to
+ *          move in each dimension. Setting a value in the \p stride array to
+ *          \p 1 moves to each element in that dimension of the dataspace;
+ *          setting a value of \p 2 in allocation in the \p stride array moves
+ *          to every other element in that dimension of the dataspace. In
+ *          other words, the \p stride determines the number of elements to
+ *          move from the \p start location in each dimension. Stride values
+ *          of \p 0 are not allowed. If the \p stride parameter is NULL, a
+ *          contiguous hyperslab is selected (as if each value in the \p stride
+ *          array were set to \p 1).
+ *
+ *          The \p count array determines how many blocks to select from the
+ *          dataspace, in each dimension.
+ *
+ *          The \p block array determines the size of the element block
+ *          selected from the dataspace. If the \p block parameter is set to
+ *          NULL, the block size defaults to a single element in each dimension
+ *          (as if each value in the \p block array were set to \p 1).
+ *
+ *          For example, consider a 2-dimensional dataspace with hyperslab
+ *          selection settings as follows: the \p start offset is specified as
+ *          [1,1], \p stride is [4,4], \p count is [3,7], and \p block is [2,2].
+ *          In C, these settings will specify a hyperslab consisting of 21
+ *          2x2 blocks of array elements starting with location (1,1) with the
+ *          selected blocks at locations (1,1), (5,1), (9,1), (1,5), (5,5), etc.;
+ *          in Fortran, they will specify a hyperslab consisting of 21 2x2
+ *          blocks of array elements starting with location (2,2), since \p start
+ *          is 0-based indexed, with the selected blocks at
+ *          locations (2,2), (6,2), (10,2), (2,6), (6,6), etc.
+ *
+ *          Regions selected with this function call default to C order
+ *          iteration when I/O is performed.
+ *
+ * \version 1.4.0 Fortran subroutine introduced in this release.
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Sselect_hyperslab(hid_t space_id, H5S_seloper_t op, const hsize_t start[],
+                                  const hsize_t stride[], const hsize_t count[], const hsize_t block[]);
+/*--------------------------------------------------------------------------*/
+/**\ingroup H5S
+ *
+ * \brief Checks if current selection intersects with a block
+ *
+ * \space_id
+ * \param[in] start  Starting coordinate of block
+ * \param[in] end    Opposite ("ending") coordinate of block
+ *
+ * \return \htri_t
+ *
+ * \details H5Sselect_intersect_block() checks to see if the current
+ *          selection \p space_id in the dataspace intersects with the block
+ *          specified by \p start and \p end.
+ *
+ * \note Assumes that \p start & \p end block bounds are inclusive, so
+ *       \p start == \p end value is OK.
+ *
+ * \since 1.10.6
+ *
+ */
+H5_DLL htri_t H5Sselect_intersect_block(hid_t space_id, const hsize_t *start, const hsize_t *end);
+/*--------------------------------------------------------------------------*/
+/**\ingroup H5S
+ *
+ * \brief Resets the selection region to include no elements
+ *
+ * \space_id{spaceid}
+ *
+ * \return \herr_t
+ *
+ * \details H5Sselect_none() resets the selection region for the dataspace
+ *          \p space_id to include no elements.
+ *
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Sselect_none(hid_t spaceid);
+/*--------------------------------------------------------------------------*/
+/**\ingroup H5S
+ *
+ * \brief Projects the intersection of two source selections to a
+ *        destination selection
+ *
+ * \space_id{src_space_id}
+ * \space_id{dst_space_id}
+ * \space_id{src_intersect_space_id}
+ *
+ * \return Returns a dataspace with a selection equal to the intersection of
+ *         \p src_intersect_space_id and \p src_space_id projected from
+ *         \p src_space to \p dst_space on success, negative on failure.
+ *
+ * \details H5Sselect_project_intersection() computes the intersection
+ *          between two dataspace selections and projects that intersection
+ *          into a third selection.This can be useful for VOL developers to
+ *          implement chunked or virtual datasets.
+ *
+ * \since 1.10.6
+ *
+ */
+H5_DLL hid_t H5Sselect_project_intersection(hid_t src_space_id, hid_t dst_space_id,
+                                            hid_t src_intersect_space_id);
+/*--------------------------------------------------------------------------*/
+/**\ingroup H5S
+ *
+ * \brief Checks if two selections are the same shape
+ *
+ * \space_id{space1_id}
+ * \space_id{space2_id}
+ *
+ * \return \htri_t
+ *
+ * \details H5Sselect_shape_same() checks to see if the current selection
+ *          in the dataspaces are the same dimensionality and shape.
+ *
+ *          This is primarily used for reading the entire selection in
+ *          one swoop.
+ *
+ * \since 1.10.6
+ *
+ */
+H5_DLL htri_t H5Sselect_shape_same(hid_t space1_id, hid_t space2_id);
+/*--------------------------------------------------------------------------*/
+/**\ingroup H5S
+ *
+ * \brief Verifies that the selection is within the extent of the dataspace
+ *
+ * \space_id{spaceid}
+ *
+ * \return \htri_t
+ *
+ * \details H5Sselect_valid() verifies that the selection for the dataspace
+ *          \p space_id is within the extent of the dataspace if the current
+ *          offset for the dataspace is used.
+ *
+ * \version 1.4.0 Fortran subroutine introduced in this release.
+ * \since 1.0.0
+ *
+ */
+H5_DLL htri_t H5Sselect_valid(hid_t spaceid);
+/*--------------------------------------------------------------------------*/
+/**\ingroup H5S
+ *
+ * \brief Resets the extent of a dataspace back to "none"
+ *
+ * \space_id
+ *
+ * \return  \herr_t
+ *
+ * \details H5Sset_extent_none() resets the type of a dataspace to
+ *          #H5S_NULL with no extent information stored for the dataspace.
+ *
+ * \version 1.10.7, 1.12.1  The function behavior changed. The previous
+ *                          behavior was to set the class to #H5S_NO_CLASS.
+ * \version 1.4.0           Fortran subroutine was introduced.
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Sset_extent_none(hid_t space_id);
+/*--------------------------------------------------------------------------*/
+/**\ingroup H5S
+ *
+ * \brief Sets or resets the size of an existing dataspace
+ *
+ * \space_id
+ * \param[in] rank   Rank, or dimensionality, of the dataspace
+ * \param[in] dims   Array containing current size of dataspace
+ * \param[in] max    Array containing maximum size of dataspace
+ *
+ * \return \herr_t
+ *
+ * \details H5Sset_extent_simple() sets or resets the size of an existing
+ *          dataspace.
+ *
+ *          \p dims is an array of size \p rank that contains the new size
+ *          of each dimension in the dataspace. \p max is an array of size
+ *          \p rank that contains the maximum size of each dimension in
+ *          the dataspace.
+ *
+ *          Any previous extent is removed from the dataspace, the dataspace
+ *          type is set to #H5S_SIMPLE, and the extent is set as specified.
+ *
+ * \version 1.4.0 Fortran subroutine was introduced.
+ * \since 1.0.0
+ *
+ */
+H5_DLL herr_t H5Sset_extent_simple(hid_t space_id, int rank, const hsize_t dims[], const hsize_t max[]);
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+/* Function prototypes */
+/* --------------------------------------------------------------------------*/
+/**\ingroup H5S
+ *
+ * \brief Encodes a data space object description into a binary buffer
+ *
+ * \space_id{obj_id}
+ * \param[in,out] buf     Buffer for the object to be encoded into;
+ *                        If the provided buffer is NULL, only the size of
+ *                        buffer needed is returned through \p nalloc.
+ * \param[in,out] nalloc  The size of the allocated buffer
+ *
+ * \return \herr_t
+ *
+ * \deprecated Deprecated in favor of H5Sencode2()
+ *
+ * \details Given the data space identifier \p obj_id, H5Sencode1() converts
+ *          a data space description into binary form in a buffer. Using
+ *          this binary form in the buffer, a data space object can be
+ *          reconstructed using H5Sdecode() to return a new object handle
+ *          (\p hid_t) for this data space.
+ *
+ *          A preliminary H5Sencode1() call can be made to find out the size
+ *          of the buffer needed. This value is returned as \p nalloc. That
+ *          value can then be assigned to \p nalloc for a second H5Sencode1()
+ *          call, which will retrieve the actual encoded object.
+ *
+ *          If the library finds out \p nalloc is not big enough for the
+ *          object, it simply returns the size of the buffer needed through
+ *          \p nalloc without encoding the provided buffer.
+ *
+ *          The types of data space addressed in this function are null,
+ *          scalar, and simple space. For a simple data space, the information
+ *          on the selection, for example, hyperslab selection, is also
+ *          encoded and decoded. A complex data space has not been
+ *          implemented in the library.
+ *
+ * \version 1.12.0 The function H5Sencode() was renamed H5Sencode1() and
+ *                 deprecated.
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Sencode1(hid_t obj_id, void *buf, size_t *nalloc);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* H5Spublic_H */
diff --git a/install/include/H5TBpublic.h b/install/include/H5TBpublic.h
new file mode 100644
index 0000000000..42585cf012
--- /dev/null
+++ b/install/include/H5TBpublic.h
@@ -0,0 +1,676 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef H5TBpublic_H
+#define H5TBpublic_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** \page H5TB_UG The HDF5 High Level Table
+ * @todo Under Construction
+ */
+
+/**\defgroup H5TB HDF5 Table APIs (H5TB)
+ *
+ * <em>Creating and manipulating HDF5 datasets intended to be
+ * interpreted as tables (H5TB)</em>
+ *
+ * The HDF5 Table API defines a standard storage for HDF5 datasets
+ * that are intended to be interpreted as tables. A table is defined
+ * as a collection of records whose values are stored in fixed-length
+ * fields. All records have the same structure, and all values in
+ * each field have the same data type.
+ *
+ * \note \Bold{Programming hints:}
+ * \note To use any of these functions or subroutines,
+ *       you must first include the relevant include file (C) or
+ *       module (Fortran) in your application.
+ * \note The following line includes the HDF5 Table package, H5TB,
+ *       in C applications:
+ *       \code #include "hdf5_hl.h" \endcode
+ * \note To include the H5TB module in Fortran applications specify:
+ *       \code use h5tb \endcode
+ *       Fortran applications must also include \ref H5open before
+ *       any HDF5 calls to initialize global variables and \ref H5close
+ *       after all HDF5 calls to close the Fortran interface.
+ *
+ * <table>
+ * <tr valign="top"><td style="border: none;">
+ *
+ * - Creation
+ *   - \ref H5TBmake_table
+ * - Storage
+ *   - \ref H5TBappend_records (No Fortran)
+ *   - \ref H5TBwrite_records (No Fortran)
+ *   - \ref H5TBwrite_fields_name
+ *   - \ref H5TBwrite_fields_index
+ *
+ * - Modification
+ *   - \ref H5TBdelete_record (No Fortran)
+ *   - \ref H5TBinsert_record (No Fortran)
+ *   - \ref H5TBadd_records_from (No Fortran)
+ *   - \ref H5TBcombine_tables (No Fortran)
+ *   - \ref H5TBinsert_field
+ *   - \ref H5TBdelete_field
+ *
+ * </td><td style="border: none;">
+ *
+ * - Retrieval
+ *   - \ref H5TBread_table
+ *   - \ref H5TBread_records (No Fortran)
+ *   - \ref H5TBread_fields_name
+ *   - \ref H5TBread_fields_index
+ *
+ * - Query
+ *   - \ref H5TBget_table_info
+ *   - \ref H5TBget_field_info
+ *
+ * - Query Table Attributes
+ *   - \ref H5TBAget_fill
+ *   - \ref H5TBAget_title
+ *
+ * </td></tr>
+ * </table>
+ *
+ */
+
+/*-------------------------------------------------------------------------
+ *
+ * Create functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ * \brief Creates and writes a table
+ *
+ * \param[in] table_title   The title of the table
+ * \fg_loc_id
+ * \param[in] dset_name     The name of the dataset to create
+ * \param[in] nfields       The number of fields
+ * \param[in] nrecords      The number of records
+ * \param[in] type_size     The size in bytes of the structure
+ *                          associated with the table;
+ *                          This value is obtained with \c sizeof().
+ * \param[in] field_names   An array containing the names of
+ *                          the fields
+ * \param[in] field_offset  An array containing the offsets of
+ *                          the fields
+ * \param[in] field_types   An array containing the type of
+ *                          the fields
+ * \param[in] chunk_size    The chunk size
+ * \param[in] fill_data     Fill values data
+ * \param[in] compress      Flag that turns compression on or off
+ * \param[in] buf           Buffer with data to be written to the table
+ *
+ * \return \herr_t
+ *
+ * \details H5TBmake_table() creates and writes a dataset named
+ *          \p dset_name attached to the object specified by the
+ *          identifier loc_id.
+ *
+ */
+H5_HLDLL herr_t H5TBmake_table(const char *table_title, hid_t loc_id, const char *dset_name, hsize_t nfields,
+                               hsize_t nrecords, size_t type_size, const char *field_names[],
+                               const size_t *field_offset, const hid_t *field_types, hsize_t chunk_size,
+                               void *fill_data, int compress, const void *buf);
+
+/*-------------------------------------------------------------------------
+ *
+ * Write functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ * \brief Adds records to the end of the table
+ *
+ * \fg_loc_id
+ * \param[in] dset_name     The name of the dataset to overwrite
+ * \param[in] nrecords      The number of records to append
+ * \param[in] type_size     The size of the structure type,
+ *                          as calculated by \c sizeof().
+ * \param[in] field_offset  An array containing the offsets of
+ *                          the fields. These offsets can be
+ *                          calculated with the #HOFFSET macro
+ * \param[in] dst_sizes     An array containing the sizes of
+ *                          the fields
+ * \param[in] buf           Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5TBappend_records() adds records to the end of the table
+ *          named \p dset_name attached to the object specified by the
+ *          identifier \p loc_id. The dataset is extended to hold the
+ *          new records.
+ *
+ */
+H5_HLDLL herr_t H5TBappend_records(hid_t loc_id, const char *dset_name, hsize_t nrecords, size_t type_size,
+                                   const size_t *field_offset, const size_t *dst_sizes, const void *buf);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ * \brief Overwrites records
+ *
+ * \fg_loc_id
+ * \param[in] dset_name    The name of the dataset to overwrite
+ * \param[in] start         The zero index record to start writing
+ * \param[in] nrecords      The number of records to write
+ * \param[in] type_size     The size of the structure type, as
+ *                          calculated by \c sizeof().
+ * \param[in] field_offset  An array containing the offsets of
+ *                          the fields.  These offsets can be
+ *                          calculated with the #HOFFSET macro
+ * \param[in] dst_sizes     An array containing the sizes of
+ *                          the fields
+ * \param[in] buf           Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5TBwrite_records() overwrites records starting at the zero
+ *          index position start of the table named \p dset_name attached
+ *          to the object specified by the identifier \p loc_id.
+ *
+ */
+H5_HLDLL herr_t H5TBwrite_records(hid_t loc_id, const char *dset_name, hsize_t start, hsize_t nrecords,
+                                  size_t type_size, const size_t *field_offset, const size_t *dst_sizes,
+                                  const void *buf);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ * \brief Overwrites fields
+ *
+ * \fg_loc_id
+ * \param[in] dset_name    The name of the dataset to overwrite
+ * \param[in] field_names   The names of the fields to write
+ * \param[in] start         The zero index record to start writing
+ * \param[in] nrecords      The number of records to write
+ * \param[in] type_size     The size of the structure type, as
+ *                          calculated by \c sizeof().
+ * \param[in] field_offset  An array containing the offsets of
+ *                          the fields.  These offsets can be
+ *                          calculated with the #HOFFSET macro
+ * \param[in] dst_sizes     An array containing the sizes of
+ *                          the fields
+ * \param[in] buf           Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5TBwrite_fields_name() overwrites one or several fields
+ *          specified by \p field_names with data in \p buf from a
+ *          dataset named \p dset_name attached to the object specified
+ *          by the identifier \p loc_id.
+ *
+ */
+H5_HLDLL herr_t H5TBwrite_fields_name(hid_t loc_id, const char *dset_name, const char *field_names,
+                                      hsize_t start, hsize_t nrecords, size_t type_size,
+                                      const size_t *field_offset, const size_t *dst_sizes, const void *buf);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ * \brief Overwrites fields
+ *
+ * \fg_loc_id
+ * \param[in] dset_name     The name of the dataset to overwrite
+ * \param[in] nfields       The number of fields to overwrite.
+ *                          This parameter is also the size of the
+ *                          \p field_index array.
+ * \param[in] field_index   The indexes of the fields to write
+ * \param[in] start         The zero based index record to start writing
+ * \param[in] nrecords      The number of records to write
+ * \param[in] type_size     The size of the structure type, as
+ *                          calculated by \c sizeof().
+ * \param[in] field_offset  An array containing the offsets of
+ *                          the fields.  These offsets can be
+ *                          calculated with the #HOFFSET macro
+ * \param[in] dst_sizes     An array containing the sizes of
+ *                          the fields
+ * \param[in] buf           Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5TBwrite_fields_index() overwrites one or several fields
+ *          specified by \p field_index with a buffer \p buf from a
+ *          dataset named \p dset_name attached to the object
+ *          specified by the identifier \p loc_id.
+ *
+ */
+H5_HLDLL herr_t H5TBwrite_fields_index(hid_t loc_id, const char *dset_name, hsize_t nfields,
+                                       const int *field_index, hsize_t start, hsize_t nrecords,
+                                       size_t type_size, const size_t *field_offset, const size_t *dst_sizes,
+                                       const void *buf);
+
+/*-------------------------------------------------------------------------
+ *
+ * Read functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ * \brief Reads a table
+ *
+ * \fg_loc_id
+ * \param[in] dset_name    The name of the dataset to read
+ * \param[in] dst_size     The size of the structure type,
+ *                          as calculated by \c sizeof()
+ * \param[in] dst_offset    An array containing the offsets of
+ *                          the fields.  These offsets can be
+ *                          calculated with the #HOFFSET macro
+ * \param[in] dst_sizes     An array containing the sizes of
+ *                          the fields.  These sizes can be
+ *                          calculated with the sizeof() macro.
+ * \param[in] dst_buf       Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5TBread_table() reads a table named
+ *          \p dset_name attached to the object specified by
+ *          the identifier \p loc_id.
+ *
+ */
+H5_HLDLL herr_t H5TBread_table(hid_t loc_id, const char *dset_name, size_t dst_size, const size_t *dst_offset,
+                               const size_t *dst_sizes, void *dst_buf);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ * \brief Reads one or several fields. The fields are identified by name.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name    The name of the dataset to read
+ * \param[in] field_names   An array containing the names of the
+ *                          fields to read
+ * \param[in] start         The start record to read from
+ * \param[in] nrecords      The number of records to read
+ * \param[in] type_size     The size in bytes of the structure associated
+ *                          with the table
+ *                          (This value is obtained with \c sizeof().)
+ * \param[in] field_offset  An array containing the offsets of the fields
+ * \param[in] dst_sizes     An array containing the size in bytes of
+ *                          the fields
+ * \param[out] buf          Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5TBread_fields_name() reads the fields identified
+ *          by \p field_names from a dataset named \p dset_name
+ *          attached to the object specified by the identifier \p loc_id.
+ *
+ */
+H5_HLDLL herr_t H5TBread_fields_name(hid_t loc_id, const char *dset_name, const char *field_names,
+                                     hsize_t start, hsize_t nrecords, size_t type_size,
+                                     const size_t *field_offset, const size_t *dst_sizes, void *buf);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ *
+ * \brief Reads one or several fields. The fields are identified by index.
+ *
+ * \fg_loc_id
+ * \param[in] dset_name     The name of the dataset to read
+ * \param[in] nfields       The number of fields to read
+ *                          (This parameter is also the size of the
+ *                          \p field_index array.)
+ *                          fields to read
+ * \param[in] field_index   The indexes of the fields to read
+ * \param[in] start         The start record to read from
+ * \param[in] nrecords      The number of records to read
+ * \param[in] type_size     The size in bytes of the structure associated
+ *                          with the table
+ *                          (This value is obtained with \c sizeof())
+ * \param[in] field_offset  An array containing the offsets of the fields
+ * \param[in] dst_sizes     An array containing the size in bytes of
+ *                          the fields
+ * \param[out] buf          Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5TBread_fields_index() reads the fields identified
+ *          by \p field_index from a dataset named \p dset_name attached
+ *          to the object specified by the identifier \p loc_id.
+ *
+ */
+H5_HLDLL herr_t H5TBread_fields_index(hid_t loc_id, const char *dset_name, hsize_t nfields,
+                                      const int *field_index, hsize_t start, hsize_t nrecords,
+                                      size_t type_size, const size_t *field_offset, const size_t *dst_sizes,
+                                      void *buf);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ *
+ * \brief Reads records
+ *
+ * \fg_loc_id
+ * \param[in] dset_name     The name of the dataset to read
+ * \param[in] start         The start record to read from
+ * \param[in] nrecords      The number of records to read
+ * \param[in] type_size     The size of the structure type,
+ *                          as calculated by \c sizeof()
+ * \param[in] dst_offset    An array containing the offsets of the
+ *                          fields.  These offsets can be calculated
+ *                          with the #HOFFSET macro
+ * \param[in] dst_sizes     An array containing the size in bytes of
+ *                          the fields
+ * \param[out] buf          Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5TBread_records() reads some records identified from a dataset
+ *          named \p dset_name attached to the object specified by the
+ *          identifier \p loc_id.
+ *
+ */
+H5_HLDLL herr_t H5TBread_records(hid_t loc_id, const char *dset_name, hsize_t start, hsize_t nrecords,
+                                 size_t type_size, const size_t *dst_offset, const size_t *dst_sizes,
+                                 void *buf);
+
+/*-------------------------------------------------------------------------
+ *
+ * Inquiry functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ *
+ * \brief Gets the table dimensions
+ *
+ * \fg_loc_id
+ * \param[in] dset_name     The name of the dataset to read
+ * \param[out] nfields      The number of fields
+ * \param[out] nrecords     The number of records
+ *
+ * \return \herr_t
+ *
+ * \details H5TBget_table_info() retrieves the table dimensions from a
+ *          dataset named \p dset_name attached to the object specified
+ *          by the identifier \p loc_id.
+ *
+ */
+H5_HLDLL herr_t H5TBget_table_info(hid_t loc_id, const char *dset_name, hsize_t *nfields, hsize_t *nrecords);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ *
+ * \brief Gets information about a table
+ *
+ * \fg_loc_id
+ * \param[in] dset_name         The name of the dataset to read
+ * \param[out] field_names      An array containing the names of the fields
+ * \param[out] field_sizes      An array containing the size of the fields
+ * \param[out] field_offsets    An array containing the offsets of the fields
+ * \param[out] type_size        The size of the HDF5 datatype associated
+ *                              with the table.  (More specifically,
+ *                              the size in bytes of the HDF5 compound
+ *                              datatype used to define a row, or record,
+ *                              in the table)
+ *
+ * \return \herr_t
+ *
+ * \details H5TBget_field_info() gets information about a dataset
+ *          named \p dset_name attached to the object specified
+ *          by the identifier \p loc_id.
+ *
+ */
+H5_HLDLL herr_t H5TBget_field_info(hid_t loc_id, const char *dset_name, char *field_names[],
+                                   size_t *field_sizes, size_t *field_offsets, size_t *type_size);
+
+/*-------------------------------------------------------------------------
+ *
+ * Manipulation functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ *
+ * \brief Delete records
+ *
+ * \fg_loc_id
+ * \param[in] dset_name    The name of the dataset
+ * \param[in] start        The start record to delete from
+ * \param[in] nrecords     The number of records to delete
+ *
+ * \return \herr_t
+ *
+ * \details H5TBdelete_record() deletes nrecords number of records starting
+ *          from \p start from the middle of the table \p dset_name
+ *          ("pulling up" all the records after it).
+ *
+ */
+H5_HLDLL herr_t H5TBdelete_record(hid_t loc_id, const char *dset_name, hsize_t start, hsize_t nrecords);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ *
+ * \brief Insert records
+ *
+ * \fg_loc_id
+ * \param[in] dset_name     The name of the dataset
+ * \param[in] start         The position to insert
+ * \param[in] nrecords      The number of records to insert
+ * \param[in] dst_size      The size in bytes of the structure
+ *                          associated with the table
+ * \param[in] dst_offset    An array containing the offsets of the
+ *                          fields
+ * \param[in] dst_sizes     An array containing the size in bytes of
+ *                          the fields
+ * \param[in] buf           Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5TBinsert_record() inserts records into the middle of the table
+ *          ("pushing down" all the records after it)
+ *
+ */
+H5_HLDLL herr_t H5TBinsert_record(hid_t loc_id, const char *dset_name, hsize_t start, hsize_t nrecords,
+                                  size_t dst_size, const size_t *dst_offset, const size_t *dst_sizes,
+                                  void *buf);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ *
+ * \brief Add records from first table to second table
+ *
+ * \fg_loc_id
+ * \param[in] dset_name1    The name of the dataset to read the records
+ * \param[in] start1        The position to read the records from the
+ *                          first table
+ * \param[in] nrecords      The number of records to read from the first
+ *                          table
+ * \param[in] dset_name2    The name of the dataset to write the records
+ * \param[in] start2        The position to write the records on the
+ *                          second table
+ *
+ * \return \herr_t
+ *
+ * \details H5TBadd_records_from() adds records from a dataset named
+ *          \p dset_name1 to a dataset named \p dset_name2. Both tables
+ *          are attached to the object specified by the identifier loc_id.
+ *
+ */
+H5_HLDLL herr_t H5TBadd_records_from(hid_t loc_id, const char *dset_name1, hsize_t start1, hsize_t nrecords,
+                                     const char *dset_name2, hsize_t start2);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ *
+ * \brief Combines records from two tables into a third
+ *
+ * \param[in] loc_id1       Identifier of the file or group in which
+ *                          the first table is located
+ * \param[in] dset_name1    The name of the first table to combine
+ * \param[in] loc_id2       Identifier of the file or group in which
+ *                          the second table is located
+ * \param[in] dset_name2    The name of the second table to combine
+ * \param[in] dset_name3    The name of the new table
+ *
+ * \return \herr_t
+ *
+ * \details H5TBcombine_tables() combines records from two datasets named
+ *          \p dset_name1 and \p dset_name2, to a new table named
+ *          \p dset_name3. These tables can be located on different files,
+ *          identified by \p loc_id1 and \p loc_id2 (identifiers obtained
+ *          with H5Fcreate()). They can also be located on the same file.
+ *          In this case one uses the same identifier for both parameters
+ *          \p loc_id1 and \p loc_id2. If two files are used, the third
+ *          table is written in the first file.
+ *
+ */
+H5_HLDLL herr_t H5TBcombine_tables(hid_t loc_id1, const char *dset_name1, hid_t loc_id2,
+                                   const char *dset_name2, const char *dset_name3);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ *
+ * \brief Insert a new field into a table
+ *
+ * \fg_loc_id
+ * \param[in] dset_name     The name of the table
+ * \param[in] field_name    The name of the field to insert
+ * \param[in] field_type    The data type of the field
+ * \param[in] position      The zero based index position where to
+ *                          insert the field
+ * \param[in] fill_data     Fill value data for the field. This parameter
+ *                          can be NULL
+ * \param[in] buf           Buffer with data
+ *
+ * \return \herr_t
+ *
+ * \details H5TBinsert_field() inserts a new field named \p field_name into
+ *          the table \p dset_name. Note: this function requires the table
+ *          to be re-created and rewritten in its entirety, and this can result
+ *          in some unused space in the file, and can also take a great deal of
+ *          time if the table is large.
+ *
+ */
+H5_HLDLL herr_t H5TBinsert_field(hid_t loc_id, const char *dset_name, const char *field_name,
+                                 hid_t field_type, hsize_t position, const void *fill_data, const void *buf);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ *
+ * \brief Deletes a field from a table
+ *
+ * \fg_loc_id
+ * \param[in] dset_name     The name of the table
+ * \param[in] field_name    The name of the field to delete
+ *
+ * \return \herr_t
+ *
+ * \details H5TBdelete_field() deletes a field named \p field_name from the
+ *          table \p dset_name. Note: this function requires the table to be
+ *          re-created and rewritten in its entirety, and this can result in
+ *          some unused space in the file, and can also take a great deal of
+ *          time if the table is large.
+ *
+ */
+H5_HLDLL herr_t H5TBdelete_field(hid_t loc_id, const char *dset_name, const char *field_name);
+
+/*-------------------------------------------------------------------------
+ *
+ * Table attribute functions
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ *
+ * \brief Reads a table's title
+ *
+ * \fg_loc_id
+ * \param[out] table_title  Buffer for title name
+ *
+ * \return \herr_t
+ *
+ * \details H5TBget_title() returns the title of the table identified
+ *          by \p loc_id in a buffer \p table_title.
+ *
+ */
+H5_HLDLL herr_t H5TBAget_title(hid_t loc_id, char *table_title);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5TB
+ *
+ *
+ * \brief Reads the table attribute fill values
+ *
+ * \fg_loc_id
+ * \param[in] dset_name Name of table
+ * \param[in] dset_id   Table identifier
+ * \param[out] dst_buf Buffer of fill values for table fields
+ *
+ * \return
+ * \return A return value of 1 indicates that a fill value is present.
+ * \return A return value of 0 indicates a fill value is not present.
+ * \return A return value <0 indicates an error.
+ *
+ * \details H5TBget_fill() reads the table attribute fill values into
+ *          the buffer \p dst_buf for the table specified by \p dset_id
+ *          and \p dset_name located in \p loc_id.
+ *
+ * \par Example
+ * \include H5TBAget_fill.c
+ *
+ */
+H5_HLDLL htri_t H5TBAget_fill(hid_t loc_id, const char *dset_name, hid_t dset_id, unsigned char *dst_buf);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/install/include/H5TSdevelop.h b/install/include/H5TSdevelop.h
new file mode 100644
index 0000000000..c3e1a6a65b
--- /dev/null
+++ b/install/include/H5TSdevelop.h
@@ -0,0 +1,50 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5TS (threadsafety) developer
+ *      support routines.
+ */
+
+#ifndef H5TSdevelop_H
+#define H5TSdevelop_H
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* HDF5 global library lock routines */
+H5_DLL herr_t H5TSmutex_acquire(unsigned int lock_count, bool *acquired);
+H5_DLL herr_t H5TSmutex_release(unsigned int *lock_count);
+H5_DLL herr_t H5TSmutex_get_attempt_count(unsigned int *count);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5TSdevelop_H */
diff --git a/install/include/H5Tdevelop.h b/install/include/H5Tdevelop.h
new file mode 100644
index 0000000000..e571741ec2
--- /dev/null
+++ b/install/include/H5Tdevelop.h
@@ -0,0 +1,227 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5T (datatype) developer
+ *      support routines.
+ */
+
+#ifndef H5Tdevelop_H
+#define H5Tdevelop_H
+
+/* Include package's public header */
+#include "H5Tpublic.h"
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/**
+ * Commands sent to conversion functions
+ */
+typedef enum H5T_cmd_t {
+    H5T_CONV_INIT = 0, /**< query and/or initialize private data	     */
+    H5T_CONV_CONV = 1, /**< convert data from source to dest datatype */
+    H5T_CONV_FREE = 2  /**< function is being removed from path	     */
+} H5T_cmd_t;
+
+/**
+ * How is the `bkg' buffer used by the conversion function?
+ */
+typedef enum H5T_bkg_t {
+    H5T_BKG_NO   = 0, /**< background buffer is not needed, send NULL */
+    H5T_BKG_TEMP = 1, /**< bkg buffer used as temp storage only       */
+    H5T_BKG_YES  = 2  /**< init bkg buf with data before conversion   */
+} H5T_bkg_t;
+
+/**
+ * Type conversion client data
+ */
+//! <!-- [H5T_cdata_t_snip] -->
+typedef struct H5T_cdata_t {
+    H5T_cmd_t command;  /**< what should the conversion function do?    */
+    H5T_bkg_t need_bkg; /**< is the background buffer needed?	     */
+    hbool_t   recalc;   /**< recalculate private data		     */
+    void     *priv;     /**< private data				     */
+} H5T_cdata_t;
+//! <!-- [H5T_cdata_t_snip] -->
+
+/**
+ * Conversion function persistence
+ */
+typedef enum H5T_pers_t {
+    H5T_PERS_DONTCARE = -1, /**< wild card				     */
+    H5T_PERS_HARD     = 0,  /**< hard conversion function		     */
+    H5T_PERS_SOFT     = 1   /**< soft conversion function		     */
+} H5T_pers_t;
+
+/**
+ * All datatype conversion functions are...
+ */
+//! <!-- [H5T_conv_t_snip] -->
+typedef herr_t (*H5T_conv_t)(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata, size_t nelmts, size_t buf_stride,
+                             size_t bkg_stride, void *buf, void *bkg, hid_t dset_xfer_plist);
+//! <!-- [H5T_conv_t_snip] -->
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \ingroup CONV
+ *
+ * \brief Registers a datatype conversion function
+ *
+ * \param[in] pers Conversion function type
+ * \param[in] name Name displayed in diagnostic output
+ * \type_id{src_id} of source datatype
+ * \type_id{dst_id} of destination datatype
+ * \param[in] func Function to convert between source and destination datatypes
+ *
+ * \return \herr_t
+ *
+ * \details H5Tregister() registers a hard or soft conversion function for a
+ *          datatype conversion path. The parameter \p pers indicates whether a
+ *          conversion function is hard (#H5T_PERS_HARD) or soft
+ *          (#H5T_PERS_SOFT). User-defined functions employing compiler casting
+ *          are designated as \Emph{hard}; other user-defined conversion
+ *          functions registered with the HDF5 library (with H5Tregister() )
+ *          are designated as \Emph{soft}. The HDF5 library also has its own
+ *          hard and soft conversion functions.
+ *
+ *          A conversion path can have only one hard function. When type is
+ *          #H5T_PERS_HARD, \p func replaces any previous hard function.
+ *
+ *          When type is #H5T_PERS_SOFT, H5Tregister() adds the function to the
+ *          end of the master soft list and replaces the soft function in all
+ *          applicable existing conversion paths. Soft functions are used when
+ *          determining which conversion function is appropriate for this path.
+ *
+ *          The \p name is used only for debugging and should be a short
+ *          identifier for the function.
+ *
+ *          The path is specified by the source and destination datatypes \p
+ *          src_id and \p dst_id. For soft conversion functions, only the class
+ *          of these types is important.
+ *
+ *          The type of the conversion function pointer is declared as:
+ *          \snippet this H5T_conv_t_snip
+ *
+ *          The \ref H5T_cdata_t \c struct is declared as:
+ *          \snippet this H5T_cdata_t_snip
+ *
+ * \since 1.6.3 The following change occurred in the \ref H5T_conv_t function:
+ *              the \c nelmts parameter type changed to size_t.
+ *
+ */
+H5_DLL herr_t H5Tregister(H5T_pers_t pers, const char *name, hid_t src_id, hid_t dst_id, H5T_conv_t func);
+/**
+ * \ingroup CONV
+ *
+ * \brief Removes a conversion function
+ *
+ * \param[in] pers Conversion function type
+ * \param[in] name Name displayed in diagnostic output
+ * \type_id{src_id} of source datatype
+ * \type_id{dst_id} of destination datatype
+ * \param[in] func Function to convert between source and destination datatypes
+ *
+ * \return \herr_t
+ *
+ * \details H5Tunregister() removes a conversion function matching criteria
+ *          such as soft or hard conversion, source and destination types, and
+ *          the conversion function.
+ *
+ *          If a user is trying to remove a conversion function he registered,
+ *          all parameters can be used. If he is trying to remove a library's
+ *          default conversion function, there is no guarantee the \p name and
+ *          \p func parameters will match the user's chosen values. Passing in
+ *          some values may cause this function to fail. A good practice is to
+ *          pass in NULL as their values.
+ *
+ *          All parameters are optional. The missing parameters will be used to
+ *          generalize the search criteria.
+ *
+ *          The conversion function pointer type declaration is described in
+ *          H5Tregister().
+ *
+ * \version 1.6.3 The following change occurred in the \ref H5T_conv_t function:
+ *                the \c nelmts parameter type changed to size_t.
+ *
+ */
+H5_DLL herr_t H5Tunregister(H5T_pers_t pers, const char *name, hid_t src_id, hid_t dst_id, H5T_conv_t func);
+/**
+ * \ingroup CONV
+ *
+ * \brief Finds a conversion function
+ *
+ * \type_id{src_id} of source datatype
+ * \type_id{dst_id} of destination datatype
+ * \param[out] pcdata Pointer to type conversion data
+ *
+ * \return Returns a pointer to a suitable conversion function if successful.
+ *         Otherwise returns NULL.
+ *
+ * \details H5Tfind() finds a conversion function that can handle a conversion
+ *          from type \p src_id to type \p dst_id. The \p pcdata argument is a
+ *          pointer to a pointer to type conversion data which was created and
+ *          initialized by the soft type conversion function of this path when
+ *          the conversion function was installed on the path.
+ *
+ */
+H5_DLL H5T_conv_t H5Tfind(hid_t src_id, hid_t dst_id, H5T_cdata_t **pcdata);
+/**
+ * \ingroup CONV
+ *
+ * \brief Check whether the library's default conversion is hard conversion
+ *
+ * \type_id{src_id} of source datatype
+ * \type_id{dst_id} of destination datatype
+ *
+ * \return \htri_t
+ *
+ * \details H5Tcompiler_conv() determines whether the library's conversion
+ *          function from type \p src_id to type \p dst_id is a compiler (hard)
+ *          conversion or not. A compiler conversion uses compiler's casting; a
+ *          library (soft) conversion uses the library's own conversion
+ *          function.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL htri_t H5Tcompiler_conv(hid_t src_id, hid_t dst_id);
+
+#ifdef __cplusplus
+}
+#endif
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#endif /* H5Tdevelop_H */
diff --git a/install/include/H5Tpublic.h b/install/include/H5Tpublic.h
new file mode 100644
index 0000000000..1a16301b9c
--- /dev/null
+++ b/install/include/H5Tpublic.h
@@ -0,0 +1,2905 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5T module.
+ */
+#ifndef H5Tpublic_H
+#define H5Tpublic_H
+
+#include "H5public.h"  /* Generic Functions                        */
+#include "H5Ipublic.h" /* Identifiers                              */
+
+#define HOFFSET(S, M) (offsetof(S, M))
+
+/**
+ * These are the various classes of datatypes
+ * internal If this goes over 16 types (0-15), the file format will need to
+ *          change.
+ */
+//! <!-- [H5T_class_t_snip] -->
+typedef enum H5T_class_t {
+    H5T_NO_CLASS  = -1, /**< error                                   */
+    H5T_INTEGER   = 0,  /**< integer types                           */
+    H5T_FLOAT     = 1,  /**< floating-point types                    */
+    H5T_TIME      = 2,  /**< date and time types                     */
+    H5T_STRING    = 3,  /**< character string types                  */
+    H5T_BITFIELD  = 4,  /**< bit field types                         */
+    H5T_OPAQUE    = 5,  /**< opaque types                            */
+    H5T_COMPOUND  = 6,  /**< compound types                          */
+    H5T_REFERENCE = 7,  /**< reference types                         */
+    H5T_ENUM      = 8,  /**< enumeration types                       */
+    H5T_VLEN      = 9,  /**< variable-Length types                   */
+    H5T_ARRAY     = 10, /**< array types                             */
+
+    H5T_NCLASSES /**< sentinel: this must be last             */
+} H5T_class_t;
+//! <!-- [H5T_class_t_snip] -->
+
+/**
+ * Byte orders
+ */
+//! <!-- [H5T_order_t_snip] -->
+typedef enum H5T_order_t {
+    H5T_ORDER_ERROR = -1, /**< error                                   */
+    H5T_ORDER_LE    = 0,  /**< little endian                           */
+    H5T_ORDER_BE    = 1,  /**< bit endian                              */
+    H5T_ORDER_VAX   = 2,  /**< VAX mixed endian                        */
+    H5T_ORDER_MIXED = 3,  /**< Compound type with mixed member orders  */
+    H5T_ORDER_NONE  = 4   /**< no particular order (strings, bits,..)  */
+    /*H5T_ORDER_NONE must be last */
+} H5T_order_t;
+//! <!-- [H5T_order_t_snip] -->
+
+/**
+ * Types of integer sign schemes
+ */
+//! <!-- [H5T_sign_t_snip] -->
+typedef enum H5T_sign_t {
+    H5T_SGN_ERROR = -1, /**< error                                   */
+    H5T_SGN_NONE  = 0,  /**< this is an unsigned type                */
+    H5T_SGN_2     = 1,  /**< two's complement                        */
+
+    H5T_NSGN = 2 /** sentinel: this must be last!             */
+} H5T_sign_t;
+//! <!-- [H5T_sign_t_snip] -->
+
+/**
+ * Floating-point normalization schemes
+ */
+//! <!-- [H5T_norm_t_snip] -->
+typedef enum H5T_norm_t {
+    H5T_NORM_ERROR   = -1, /**< error                                   */
+    H5T_NORM_IMPLIED = 0,  /**< msb of mantissa isn't stored, always 1  */
+    H5T_NORM_MSBSET  = 1,  /**< msb of mantissa is always 1             */
+    H5T_NORM_NONE    = 2   /**< not normalized                          */
+    /*H5T_NORM_NONE must be last */
+} H5T_norm_t;
+//! <!-- [H5T_norm_t_snip] -->
+
+/**
+ * Character set to use for text strings.
+ * \internal Do not change these values since they appear in HDF5 files!
+ */
+typedef enum H5T_cset_t {
+    H5T_CSET_ERROR       = -1, /**< error                           */
+    H5T_CSET_ASCII       = 0,  /**< US ASCII                        */
+    H5T_CSET_UTF8        = 1,  /**< UTF-8 Unicode encoding		     */
+    H5T_CSET_RESERVED_2  = 2,  /**< reserved for later use		     */
+    H5T_CSET_RESERVED_3  = 3,  /**< reserved for later use		     */
+    H5T_CSET_RESERVED_4  = 4,  /**< reserved for later use		     */
+    H5T_CSET_RESERVED_5  = 5,  /**< reserved for later use		     */
+    H5T_CSET_RESERVED_6  = 6,  /**< reserved for later use		     */
+    H5T_CSET_RESERVED_7  = 7,  /**< reserved for later use		     */
+    H5T_CSET_RESERVED_8  = 8,  /**< reserved for later use		     */
+    H5T_CSET_RESERVED_9  = 9,  /**< reserved for later use		     */
+    H5T_CSET_RESERVED_10 = 10, /**< reserved for later use		     */
+    H5T_CSET_RESERVED_11 = 11, /**< reserved for later use		     */
+    H5T_CSET_RESERVED_12 = 12, /**< reserved for later use		     */
+    H5T_CSET_RESERVED_13 = 13, /**< reserved for later use		     */
+    H5T_CSET_RESERVED_14 = 14, /**< reserved for later use		     */
+    H5T_CSET_RESERVED_15 = 15  /**< reserved for later use		     */
+} H5T_cset_t;
+#define H5T_NCSET H5T_CSET_RESERVED_2 /*Number of character sets actually defined  */
+
+/**
+ * Type of padding to use in character strings.
+ * \internal  Do not change these values since they appear in HDF5 files!
+ */
+typedef enum H5T_str_t {
+    H5T_STR_ERROR       = -1, /**< error                           */
+    H5T_STR_NULLTERM    = 0,  /**< null terminate like in C        */
+    H5T_STR_NULLPAD     = 1,  /**< pad with nulls                  */
+    H5T_STR_SPACEPAD    = 2,  /**< pad with spaces like in Fortran */
+    H5T_STR_RESERVED_3  = 3,  /**< reserved for later use		     */
+    H5T_STR_RESERVED_4  = 4,  /**< reserved for later use		     */
+    H5T_STR_RESERVED_5  = 5,  /**< reserved for later use		     */
+    H5T_STR_RESERVED_6  = 6,  /**< reserved for later use		     */
+    H5T_STR_RESERVED_7  = 7,  /**< reserved for later use		     */
+    H5T_STR_RESERVED_8  = 8,  /**< reserved for later use		     */
+    H5T_STR_RESERVED_9  = 9,  /**< reserved for later use		     */
+    H5T_STR_RESERVED_10 = 10, /**< reserved for later use		     */
+    H5T_STR_RESERVED_11 = 11, /**< reserved for later use		     */
+    H5T_STR_RESERVED_12 = 12, /**< reserved for later use		     */
+    H5T_STR_RESERVED_13 = 13, /**< reserved for later use		     */
+    H5T_STR_RESERVED_14 = 14, /**< reserved for later use		     */
+    H5T_STR_RESERVED_15 = 15  /**< reserved for later use		     */
+} H5T_str_t;
+#define H5T_NSTR H5T_STR_RESERVED_3 /*num H5T_str_t types actually defined	     */
+
+/**
+ * Type of padding to use in other atomic types
+ */
+//! <!-- [H5T_pad_t_snip] -->
+typedef enum H5T_pad_t {
+    H5T_PAD_ERROR      = -1, /**< error                           */
+    H5T_PAD_ZERO       = 0,  /**< always set to zero              */
+    H5T_PAD_ONE        = 1,  /**< always set to one               */
+    H5T_PAD_BACKGROUND = 2,  /**< set to background value         */
+
+    H5T_NPAD = 3 /**< sentinel: THIS MUST BE LAST     */
+} H5T_pad_t;
+//! <!-- [H5T_pad_t_snip] -->
+
+/**
+ * The order to retrieve atomic native datatype
+ */
+//! <!-- [H5T_direction_t_snip] -->
+typedef enum H5T_direction_t {
+    H5T_DIR_DEFAULT = 0, /**< default direction is ascending         */
+    H5T_DIR_ASCEND  = 1, /**< in ascending order                     */
+    H5T_DIR_DESCEND = 2  /**< in descending order                    */
+} H5T_direction_t;
+//! <!-- [H5T_direction_t_snip] -->
+
+/**
+ * The exception type passed into the conversion callback function
+ */
+typedef enum H5T_conv_except_t {
+    H5T_CONV_EXCEPT_RANGE_HI = 0,
+    /**< Source value is greater than destination's range */
+    H5T_CONV_EXCEPT_RANGE_LOW = 1,
+    /**< Source value is less than destination's range */
+    H5T_CONV_EXCEPT_PRECISION = 2,
+    /**< Source value loses precision in destination */
+    H5T_CONV_EXCEPT_TRUNCATE = 3,
+    /**< Source value is truncated in destination */
+    H5T_CONV_EXCEPT_PINF = 4,
+    /**< Source value is positive infinity */
+    H5T_CONV_EXCEPT_NINF = 5,
+    /**< Source value is negative infinity */
+    H5T_CONV_EXCEPT_NAN = 6
+    /**< Source value is \c NaN (not a number, including \c QNaN and \c SNaN) */
+} H5T_conv_except_t;
+
+/**
+ * The return value from conversion callback function H5T_conv_except_func_t()
+ */
+typedef enum H5T_conv_ret_t {
+    H5T_CONV_ABORT     = -1, /**< abort conversion                           */
+    H5T_CONV_UNHANDLED = 0,  /**< callback function failed to handle the exception      */
+    H5T_CONV_HANDLED   = 1   /**< callback function handled the exception successfully  */
+} H5T_conv_ret_t;
+
+/**
+ * Variable Length Datatype struct in memory (This is only used for VL
+ * sequences, not VL strings, which are stored in char *'s)
+ */
+typedef struct {
+    size_t len; /**< Length of VL data (in base type units) */
+    void  *p;   /**< Pointer to VL data */
+} hvl_t;
+
+/* Variable Length String information */
+/**
+ * Indicate that a string is variable length (null-terminated in C, instead of
+ * fixed length)
+ */
+#define H5T_VARIABLE SIZE_MAX
+
+/* Opaque information */
+/**
+ * Maximum length of an opaque tag
+ * \internal This could be raised without too much difficulty
+ */
+#define H5T_OPAQUE_TAG_MAX 256
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//! <!-- [H5T_conv_except_func_t_snip] -->
+/**
+ * \brief Exception handler.
+ *
+ * \param[in] except_type The kind of exception that occurred
+ * \param[in] src_id Source datatype identifier
+ * \param[in] dst_id Destination datatype identifier
+ * \param[in] src_buf Source data buffer
+ * \param[in,out] dst_buf Destination data buffer
+ * \param[in,out] user_data Callback context
+ * \returns Valid callback function return values are #H5T_CONV_ABORT,
+ *          #H5T_CONV_UNHANDLED and #H5T_CONV_HANDLED.
+ *
+ * \details If an exception like overflow happens during conversion, this
+ *          function is called if it's registered through H5Pset_type_conv_cb().
+ *
+ */
+typedef H5T_conv_ret_t (*H5T_conv_except_func_t)(H5T_conv_except_t except_type, hid_t src_id, hid_t dst_id,
+                                                 void *src_buf, void *dst_buf, void *user_data);
+//! <!-- [H5T_conv_except_func_t_snip] -->
+
+/* When this header is included from a private header, don't make calls to H5open() */
+#undef H5OPEN
+#ifndef H5private_H
+#define H5OPEN H5open(),
+#else /* H5private_H */
+#define H5OPEN
+#endif /* H5private_H */
+
+/*
+ * The IEEE floating point types in various byte orders.
+ */
+/**
+ * \ingroup PDTIEEE
+ * 32-bit big-endian IEEE floating-point numbers
+ */
+#define H5T_IEEE_F32BE (H5OPEN H5T_IEEE_F32BE_g)
+/**
+ * \ingroup PDTIEEE
+ * 32-bit little-endian IEEE floating-point numbers
+ */
+#define H5T_IEEE_F32LE (H5OPEN H5T_IEEE_F32LE_g)
+/**
+ * \ingroup PDTIEEE
+ * 64-bit big-endian IEEE floating-point numbers
+ */
+#define H5T_IEEE_F64BE (H5OPEN H5T_IEEE_F64BE_g)
+/**
+ * \ingroup PDTIEEE
+ * 64-bit little-endian IEEE floating-point numbers
+ */
+#define H5T_IEEE_F64LE (H5OPEN H5T_IEEE_F64LE_g)
+H5_DLLVAR hid_t H5T_IEEE_F32BE_g;
+H5_DLLVAR hid_t H5T_IEEE_F32LE_g;
+H5_DLLVAR hid_t H5T_IEEE_F64BE_g;
+H5_DLLVAR hid_t H5T_IEEE_F64LE_g;
+
+/*
+ * These are "standard" types.  For instance, signed (2's complement) and
+ * unsigned integers of various sizes and byte orders.
+ */
+/**
+ * \ingroup PDTSTD
+ * 8-bit big-endian signed integers
+ */
+#define H5T_STD_I8BE (H5OPEN H5T_STD_I8BE_g)
+/**
+ * \ingroup PDTSTD
+ * 8-bit little-endian signed integers
+ */
+#define H5T_STD_I8LE (H5OPEN H5T_STD_I8LE_g)
+/**
+ * \ingroup PDTSTD
+ * 16-bit big-endian signed integers
+ */
+#define H5T_STD_I16BE (H5OPEN H5T_STD_I16BE_g)
+/**
+ * \ingroup PDTSTD
+ * 16-bit little-endian signed integers
+ */
+#define H5T_STD_I16LE (H5OPEN H5T_STD_I16LE_g)
+/**
+ * \ingroup PDTSTD
+ * 32-bit big-endian signed integers
+ */
+#define H5T_STD_I32BE (H5OPEN H5T_STD_I32BE_g)
+/**
+ * \ingroup PDTSTD
+ * 32-bit little-endian signed integers
+ */
+#define H5T_STD_I32LE (H5OPEN H5T_STD_I32LE_g)
+/**
+ * \ingroup PDTSTD
+ * 64-bit big-endian signed integers
+ */
+#define H5T_STD_I64BE (H5OPEN H5T_STD_I64BE_g)
+/**
+ * \ingroup PDTSTD
+ * 64-bit little-endian signed integers
+ */
+#define H5T_STD_I64LE (H5OPEN H5T_STD_I64LE_g)
+/**
+ * \ingroup PDTSTD
+ * 8-bit big-endian unsigned integers
+ */
+#define H5T_STD_U8BE (H5OPEN H5T_STD_U8BE_g)
+/**
+ * \ingroup PDTSTD
+ * 8-bit little-endian unsigned integers
+ */
+#define H5T_STD_U8LE (H5OPEN H5T_STD_U8LE_g)
+/**
+ * \ingroup PDTSTD
+ * 16-bit big-endian unsigned integers
+ */
+#define H5T_STD_U16BE (H5OPEN H5T_STD_U16BE_g)
+/**
+ * \ingroup PDTSTD
+ * 16-bit little-endian unsigned integers
+ */
+#define H5T_STD_U16LE (H5OPEN H5T_STD_U16LE_g)
+/**
+ * \ingroup PDTSTD
+ * 32-bit big-endian unsigned integers
+ */
+#define H5T_STD_U32BE (H5OPEN H5T_STD_U32BE_g)
+/**
+ * \ingroup PDTSTD
+ * 32-bit little-endian unsigned integers
+ */
+#define H5T_STD_U32LE (H5OPEN H5T_STD_U32LE_g)
+/**
+ * \ingroup PDTSTD
+ * 64-bit big-endian unsigned integers
+ */
+#define H5T_STD_U64BE (H5OPEN H5T_STD_U64BE_g)
+/**
+ * \ingroup PDTSTD
+ * 64-bit little-endian unsigned integers
+ */
+#define H5T_STD_U64LE (H5OPEN H5T_STD_U64LE_g)
+/**
+ * \ingroup PDTSTD
+ * 8-bit big-endian bitfield
+ */
+#define H5T_STD_B8BE (H5OPEN H5T_STD_B8BE_g)
+/**
+ * \ingroup PDTSTD
+ * 8-bit little-endian bitfield
+ */
+#define H5T_STD_B8LE (H5OPEN H5T_STD_B8LE_g)
+/**
+ * \ingroup PDTSTD
+ * 16-bit big-endian bitfield
+ */
+#define H5T_STD_B16BE (H5OPEN H5T_STD_B16BE_g)
+/**
+ * \ingroup PDTSTD
+ * 16-bit little-endian bitfield
+ */
+#define H5T_STD_B16LE (H5OPEN H5T_STD_B16LE_g)
+/**
+ * \ingroup PDTSTD
+ * 32-bit big-endian bitfield
+ */
+#define H5T_STD_B32BE (H5OPEN H5T_STD_B32BE_g)
+/**
+ * \ingroup PDTSTD
+ * 32-bit little-endian bitfield
+ */
+#define H5T_STD_B32LE (H5OPEN H5T_STD_B32LE_g)
+/**
+ * \ingroup PDTSTD
+ * 64-bit big-endian bitfield
+ */
+#define H5T_STD_B64BE (H5OPEN H5T_STD_B64BE_g)
+/**
+ * \ingroup PDTSTD
+ * 64-bit little-endian bitfield
+ */
+#define H5T_STD_B64LE (H5OPEN H5T_STD_B64LE_g)
+/**
+ * \ingroup PDTSTD
+ * Object reference
+ */
+#define H5T_STD_REF_OBJ (H5OPEN H5T_STD_REF_OBJ_g)
+/**
+ * \ingroup PDTSTD
+ * Dataset region reference
+ */
+#define H5T_STD_REF_DSETREG (H5OPEN H5T_STD_REF_DSETREG_g)
+/**
+ * \ingroup PDTSTD
+ * Generic reference
+ */
+#define H5T_STD_REF (H5OPEN H5T_STD_REF_g)
+H5_DLLVAR hid_t H5T_STD_I8BE_g;
+H5_DLLVAR hid_t H5T_STD_I8LE_g;
+H5_DLLVAR hid_t H5T_STD_I16BE_g;
+H5_DLLVAR hid_t H5T_STD_I16LE_g;
+H5_DLLVAR hid_t H5T_STD_I32BE_g;
+H5_DLLVAR hid_t H5T_STD_I32LE_g;
+H5_DLLVAR hid_t H5T_STD_I64BE_g;
+H5_DLLVAR hid_t H5T_STD_I64LE_g;
+H5_DLLVAR hid_t H5T_STD_U8BE_g;
+H5_DLLVAR hid_t H5T_STD_U8LE_g;
+H5_DLLVAR hid_t H5T_STD_U16BE_g;
+H5_DLLVAR hid_t H5T_STD_U16LE_g;
+H5_DLLVAR hid_t H5T_STD_U32BE_g;
+H5_DLLVAR hid_t H5T_STD_U32LE_g;
+H5_DLLVAR hid_t H5T_STD_U64BE_g;
+H5_DLLVAR hid_t H5T_STD_U64LE_g;
+H5_DLLVAR hid_t H5T_STD_B8BE_g;
+H5_DLLVAR hid_t H5T_STD_B8LE_g;
+H5_DLLVAR hid_t H5T_STD_B16BE_g;
+H5_DLLVAR hid_t H5T_STD_B16LE_g;
+H5_DLLVAR hid_t H5T_STD_B32BE_g;
+H5_DLLVAR hid_t H5T_STD_B32LE_g;
+H5_DLLVAR hid_t H5T_STD_B64BE_g;
+H5_DLLVAR hid_t H5T_STD_B64LE_g;
+H5_DLLVAR hid_t H5T_STD_REF_OBJ_g;
+H5_DLLVAR hid_t H5T_STD_REF_DSETREG_g;
+H5_DLLVAR hid_t H5T_STD_REF_g;
+
+/*
+ * Types which are particular to Unix.
+ */
+/**
+ * \ingroup PDTUNIX
+ */
+#define H5T_UNIX_D32BE (H5OPEN H5T_UNIX_D32BE_g)
+/**
+ * \ingroup PDTUNIX
+ */
+#define H5T_UNIX_D32LE (H5OPEN H5T_UNIX_D32LE_g)
+/**
+ * \ingroup PDTUNIX
+ */
+#define H5T_UNIX_D64BE (H5OPEN H5T_UNIX_D64BE_g)
+/**
+ * \ingroup PDTUNIX
+ */
+#define H5T_UNIX_D64LE (H5OPEN H5T_UNIX_D64LE_g)
+H5_DLLVAR hid_t H5T_UNIX_D32BE_g;
+H5_DLLVAR hid_t H5T_UNIX_D32LE_g;
+H5_DLLVAR hid_t H5T_UNIX_D64BE_g;
+H5_DLLVAR hid_t H5T_UNIX_D64LE_g;
+
+/*
+ * Types particular to the C language.  String types use `bytes' instead
+ * of `bits' as their size.
+ */
+/**
+ * \ingroup PDTS
+ * String datatype in C (size defined in bytes rather than in bits)
+ */
+#define H5T_C_S1 (H5OPEN H5T_C_S1_g)
+H5_DLLVAR hid_t H5T_C_S1_g;
+
+/*
+ * Types particular to Fortran.
+ */
+/**
+ * \ingroup PDTS
+ * String datatype in Fortran (as defined for the HDF5 C library)
+ */
+#define H5T_FORTRAN_S1 (H5OPEN H5T_FORTRAN_S1_g)
+H5_DLLVAR hid_t H5T_FORTRAN_S1_g;
+
+/*
+ * These types are for Intel CPU's.  They are little endian with IEEE
+ * floating point.
+ */
+/**
+ * \ingroup PDTX86
+ * 8-bit little-endian signed (2's complement) integers for Intel CPUs
+ */
+#define H5T_INTEL_I8 H5T_STD_I8LE
+/**
+ * \ingroup PDTX86
+ * 16-bit little-endian signed (2's complement) integers for Intel CPUs
+ */
+#define H5T_INTEL_I16 H5T_STD_I16LE
+/**
+ * \ingroup PDTX86
+ * 32-bit little-endian signed (2's complement) integers for Intel CPUs
+ */
+#define H5T_INTEL_I32 H5T_STD_I32LE
+/**
+ * \ingroup PDTX86
+ * 64-bit little-endian signed (2's complement) integers for Intel CPUs
+ */
+#define H5T_INTEL_I64 H5T_STD_I64LE
+/**
+ * \ingroup PDTX86
+ * 8-bit little-endian unsigned integers for Intel CPUs
+ */
+#define H5T_INTEL_U8 H5T_STD_U8LE
+/**
+ * \ingroup PDTX86
+ * 16-bit little-endian unsigned integers for Intel CPUs
+ */
+#define H5T_INTEL_U16 H5T_STD_U16LE
+/**
+ * \ingroup PDTX86
+ * 32-bit little-endian unsigned integers for Intel CPUs
+ */
+#define H5T_INTEL_U32 H5T_STD_U32LE
+/**
+ * \ingroup PDTX86
+ * 64-bit little-endian unsigned integers for Intel CPUs
+ */
+#define H5T_INTEL_U64 H5T_STD_U64LE
+/**
+ * \ingroup PDTX86
+ * 8-bit little-endian bitfield for Intel CPUs
+ */
+#define H5T_INTEL_B8 H5T_STD_B8LE
+/**
+ * \ingroup PDTX86
+ * 16-bit little-endian bitfield for Intel CPUs
+ */
+#define H5T_INTEL_B16 H5T_STD_B16LE
+/**
+ * \ingroup PDTX86
+ * 32-bit little-endian bitfield for Intel CPUs
+ */
+#define H5T_INTEL_B32 H5T_STD_B32LE
+/**
+ * \ingroup PDTX86
+ * 64-bit little-endian bitfield for Intel CPUs
+ */
+#define H5T_INTEL_B64 H5T_STD_B64LE
+/**
+ * \ingroup PDTX86
+ * 32-bit little-endian IEEE floating-point numbers for Intel CPUs
+ */
+#define H5T_INTEL_F32 H5T_IEEE_F32LE
+/**
+ * \ingroup PDTX86
+ * 64-bit little-endian IEEE floating-point numbers for Intel CPUs
+ */
+#define H5T_INTEL_F64 H5T_IEEE_F64LE
+
+/*
+ * These types are for DEC Alpha CPU's.  They are little endian with IEEE
+ * floating point.
+ */
+/**
+ * \ingroup PDTALPHA
+ * 8-bit little-endian signed (2's complement) integers for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_I8 H5T_STD_I8LE
+/**
+ * \ingroup PDTALPHA
+ * 16-bit little-endian signed (2's complement) integers for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_I16 H5T_STD_I16LE
+/**
+ * \ingroup PDTALPHA
+ * 32-bit little-endian signed (2's complement) integers for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_I32 H5T_STD_I32LE
+/**
+ * \ingroup PDTALPHA
+ * 64-bit little-endian signed (2's complement) integers for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_I64 H5T_STD_I64LE
+/**
+ * \ingroup PDTALPHA
+ * 8-bit little-endian unsigned integers for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_U8 H5T_STD_U8LE
+/**
+ * \ingroup PDTALPHA
+ * 16-bit little-endian unsigned integers for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_U16 H5T_STD_U16LE
+/**
+ * \ingroup PDTALPHA
+ * 32-bit little-endian unsigned integers for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_U32 H5T_STD_U32LE
+/**
+ * \ingroup PDTALPHA
+ * 64-bit little-endian unsigned integers for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_U64 H5T_STD_U64LE
+/**
+ * \ingroup PDTALPHA
+ * 8-bit little-endian bitfield for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_B8 H5T_STD_B8LE
+/**
+ * \ingroup PDTALPHA
+ * 16-bit little-endian bitfield for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_B16 H5T_STD_B16LE
+/**
+ * \ingroup PDTALPHA
+ * 32-bit little-endian bitfield for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_B32 H5T_STD_B32LE
+/**
+ * \ingroup PDTALPHA
+ * 64-bit little-endian bitfield for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_B64 H5T_STD_B64LE
+/**
+ * \ingroup PDTALPHA
+ * 32-bit little-endian IEEE floating-point numbers for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_F32 H5T_IEEE_F32LE
+/**
+ * \ingroup PDTALPHA
+ * 64-bit little-endian IEEE floating-point numbers for DEC Alpha CPUs
+ */
+#define H5T_ALPHA_F64 H5T_IEEE_F64LE
+
+/*
+ * These types are for MIPS cpu's commonly used in SGI systems. They are big
+ * endian with IEEE floating point.
+ */
+/**
+ * \ingroup PDTMIPS
+ * 8-bit big-endian signed (2's complement) integers for SGI MIPS CPUs
+ */
+#define H5T_MIPS_I8 H5T_STD_I8BE
+/**
+ * \ingroup PDTMIPS
+ * 16-bit big-endian signed (2's complement) integers for SGI MIPS CPUs
+ */
+#define H5T_MIPS_I16 H5T_STD_I16BE
+/**
+ * \ingroup PDTMIPS
+ * 32-bit big-endian signed (2's complement) integers for SGI MIPS CPUs
+ */
+#define H5T_MIPS_I32 H5T_STD_I32BE
+/**
+ * \ingroup PDTMIPS
+ * 64-bit big-endian signed (2's complement) integers for SGI MIPS CPUs
+ */
+#define H5T_MIPS_I64 H5T_STD_I64BE
+/**
+ * \ingroup PDTMIPS
+ * 8-bit big-endian unsigned integers for SGI MIPS CPUs
+ */
+#define H5T_MIPS_U8 H5T_STD_U8BE
+/**
+ * \ingroup PDTMIPS
+ * 16-bit big-endian unsigned integers for SGI MIPS CPUs
+ */
+#define H5T_MIPS_U16 H5T_STD_U16BE
+/**
+ * \ingroup PDTMIPS
+ * 32-bit big-endian unsigned integers for SGI MIPS CPUs
+ */
+#define H5T_MIPS_U32 H5T_STD_U32BE
+/**
+ * \ingroup PDTMIPS
+ * 64-bit big-endian unsigned integers for SGI MIPS CPUs
+ */
+#define H5T_MIPS_U64 H5T_STD_U64BE
+/**
+ * \ingroup PDTMIPS
+ * 8-bit big-endian bitfield for SGI MIPS CPUs
+ */
+#define H5T_MIPS_B8 H5T_STD_B8BE
+/**
+ * \ingroup PDTMIPS
+ * 16-bit big-endian bitfield for SGI MIPS CPUs
+ */
+#define H5T_MIPS_B16 H5T_STD_B16BE
+/**
+ * \ingroup PDTMIPS
+ * 32-bit big-endian bitfield for SGI MIPS CPUs
+ */
+#define H5T_MIPS_B32 H5T_STD_B32BE
+/**
+ * \ingroup PDTMIPS
+ * 64-bit big-endian bitfield for SGI MIPS CPUs
+ */
+#define H5T_MIPS_B64 H5T_STD_B64BE
+/**
+ * \ingroup PDTMIPS
+ * 32-bit big-endian IEEE floating-point numbers for MIPS CPUs
+ */
+#define H5T_MIPS_F32 H5T_IEEE_F32BE
+/**
+ * \ingroup PDTMIPS
+ * 64-bit big-endian IEEE floating-point numbers for MIPS CPUs
+ */
+#define H5T_MIPS_F64 H5T_IEEE_F64BE
+
+/*
+ * The VAX floating point types (i.e. in VAX byte order)
+ */
+/**
+ * \ingroup PDTALPHA
+ * 32-bit VAX byte order floating-point numbers for OpenVMS on DEC Alpha CPUs
+ */
+#define H5T_VAX_F32 (H5OPEN H5T_VAX_F32_g)
+/**
+ * \ingroup PDTALPHA
+ * 64-bit VAX byte order floating-point numbers for OpenVMS on DEC Alpha CPUs
+ */
+#define H5T_VAX_F64 (H5OPEN H5T_VAX_F64_g)
+H5_DLLVAR hid_t H5T_VAX_F32_g;
+H5_DLLVAR hid_t H5T_VAX_F64_g;
+
+/*
+ * The predefined native types for this platform. Instead of a class name,
+ * precision and byte order as the last component, they have a C-like type
+ * name.  If the type begins with `U' then it is the unsigned version of the
+ * integer type; other integer types are signed.  The type LLONG corresponds
+ * to C's `long long' and LDOUBLE is `long double' (these types might be the
+ * same as `LONG' and `DOUBLE' respectively).
+ */
+/**
+ * \ingroup PDTNAT
+ * C-style \c char
+ */
+#define H5T_NATIVE_CHAR (CHAR_MIN ? H5T_NATIVE_SCHAR : H5T_NATIVE_UCHAR)
+/**
+ * \ingroup PDTNAT
+ * C-style \Code{signed char}
+ */
+#define H5T_NATIVE_SCHAR (H5OPEN H5T_NATIVE_SCHAR_g)
+/**
+ * \ingroup PDTNAT
+ * C-style \Code{unsigned char}
+ */
+#define H5T_NATIVE_UCHAR (H5OPEN H5T_NATIVE_UCHAR_g)
+/**
+ * \ingroup PDTNAT
+ * C-style \Code{short}
+ */
+#define H5T_NATIVE_SHORT (H5OPEN H5T_NATIVE_SHORT_g)
+/**
+ * \ingroup PDTNAT
+ * C-style \Code{unsigned short}
+ */
+#define H5T_NATIVE_USHORT (H5OPEN H5T_NATIVE_USHORT_g)
+/**
+ * \ingroup PDTNAT
+ * C-style \Code{int}
+ */
+#define H5T_NATIVE_INT (H5OPEN H5T_NATIVE_INT_g)
+/**
+ * \ingroup PDTNAT
+ * C-style \Code{unsigned int}
+ */
+#define H5T_NATIVE_UINT (H5OPEN H5T_NATIVE_UINT_g)
+/**
+ * \ingroup PDTNAT
+ * C-style \Code{long}
+ */
+#define H5T_NATIVE_LONG (H5OPEN H5T_NATIVE_LONG_g)
+/**
+ * \ingroup PDTNAT
+ * C-style \Code{unsigned long}
+ */
+#define H5T_NATIVE_ULONG (H5OPEN H5T_NATIVE_ULONG_g)
+/**
+ * \ingroup PDTNAT
+ * C-style \Code{long long}
+ */
+#define H5T_NATIVE_LLONG (H5OPEN H5T_NATIVE_LLONG_g)
+/**
+ * \ingroup PDTNAT
+ * C-style \Code{unsigned long long}
+ */
+#define H5T_NATIVE_ULLONG (H5OPEN H5T_NATIVE_ULLONG_g)
+/**
+ * \ingroup PDTNAT
+ * C-style \Code{float}
+ */
+#define H5T_NATIVE_FLOAT (H5OPEN H5T_NATIVE_FLOAT_g)
+/**
+ * \ingroup PDTNAT
+ * C-style \Code{double}
+ */
+#define H5T_NATIVE_DOUBLE (H5OPEN H5T_NATIVE_DOUBLE_g)
+/**
+ * \ingroup PDTNAT
+ * C-style \Code{long double}
+ */
+#define H5T_NATIVE_LDOUBLE (H5OPEN H5T_NATIVE_LDOUBLE_g)
+/**
+ * \ingroup PDTNAT
+ * HDF5 8-bit bitfield based on native types
+ */
+#define H5T_NATIVE_B8 (H5OPEN H5T_NATIVE_B8_g)
+/**
+ * \ingroup PDTNAT
+ * HDF5 16-bit bitfield based on native types
+ */
+#define H5T_NATIVE_B16 (H5OPEN H5T_NATIVE_B16_g)
+/**
+ * \ingroup PDTNAT
+ * HDF5 32-bit bitfield based on native types
+ */
+#define H5T_NATIVE_B32 (H5OPEN H5T_NATIVE_B32_g)
+/**
+ * \ingroup PDTNAT
+ * HDF5 64-bit bitfield based on native types
+ */
+#define H5T_NATIVE_B64 (H5OPEN H5T_NATIVE_B64_g)
+/**
+ * \ingroup PDTNAT
+ * HDF5 opaque unit based on native types
+ */
+#define H5T_NATIVE_OPAQUE (H5OPEN H5T_NATIVE_OPAQUE_g)
+/**
+ * \ingroup PDTNAT
+ * HDF5 address type based on native types
+ */
+#define H5T_NATIVE_HADDR (H5OPEN H5T_NATIVE_HADDR_g)
+/**
+ * \ingroup PDTNAT
+ * HDF5 size type based on native types
+ */
+#define H5T_NATIVE_HSIZE (H5OPEN H5T_NATIVE_HSIZE_g)
+/**
+ * \ingroup PDTNAT
+ * HDF5 signed size type based on native types
+ */
+#define H5T_NATIVE_HSSIZE (H5OPEN H5T_NATIVE_HSSIZE_g)
+/**
+ * \ingroup PDTNAT
+ * HDF5 error code type based on native types
+ */
+#define H5T_NATIVE_HERR (H5OPEN H5T_NATIVE_HERR_g)
+/**
+ * \ingroup PDTNAT
+ * HDF5 Boolean type based on native types
+ */
+#define H5T_NATIVE_HBOOL (H5OPEN H5T_NATIVE_HBOOL_g)
+H5_DLLVAR hid_t H5T_NATIVE_SCHAR_g;
+H5_DLLVAR hid_t H5T_NATIVE_UCHAR_g;
+H5_DLLVAR hid_t H5T_NATIVE_SHORT_g;
+H5_DLLVAR hid_t H5T_NATIVE_USHORT_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_g;
+H5_DLLVAR hid_t H5T_NATIVE_LONG_g;
+H5_DLLVAR hid_t H5T_NATIVE_ULONG_g;
+H5_DLLVAR hid_t H5T_NATIVE_LLONG_g;
+H5_DLLVAR hid_t H5T_NATIVE_ULLONG_g;
+H5_DLLVAR hid_t H5T_NATIVE_FLOAT_g;
+H5_DLLVAR hid_t H5T_NATIVE_DOUBLE_g;
+H5_DLLVAR hid_t H5T_NATIVE_LDOUBLE_g;
+H5_DLLVAR hid_t H5T_NATIVE_B8_g;
+H5_DLLVAR hid_t H5T_NATIVE_B16_g;
+H5_DLLVAR hid_t H5T_NATIVE_B32_g;
+H5_DLLVAR hid_t H5T_NATIVE_B64_g;
+H5_DLLVAR hid_t H5T_NATIVE_OPAQUE_g;
+H5_DLLVAR hid_t H5T_NATIVE_HADDR_g;
+H5_DLLVAR hid_t H5T_NATIVE_HSIZE_g;
+H5_DLLVAR hid_t H5T_NATIVE_HSSIZE_g;
+H5_DLLVAR hid_t H5T_NATIVE_HERR_g;
+H5_DLLVAR hid_t H5T_NATIVE_HBOOL_g;
+
+/* C9x integer types */
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_INT8 (H5OPEN H5T_NATIVE_INT8_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_UINT8 (H5OPEN H5T_NATIVE_UINT8_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_INT_LEAST8 (H5OPEN H5T_NATIVE_INT_LEAST8_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_UINT_LEAST8 (H5OPEN H5T_NATIVE_UINT_LEAST8_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_INT_FAST8 (H5OPEN H5T_NATIVE_INT_FAST8_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_UINT_FAST8 (H5OPEN H5T_NATIVE_UINT_FAST8_g)
+H5_DLLVAR hid_t H5T_NATIVE_INT8_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT8_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_LEAST8_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_LEAST8_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_FAST8_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_FAST8_g;
+
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_INT16 (H5OPEN H5T_NATIVE_INT16_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_UINT16 (H5OPEN H5T_NATIVE_UINT16_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_INT_LEAST16 (H5OPEN H5T_NATIVE_INT_LEAST16_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_UINT_LEAST16 (H5OPEN H5T_NATIVE_UINT_LEAST16_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_INT_FAST16 (H5OPEN H5T_NATIVE_INT_FAST16_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_UINT_FAST16 (H5OPEN H5T_NATIVE_UINT_FAST16_g)
+H5_DLLVAR hid_t H5T_NATIVE_INT16_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT16_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_LEAST16_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_LEAST16_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_FAST16_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_FAST16_g;
+
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_INT32 (H5OPEN H5T_NATIVE_INT32_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_UINT32 (H5OPEN H5T_NATIVE_UINT32_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_INT_LEAST32 (H5OPEN H5T_NATIVE_INT_LEAST32_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_UINT_LEAST32 (H5OPEN H5T_NATIVE_UINT_LEAST32_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_INT_FAST32 (H5OPEN H5T_NATIVE_INT_FAST32_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_UINT_FAST32 (H5OPEN H5T_NATIVE_UINT_FAST32_g)
+H5_DLLVAR hid_t H5T_NATIVE_INT32_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT32_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_LEAST32_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_LEAST32_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_FAST32_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_FAST32_g;
+
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_INT64 (H5OPEN H5T_NATIVE_INT64_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_UINT64 (H5OPEN H5T_NATIVE_UINT64_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_INT_LEAST64 (H5OPEN H5T_NATIVE_INT_LEAST64_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_UINT_LEAST64 (H5OPEN H5T_NATIVE_UINT_LEAST64_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_INT_FAST64 (H5OPEN H5T_NATIVE_INT_FAST64_g)
+/**
+ * \ingroup PDTC9x
+ */
+#define H5T_NATIVE_UINT_FAST64 (H5OPEN H5T_NATIVE_UINT_FAST64_g)
+H5_DLLVAR hid_t H5T_NATIVE_INT64_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT64_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_LEAST64_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_LEAST64_g;
+H5_DLLVAR hid_t H5T_NATIVE_INT_FAST64_g;
+H5_DLLVAR hid_t H5T_NATIVE_UINT_FAST64_g;
+
+/* Operations defined on all datatypes */
+/**
+ * \ingroup H5T
+ *
+ * \brief Creates a new datatype.
+ *
+ * \param[in] type Class of datatype to create
+ * \param[in] size  Size, in bytes, of the datatype being created
+ *
+ * \return \hid_t{datatype}
+ *
+ * \details H5Tcreate() creates a new datatype of the specified class with the
+ *          specified number of bytes. This function is used only with the
+ *          following datatype classes:
+ *          - #H5T_COMPOUND
+ *          - #H5T_OPAQUE
+ *          - #H5T_ENUM
+ *          - #H5T_STRING
+ *
+ *          Other datatypes, including integer and floating-point datatypes,
+ *          are typically created by using H5Tcopy() to copy and modify a
+ *          predefined datatype.
+ *
+ *          When creating a variable-length string datatype, \p size must
+ *          be #H5T_VARIABLE; see \ref_vlen_strings.
+ *
+ *          When creating a fixed-length string datatype, \p size will
+ *          be the length of the string in bytes. The length of the
+ *          string in characters will depend on i the encoding used; see
+ *          #H5Pset_char_encoding.
+ *
+ *          ENUMs created with this function have a signed native integer
+ *          base datatype.  Use H5Tenum_create() if a different integer base
+ *          datatype is required.
+ *
+ *          The datatype identifier returned from this function should be
+ *          released with H5Tclose or resource leaks will result.
+ *
+ * \see H5Tclose()
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL hid_t H5Tcreate(H5T_class_t type, size_t size);
+/**
+ * \ingroup H5T
+ *
+ * \brief Copies an existing datatype.
+ *
+ * \type_id
+ *
+ * \return \hid_t{datatype}
+ *
+ * \details H5Tcopy() makes a copy of an existing datatype. The returned type
+ *          is always transient and unlocked.
+ *
+ *          The \p type_id argument can be either a datatype identifier,
+ *          a predefined datatype (defined in H5Tpublic.h), or a dataset
+ *          identifier.  If \p type_id is a dataset identifier, this function
+ *          returns a transient, modifiable datatype which is a copy of the
+ *          dataset's datatype.
+ *
+ *          The returned datatype identifier should be released with H5Tclose()
+ *          to prevent resource leaks.
+ *
+ */
+H5_DLL hid_t H5Tcopy(hid_t type_id);
+/**
+ * \ingroup H5T
+ *
+ * \brief Releases a datatype
+ *
+ * \type_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Tclose() releases the datatype \p dtype_id. Further access
+ *          through this datatype identifier is illegal. Failure to release
+ *          a datatype with this call will result in resource leaks.
+ *
+ */
+H5_DLL herr_t H5Tclose(hid_t type_id);
+/**
+ * \ingroup H5T
+ *
+ * \brief Asynchronous version of H5Tclose().
+ *
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Tclose_async(const char *app_file, const char *app_func, unsigned app_line, hid_t type_id,
+                             hid_t es_id);
+#else
+H5_DLL herr_t H5Tclose_async(hid_t type_id, hid_t es_id);
+#endif
+/**
+ * \ingroup H5T
+ *
+ * \brief Determines whether two datatype identifiers refer to the same datatype
+ *
+ * \type_id{type1_id}
+ * \type_id{type2_id}
+ *
+ * \return \htri_t
+ *
+ * \details H5Tequal() determines whether two datatype identifiers refer to
+ *          the same datatype.
+ *
+ * \since 1.6 or earlier
+ *
+ */
+H5_DLL htri_t H5Tequal(hid_t type1_id, hid_t type2_id);
+/**
+ * \ingroup H5T
+ *
+ * \brief Locks a datatype
+ *
+ * \type_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Tlock() locks the datatype specified by the dtype_id identifier,
+ *          making it read-only and non-destructible. This is normally done by
+ *          the library for predefined datatypes so the application does not
+ *          inadvertently change or delete a predefined type. Once a datatype
+ *          is locked it can never be unlocked.
+ *
+ */
+H5_DLL herr_t H5Tlock(hid_t type_id);
+/**
+ * \ingroup H5T
+ *
+ * \brief Commits a transient datatype, linking it into the file and creating
+ *        a new committed datatype
+ *
+ * \fg_loc_id
+ * \param[in] name Name given to committed datatype
+ * \type_id Identifier of datatype to be committed and, upon function's
+ *          return, identifier for the committed datatype
+ * \lcpl_id
+ * \tcpl_id
+ * \tapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Tcommit2() saves a transient datatype as an immutable committed
+ *          datatype in a file. The datatype specified by \p dtype_id is
+ *          committed to the file with the name name at the location specified
+ *          by \p loc_id and with the datatype creation and access property
+ *          lists \p tcpl_id and \p tapl_id, respectively.
+ *
+ *          \p loc_id may be a file identifier, or a group identifier within
+ *          that file. \p name may be either an absolute path in the file or
+ *          a relative path from \p loc_id naming the newly-committed datatype.
+ *
+ *          The link creation property list, \p lcpl_id, governs creation of
+ *          the link(s) by which the new committed datatype is accessed and
+ *          the creation of any intermediate groups that may be missing.
+ *
+ *          Once committed, this datatype may be used to define the datatype
+ *          of any other dataset or attribute in the file.
+ *
+ *          This function will not accept a datatype that cannot actually hold
+ *          information. This currently includes compound datatypes with no
+ *          fields and enumerated datatypes with no members.
+ *
+ *          Committed datatypes are sometimes referred to as named datatypes.
+ *
+ * \version 1.8.7 Function modified in this release to reject datatypes that
+ *          will not accommodate actual data, such as a compound datatype
+ *          with no fields or an enumerated datatype with no members.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL herr_t H5Tcommit2(hid_t loc_id, const char *name, hid_t type_id, hid_t lcpl_id, hid_t tcpl_id,
+                         hid_t tapl_id);
+/**
+ * \ingroup H5T
+ *
+ * \brief Asynchronous version of H5Tcommit2().
+ *
+ */
+#ifndef H5_DOXYGEN
+H5_DLL herr_t H5Tcommit_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                              const char *name, hid_t type_id, hid_t lcpl_id, hid_t tcpl_id, hid_t tapl_id,
+                              hid_t es_id);
+#else
+H5_DLL herr_t H5Tcommit_async(hid_t loc_id, const char *name, hid_t type_id, hid_t lcpl_id, hid_t tcpl_id,
+                              hid_t tapl_id, hid_t es_id);
+#endif
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup H5T
+ *
+ * \brief Opens a committed (named) datatype
+ *
+ * \fgdta_loc_id
+ * \param[in] name Name of the datatype to open
+ * \tapl_id
+ *
+ * \return \hid_t{datatype}
+ *
+ * \details H5Topen2() opens a committed datatype at the location specified
+ *          by \p loc_id and returns an identifier for the datatype. \p
+ *          loc_id is either a file or group identifier. The identifier should
+ *          eventually be closed by calling H5Tclose()  to release resources.
+ *
+ *          The committed datatype is opened with the datatype access property
+ *          list tapl_id.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Topen2(hid_t loc_id, const char *name, hid_t tapl_id);
+/**
+ * \ingroup H5T
+ *
+ * \brief Asynchronous version of H5Topen2().
+ *
+ */
+#ifndef H5_DOXYGEN
+H5_DLL hid_t H5Topen_async(const char *app_file, const char *app_func, unsigned app_line, hid_t loc_id,
+                           const char *name, hid_t tapl_id, hid_t es_id);
+#else
+H5_DLL hid_t  H5Topen_async(hid_t loc_id, const char *name, hid_t tapl_id, hid_t es_id);
+#endif
+/**
+ * \ingroup H5T
+ *
+ * \brief Commits a transient datatype to a file, creating a newly named
+ *        datatype, but does not link it into the file structure
+ *
+ * \fg_loc_id
+ * \type_id
+ * \tcpl_id
+ * \tapl_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Tcommit_anon() commits a transient datatype (not immutable)
+ *          to a file, turning it into a named datatype with the specified
+ *          creation and property lists. With default property lists,
+ *          #H5P_DEFAULT, H5Tcommit_anon() provides similar functionality to
+ *          that of H5Tcommit(), with the differences described below.
+ *
+ *          #H5P_DEFAULT can be passed in for the datatype creation property
+ *          list identifier, \p tcpl_id.  The datatype access property list
+ *          identifier, \p tapl_id, is provided for future functionality and
+ *          is not used at this time. This parameter should always be passed
+ *          as the value #H5P_DEFAULT.
+ *
+ *          Note that H5Tcommit_anon() does not link this newly-committed
+ *          datatype into the file. After the H5Tcommit_anon() call, the
+ *          datatype identifier \p type_id must be linked into the HDF5 file
+ *          structure with H5Olink() or it will be deleted from the file when
+ *          the file is closed.
+ *
+ *          The differences between this function and H5Tcommit() are as follows:
+ *          \li H5Tcommit_anon() explicitly includes property lists,
+ *              which provides for greater control of the creation process
+ *              and of the properties of the new named datatype. H5Tcommit()
+ *              always uses default properties.
+ *          \li H5Tcommit_anon() neither provides the new named datatype's
+ *              name nor links it into the HDF5 file structure; those actions
+ *              must be performed separately through a call to H5Olink(),
+ *              which offers greater control over linking.
+ *
+ *          This function will not accept a datatype that cannot actually
+ *          hold data. This currently includes compound datatypes with no
+ *          fields and enumerated datatypes with no members.
+ *
+ * \version 1.8.7 Function modified in this release to reject datatypes that
+ *                will not accommodate actual data, such as a compound datatype
+ *                with no fields or an enumerated datatype with no members.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tcommit_anon(hid_t loc_id, hid_t type_id, hid_t tcpl_id, hid_t tapl_id);
+/**
+ * \ingroup H5T
+ *
+ * \brief Returns a copy of a datatype's creation property list
+ *
+ * \type_id
+ *
+ * \return \hid_t{datatype creation property list}
+ *
+ * \details H5Tget_create_plist() returns a property list identifier
+ *          for the datatype creation property list associated with the datatype
+ *          specified by \p type_id.
+ *
+ *          The creation property list identifier should be released with
+ *          H5Pclose() to prevent memory leaks.
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Tget_create_plist(hid_t type_id);
+/**
+ * \ingroup H5T
+ *
+ * \brief Determines whether a datatype is a committed type or a transient type
+ *
+ * \type_id
+ *
+ * \return \htri_t
+ *
+ * \details H5Tcommitted() queries a type to determine whether the type
+ *          specified by the \p dtype_id identifier is a committed (formerly
+ *          known as a \Emph{named}) type or a transient type. If this function returns
+ *          a positive value, then the type is committed (that is, it has been
+ *          committed, perhaps by some other application). Datasets which
+ *          return committed datatypes with H5Dget_type() are able to share
+ *          the datatype with other datasets in the same file.
+ *
+ * \version 1.8.0 Fortran API was added
+ *
+ * \since 1.6 or earlier
+ *
+ */
+H5_DLL htri_t H5Tcommitted(hid_t type_id);
+/**
+ * \ingroup H5T
+ *
+ * \brief Encodes a datatype object description into a binary buffer
+ *
+ * \param[in] obj_id Identifier of the object to be encoded
+ * \param[in,out] buf Buffer for the object to be encoded into.
+ * \param[in,out] nalloc IN: The size of the allocated buffer
+ *                       OUT: The size of the buffer needed
+ *
+ * \return \herr_t
+ *
+ * \details H5Tencode() Given datatype identifier, H5Tencode() converts a
+ *          datatype description into binary form in a buffer. Using this
+ *          binary form in the buffer, a datatype object can be reconstructed
+ *          using H5Tdecode() to return a new object handle (\ref hid_t) for
+ *          this datatype.
+ *
+ *          If the provided buffer is NULL, only the size of buffer needed is
+ *          returned through \p nalloc.
+ *
+ *          A preliminary H5Tencode() call can be made to find out the size
+ *          of the buffer needed. This value is returned as \p nalloc. That
+ *          value can then be assigned to \p nalloc for a second H5Tencode()
+ *          call, which will retrieve the actual encoded object.
+ *
+ *          If the library finds that \p nalloc is not big enough for the
+ *          object, it simply returns the size of the buffer needed through
+ *          \p nalloc without encoding the provided buffer.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tencode(hid_t obj_id, void *buf, size_t *nalloc);
+/**
+ * \ingroup H5T
+ *
+ * \brief Decodes a binary object description of datatype and returns a new
+ *        object handle
+ *
+ * \param[in] buf Buffer for the datatype object to be decoded
+ *
+ * \return \hid_t{datatype}
+ *
+ * \details H5Tdecode() Given an object description of datatype in binary in a
+ *          buffer, H5Tdecode() reconstructs the HDF5 datatype object and
+ *          returns a new object handle for it. The binary description of
+ *          the object is encoded by H5Tencode(). User is responsible for
+ *          passing in the right buffer.
+ *
+ *          The datatype identifier returned by this function can be released
+ *          with H5Tclose() when the identifier is no longer needed so that
+ *          resource leaks will not develop.
+ *
+ */
+H5_DLL hid_t H5Tdecode(const void *buf);
+/**
+ * \ingroup H5T
+ *
+ * \brief Flushes all buffers associated with a committed datatype to disk
+ *
+ * \type_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Tflush() causes all buffers associated with a committed datatype
+ *          \p type_id to be immediately flushed to disk without removing the
+ *          data from the cache.
+ *
+ *          HDF5 does not possess full control over buffering.  H5Tflush()
+ *          flushes the internal HDF5 buffers and then asks the operating
+ *          system (the OS) to flush the system buffers for the open
+ *          files. After that, the OS is responsible for ensuring that the
+ *          data is actually flushed to disk.
+ *
+ * \return \herr_t
+ *
+ * \since 1.10.0  C function introduced with this release.
+ *
+ * \see     H5Dflush()
+ *          H5Drefresh()
+ *          H5Tflush()
+ *          H5Grefresh()
+ *          H5Oflush()
+ *          H5Orefresh()
+ *          H5Tflush()
+ *          H5Trefresh()
+ *          H5Fstart_swmr_write()
+ *          H5Pget_append_flush()
+ *          H5Pget_object_flush_cb()
+ *          H5Pset_append_flush()
+ *          H5Pset_object_flush_cb()
+ *
+ */
+H5_DLL herr_t H5Tflush(hid_t type_id);
+/**
+ * \ingroup H5T
+ *
+ * \brief Refreshes all buffers associated with a committed datatype
+ *
+ * \type_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Trefresh() causes all buffers associated with a committed
+ *          datatype to be cleared and immediately re-loaded with updated
+ *          contents from disk.
+ *
+ *          This function essentially closes the datatype, evicts all
+ *          metadata associated with it from the cache, and then reopens the
+ *          datatype. The reopened datatype is automatically re-registered
+ *          with the same identifier.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Trefresh(hid_t type_id);
+
+/* Operations defined on compound datatypes */
+/**
+ * \ingroup COMPOUND
+ *
+ * \brief Adds a new member to a compound datatype.
+ *
+ * \type_id{parent_id}
+ * \param[in] name      Name of the field to insert
+ * \param[in] offset    Offset in memory structure of the field to insert
+ * \param[in] member_id  Datatype identifier of the field to insert
+ *
+ * \return \herr_t
+ *
+ * \details H5Tinsert() adds another member to the compound datatype, specified
+ *          \p type_id.
+ *
+ *          The new member has a \p name which must be unique within the
+ *          compound datatype. The \p offset argument defines the start of the
+ *          member in an instance of the compound datatype, and \p member_id
+ *          is the datatype identifier of the new member.
+ *
+ *          \note Members of a compound datatype do not have to be atomic
+ *          datatypes; a compound datatype can have a member which is a
+ *          compound datatype.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tinsert(hid_t parent_id, const char *name, size_t offset, hid_t member_id);
+/**
+ * \ingroup COMPOUND
+ *
+ * \brief Recursively removes padding from within a compound datatype
+ *
+ * \type_id
+ *
+ * \return \herr_t
+ *
+ * \details H5Tpack() recursively removes padding from within a compound
+ *          datatype to make it more efficient (space-wise) to store that data.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tpack(hid_t type_id);
+
+/* Operations defined on enumeration datatypes */
+/**
+ * \ingroup ENUM
+ *
+ * \brief Creates a new enumeration datatype
+ *
+ * \param[in] base_id Datatype identifier for the base datatype.  Must be an
+ *            integer datatype
+ *
+ * \return \hid_t{enumeration datatype}
+ *
+ * \details H5Tenum_create() creates a new enumeration datatype based on the
+ *          specified base datatype, dtype_id, which must be an integer datatype.
+ *
+ *          If a particular architecture datatype is required, a little endian
+ *          or big endian datatype for example, use a native datatype as the
+ *          base datatype and use H5Tconvert()  on values as they are read
+ *          from or written to a dataset.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL hid_t H5Tenum_create(hid_t base_id);
+/**
+ * \ingroup ENUM
+ *
+ * \brief Inserts a new enumeration datatype member
+ *
+ * \type_id{type}
+ * \param[in] name  Name of the new member
+ * \param[in] value Pointer to the value of the new member
+ *
+ * \return \herr_t
+ *
+ * \details H5Tenum_insert() inserts a new enumeration datatype member into an
+ *          enumeration datatype.
+ *
+ *          \p type_id is the datatype identifier for the enumeration datatype,
+ *          \p name is the name of the new member, and \p value points to the
+ *           value of the new member.
+ *
+ *          \p name and \p value must both be unique within \p dtype_id.
+ *
+ *          \p value points to data which must be of the integer base datatype
+ *          used when the enumeration datatype was created. If a particular
+ *          architecture datatype is required, a little endian or big endian
+ *          datatype for example, use a native datatype as the base datatype
+ *          and use H5Tconvert() on values as they are read from or written
+ *          to a dataset.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tenum_insert(hid_t type, const char *name, const void *value);
+/**
+ * \ingroup ENUM
+ *
+ * \brief Returns the symbol name corresponding to a specified member of an
+ *        enumeration datatype
+ *
+ * \type_id{type}
+ * \param[in] value Value of the enumeration datatype
+ * \param[out] name Buffer for output of the symbol name
+ * \param[in] size Anticipated size of the symbol name, in bytes
+ *
+ * \return Returns a non-negative value if successful. Otherwise returns a
+ *         negative value
+ *
+ * \details H5Tenum_nameof() finds the symbol name that corresponds to the
+ *          specified \p value of the enumeration datatype \p type.
+ *
+ *          At most \p size characters of the symbol \p name are copied into
+ *          the \p name buffer. If the entire symbol name and null terminator
+ *          do not fit in the name buffer, then as many characters as possible
+ *          are copied (not null terminated) and the function fails.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tenum_nameof(hid_t type, const void *value, char *name /*out*/, size_t size);
+/**
+ * \ingroup ENUM
+ *
+ * \brief Returns the value corresponding to a specified member of an
+ *        enumeration datatype
+ *
+ * \type_id{type}
+ * \param[in] name Symbol name of the enumeration datatype
+ * \param[out] value Buffer for the value of the enumeration datatype
+ *
+ * \return \herr_t
+ *
+ * \details H5Tenum_valueof() finds the value that corresponds to the
+ *          specified name of the enumeration datatype \p dtype_id.
+ *
+ *          Values returned in \p value will be of the enumerated type's
+ *          base type, that is, the datatype used by H5Tenum_create() when
+ *          the enumerated type was created.
+ *
+ *          The \p value buffer must be at least large enough to hold a value
+ *          of that base type. If the size is unknown, you can determine it
+ *          with H5Tget_size().
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tenum_valueof(hid_t type, const char *name, void *value /*out*/);
+
+/* Operations defined on variable-length datatypes */
+/**
+ * \ingroup VLEN
+ *
+ * \brief Creates a new variable-length array datatype
+ *
+ * \type_id{base_id}, the element type of the datatype to create
+ *
+ * \return \hid_t{variable-length datatype}
+ *
+ * \details H5Tvlen_create() creates a new one-dimensional array datatype of
+ *          variable-length (VL) with the base datatype \p base_id.
+ *
+ *          This one-dimensional array often represents a data sequence of the
+ *          base datatype, such as characters for character sequences or vertex
+ *          coordinates for polygon lists. The base type specified for the VL
+ *          datatype can be any HDF5 datatype, including another VL datatype, a
+ *          compound datatype, or an atomic datatype.
+ *
+ *          When necessary, use H5Tget_super() to determine the base type of
+ *          the VL datatype.
+ *
+ *          The datatype identifier returned from this function should be
+ *          released with H5Tclose() or resource leaks will result. Under
+ *          certain circumstances, H5Dvlen_reclaim() must also be used.
+ *
+ * \attention H5Tvlen_create() cannot be used to create a variable-length
+ *            string datatype. H5Tvlen_create() called with a string or
+ *            character base type creates a variable-length sequence of strings
+ *            (a variable-length, 1-dimensional array), with each element of
+ *            the array being of the string or character base type.\n
+ *            To create a variable-length string datatype, see \ref_vlen_strings.
+ *
+ */
+H5_DLL hid_t H5Tvlen_create(hid_t base_id);
+
+/* Operations defined on array datatypes */
+/**
+ * \ingroup ARRAY
+ *
+ * \brief Creates an array datatype object
+ *
+ * \param[in] base_id Datatype identifier for the array base datatype
+ * \param[in] ndims Rank of the array
+ * \param[in] dim Size of each array dimension
+ *
+ * \return \hid_t{array datatype}
+ *
+ * \details H5Tarray_create2() creates a new array datatype object.\n\n
+ *          \p base_id is the datatype of every element of the array, i.e.,
+ *          of the number at each position in the array.
+ *
+ *          \p ndims is the number of dimensions and the size of each dimension
+ *          is specified in the array \p dim. The value of \p rank is
+ *          currently limited to #H5S_MAX_RANK and must be greater than 0
+ *          (zero). All dimension sizes specified in \p dim must be greater
+ *          than 0 (zero).
+ *
+ * \since 1.8.0
+ *
+ */
+H5_DLL hid_t H5Tarray_create2(hid_t base_id, unsigned ndims, const hsize_t dim[/* ndims */]);
+/**
+ * \ingroup ARRAY
+ *
+ * \brief Returns the rank of an array datatype
+ *
+ * \type_id
+ *
+ * \return Returns the rank of the array if successful; otherwise returns a
+ *         negative value.
+ *
+ * \details H5Tget_array_ndims() returns the rank, i.e., the number of
+ *          dimensions, of an array datatype object.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL int H5Tget_array_ndims(hid_t type_id);
+/**
+ * \ingroup ARRAY
+ *
+ * \brief Retrieves sizes of array dimensions
+ *
+ * \type_id
+ * \param[out] dims Sizes of array dimensions
+ *
+ * \return Returns the non-negative number of dimensions of the array type
+ *         if successful; otherwise returns a negative value.
+ *
+ * \details H5Tget_array_dims2() returns the sizes of the dimensions of the
+ *          specified array datatype object in the array \p dims.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL int H5Tget_array_dims2(hid_t type_id, hsize_t dims[]);
+
+/* Operations defined on opaque datatypes */
+/**
+ * \ingroup OPAQUE
+ *
+ * \brief Tags an opaque datatype
+ *
+ * \type_id{type} of an opaque datatype
+ * \param[in] tag Descriptive ASCII string with which the opaque datatype is
+ *                to be tagged
+ *
+ * \return \herr_t
+ *
+ * \details H5Tset_tag() tags an opaque datatype \p type with a descriptive
+ *          ASCII identifier, \p tag.
+ *
+ *          \p tag is intended to provide a concise description; the maximum
+ *          size is hard-coded in the HDF5 library as 256 bytes
+ *          (#H5T_OPAQUE_TAG_MAX).
+ *
+ * \version 1.6.5 The #H5T_OPAQUE_TAG_MAX macro constant, specifying the
+ *                maximum size of an opaque datatype tag, was added in
+ *                H5Tpublic.h.
+ *
+ */
+H5_DLL herr_t H5Tset_tag(hid_t type, const char *tag);
+/**
+ * \ingroup OPAQUE
+ *
+ * \brief Gets the tag associated with an opaque datatype
+ *
+ * \type_id{type} of an opaque datatype
+ *
+ * \return Returns a pointer to an allocated string if successful; otherwise
+ *         returns NULL.
+ *
+ * \details H5Tget_tag() returns the tag associated with the opaque datatype
+ *         \p type.
+ *
+ * \attention The tag is returned via a pointer to an allocated string, which
+ *            the caller must free.
+ *
+ */
+H5_DLL char *H5Tget_tag(hid_t type);
+
+/* Querying property values */
+/**
+ * \ingroup H5T
+ *
+ * \brief Returns the base datatype from which a datatype is derived
+ *
+ * \type_id{type}
+ *
+ * \return \hid_t{datatype}
+ *
+ * \details H5Tget_super() returns the base datatype from which the datatype
+ *          \p type_id is derived.  In the case of an enumeration type, the
+ *          return value is an integer type.
+ *
+ *          The datatype identifier returned by this function must be released
+ *          with H5Tclose()  when the identifier is no longer needed so that
+ *          resource leaks will not develop.
+ *
+ */
+H5_DLL hid_t H5Tget_super(hid_t type);
+/**
+ * \ingroup H5T
+ *
+ * \brief Returns a datatype class
+ *
+ * \type_id
+ *
+ * \return Returns the datatype class if successful; otherwise #H5T_NO_CLASS.
+ *
+ * \details H5Tget_class() returns the class of the datatype \p type_id.
+ *          Valid class identifiers, as defined in H5Tpublic.h, are:
+ *          \snippet this H5T_class_t_snip
+ *
+ * \note The library returns #H5T_STRING for both fixed-length and
+ *       variable-length strings.
+ *
+ * \note Unsupported datatype: The time datatype class, #H5T_TIME,
+ *       is not supported. If #H5T_TIME is used, the resulting data will
+ *       be readable and modifiable only on the originating computing
+ *       platform; it will not be portable to other platforms.
+ *
+ */
+H5_DLL H5T_class_t H5Tget_class(hid_t type_id);
+/**
+ * \ingroup H5T
+ *
+ * \brief Determines whether a datatype contains any datatypes of the given
+ *        datatype class
+ *
+ * \type_id
+ * \param[in] cls Datatype class
+ *
+ * \return \htri_t
+ *
+ * \details H5Tdetect_class() determines whether the datatype specified in
+ *          \p type_id contains any datatypes of the datatype class specified
+ *          in \p dtype_class.
+ *
+ *          This function is useful primarily in recursively examining all the
+ *          fields and/or base types of compound, array, and variable-length
+ *          datatypes.
+ *
+ *          Valid class identifiers, as defined in H5Tpublic.h, are:
+ *          \snippet this H5T_class_t_snip
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL htri_t H5Tdetect_class(hid_t type_id, H5T_class_t cls);
+/**
+ * \ingroup H5T
+ *
+ * \brief Returns the size of a datatype
+ *
+ * \type_id
+ *
+ * \return Returns the size of the datatype in bytes if successful; otherwise,
+ *         returns 0.
+ *
+ * \details H5Tget_size() returns the size of a datatype in bytes.
+ *          \li For atomic datatypes, array datatypes, compound datatypes, and
+ *          other datatypes of a constant size, the returned value is the
+ *          size of the actual datatype in bytes.
+ *          \li For variable-length string datatypes the returned value is
+ *          the size of the pointer to the actual string, or \c sizeof(\c
+ *          char \c *). This function does not return the size of actual
+ *          variable-length string data.
+ *          \li For variable-length sequence datatypes (see H5Tvlen_create()),
+ *          the returned value is the size of the \p hvl_t struct, or \c
+ *          sizeof(\p hvl_t). The \p hvl_t struct contains a pointer to the
+ *          actual data and a size value.  This function does not return the
+ *          size of actual variable-length sequence data.
+ *
+ * \see H5Tset_size()
+ *
+ * \since 1.2.0
+ */
+H5_DLL size_t H5Tget_size(hid_t type_id);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Returns the byte order of an atomic datatype
+ *
+ * \type_id
+ *
+ * \return Returns a byte order constant if successful; otherwise returns
+ *         #H5T_ORDER_ERROR (-1)
+ *
+ * \details H5Tget_order() returns the byte order of an atomic datatype.
+ *          Possible return values are:
+ *          \snippet this H5T_order_t_snip
+ *          Members of a compound datatype need not have the same byte
+ *          order. If members of a compound datatype have more than one of
+ *          little endian, big endian, or VAX byte order, H5Tget_order() will
+ *          return #H5T_ORDER_MIXED for the compound datatype. A byte order of
+ *          #H5T_ORDER_NONE will, however, be ignored; for example, if one or
+ *          more members of a compound datatype have byte order #H5T_ORDER_NONE
+ *          but all other members have byte order #H5T_ORDER_LE,  H5Tget_order()
+ *          will return #H5T_ORDER_LE for the compound datatype.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL H5T_order_t H5Tget_order(hid_t type_id);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Returns the precision of an atomic datatype
+ *
+ * \type_id
+ *
+ * \return Returns the number of significant bits if successful; otherwise 0
+ *
+ * \details H5Tget_precision() returns the precision of an atomic datatype
+ *          (for example, integer or float) or a datatype whose base (parent)
+ *          type is an atomic type (for example, array, enum and variable
+ *          length). The precision is the number of significant bits which,
+ *          unless padding is present, is 8 times larger than the value
+ *          returned by H5Tget_size().
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL size_t H5Tget_precision(hid_t type_id);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Retrieves the bit offset of the first significant bit
+ *
+ * \type_id
+ *
+ * \return Returns an offset value if successful; otherwise returns a
+ *         negative value.
+ *
+ * \details H5Tget_offset() retrieves the bit offset of the first significant
+ *          bit. The significant bits of an atomic datum can be offset from the
+ *          beginning of the memory for that datum by an amount of padding. The
+ *          'offset' property specifies the number of bits of padding that
+ *          appear to the "right of" the value. That is, if we have a 32-bit
+ *          datum with 16-bits of precision having the value 0x1122 then it
+ *          will be laid out in memory as (from small byte address toward
+ *          larger byte addresses):
+ *          \code{.unparsed}
+ *          0:  [ pad]  [0x11]  [0x22]  [ pad]
+ *          1:  [ pad]  [0x22]  [0x11]  [ pad]
+ *          2:  [0x11]  [ pad]  [ pad]  [0x22]
+ *          3:  [0x22]  [ pad]  [ pad]  [0x11]
+ *          \endcode
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL int H5Tget_offset(hid_t type_id);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Retrieves the padding type of the least and most-significant bit padding
+ *
+ * \type_id
+ * \param[out] lsb Buffer for the least-significant bit padding type
+ * \param[out] msb Buffer for the most-significant bit padding type
+ *
+ * \return \herr_t
+ *
+ * \details H5Tget_pad() retrieves the padding type of the least and
+ *          most-significant bit padding. Valid padding types are:
+ *          \snippet this H5T_pad_t_snip
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tget_pad(hid_t type_id, H5T_pad_t *lsb /*out*/, H5T_pad_t *msb /*out*/);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Retrieves the sign type for an integer type
+ *
+ * \type_id
+ *
+ * \return Returns a valid sign type if successful; otherwise #H5T_SGN_ERROR (-1)
+ *
+ * \details H5Tget_sign() retrieves the sign type for an integer type.
+ *          Valid types are:
+ *          \snippet this H5T_sign_t_snip
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL H5T_sign_t H5Tget_sign(hid_t type_id);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Retrieves floating point datatype bit field information
+ *
+ * \type_id
+ * \param[out] spos Pointer to location to return floating-point sign bit
+ * \param[out] epos Pointer to location to return exponent bit-position
+ * \param[out] esize Pointer to location to return size of exponent in bits
+ * \param[out] mpos Pointer to location to return mantissa bit-position
+ * \param[out] msize Pointer to location to return size of mantissa in bits
+ *
+ * \return \herr_t
+ *
+ * \details H5Tget_fields() retrieves information about the locations of
+ *          the various bit fields of a floating point datatype. The field
+ *          positions are bit positions in the significant region of the
+ *          datatype. Bits are numbered with the least significant bit number
+ *          zero. Any (or even all) of the arguments can be null pointers.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tget_fields(hid_t type_id, size_t *spos /*out*/, size_t *epos /*out*/, size_t *esize /*out*/,
+                            size_t *mpos /*out*/, size_t *msize /*out*/);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Retrieves the exponent bias of a floating-point type
+ *
+ * \type_id
+ *
+ * \return Returns the bias if successful and 0, otherwise.
+ *
+ * \details H5Tget_ebias() retrieves the exponent bias of a floating-point type.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL size_t H5Tget_ebias(hid_t type_id);
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup ATOM
+ *
+ * \brief Retrieves mantissa normalization of a floating-point datatype
+ *
+ * \type_id
+ *
+ * \return Returns a valid normalization type if successful; otherwise
+ *         returns #H5T_NORM_ERROR (-1)
+ *
+ * \details H5Tget_norm() retrieves the mantissa normalization of a
+ *          floating-point datatype. Valid normalization types are:
+ *          \snippet this H5T_norm_t_snip
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL H5T_norm_t H5Tget_norm(hid_t type_id);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Retrieves the internal padding type for unused bits in floating-point
+ *        datatypes
+ *
+ * \type_id
+ *
+ * \return Returns a valid padding type if successful; otherwise returns
+ *         #H5T_PAD_ERROR (-1).
+ *
+ * \details H5Tget_inpad() retrieves the internal padding type for unused
+ *          bits in floating-point datatypes. Valid padding types are:
+ *          \snippet this H5T_pad_t_snip
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL H5T_pad_t H5Tget_inpad(hid_t type_id);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Retrieves the type of padding used for a string datatype
+ *
+ * \type_id
+ *
+ * \return Returns a valid string of the padding if successful; otherwise
+ *         returns #H5T_STR_ERROR (-1)
+ *
+ * \details H5Tget_strpad() retrieves the type of padding used for a string
+ *          datatype.
+ *
+ *          The string padding type is set with H5Tset_strpad().  Possible
+ *          values returned are:
+ * \str_pad_type
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL H5T_str_t H5Tget_strpad(hid_t type_id);
+/**
+ * \ingroup COMPENUM
+ *
+ * \brief Retrieves the number of elements in a compound or enumeration datatype
+ *
+ * \type_id
+ *
+ * \return Returns the number of elements if successful; otherwise returns a
+ *         negative value.
+ *
+ * \details H5Tget_nmembers() retrieves the number of fields in a compound
+ *          datatype or the number of members of an enumeration datatype.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL int H5Tget_nmembers(hid_t type_id);
+/**
+ * \ingroup COMPENUM
+ *
+ * \brief Retrieves the name of a compound or enumeration datatype member
+ *
+ * \type_id
+ * \param[in] membno Zero-based index of the field or element
+ *
+ * \return Returns a valid pointer to a string allocated with malloc() if
+ *         successful; otherwise returns NULL.
+ *
+ * \details H5Tget_member_name() retrieves the name of a field of a compound
+ *          datatype or an element of an enumeration datatype.
+ *
+ *          The index of the target field or element is specified in \p
+ *          member_no. Compound datatype fields and enumeration datatype
+ *          elements are stored in no particular order with index values of
+ *          0 through N-1, where N is the value returned by H5Tget_nmembers().
+ *
+ *          The HDF5 library allocates a buffer to receive the name of
+ *          the field. The caller must subsequently free the buffer with
+ *          H5free_memory().
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL char *H5Tget_member_name(hid_t type_id, unsigned membno);
+/**
+ * \ingroup COMPENUM
+ *
+ * \brief Retrieves the index of a compound or enumeration datatype member
+ *
+ * \type_id
+ * \param[in] name Name of the field or member
+ *
+ * \return \herr_t
+ *
+ * \details H5Tget_member_index() retrieves the index of a field of a compound
+ *          datatype or an element of an enumeration datatype.
+ *
+ *          The name of the target field or element is specified by \p name.
+ *
+ *          Fields are stored in no particular order with index values of 0
+ *          through N-1, where N is the value returned by H5Tget_nmembers() .
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL int H5Tget_member_index(hid_t type_id, const char *name);
+/**
+ * \ingroup COMPOUND
+ *
+ * \brief Retrieves the offset of a field of a compound datatype
+ *
+ * \type_id
+ * \param[in] membno Zero-based index of the field or element
+ *
+ * \return Returns the byte offset of the field if successful; otherwise
+ *         returns 0 (zero).
+ *
+ * \details H5Tget_member_offset() retrieves the byte offset of the beginning
+ *          of a field within a compound datatype with respect to the beginning
+ *          of the compound datatype datum.
+ *
+ *          Note that zero is a valid offset and that this function will fail
+ *          only if a call to H5Tget_member_class() fails with the same arguments.
+ *
+ * \version 1.6.4 \p member_no parameter type changed to unsigned.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL size_t H5Tget_member_offset(hid_t type_id, unsigned membno);
+/**
+ * \ingroup COMPOUND
+ *
+ * \brief Returns datatype class of compound datatype member
+ *
+ * \type_id
+ * \param[in] membno Zero-based index of the field or element
+ *
+ * \return Returns the datatype class, a non-negative value, if successful;
+ *         otherwise returns a negative value.
+ *
+ * \details Given a compound datatype, \p dtype_id, H5Tget_member_class()
+ *          returns the datatype class of the member specified by \p member_no.
+ *
+ *          Valid class identifiers, as defined in H5Tpublic.h, are:
+ *          \snippet this H5T_class_t_snip
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL H5T_class_t H5Tget_member_class(hid_t type_id, unsigned membno);
+/**
+ * \ingroup COMPOUND
+ *
+ * \brief Returns the datatype of the specified member
+ *
+ * \type_id
+ * \param[in] membno Zero-based index of the field or element
+ *
+ * \return Returns the identifier of a copy of the datatype of the field if
+ *         successful; otherwise returns a negative value.
+ *
+ * \details H5Tget_member_type() returns the datatype of the specified member.
+ *          The caller should invoke H5Tclose() to release resources associated
+ *          with the type.
+ *
+ * \version 1.6.4 \p membno parameter type changed to unsigned.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL hid_t H5Tget_member_type(hid_t type_id, unsigned membno);
+/**
+ * \ingroup ENUM
+ *
+ * \brief Returns the value of an enumeration datatype member
+ *
+ * \type_id
+ * \param[in] membno Number of the enumeration datatype member
+ * \param[out] value Buffer for the value of the enumeration datatype member
+ *
+ * \return \herr_t
+ *
+ * \details H5Tget_member_value() returns the value of the enumeration datatype
+ *          member \p member_no.
+ *
+ *          The member value is returned in a user-supplied buffer pointed to
+ *          by \p value. Values returned in \p value will be of the enumerated
+ *          type's base type, that is, the datatype used by H5Tenum_create()
+ *          when the enumerated type was created.
+ *
+ *          The value buffer must be at least large enough to hold a value
+ *          of that base type. If the size is unknown, you can determine it
+ *          with H5Tget_size().
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tget_member_value(hid_t type_id, unsigned membno, void *value /*out*/);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Retrieves the character set type of a string datatype
+ *
+ * \type_id
+ *
+ * \return Returns a valid character set type if successful; otherwise
+ *         #H5T_CSET_ERROR (-1).
+ *
+ * \details H5Tget_cset() retrieves the character set type of a string datatype.
+ *          Valid character set types are:
+ *          \csets
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL H5T_cset_t H5Tget_cset(hid_t type_id);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Determines whether datatype is a variable-length string
+ *
+ * \type_id
+ *
+ * \return Returns:
+ *         \li a positive value if the specified datatype is a variable-length
+ *             string
+ *         \li 0 if the specified datatype is not a variable-length string
+ *         \li a negative value when the function fails
+ *
+ * \details H5Tis_variable_str() determines whether the datatype identified
+ *          by \p dtype_id is a variable-length string.
+ *
+ *          This function can be used to distinguish between fixed and
+ *          variable-length string datatypes.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL htri_t H5Tis_variable_str(hid_t type_id);
+/**
+ * \ingroup H5T
+ *
+ * \brief Returns the native datatype identifier of a specified datatype
+ *
+ * \type_id
+ * \param[in] direction Direction of search
+ *
+ * \return \hid_t{native datatype}
+ *
+ * \details H5Tget_native_type() returns the equivalent native datatype
+ *          identifier for the datatype specified by \p type_id.
+ *
+ *          H5Tget_native_type() is designed primarily to facilitate the use of
+ *          the H5Dread() function, for which users otherwise must undertake a
+ *          multi-step process to determine the native datatype of a dataset
+ *          prior to reading it into memory. This function can be used for
+ *          the following purposes:
+ *
+ *          \li To determine the native datatype of an atomic datatype
+ *          \li To determine the base datatype of an array, enumerated, or
+ *              variable-length datatype
+ *          \li To determine the native atomic datatypes of the individual
+ *              components of a compound datatype
+ *
+ *          For example, if \p type_id is a compound datatype, the returned
+ *          datatype identifier will be for a similar compound datatype with
+ *          each element converted to the corresponding native datatype;
+ *          nested compound datatypes will be unwound. If \p type_id is an
+ *          array, the returned datatype identifier will be for the native
+ *          datatype of a single array element.
+ *
+ *          H5Tget_native_type() selects the first matching native datatype
+ *          from the following list:
+ *
+ *          \li #H5T_NATIVE_CHAR
+ *          \li #H5T_NATIVE_SHORT
+ *          \li #H5T_NATIVE_INT
+ *          \li #H5T_NATIVE_LONG
+ *          \li #H5T_NATIVE_LLONG
+ *
+ *          \li #H5T_NATIVE_UCHAR
+ *          \li #H5T_NATIVE_USHORT
+ *          \li #H5T_NATIVE_UINT
+ *          \li #H5T_NATIVE_ULONG
+ *          \li #H5T_NATIVE_ULLONG
+ *
+ *          \li #H5T_NATIVE_FLOAT
+ *          \li #H5T_NATIVE_DOUBLE
+ *          \li #H5T_NATIVE_LDOUBLE
+ *
+ *          \li #H5T_NATIVE_B8
+ *          \li #H5T_NATIVE_B16
+ *          \li #H5T_NATIVE_B32
+ *          \li #H5T_NATIVE_B64
+ *
+ *          The direction parameter indicates the order in which the library
+ *          searches for a native datatype match. Valid values for direction
+ *          are as follows:
+ *          \snippet this H5T_direction_t_snip
+ *
+ *          H5Tget_native_type() is designed primarily for use with integer,
+ *          floating point, and bitfield datatypes. String, time, opaque, and
+ *          reference datatypes are returned as a copy of dtype_id. See above
+ *          for compound, array, enumerated, and variable-length datatypes.
+ *
+ *          The identifier returned by H5Tget_native_type() should eventually
+ *          be closed by calling H5Tclose() to release resources.
+ *
+ *          \note Please note that a datatype is actually an object
+ *          identifier or handle returned from opening the datatype. It
+ *          is not persistent, and its value can be different from one HDF5
+ *          session to the next.
+ *
+ *          \note H5Tequal() can be used to compare datatypes.
+ *
+ *          \note HDF5 High Level APIs that may also be of interest are: H5LTdtype_to_text()
+ *                creates a text description of a datatype. H5LTtext_to_dtype() creates an
+ *                HDF5 datatype given a text description.
+ *
+ * \since 1.6.0
+ *
+ */
+H5_DLL hid_t H5Tget_native_type(hid_t type_id, H5T_direction_t direction);
+
+/* Setting property values */
+/**
+ * \ingroup H5T
+ *
+ * \brief Sets size for a datatype.
+ *
+ * \type_id
+ * \param[in] size New datatype size in bytes or #H5T_VARIABLE
+ *
+ * \return \herr_t
+ *
+ * \details H5Tset_size() sets the total size, \p size, in bytes, for a
+ *          datatype.
+ *
+ *          \p size must have a positive value unless it is passed in as
+ *          #H5T_VARIABLE and the datatype is a string datatype.
+ *
+ *          \li Numeric datatypes: If the datatype is atomic and the size
+ *          is decreased so that significant bits of the datatype extend
+ *          beyond the edge of the new size, then the offset property of the
+ *          datatype is decreased toward zero.  If the offset becomes zero
+ *          and the significant bits of the datatype still hang over the edge
+ *          of the new size, then the number of significant bits is decreased.
+ *
+ *          \li String or character datatypes: The size set for a string
+ *          datatype should include space for the null-terminator character,
+ *          otherwise it will not be stored on (or retrieved from) the
+ *          disk. Adjusting the size of a string automatically sets the
+ *          precision to \p 8*size.
+ *
+ *          \li Variable-length string datatypes: If \p dtype_id is a
+ *          variable-length string, size must normally be set to #H5T_VARIABLE.
+ *          See \ref_vlen_strings.
+ *
+ *          \li Compound datatypes: This function may be used to increase or
+ *          decrease the size of a compound datatype, but the function will
+ *          fail if the new size is too small to accommodate all member fields.
+ *
+ *          \li Ineligible datatypes: This function cannot be used with
+ *          enumerated datatypes (#H5T_ENUM), array datatypes (#H5T_ARRAY),
+ *          variable-length array datatypes (#H5T_VLEN), or reference datatypes
+ *          (#H5T_REFERENCE).
+ *
+ * \see H5Tget_size()
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tset_size(hid_t type_id, size_t size);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Sets the byte order of a datatype
+ *
+ * \type_id
+ * \param[in] order Byte order constant
+ *
+ * \return \herr_t
+ *
+ * \details H5Tset_order() sets the byte order of a datatype.\n
+ *          Byte order can currently be set to any of the following:
+ *          \snippet this H5T_order_t_snip
+ *          #H5T_ORDER_MIXED (3) is a valid value for order only when
+ *          returned by the function H5Tget_order(); it cannot be set with
+ *          H5Tset_order().
+ *
+ *          #H5T_ORDER_NONE (4) is a valid value for order, but it has no
+ *          effect. It is valid only for fixed-length strings and object and
+ *          region references and specifies no particular order.
+ *
+ *          The byte order of a derived datatype is initially the same as
+ *          that of the parent type, but can be changed with H5Tset_order().
+ *
+ *          This function cannot be used with a datatype after it has been
+ *          committed.
+ *
+ * \note    Special considerations:
+ *          \li ENUM datatypes: Byte order must be set before any member on
+ *              an ENUM is defined.
+ *          \li Compound datatypes: Byte order is set individually on each member
+ *              of a compound datatype; members of a compound datatype need not
+ *              have the same byte order.
+ *          \li Opaque datatypes: Byte order can be set but has no effect.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tset_order(hid_t type_id, H5T_order_t order);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Sets the precision of an atomic datatype
+ *
+ * \type_id
+ * \param[in] prec Number of bits of precision for datatype
+ *
+ * \return \herr_t
+ *
+ * \details H5Tset_precision() sets the precision of an atomic datatype. The
+ *          precision is the number of significant bits which, unless
+ *          padding is present, is 8 times larger than the value returned
+ *          by H5Tget_size().
+ *
+ *          If the precision is increased then the offset is decreased and
+ *          then the size is increased to insure that significant bits do not
+ *          "hang over" the edge of the datatype.
+ *
+ *          Changing the precision of an #H5T_STRING automatically changes
+ *          the size as well. The precision must be a multiple of 8.
+ *
+ *          When decreasing the precision of a floating point type, set the
+ *          locations and sizes of the sign, mantissa, and exponent fields
+ *          first.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tset_precision(hid_t type_id, size_t prec);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Sets the bit offset of the first significant bit
+ *
+ * \type_id
+ * \param[in] offset Offset of first significant bit
+ *
+ * \return \herr_t
+ *
+ * \details H5Tset_offset() sets the bit offset of the first significant
+ *          bit. The significant bits of an atomic datum can be offset from
+ *          the beginning of the memory for that datum by an amount of
+ *          padding. The offset property specifies the number of bits of
+ *          padding that appear to the right of the value. That is,
+ *          if we have a 32-bit datum with 16-bits of precision having the
+ *          value 0x1122, then it will be laid out in memory as (from small
+ *          byte address toward larger byte addresses):
+ *          \code{.unparsed}
+ *          0:  [ pad]  [0x11]  [0x22]  [ pad]
+ *          1:  [ pad]  [0x22]  [0x11]  [ pad]
+ *          2:  [0x11]  [ pad]  [ pad]  [0x22]
+ *          3:  [0x22]  [ pad]  [ pad]  [0x11]
+ *          \endcode
+ *          If the offset is incremented then the total size is incremented
+ *          also if necessary to prevent significant bits of the value from
+ *          hanging over the edge of the datatype.
+ *
+ *          The offset of an #H5T_STRING cannot be set to anything but zero.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tset_offset(hid_t type_id, size_t offset);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Sets the least and most-significant bits padding types
+ *
+ * \type_id
+ * \param[in] lsb Padding type for least-significant bits
+ * \param[in] msb Padding type for most-significant bits
+ *
+ * \return \herr_t
+ *
+ * \details H5Tset_pad() sets the least and most-significant bits padding types.
+ *          Available values are:
+ * \padding_type
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tset_pad(hid_t type_id, H5T_pad_t lsb, H5T_pad_t msb);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Sets the sign property for an integer type
+ *
+ * \type_id
+ * \param[in] sign Sign type
+ *
+ * \return \herr_t
+ *
+ * \details H5Tset_sign() sets the sign property for an integer type:
+ * \sign_prop
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tset_sign(hid_t type_id, H5T_sign_t sign);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Sets locations and sizes of floating point bit fields
+ *
+ * \type_id
+ * \param[in] spos Sign position, i.e., the bit offset of the floating-point
+ *                 sign bit
+ * \param[in] epos Exponent bit position
+ * \param[in] esize Size of exponent in bits
+ * \param[in] mpos Mantissa bit position
+ * \param[in] msize Size of mantissa in bits
+ *
+ * \return \herr_t
+ *
+ * \details H5Tset_fields() sets the locations and sizes of the various
+ *          floating-point bit fields. The field positions are bit positions
+ *          in the significant region of the datatype. Bits are numbered with
+ *          the least significant bit number zero.
+ *
+ *          Fields are not allowed to extend beyond the number of bits of
+ *          precision, nor are they allowed to overlap with one another.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tset_fields(hid_t type_id, size_t spos, size_t epos, size_t esize, size_t mpos, size_t msize);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Sets the exponent bias of a floating-point type
+ *
+ * \type_id
+ * \param[in] ebias Exponent bias value
+ *
+ * \return \herr_t
+ *
+ * \details H5Tset_ebias() sets the exponent bias of a floating-point type.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tset_ebias(hid_t type_id, size_t ebias);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Sets the mantissa normalization of a floating-point datatype
+ *
+ * \type_id
+ * \param[in] norm Mantissa normalization type
+ *
+ * \return \herr_t
+ *
+ * \details H5Tset_norm() sets the mantissa normalization of a floating-point
+ *          datatype. Valid normalization types are:
+ *          \snippet this H5T_norm_t_snip
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tset_norm(hid_t type_id, H5T_norm_t norm);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Fills unused internal floating-point bits
+ *
+ * \type_id
+ * \param[in] pad Padding type
+ *
+ * \return \herr_t
+ *
+ * \details H5Tset_inpad() If any internal bits of a floating point-type are
+ *          unused (that is, those significant bits which are not part of the
+ *          sign, exponent, or mantissa), then H5Tset_inpad()  will be filled
+ *          according to the value of the padding value property inpad. Valid
+ *          padding types are:
+ *          \snippet this H5T_pad_t_snip
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tset_inpad(hid_t type_id, H5T_pad_t pad);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Sets character set to be used in a string or character datatype
+ *
+ * \type_id
+ * \param[in] cset Character set type
+ *
+ * \return \herr_t
+ *
+ * \details H5Tset_cset() sets the character set to be used in a dataset with
+ *          a string or character datatype.
+ *
+ *          Valid values for cset include the following:
+ *          \csets
+ *          For example, if the character set for the datatype \p type_id is set
+ *          to #H5T_CSET_UTF8, string or character data of datatype dtype_id
+ *          will be encoded using the UTF-8 Unicode character set.
+ *
+ *          ASCII and UTF-8 Unicode are the only currently supported character
+ *          encodings. Extended ASCII encodings (for example, ISO 8859) are
+ *          not supported. This encoding policy is not enforced by the HDF5
+ *          library. Using encodings other than ASCII and UTF-8 can lead to
+ *          compatibility and usability problems.
+ *
+ *          Note that H5Tset_cset()  sets the character set for a character or
+ *          string datatype while H5Pset_char_encoding()  sets the character
+ *          set used for an HDF5 link or attribute name.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tset_cset(hid_t type_id, H5T_cset_t cset);
+/**
+ * \ingroup ATOM
+ *
+ * \brief Defines the type of padding used for character strings
+ *
+ * \type_id
+ * \param[in] strpad String padding type
+ *
+ * \return \herr_t
+ *
+ * \details H5Tset_strpad() defines the type of padding used for a string
+ *          datatype.
+ *
+ *          The method used to store character strings differs with the
+ *          programming language.  C usually null terminates strings while
+ *          Fortran left-justifies and space-pads strings.
+ *
+ *          Valid values of \p strpad are as follows:
+ *          \str_pad_type
+ *          When converting from a longer string to a shorter string, the
+ *          behavior is as follows. If the shorter string is #H5T_STR_NULLPAD
+ *          or #H5T_STR_SPACEPAD, then the string is simply truncated. If
+ *          the short string is #H5T_STR_NULLTERM, it is truncated and a null
+ *          terminator is appended.
+ *
+ *          When converting from a shorter string to a longer string, the
+ *          longer string is padded on the end by appending nulls or spaces.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tset_strpad(hid_t type_id, H5T_str_t strpad);
+
+/**
+ * --------------------------------------------------------------------------
+ * \ingroup CONV
+ *
+ * \brief Converts data from one specified datatype to another
+ *
+ * \type_id{src_id} of source datatype
+ * \type_id{dst_id} of destination datatype
+ * \param[in] nelmts Size of array \p buf
+ * \param[in,out] buf Array containing pre- and post-conversion values
+ * \param[in] background Optional background buffer
+ * \dxpl_id{plist_id}
+ *
+ * \return \herr_t
+ *
+ * \details H5Tconvert() converts \p nelmts elements from a source datatype,
+ *          specified by \p src_id, to a destination datatype, \p dst_id. The
+ *          source elements are packed in \p buf and on return the destination
+ *          elements will be packed in \p buf. That is, the conversion is
+ *          performed in place.
+ *
+ *          The optional background buffer is for use with compound datatypes.
+ *          It is an array of \p nelmts values for the destination datatype
+ *          which can then be merged with the converted values to recreate the
+ *          compound datatype. For instance, background might be an array of
+ *          structs with the \c a and \c b fields already initialized and the
+ *          conversion of buf supplies the \c c and \c d field values.
+ *
+ *          The parameter \p plist_id contains the dataset transfer property list
+ *          identifier which is passed to the conversion functions. As of
+ *          Release 1.2, this parameter is only used to pass along the
+ *          variable-length datatype custom allocation information.
+ *
+ * \note H5Tconvert() will not resize the buffer \p buf; it must be large
+ *       enough to hold the larger of the input and output data.
+ *
+ * \version 1.6.3 \p nelmts parameter type changed to size_t.
+ * \version 1.4.0 \p nelmts parameter type changed to hsize_t.
+ *
+ */
+H5_DLL herr_t H5Tconvert(hid_t src_id, hid_t dst_id, size_t nelmts, void *buf, void *background,
+                         hid_t plist_id);
+/**
+ * \ingroup VLEN
+ *
+ * \brief Reclaims the variable length (VL) datatype memory buffers
+ *
+ * \type_id
+ * \space_id
+ * \dxpl_id{plist_id} used to create the buffer
+ * \param[in] buf Pointer to the buffer to be reclaimed
+ *
+ * \return \herr_t
+ *
+ * \details H5Treclaim() reclaims memory buffers created to store VL datatypes.
+ *          It only frees the variable length data in the selection defined in
+ *          the dataspace specified by \p space_id. The dataset transfer
+ *          property list \p plist_id is required to find the correct
+ *          allocation and/or free methods for the variable-length data in the
+ *          buffer.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL herr_t H5Treclaim(hid_t type_id, hid_t space_id, hid_t plist_id, void *buf);
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+
+/* API Wrappers for async routines */
+/* (Must be defined _after_ the function prototype) */
+/* (And must only defined when included in application code, not the library) */
+#ifndef H5T_MODULE
+#define H5Tcommit_async(...) H5Tcommit_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Topen_async(...)   H5Topen_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5Tclose_async(...)  H5Tclose_async(__FILE__, __func__, __LINE__, __VA_ARGS__)
+
+/* Define "wrapper" versions of function calls, to allow compile-time values to
+ * be passed in by language wrapper or library layer on top of HDF5. */
+#define H5Tcommit_async_wrap H5_NO_EXPAND(H5Tcommit_async)
+#define H5Topen_async_wrap   H5_NO_EXPAND(H5Topen_async)
+#define H5Tclose_async_wrap  H5_NO_EXPAND(H5Tclose_async)
+#endif /* H5T_MODULE */
+
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/* Macros */
+
+/* Typedefs */
+
+/* Function prototypes */
+/**
+ * \ingroup H5T
+ *
+ * \brief Commits a transient datatype to a file, creating a newly named datatype
+ *
+ * \fg_loc_id
+ * \param[in] name Name given to committed datatype
+ * \param[in] type_id Identifier of datatype to be committed
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function has been renamed from H5Tcommit() and is
+ *             deprecated in favor of the macro #H5Tcommit or the function
+ *             H5Tcommit2().
+ *
+ * \details H5Tcommit1() commits the transient datatype (not immutable) to
+ *          a file, turning it into a named datatype.
+ *
+ *          The datatype \p dtype_id is committed as a named datatype at the
+ *          location \p loc_id, which is either a file or group identifier,
+ *          with the name \p name.
+ *
+ *          \p name can be a relative path based at \p loc_id or an absolute
+ *          path from the root of the file. Use of this function requires
+ *          that any intermediate groups specified in the path already exist.
+ *
+ *          As is the case for any object in a group, the length of the name
+ *          of a named datatype is not limited.
+ *
+ *          See H5Tcommit_anon() for a discussion of the differences between
+ *          H5Tcommit() and H5Tcommit_anon().
+ *
+ *          This function will not accept a datatype that cannot actually
+ *          hold data. This currently includes compound datatypes with no
+ *          fields and enumerated datatypes with no members.
+ *
+ * \version 1.8.7 Function modified in this release to reject datatypes that
+ *          will not accommodate actual data, such as a compound datatype with
+ *          no fields or an enumerated datatype with no members.
+ * \version 1.8.0 C function H5Tcommit() renamed to H5Tcommit1() and deprecated
+ *          in this release.
+ * \since 1.2.0
+ *
+ */
+H5_DLL herr_t H5Tcommit1(hid_t loc_id, const char *name, hid_t type_id);
+/**
+ * \ingroup H5T
+ *
+ * \brief Opens a named datatype
+ *
+ * \fg_loc_id
+ * \param[in] name A datatype name, defined within the specified file or group
+ *
+ * \return \herr_t
+ *
+ * \deprecated This function has been renamed from H5Topen() and is
+ *             deprecated in favor of the macro #H5Topen or the function
+ *             H5Topen2().
+ *
+ * \details H5Topen1() opens a named datatype at the location specified by
+ *          \p loc_id and returns an identifier for the datatype. \p loc_id
+ *          can be either a file or group identifier. The identifier should
+ *          eventually be closed by calling H5Tclose()  to release resources.
+ *
+ * \version 1.8.0 Function H5Topen() renamed to H5Topen1() and deprecated in
+ *          this release.
+ *
+ * \since 1.2.0
+ *
+ */
+H5_DLL hid_t H5Topen1(hid_t loc_id, const char *name);
+/**
+ * \ingroup ARRAY
+ *
+ * \brief Creates an array datatype object
+ *
+ * \param[in] base_id Datatype identifier for the array base datatype
+ * \param[in] ndims Rank of the array
+ * \param[in] dim Size of each array dimension
+ * \param[in] perm Dimension permutation   (Currently not implemented.)
+ *
+ * \return \hid_t{array datatype}
+ *
+ * \deprecated This function has been renamed from H5Tarray_create() and is
+ *             deprecated in favor of the macro #H5Tarray_create or the function
+ *             H5Tarray_create2().
+ *
+ * \details H5Tarray_create1() creates a new array datatype object.\n\n
+ *          \p base_id is the datatype of every element of the array, i.e.,
+ *          of the number at each position in the array.
+ *
+ *          \p rank is the number of dimensions and the size of each dimension
+ *          is specified in the array dims. The value of rank is currently
+ *          limited to #H5S_MAX_RANK and must be greater than 0 (zero). All
+ *          dimension sizes specified in dims must be greater than 0 (zero).
+ *
+ *          The array \p perm is designed to contain the dimension permutation,
+ *          i.e. C versus FORTRAN array order.   (The parameter perm is
+ *          currently unused and is not yet implemented.)
+ *
+ * \version 1.8.0 Function H5Tarray_create() renamed to H5Tarray_create1()
+ *          and deprecated in this release.
+ * \since 1.4.0
+ *
+ */
+H5_DLL hid_t H5Tarray_create1(hid_t base_id, int ndims, const hsize_t dim[/* ndims */],
+                              const int perm[/* ndims */]);
+/**
+ * \ingroup ARRAY
+ *
+ * \brief Retrieves sizes of array dimensions
+ *
+ * \type_id
+ * \param[out] dims Sizes of array dimensions
+ * \param[out] perm Dimension permutations (This parameter is not used.)
+ *
+ * \return Returns the non-negative number of dimensions of the array type
+ *         if successful; otherwise, returns a negative value.
+ *
+ * \deprecated This function has been renamed from H5Tget_array_dims() and is
+ *             deprecated in favor of the macro #H5Tget_array_dims or the
+ *             function H5Tget_array_dims2().
+ *
+ * \details H5Tget_array_dims1() returns the sizes of the dimensions and
+ *          the dimension permutations of the specified array datatype object.
+ *
+ *          The sizes of the dimensions are returned in the array \p dims.
+ *
+ * \version 1.8.0 Function H5Tarray_create() renamed to H5Tarray_create1()
+ *          and deprecated in this release.
+ * \since 1.2.0
+ *
+ */
+H5_DLL int H5Tget_array_dims1(hid_t type_id, hsize_t dims[], int perm[]);
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* H5Tpublic_H */
diff --git a/install/include/H5VLconnector.h b/install/include/H5VLconnector.h
new file mode 100644
index 0000000000..02d22314eb
--- /dev/null
+++ b/install/include/H5VLconnector.h
@@ -0,0 +1,1159 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for authoring VOL connectors.
+ */
+
+#ifndef H5VLconnector_H
+#define H5VLconnector_H
+
+/* Public headers needed by this file */
+#include "H5public.h"   /* Generic Functions                    */
+#include "H5Apublic.h"  /* Attributes                           */
+#include "H5Dpublic.h"  /* Datasets                             */
+#include "H5ESpublic.h" /* Event Stack                          */
+#include "H5Fpublic.h"  /* Files                                */
+#include "H5Ipublic.h"  /* IDs                                  */
+#include "H5Lpublic.h"  /* Links                                */
+#include "H5Opublic.h"  /* Objects                              */
+#include "H5Rpublic.h"  /* References                           */
+#include "H5VLpublic.h" /* Virtual Object Layer                 */
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* Container info version */
+#define H5VL_CONTAINER_INFO_VERSION 0x01 /* Container info struct version */
+
+/* The maximum size allowed for blobs */
+#define H5VL_MAX_BLOB_ID_SIZE (16) /* Allow for 128-bits blob IDs */
+
+/* # of optional operations reserved for the native VOL connector */
+#define H5VL_RESERVED_NATIVE_OPTIONAL 1024
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/* Types for different ways that objects are located in an HDF5 container */
+typedef enum H5VL_loc_type_t {
+    H5VL_OBJECT_BY_SELF,
+    H5VL_OBJECT_BY_NAME,
+    H5VL_OBJECT_BY_IDX,
+    H5VL_OBJECT_BY_TOKEN
+} H5VL_loc_type_t;
+
+typedef struct H5VL_loc_by_name {
+    const char *name;
+    hid_t       lapl_id;
+} H5VL_loc_by_name_t;
+
+typedef struct H5VL_loc_by_idx {
+    const char     *name;
+    H5_index_t      idx_type;
+    H5_iter_order_t order;
+    hsize_t         n;
+    hid_t           lapl_id;
+} H5VL_loc_by_idx_t;
+
+typedef struct H5VL_loc_by_token {
+    H5O_token_t *token;
+} H5VL_loc_by_token_t;
+
+/* Structure to hold parameters for object locations.
+ * Either: BY_SELF, BY_NAME, BY_IDX, BY_TOKEN
+ *
+ * Note: Leave loc_by_token as the first union member so we
+ *       can perform the simplest initialization of the struct
+ *       without raising warnings.
+ *
+ * Note: BY_SELF requires no union members.
+ */
+typedef struct H5VL_loc_params_t {
+    H5I_type_t      obj_type;
+    H5VL_loc_type_t type;
+    union {
+        H5VL_loc_by_token_t loc_by_token;
+        H5VL_loc_by_name_t  loc_by_name;
+        H5VL_loc_by_idx_t   loc_by_idx;
+    } loc_data;
+} H5VL_loc_params_t;
+
+/* Struct for all 'optional' callbacks */
+typedef struct H5VL_optional_args_t {
+    int   op_type; /* Operation to perform */
+    void *args;    /* Pointer to operation's argument struct */
+} H5VL_optional_args_t;
+
+/* Values for attribute 'get' operations */
+typedef enum H5VL_attr_get_t {
+    H5VL_ATTR_GET_ACPL,         /* creation property list              */
+    H5VL_ATTR_GET_INFO,         /* info                                */
+    H5VL_ATTR_GET_NAME,         /* access property list                */
+    H5VL_ATTR_GET_SPACE,        /* dataspace                           */
+    H5VL_ATTR_GET_STORAGE_SIZE, /* storage size                        */
+    H5VL_ATTR_GET_TYPE          /* datatype                            */
+} H5VL_attr_get_t;
+
+/* Parameters for attribute 'get_name' operation */
+typedef struct H5VL_attr_get_name_args_t {
+    H5VL_loc_params_t loc_params;    /* Location parameters for object access */
+    size_t            buf_size;      /* Size of attribute name buffer */
+    char             *buf;           /* Buffer for attribute name (OUT) */
+    size_t           *attr_name_len; /* Actual length of attribute name (OUT) */
+} H5VL_attr_get_name_args_t;
+
+/* Parameters for attribute 'get_info' operation */
+typedef struct H5VL_attr_get_info_args_t {
+    H5VL_loc_params_t loc_params; /* Location parameters for object access */
+    const char       *attr_name;  /* Attribute name (for get_info_by_name) */
+    H5A_info_t       *ainfo;      /* Attribute info (OUT) */
+} H5VL_attr_get_info_args_t;
+
+/* Parameters for attribute 'get' operations */
+typedef struct H5VL_attr_get_args_t {
+    H5VL_attr_get_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_ATTR_GET_ACPL */
+        struct {
+            hid_t acpl_id; /* Attribute creation property list ID (OUT) */
+        } get_acpl;
+
+        /* H5VL_ATTR_GET_INFO */
+        H5VL_attr_get_info_args_t get_info; /* Attribute info */
+
+        /* H5VL_ATTR_GET_NAME */
+        H5VL_attr_get_name_args_t get_name; /* Attribute name */
+
+        /* H5VL_ATTR_GET_SPACE */
+        struct {
+            hid_t space_id; /* Dataspace ID (OUT) */
+        } get_space;
+
+        /* H5VL_ATTR_GET_STORAGE_SIZE */
+        struct {
+            hsize_t *data_size; /* Size of attribute in file (OUT) */
+        } get_storage_size;
+
+        /* H5VL_ATTR_GET_TYPE */
+        struct {
+            hid_t type_id; /* Datatype ID (OUT) */
+        } get_type;
+    } args;
+} H5VL_attr_get_args_t;
+
+/* Values for attribute 'specific' operation */
+typedef enum H5VL_attr_specific_t {
+    H5VL_ATTR_DELETE,        /* H5Adelete(_by_name)  */
+    H5VL_ATTR_DELETE_BY_IDX, /* H5Adelete_by_idx     */
+    H5VL_ATTR_EXISTS,        /* H5Aexists(_by_name)  */
+    H5VL_ATTR_ITER,          /* H5Aiterate(_by_name) */
+    H5VL_ATTR_RENAME         /* H5Arename(_by_name)  */
+} H5VL_attr_specific_t;
+
+/* Parameters for attribute 'iterate' operation */
+typedef struct H5VL_attr_iterate_args_t {
+    H5_index_t      idx_type; /* Type of index to iterate over */
+    H5_iter_order_t order;    /* Order of index iteration */
+    hsize_t        *idx;      /* Start/stop iteration index (IN/OUT) */
+    H5A_operator2_t op;       /* Iteration callback function */
+    void           *op_data;  /* Iteration callback context */
+} H5VL_attr_iterate_args_t;
+
+/* Parameters for attribute 'delete_by_idx' operation */
+typedef struct H5VL_attr_delete_by_idx_args_t {
+    H5_index_t      idx_type; /* Type of index to iterate over */
+    H5_iter_order_t order;    /* Order of index iteration */
+    hsize_t         n;        /* Iteration index */
+} H5VL_attr_delete_by_idx_args_t;
+
+/* Parameters for attribute 'specific' operations */
+typedef struct H5VL_attr_specific_args_t {
+    H5VL_attr_specific_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_ATTR_DELETE */
+        struct {
+            const char *name; /* Name of attribute to delete */
+        } del;
+
+        /* H5VL_ATTR_DELETE_BY_IDX */
+        H5VL_attr_delete_by_idx_args_t delete_by_idx;
+
+        /* H5VL_ATTR_EXISTS */
+        struct {
+            const char *name;   /* Name of attribute to check */
+            hbool_t    *exists; /* Whether attribute exists (OUT) */
+        } exists;
+
+        /* H5VL_ATTR_ITER */
+        H5VL_attr_iterate_args_t iterate;
+
+        /* H5VL_ATTR_RENAME */
+        struct {
+            const char *old_name; /* Name of attribute to rename */
+            const char *new_name; /* New attribute name */
+        } rename;
+    } args;
+} H5VL_attr_specific_args_t;
+
+/* Typedef for VOL connector attribute optional VOL operations */
+typedef int H5VL_attr_optional_t;
+
+/* Values for dataset 'get' operation */
+typedef enum H5VL_dataset_get_t {
+    H5VL_DATASET_GET_DAPL,         /* access property list                */
+    H5VL_DATASET_GET_DCPL,         /* creation property list              */
+    H5VL_DATASET_GET_SPACE,        /* dataspace                           */
+    H5VL_DATASET_GET_SPACE_STATUS, /* space status                        */
+    H5VL_DATASET_GET_STORAGE_SIZE, /* storage size                        */
+    H5VL_DATASET_GET_TYPE          /* datatype                            */
+} H5VL_dataset_get_t;
+
+/* Parameters for dataset 'get' operations */
+typedef struct H5VL_dataset_get_args_t {
+    H5VL_dataset_get_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_DATASET_GET_DAPL */
+        struct {
+            hid_t dapl_id; /* Dataset access property list ID (OUT) */
+        } get_dapl;
+
+        /* H5VL_DATASET_GET_DCPL */
+        struct {
+            hid_t dcpl_id; /* Dataset creation property list ID (OUT) */
+        } get_dcpl;
+
+        /* H5VL_DATASET_GET_SPACE */
+        struct {
+            hid_t space_id; /* Dataspace ID (OUT) */
+        } get_space;
+
+        /* H5VL_DATASET_GET_SPACE_STATUS */
+        struct {
+            H5D_space_status_t *status; /* Storage space allocation status (OUT) */
+        } get_space_status;
+
+        /* H5VL_DATASET_GET_STORAGE_SIZE */
+        struct {
+            hsize_t *storage_size; /* Size of dataset's storage (OUT) */
+        } get_storage_size;
+
+        /* H5VL_DATASET_GET_TYPE */
+        struct {
+            hid_t type_id; /* Datatype ID (OUT) */
+        } get_type;
+    } args;
+} H5VL_dataset_get_args_t;
+
+/* Values for dataset 'specific' operation */
+typedef enum H5VL_dataset_specific_t {
+    H5VL_DATASET_SET_EXTENT, /* H5Dset_extent                       */
+    H5VL_DATASET_FLUSH,      /* H5Dflush                            */
+    H5VL_DATASET_REFRESH     /* H5Drefresh                          */
+} H5VL_dataset_specific_t;
+
+/* Parameters for dataset 'specific' operations */
+typedef struct H5VL_dataset_specific_args_t {
+    H5VL_dataset_specific_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_DATASET_SET_EXTENT */
+        struct {
+            const hsize_t *size; /* New dataspace extent */
+        } set_extent;
+
+        /* H5VL_DATASET_FLUSH */
+        struct {
+            hid_t dset_id; /* Dataset ID (IN) */
+        } flush;
+
+        /* H5VL_DATASET_REFRESH */
+        struct {
+            hid_t dset_id; /* Dataset ID (IN) */
+        } refresh;
+    } args;
+} H5VL_dataset_specific_args_t;
+
+/* Typedef for VOL connector dataset optional VOL operations */
+typedef int H5VL_dataset_optional_t;
+
+/* Values for datatype 'get' operation */
+typedef enum H5VL_datatype_get_t {
+    H5VL_DATATYPE_GET_BINARY_SIZE, /* Get size of serialized form of transient type */
+    H5VL_DATATYPE_GET_BINARY,      /* Get serialized form of transient type         */
+    H5VL_DATATYPE_GET_TCPL         /* Datatype creation property list               */
+} H5VL_datatype_get_t;
+
+/* Parameters for datatype 'get' operations */
+typedef struct H5VL_datatype_get_args_t {
+    H5VL_datatype_get_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_DATATYPE_GET_BINARY_SIZE */
+        struct {
+            size_t *size; /* Size of serialized form of datatype (OUT) */
+        } get_binary_size;
+
+        /* H5VL_DATATYPE_GET_BINARY */
+        struct {
+            void  *buf;      /* Buffer to store serialized form of datatype (OUT) */
+            size_t buf_size; /* Size of serialized datatype buffer */
+        } get_binary;
+
+        /* H5VL_DATATYPE_GET_TCPL */
+        struct {
+            hid_t tcpl_id; /* Named datatype creation property list ID (OUT) */
+        } get_tcpl;
+    } args;
+} H5VL_datatype_get_args_t;
+
+/* Values for datatype 'specific' operation */
+typedef enum H5VL_datatype_specific_t {
+    H5VL_DATATYPE_FLUSH,  /* H5Tflush */
+    H5VL_DATATYPE_REFRESH /* H5Trefresh */
+} H5VL_datatype_specific_t;
+
+/* Parameters for datatype 'specific' operations */
+typedef struct H5VL_datatype_specific_args_t {
+    H5VL_datatype_specific_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_DATATYPE_FLUSH */
+        struct {
+            hid_t type_id; /* Named datatype ID (IN) */
+        } flush;
+
+        /* H5VL_DATATYPE_REFRESH */
+        struct {
+            hid_t type_id; /* Named datatype ID (IN) */
+        } refresh;
+    } args;
+} H5VL_datatype_specific_args_t;
+
+/* Typedef and values for native VOL connector named datatype optional VOL operations */
+typedef int H5VL_datatype_optional_t;
+/* (No optional named datatype VOL operations currently) */
+
+/* Info for H5VL_FILE_GET_CONT_INFO */
+typedef struct H5VL_file_cont_info_t {
+    unsigned version;       /* version information (keep first) */
+    uint64_t feature_flags; /* Container feature flags          */
+                            /* (none currently defined)         */
+    size_t token_size;      /* Size of tokens                   */
+    size_t blob_id_size;    /* Size of blob IDs                 */
+} H5VL_file_cont_info_t;
+
+/* Values for file 'get' operation */
+typedef enum H5VL_file_get_t {
+    H5VL_FILE_GET_CONT_INFO, /* file get container info              */
+    H5VL_FILE_GET_FAPL,      /* file access property list            */
+    H5VL_FILE_GET_FCPL,      /* file creation property list          */
+    H5VL_FILE_GET_FILENO,    /* file number                          */
+    H5VL_FILE_GET_INTENT,    /* file intent                          */
+    H5VL_FILE_GET_NAME,      /* file name                            */
+    H5VL_FILE_GET_OBJ_COUNT, /* object count in file                 */
+    H5VL_FILE_GET_OBJ_IDS    /* object ids in file                   */
+} H5VL_file_get_t;
+
+/* Parameters for file 'get_name' operation */
+typedef struct H5VL_file_get_name_args_t {
+    H5I_type_t type;          /* ID type of object pointer */
+    size_t     buf_size;      /* Size of file name buffer (IN) */
+    char      *buf;           /* Buffer for file name (OUT) */
+    size_t    *file_name_len; /* Actual length of file name (OUT) */
+} H5VL_file_get_name_args_t;
+
+/* Parameters for file 'get_obj_ids' operation */
+typedef struct H5VL_file_get_obj_ids_args_t {
+    unsigned types;    /* Type of objects to count */
+    size_t   max_objs; /* Size of array of object IDs */
+    hid_t   *oid_list; /* Array of object IDs (OUT) */
+    size_t  *count;    /* # of objects (OUT) */
+} H5VL_file_get_obj_ids_args_t;
+
+/* Parameters for file 'get' operations */
+typedef struct H5VL_file_get_args_t {
+    H5VL_file_get_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_FILE_GET_CONT_INFO */
+        struct {
+            H5VL_file_cont_info_t *info; /* Container info (OUT) */
+        } get_cont_info;
+
+        /* H5VL_FILE_GET_FAPL */
+        struct {
+            hid_t fapl_id; /* File access property list (OUT) */
+        } get_fapl;
+
+        /* H5VL_FILE_GET_FCPL */
+        struct {
+            hid_t fcpl_id; /* File creation property list (OUT) */
+        } get_fcpl;
+
+        /* H5VL_FILE_GET_FILENO */
+        struct {
+            unsigned long *fileno; /* File "number" (OUT) */
+        } get_fileno;
+
+        /* H5VL_FILE_GET_INTENT */
+        struct {
+            unsigned *flags; /* File open/create intent flags (OUT) */
+        } get_intent;
+
+        /* H5VL_FILE_GET_NAME */
+        H5VL_file_get_name_args_t get_name;
+
+        /* H5VL_FILE_GET_OBJ_COUNT */
+        struct {
+            unsigned types; /* Type of objects to count */
+            size_t  *count; /* # of objects (OUT) */
+        } get_obj_count;
+
+        /* H5VL_FILE_GET_OBJ_IDS */
+        H5VL_file_get_obj_ids_args_t get_obj_ids;
+    } args;
+} H5VL_file_get_args_t;
+
+/* Values for file 'specific' operation */
+typedef enum H5VL_file_specific_t {
+    H5VL_FILE_FLUSH,         /* Flush file                       */
+    H5VL_FILE_REOPEN,        /* Reopen the file                  */
+    H5VL_FILE_IS_ACCESSIBLE, /* Check if a file is accessible    */
+    H5VL_FILE_DELETE,        /* Delete a file                    */
+    H5VL_FILE_IS_EQUAL       /* Check if two files are the same  */
+} H5VL_file_specific_t;
+
+/* Parameters for file 'specific' operations */
+typedef struct H5VL_file_specific_args_t {
+    H5VL_file_specific_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_FILE_FLUSH */
+        struct {
+            H5I_type_t  obj_type; /* Type of object to use */
+            H5F_scope_t scope;    /* Scope of flush operation */
+        } flush;
+
+        /* H5VL_FILE_REOPEN */
+        struct {
+            void **file; /* File object for new file (OUT) */
+        } reopen;
+
+        /* H5VL_FILE_IS_ACCESSIBLE */
+        struct {
+            const char *filename;   /* Name of file to check */
+            hid_t       fapl_id;    /* File access property list to use */
+            hbool_t    *accessible; /* Whether file is accessible with FAPL settings (OUT) */
+        } is_accessible;
+
+        /* H5VL_FILE_DELETE */
+        struct {
+            const char *filename; /* Name of file to delete */
+            hid_t       fapl_id;  /* File access property list to use */
+        } del;
+
+        /* H5VL_FILE_IS_EQUAL */
+        struct {
+            void    *obj2;      /* Second file object to compare against */
+            hbool_t *same_file; /* Whether files are the same (OUT) */
+        } is_equal;
+    } args;
+} H5VL_file_specific_args_t;
+
+/* Typedef for VOL connector file optional VOL operations */
+typedef int H5VL_file_optional_t;
+
+/* Values for group 'get' operation */
+typedef enum H5VL_group_get_t {
+    H5VL_GROUP_GET_GCPL, /* group creation property list     */
+    H5VL_GROUP_GET_INFO  /* group info                       */
+} H5VL_group_get_t;
+
+/* Parameters for group 'get_info' operation */
+typedef struct H5VL_group_get_info_args_t {
+    H5VL_loc_params_t loc_params; /* Location parameters for object access */
+    H5G_info_t       *ginfo;      /* Group info (OUT) */
+} H5VL_group_get_info_args_t;
+
+/* Parameters for group 'get' operations */
+typedef struct H5VL_group_get_args_t {
+    H5VL_group_get_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_GROUP_GET_GCPL */
+        struct {
+            hid_t gcpl_id; /* Group creation property list (OUT) */
+        } get_gcpl;
+
+        /* H5VL_GROUP_GET_INFO */
+        H5VL_group_get_info_args_t get_info; /* Group info */
+    } args;
+} H5VL_group_get_args_t;
+
+/* Values for group 'specific' operation */
+typedef enum H5VL_group_specific_t {
+    H5VL_GROUP_MOUNT,   /* Mount a file on a group          */
+    H5VL_GROUP_UNMOUNT, /* Unmount a file on a group        */
+    H5VL_GROUP_FLUSH,   /* H5Gflush                         */
+    H5VL_GROUP_REFRESH  /* H5Grefresh                       */
+} H5VL_group_specific_t;
+
+/* Parameters for group 'mount' operation */
+typedef struct H5VL_group_spec_mount_args_t {
+    const char *name;       /* Name of location to mount child file */
+    void       *child_file; /* Pointer to child file object */
+    hid_t       fmpl_id;    /* File mount property list to use */
+} H5VL_group_spec_mount_args_t;
+
+/* Parameters for group 'specific' operations */
+typedef struct H5VL_group_specific_args_t {
+    H5VL_group_specific_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_GROUP_MOUNT */
+        H5VL_group_spec_mount_args_t mount;
+
+        /* H5VL_GROUP_UNMOUNT */
+        struct {
+            const char *name; /* Name of location to unmount child file */
+        } unmount;
+
+        /* H5VL_GROUP_FLUSH */
+        struct {
+            hid_t grp_id; /* Group ID (IN) */
+        } flush;
+
+        /* H5VL_GROUP_REFRESH */
+        struct {
+            hid_t grp_id; /* Group ID (IN) */
+        } refresh;
+    } args;
+} H5VL_group_specific_args_t;
+
+/* Typedef for VOL connector group optional VOL operations */
+typedef int H5VL_group_optional_t;
+
+/* Link create types for VOL */
+typedef enum H5VL_link_create_t {
+    H5VL_LINK_CREATE_HARD,
+    H5VL_LINK_CREATE_SOFT,
+    H5VL_LINK_CREATE_UD
+} H5VL_link_create_t;
+
+/* Parameters for link 'create' operations */
+typedef struct H5VL_link_create_args_t {
+    H5VL_link_create_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_LINK_CREATE_HARD */
+        struct {
+            void             *curr_obj;        /* Current object */
+            H5VL_loc_params_t curr_loc_params; /* Location parameters for current object */
+        } hard;
+
+        /* H5VL_LINK_CREATE_SOFT */
+        struct {
+            const char *target; /* Target of soft link */
+        } soft;
+
+        /* H5VL_LINK_CREATE_UD */
+        struct {
+            H5L_type_t  type;     /* Type of link to create */
+            const void *buf;      /* Buffer that contains link info */
+            size_t      buf_size; /* Size of link info buffer */
+        } ud;
+    } args;
+} H5VL_link_create_args_t;
+
+/* Values for link 'get' operation */
+typedef enum H5VL_link_get_t {
+    H5VL_LINK_GET_INFO, /* link info                         */
+    H5VL_LINK_GET_NAME, /* link name                         */
+    H5VL_LINK_GET_VAL   /* link value                        */
+} H5VL_link_get_t;
+
+/* Parameters for link 'get' operations */
+typedef struct H5VL_link_get_args_t {
+    H5VL_link_get_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_LINK_GET_INFO */
+        struct {
+            H5L_info2_t *linfo; /* Pointer to link's info (OUT) */
+        } get_info;
+
+        /* H5VL_LINK_GET_NAME */
+        struct {
+            size_t  name_size; /* Size of link name buffer (IN) */
+            char   *name;      /* Buffer for link name (OUT) */
+            size_t *name_len;  /* Actual length of link name (OUT) */
+        } get_name;
+
+        /* H5VL_LINK_GET_VAL */
+        struct {
+            size_t buf_size; /* Size of link value buffer (IN) */
+            void  *buf;      /* Buffer for link value (OUT) */
+        } get_val;
+    } args;
+} H5VL_link_get_args_t;
+
+/* Values for link 'specific' operation */
+typedef enum H5VL_link_specific_t {
+    H5VL_LINK_DELETE, /* H5Ldelete(_by_idx)                */
+    H5VL_LINK_EXISTS, /* link existence                    */
+    H5VL_LINK_ITER    /* H5Literate/visit(_by_name)              */
+} H5VL_link_specific_t;
+
+/* Parameters for link 'iterate' operation */
+typedef struct H5VL_link_iterate_args_t {
+    hbool_t         recursive; /* Whether iteration is recursive */
+    H5_index_t      idx_type;  /* Type of index to iterate over */
+    H5_iter_order_t order;     /* Order of index iteration */
+    hsize_t        *idx_p;     /* Start/stop iteration index (OUT) */
+    H5L_iterate2_t  op;        /* Iteration callback function */
+    void           *op_data;   /* Iteration callback context */
+} H5VL_link_iterate_args_t;
+
+/* Parameters for link 'specific' operations */
+typedef struct H5VL_link_specific_args_t {
+    H5VL_link_specific_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_LINK_DELETE */
+        /* No args */
+
+        /* H5VL_LINK_EXISTS */
+        struct {
+            hbool_t *exists; /* Whether link exists (OUT) */
+        } exists;
+
+        /* H5VL_LINK_ITER */
+        H5VL_link_iterate_args_t iterate;
+    } args;
+} H5VL_link_specific_args_t;
+
+/* Typedef and values for native VOL connector link optional VOL operations */
+typedef int H5VL_link_optional_t;
+/* (No optional link VOL operations currently) */
+
+/* Values for object 'get' operation */
+typedef enum H5VL_object_get_t {
+    H5VL_OBJECT_GET_FILE, /* object file                       */
+    H5VL_OBJECT_GET_NAME, /* object name                       */
+    H5VL_OBJECT_GET_TYPE, /* object type                       */
+    H5VL_OBJECT_GET_INFO  /* H5Oget_info(_by_idx|name)         */
+} H5VL_object_get_t;
+
+/* Parameters for object 'get' operations */
+typedef struct H5VL_object_get_args_t {
+    H5VL_object_get_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_OBJECT_GET_FILE */
+        struct {
+            void **file; /* File object (OUT) */
+        } get_file;
+
+        /* H5VL_OBJECT_GET_NAME */
+        struct {
+            size_t  buf_size; /* Size of name buffer (IN) */
+            char   *buf;      /* Buffer for name (OUT) */
+            size_t *name_len; /* Actual length of name (OUT) */
+        } get_name;
+
+        /* H5VL_OBJECT_GET_TYPE */
+        struct {
+            H5O_type_t *obj_type; /* Type of object (OUT) */
+        } get_type;
+
+        /* H5VL_OBJECT_GET_INFO */
+        struct {
+            unsigned     fields; /* Flags for fields to retrieve */
+            H5O_info2_t *oinfo;  /* Pointer to object info (OUT) */
+        } get_info;
+    } args;
+} H5VL_object_get_args_t;
+
+/* Values for object 'specific' operation */
+typedef enum H5VL_object_specific_t {
+    H5VL_OBJECT_CHANGE_REF_COUNT, /* H5Oincr/decr_refcount             */
+    H5VL_OBJECT_EXISTS,           /* H5Oexists_by_name                 */
+    H5VL_OBJECT_LOOKUP,           /* Lookup object                     */
+    H5VL_OBJECT_VISIT,            /* H5Ovisit(_by_name)                */
+    H5VL_OBJECT_FLUSH,            /* H5{D|G|O|T}flush                  */
+    H5VL_OBJECT_REFRESH           /* H5{D|G|O|T}refresh                */
+} H5VL_object_specific_t;
+
+/* Parameters for object 'visit' operation */
+typedef struct H5VL_object_visit_args_t {
+    H5_index_t      idx_type; /* Type of index to iterate over */
+    H5_iter_order_t order;    /* Order of index iteration */
+    unsigned        fields;   /* Flags for fields to provide in 'info' object for 'op' callback */
+    H5O_iterate2_t  op;       /* Iteration callback function */
+    void           *op_data;  /* Iteration callback context */
+} H5VL_object_visit_args_t;
+
+/* Parameters for object 'specific' operations */
+typedef struct H5VL_object_specific_args_t {
+    H5VL_object_specific_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_OBJECT_CHANGE_REF_COUNT */
+        struct {
+            int delta; /* Amount to modify object's refcount */
+        } change_rc;
+
+        /* H5VL_OBJECT_EXISTS */
+        struct {
+            hbool_t *exists; /* Whether object exists (OUT) */
+        } exists;
+
+        /* H5VL_OBJECT_LOOKUP */
+        struct {
+            H5O_token_t *token_ptr; /* Pointer to token for lookup (OUT) */
+        } lookup;
+
+        /* H5VL_OBJECT_VISIT */
+        H5VL_object_visit_args_t visit;
+
+        /* H5VL_OBJECT_FLUSH */
+        struct {
+            hid_t obj_id; /* Object ID (IN) */
+        } flush;
+
+        /* H5VL_OBJECT_REFRESH */
+        struct {
+            hid_t obj_id; /* Object ID (IN) */
+        } refresh;
+    } args;
+} H5VL_object_specific_args_t;
+
+/* Typedef for VOL connector object optional VOL operations */
+typedef int H5VL_object_optional_t;
+
+/* Status values for async request operations */
+typedef enum H5VL_request_status_t {
+    H5VL_REQUEST_STATUS_IN_PROGRESS, /* Operation has not yet completed                       */
+    H5VL_REQUEST_STATUS_SUCCEED,     /* Operation has completed, successfully                 */
+    H5VL_REQUEST_STATUS_FAIL,        /* Operation has completed, but failed                   */
+    H5VL_REQUEST_STATUS_CANT_CANCEL, /* An attempt to cancel this operation was made, but it  */
+                                     /*  can't be canceled immediately.  The operation has    */
+                                     /*  not completed successfully or failed, and is not yet */
+                                     /*  in progress.  Another attempt to cancel it may be    */
+                                     /*  attempted and may (or may not) succeed.              */
+    H5VL_REQUEST_STATUS_CANCELED     /* Operation has not completed and was canceled          */
+} H5VL_request_status_t;
+
+/* Values for async request 'specific' operation */
+typedef enum H5VL_request_specific_t {
+    H5VL_REQUEST_GET_ERR_STACK, /* Retrieve error stack for failed operation */
+    H5VL_REQUEST_GET_EXEC_TIME  /* Retrieve execution time for operation */
+} H5VL_request_specific_t;
+
+/* Parameters for request 'specific' operations */
+typedef struct H5VL_request_specific_args_t {
+    H5VL_request_specific_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_REQUEST_GET_ERR_STACK */
+        struct {
+            hid_t err_stack_id; /* Error stack ID for operation (OUT) */
+        } get_err_stack;
+
+        /* H5VL_REQUEST_GET_EXEC_TIME */
+        struct {
+            uint64_t *exec_ts;   /* Timestamp for start of task execution (OUT) */
+            uint64_t *exec_time; /* Duration of task execution (in ns) (OUT) */
+        } get_exec_time;
+    } args;
+} H5VL_request_specific_args_t;
+
+/* Typedef and values for native VOL connector request optional VOL operations */
+typedef int H5VL_request_optional_t;
+/* (No optional request VOL operations currently) */
+
+/* Values for 'blob' 'specific' operation */
+typedef enum H5VL_blob_specific_t {
+    H5VL_BLOB_DELETE, /* Delete a blob (by ID) */
+    H5VL_BLOB_ISNULL, /* Check if a blob ID is "null" */
+    H5VL_BLOB_SETNULL /* Set a blob ID to the connector's "null" blob ID value */
+} H5VL_blob_specific_t;
+
+/* Parameters for blob 'specific' operations */
+typedef struct H5VL_blob_specific_args_t {
+    H5VL_blob_specific_t op_type; /* Operation to perform */
+
+    /* Parameters for each operation */
+    union {
+        /* H5VL_BLOB_DELETE */
+        /* No args */
+
+        /* H5VL_BLOB_ISNULL */
+        struct {
+            hbool_t *isnull; /* Whether blob ID is "null" (OUT) */
+        } is_null;
+
+        /* H5VL_BLOB_SETNULL */
+        /* No args */
+    } args;
+} H5VL_blob_specific_args_t;
+
+/* Typedef and values for native VOL connector blob optional VOL operations */
+typedef int H5VL_blob_optional_t;
+/* (No optional blob VOL operations currently) */
+
+/* VOL connector info fields & callbacks */
+typedef struct H5VL_info_class_t {
+    size_t size;                     /* Size of the VOL info                         */
+    void *(*copy)(const void *info); /* Callback to create a copy of the VOL info    */
+    herr_t (*cmp)(int *cmp_value, const void *info1, const void *info2); /* Callback to compare VOL info */
+    herr_t (*free)(void *info);                     /* Callback to release a VOL info               */
+    herr_t (*to_str)(const void *info, char **str); /* Callback to serialize connector's info into a string */
+    herr_t (*from_str)(const char *str,
+                       void      **info); /* Callback to deserialize a string into connector's info */
+} H5VL_info_class_t;
+
+/* VOL object wrap / retrieval callbacks */
+/* (These only need to be implemented by "pass through" VOL connectors) */
+typedef struct H5VL_wrap_class_t {
+    void *(*get_object)(const void *obj); /* Callback to retrieve underlying object       */
+    herr_t (*get_wrap_ctx)(
+        const void *obj,
+        void      **wrap_ctx); /* Callback to retrieve the object wrapping context for the connector */
+    void *(*wrap_object)(void *obj, H5I_type_t obj_type,
+                         void *wrap_ctx); /* Callback to wrap a library object */
+    void *(*unwrap_object)(void *obj);    /* Callback to unwrap a library object */
+    herr_t (*free_wrap_ctx)(
+        void *wrap_ctx); /* Callback to release the object wrapping context for the connector */
+} H5VL_wrap_class_t;
+
+/* H5A routines */
+typedef struct H5VL_attr_class_t {
+    void *(*create)(void *obj, const H5VL_loc_params_t *loc_params, const char *attr_name, hid_t type_id,
+                    hid_t space_id, hid_t acpl_id, hid_t aapl_id, hid_t dxpl_id, void **req);
+    void *(*open)(void *obj, const H5VL_loc_params_t *loc_params, const char *attr_name, hid_t aapl_id,
+                  hid_t dxpl_id, void **req);
+    herr_t (*read)(void *attr, hid_t mem_type_id, void *buf, hid_t dxpl_id, void **req);
+    herr_t (*write)(void *attr, hid_t mem_type_id, const void *buf, hid_t dxpl_id, void **req);
+    herr_t (*get)(void *obj, H5VL_attr_get_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*specific)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_attr_specific_args_t *args,
+                       hid_t dxpl_id, void **req);
+    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*close)(void *attr, hid_t dxpl_id, void **req);
+} H5VL_attr_class_t;
+
+/* H5D routines */
+typedef struct H5VL_dataset_class_t {
+    void *(*create)(void *obj, const H5VL_loc_params_t *loc_params, const char *name, hid_t lcpl_id,
+                    hid_t type_id, hid_t space_id, hid_t dcpl_id, hid_t dapl_id, hid_t dxpl_id, void **req);
+    void *(*open)(void *obj, const H5VL_loc_params_t *loc_params, const char *name, hid_t dapl_id,
+                  hid_t dxpl_id, void **req);
+    herr_t (*read)(size_t count, void *dset[], hid_t mem_type_id[], hid_t mem_space_id[],
+                   hid_t file_space_id[], hid_t dxpl_id, void *buf[], void **req);
+    herr_t (*write)(size_t count, void *dset[], hid_t mem_type_id[], hid_t mem_space_id[],
+                    hid_t file_space_id[], hid_t dxpl_id, const void *buf[], void **req);
+    herr_t (*get)(void *obj, H5VL_dataset_get_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*specific)(void *obj, H5VL_dataset_specific_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*close)(void *dset, hid_t dxpl_id, void **req);
+} H5VL_dataset_class_t;
+
+/* H5T routines*/
+typedef struct H5VL_datatype_class_t {
+    void *(*commit)(void *obj, const H5VL_loc_params_t *loc_params, const char *name, hid_t type_id,
+                    hid_t lcpl_id, hid_t tcpl_id, hid_t tapl_id, hid_t dxpl_id, void **req);
+    void *(*open)(void *obj, const H5VL_loc_params_t *loc_params, const char *name, hid_t tapl_id,
+                  hid_t dxpl_id, void **req);
+    herr_t (*get)(void *obj, H5VL_datatype_get_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*specific)(void *obj, H5VL_datatype_specific_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*close)(void *dt, hid_t dxpl_id, void **req);
+} H5VL_datatype_class_t;
+
+/* H5F routines */
+typedef struct H5VL_file_class_t {
+    void *(*create)(const char *name, unsigned flags, hid_t fcpl_id, hid_t fapl_id, hid_t dxpl_id,
+                    void **req);
+    void *(*open)(const char *name, unsigned flags, hid_t fapl_id, hid_t dxpl_id, void **req);
+    herr_t (*get)(void *obj, H5VL_file_get_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*specific)(void *obj, H5VL_file_specific_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*close)(void *file, hid_t dxpl_id, void **req);
+} H5VL_file_class_t;
+
+/* H5G routines */
+typedef struct H5VL_group_class_t {
+    void *(*create)(void *obj, const H5VL_loc_params_t *loc_params, const char *name, hid_t lcpl_id,
+                    hid_t gcpl_id, hid_t gapl_id, hid_t dxpl_id, void **req);
+    void *(*open)(void *obj, const H5VL_loc_params_t *loc_params, const char *name, hid_t gapl_id,
+                  hid_t dxpl_id, void **req);
+    herr_t (*get)(void *obj, H5VL_group_get_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*specific)(void *obj, H5VL_group_specific_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
+    herr_t (*close)(void *grp, hid_t dxpl_id, void **req);
+} H5VL_group_class_t;
+
+/* H5L routines */
+typedef struct H5VL_link_class_t {
+    herr_t (*create)(H5VL_link_create_args_t *args, void *obj, const H5VL_loc_params_t *loc_params,
+                     hid_t lcpl_id, hid_t lapl_id, hid_t dxpl_id, void **req);
+    herr_t (*copy)(void *src_obj, const H5VL_loc_params_t *loc_params1, void *dst_obj,
+                   const H5VL_loc_params_t *loc_params2, hid_t lcpl_id, hid_t lapl_id, hid_t dxpl_id,
+                   void **req);
+    herr_t (*move)(void *src_obj, const H5VL_loc_params_t *loc_params1, void *dst_obj,
+                   const H5VL_loc_params_t *loc_params2, hid_t lcpl_id, hid_t lapl_id, hid_t dxpl_id,
+                   void **req);
+    herr_t (*get)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_link_get_args_t *args, hid_t dxpl_id,
+                  void **req);
+    herr_t (*specific)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_link_specific_args_t *args,
+                       hid_t dxpl_id, void **req);
+    herr_t (*optional)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_optional_args_t *args,
+                       hid_t dxpl_id, void **req);
+} H5VL_link_class_t;
+
+/* H5O routines */
+typedef struct H5VL_object_class_t {
+    void *(*open)(void *obj, const H5VL_loc_params_t *loc_params, H5I_type_t *opened_type, hid_t dxpl_id,
+                  void **req);
+    herr_t (*copy)(void *src_obj, const H5VL_loc_params_t *loc_params1, const char *src_name, void *dst_obj,
+                   const H5VL_loc_params_t *loc_params2, const char *dst_name, hid_t ocpypl_id, hid_t lcpl_id,
+                   hid_t dxpl_id, void **req);
+    herr_t (*get)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_object_get_args_t *args, hid_t dxpl_id,
+                  void **req);
+    herr_t (*specific)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_object_specific_args_t *args,
+                       hid_t dxpl_id, void **req);
+    herr_t (*optional)(void *obj, const H5VL_loc_params_t *loc_params, H5VL_optional_args_t *args,
+                       hid_t dxpl_id, void **req);
+} H5VL_object_class_t;
+
+/* Asynchronous request 'notify' callback */
+typedef herr_t (*H5VL_request_notify_t)(void *ctx, H5VL_request_status_t status);
+
+/* "Levels" for 'get connector class' introspection callback */
+typedef enum H5VL_get_conn_lvl_t {
+    H5VL_GET_CONN_LVL_CURR, /* Get "current" connector (for this object) */
+    H5VL_GET_CONN_LVL_TERM  /* Get "terminal" connector (for this object) */
+                            /* (Recursively called, for pass-through connectors) */
+                            /* (Connectors that "split" must choose which connector to return) */
+} H5VL_get_conn_lvl_t;
+
+/* Forward declaration of H5VL_class_t, defined later in this file */
+struct H5VL_class_t;
+
+/* Container/connector introspection routines */
+typedef struct H5VL_introspect_class_t {
+    herr_t (*get_conn_cls)(void *obj, H5VL_get_conn_lvl_t lvl, const struct H5VL_class_t **conn_cls);
+    herr_t (*get_cap_flags)(const void *info, uint64_t *cap_flags);
+    herr_t (*opt_query)(void *obj, H5VL_subclass_t cls, int opt_type, uint64_t *flags);
+} H5VL_introspect_class_t;
+
+/* Async request operation routines */
+typedef struct H5VL_request_class_t {
+    herr_t (*wait)(void *req, uint64_t timeout, H5VL_request_status_t *status);
+    herr_t (*notify)(void *req, H5VL_request_notify_t cb, void *ctx);
+    herr_t (*cancel)(void *req, H5VL_request_status_t *status);
+    herr_t (*specific)(void *req, H5VL_request_specific_args_t *args);
+    herr_t (*optional)(void *req, H5VL_optional_args_t *args);
+    herr_t (*free)(void *req);
+} H5VL_request_class_t;
+
+/* 'blob' routines */
+typedef struct H5VL_blob_class_t {
+    herr_t (*put)(void *obj, const void *buf, size_t size, void *blob_id, void *ctx);
+    herr_t (*get)(void *obj, const void *blob_id, void *buf, size_t size, void *ctx);
+    herr_t (*specific)(void *obj, void *blob_id, H5VL_blob_specific_args_t *args);
+    herr_t (*optional)(void *obj, void *blob_id, H5VL_optional_args_t *args);
+} H5VL_blob_class_t;
+
+/* Object token routines */
+typedef struct H5VL_token_class_t {
+    herr_t (*cmp)(void *obj, const H5O_token_t *token1, const H5O_token_t *token2, int *cmp_value);
+    herr_t (*to_str)(void *obj, H5I_type_t obj_type, const H5O_token_t *token, char **token_str);
+    herr_t (*from_str)(void *obj, H5I_type_t obj_type, const char *token_str, H5O_token_t *token);
+} H5VL_token_class_t;
+
+/**
+ * \ingroup H5VLDEV
+ * Class information for each VOL connector
+ */
+//! <!-- [H5VL_class_t_snip] -->
+typedef struct H5VL_class_t {
+    /* Overall connector fields & callbacks */
+    unsigned           version;          /**< VOL connector class struct version number */
+    H5VL_class_value_t value;            /**< Value to identify connector               */
+    const char        *name;             /**< Connector name (MUST be unique!)          */
+    unsigned           conn_version;     /**< Version number of connector               */
+    uint64_t           cap_flags;        /**< Capability flags for connector            */
+    herr_t (*initialize)(hid_t vipl_id); /**< Connector initialization callback         */
+    herr_t (*terminate)(void);           /**< Connector termination callback            */
+
+    /* VOL framework */
+    H5VL_info_class_t info_cls; /**< VOL info fields & callbacks  */
+    H5VL_wrap_class_t wrap_cls; /**< VOL object wrap / retrieval callbacks */
+
+    /* Data Model */
+    H5VL_attr_class_t     attr_cls;     /**< Attribute (H5A*) class callbacks */
+    H5VL_dataset_class_t  dataset_cls;  /**< Dataset (H5D*) class callbacks   */
+    H5VL_datatype_class_t datatype_cls; /**< Datatype (H5T*) class callbacks  */
+    H5VL_file_class_t     file_cls;     /**< File (H5F*) class callbacks      */
+    H5VL_group_class_t    group_cls;    /**< Group (H5G*) class callbacks     */
+    H5VL_link_class_t     link_cls;     /**< Link (H5L*) class callbacks      */
+    H5VL_object_class_t   object_cls;   /**< Object (H5O*) class callbacks    */
+
+    /* Infrastructure / Services */
+    H5VL_introspect_class_t introspect_cls; /**< Container/connector introspection class callbacks */
+    H5VL_request_class_t    request_cls;    /**< Asynchronous request class callbacks */
+    H5VL_blob_class_t       blob_cls;       /**< 'Blob' class callbacks */
+    H5VL_token_class_t      token_cls;      /**< VOL connector object token class callbacks */
+
+    /* Catch-all */
+    herr_t (*optional)(void *obj, H5VL_optional_args_t *args, hid_t dxpl_id,
+                       void **req); /**< Optional callback */
+} H5VL_class_t;
+//! <!-- [H5VL_class_t_snip] -->
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Helper routines for VOL connector authors */
+/**
+ * \ingroup H5VLDEV
+ * \brief Registers a new VOL connector
+ *
+ * \param[in] cls A pointer to the plugin structure to register
+ * \vipl_id
+ * \return \hid_t{VOL connector}
+ *
+ * \details H5VLregister_connector() registers a new VOL connector as a member
+ *          of the virtual object layer class. This VOL connector identifier is
+ *          good until the library is closed or the connector is unregistered.
+ *
+ *          \p vipl_id is either #H5P_DEFAULT or the identifier of a VOL
+ *          initialization property list of class #H5P_VOL_INITIALIZE created
+ *          with H5Pcreate(). When created, this property list contains no
+ *          library properties. If a VOL connector author decides that
+ *          initialization-specific data are needed, they can be added to the
+ *          empty list and retrieved by the connector in the VOL connector's
+ *          initialize callback. Use of the VOL initialization property list is
+ *          uncommon, as most VOL-specific properties are added to the file
+ *          access property list via the connector's API calls which set the
+ *          VOL connector for the file open/create. For more information, see
+ *          the \ref_vol_doc.
+ *
+ *          H5VL_class_t is defined in H5VLconnector.h in the source code. It
+ *          contains class information for each VOL connector:
+ *          \snippet this H5VL_class_t_snip
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL hid_t H5VLregister_connector(const H5VL_class_t *cls, hid_t vipl_id);
+/**
+ * \ingroup H5VLDEV
+ */
+H5_DLL void *H5VLobject(hid_t obj_id);
+/**
+ * \ingroup H5VLDEV
+ */
+H5_DLL hid_t H5VLget_file_type(void *file_obj, hid_t connector_id, hid_t dtype_id);
+/**
+ * \ingroup H5VLDEV
+ */
+H5_DLL hid_t H5VLpeek_connector_id_by_name(const char *name);
+/**
+ * \ingroup H5VLDEV
+ */
+H5_DLL hid_t H5VLpeek_connector_id_by_value(H5VL_class_value_t value);
+
+/* User-defined optional operations */
+H5_DLL herr_t H5VLregister_opt_operation(H5VL_subclass_t subcls, const char *op_name, int *op_val);
+H5_DLL herr_t H5VLfind_opt_operation(H5VL_subclass_t subcls, const char *op_name, int *op_val);
+H5_DLL herr_t H5VLunregister_opt_operation(H5VL_subclass_t subcls, const char *op_name);
+H5_DLL herr_t H5VLattr_optional_op(const char *app_file, const char *app_func, unsigned app_line,
+                                   hid_t attr_id, H5VL_optional_args_t *args, hid_t dxpl_id, hid_t es_id);
+H5_DLL herr_t H5VLdataset_optional_op(const char *app_file, const char *app_func, unsigned app_line,
+                                      hid_t dset_id, H5VL_optional_args_t *args, hid_t dxpl_id, hid_t es_id);
+H5_DLL herr_t H5VLdatatype_optional_op(const char *app_file, const char *app_func, unsigned app_line,
+                                       hid_t type_id, H5VL_optional_args_t *args, hid_t dxpl_id, hid_t es_id);
+H5_DLL herr_t H5VLfile_optional_op(const char *app_file, const char *app_func, unsigned app_line,
+                                   hid_t file_id, H5VL_optional_args_t *args, hid_t dxpl_id, hid_t es_id);
+H5_DLL herr_t H5VLgroup_optional_op(const char *app_file, const char *app_func, unsigned app_line,
+                                    hid_t group_id, H5VL_optional_args_t *args, hid_t dxpl_id, hid_t es_id);
+H5_DLL herr_t H5VLlink_optional_op(const char *app_file, const char *app_func, unsigned app_line,
+                                   hid_t loc_id, const char *name, hid_t lapl_id, H5VL_optional_args_t *args,
+                                   hid_t dxpl_id, hid_t es_id);
+H5_DLL herr_t H5VLobject_optional_op(const char *app_file, const char *app_func, unsigned app_line,
+                                     hid_t loc_id, const char *name, hid_t lapl_id,
+                                     H5VL_optional_args_t *args, hid_t dxpl_id, hid_t es_id);
+H5_DLL herr_t H5VLrequest_optional_op(void *req, hid_t connector_id, H5VL_optional_args_t *args);
+
+/* API Wrappers for "optional_op" routines */
+/* (Must be defined _after_ the function prototype) */
+/* (And must only defined when included in application code, not the library) */
+#ifndef H5VL_MODULE
+/* Inject application compile-time macros into function calls */
+#define H5VLattr_optional_op(...)     H5VLattr_optional_op(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5VLdataset_optional_op(...)  H5VLdataset_optional_op(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5VLdatatype_optional_op(...) H5VLdatatype_optional_op(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5VLfile_optional_op(...)     H5VLfile_optional_op(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5VLgroup_optional_op(...)    H5VLgroup_optional_op(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5VLlink_optional_op(...)     H5VLlink_optional_op(__FILE__, __func__, __LINE__, __VA_ARGS__)
+#define H5VLobject_optional_op(...)   H5VLobject_optional_op(__FILE__, __func__, __LINE__, __VA_ARGS__)
+
+/* Define "wrapper" versions of function calls, to allow compile-time values to
+ *      be passed in by language wrapper or library layer on top of HDF5.
+ */
+#define H5VLattr_optional_op_wrap     H5_NO_EXPAND(H5VLattr_optional_op)
+#define H5VLdataset_optional_op_wrap  H5_NO_EXPAND(H5VLdataset_optional_op)
+#define H5VLdatatype_optional_op_wrap H5_NO_EXPAND(H5VLdatatype_optional_op)
+#define H5VLfile_optional_op_wrap     H5_NO_EXPAND(H5VLfile_optional_op)
+#define H5VLgroup_optional_op_wrap    H5_NO_EXPAND(H5VLgroup_optional_op)
+#define H5VLlink_optional_op_wrap     H5_NO_EXPAND(H5VLlink_optional_op)
+#define H5VLobject_optional_op_wrap   H5_NO_EXPAND(H5VLobject_optional_op)
+#endif /* H5VL_MODULE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5VLconnector_H */
diff --git a/install/include/H5VLconnector_passthru.h b/install/include/H5VLconnector_passthru.h
new file mode 100644
index 0000000000..d10bac4697
--- /dev/null
+++ b/install/include/H5VLconnector_passthru.h
@@ -0,0 +1,258 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for authoring VOL connectors
+ * which act as "passthrough" connectors that forward their API calls to
+ * an underlying connector.
+ *
+ * An example of this might be a logging connector, which creates log messages
+ * and then passes the call on to an underlying VOL connector.
+ *
+ * The functionality required to implement such a connector is specialized
+ * and non-trivial so it has been split into this header in an effort to keep
+ * the H5VLconnector.h header easier to understand.
+ */
+
+#ifndef H5VLconnector_passthru_H
+#define H5VLconnector_passthru_H
+
+/* Public headers needed by this file */
+#include "H5public.h"   /* Generic Functions                    */
+#include "H5Ipublic.h"  /* IDs                                  */
+#include "H5VLpublic.h" /* Virtual Object Layer                 */
+
+/* Semi-public headers mainly for VOL connector authors */
+#include "H5VLconnector.h"
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Helper routines for VOL connector authors */
+H5_DLL herr_t H5VLcmp_connector_cls(int *cmp, hid_t connector_id1, hid_t connector_id2);
+/**
+ * \ingroup H5VL
+ *
+ * \brief Wrap an internal object with a "wrap context" and register an
+ *        hid_t for the resulting object.
+ *
+ * \param[in] obj  VOL object.
+ * \param[in] type VOL-managed object class. Allowable values are:
+ *                 - #H5I_FILE
+ *                 - #H5I_GROUP
+ *                 - #H5I_DATATYPE
+ *                 - #H5I_DATASET
+ *                 - #H5I_MAP
+ *                 - #H5I_ATTR
+ *
+ * \return \hid_t{VOL connector}
+ *
+ * \note This routine is mainly targeted toward wrapping objects for
+ *       iteration routine callbacks (i.e. the callbacks from H5Aiterate*,
+ *       H5Literate* / H5Lvisit*, and H5Ovisit* ). Using it in an application
+ *       will return an error indicating the API context isn't available or
+ *       can't be retrieved.
+ *
+ */
+H5_DLL hid_t  H5VLwrap_register(void *obj, H5I_type_t type);
+H5_DLL herr_t H5VLretrieve_lib_state(void **state);
+H5_DLL herr_t H5VLstart_lib_state(void);
+H5_DLL herr_t H5VLrestore_lib_state(const void *state);
+H5_DLL herr_t H5VLfinish_lib_state(void);
+H5_DLL herr_t H5VLfree_lib_state(void *state);
+
+/* Pass-through callbacks */
+H5_DLL void  *H5VLget_object(void *obj, hid_t connector_id);
+H5_DLL herr_t H5VLget_wrap_ctx(void *obj, hid_t connector_id, void **wrap_ctx);
+H5_DLL void  *H5VLwrap_object(void *obj, H5I_type_t obj_type, hid_t connector_id, void *wrap_ctx);
+H5_DLL void  *H5VLunwrap_object(void *obj, hid_t connector_id);
+H5_DLL herr_t H5VLfree_wrap_ctx(void *wrap_ctx, hid_t connector_id);
+
+/* Public wrappers for generic callbacks */
+H5_DLL herr_t H5VLinitialize(hid_t connector_id, hid_t vipl_id);
+H5_DLL herr_t H5VLterminate(hid_t connector_id);
+H5_DLL herr_t H5VLget_cap_flags(hid_t connector_id, uint64_t *cap_flags);
+H5_DLL herr_t H5VLget_value(hid_t connector_id, H5VL_class_value_t *conn_value);
+
+/* Public wrappers for info fields and callbacks */
+H5_DLL herr_t H5VLcopy_connector_info(hid_t connector_id, void **dst_vol_info, void *src_vol_info);
+H5_DLL herr_t H5VLcmp_connector_info(int *cmp, hid_t connector_id, const void *info1, const void *info2);
+H5_DLL herr_t H5VLfree_connector_info(hid_t connector_id, void *vol_info);
+H5_DLL herr_t H5VLconnector_info_to_str(const void *info, hid_t connector_id, char **str);
+H5_DLL herr_t H5VLconnector_str_to_info(const char *str, hid_t connector_id, void **info);
+
+/* Public wrappers for attribute callbacks */
+H5_DLL void  *H5VLattr_create(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                              const char *attr_name, hid_t type_id, hid_t space_id, hid_t acpl_id,
+                              hid_t aapl_id, hid_t dxpl_id, void **req);
+H5_DLL void  *H5VLattr_open(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                            const char *name, hid_t aapl_id, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLattr_read(void *attr, hid_t connector_id, hid_t dtype_id, void *buf, hid_t dxpl_id,
+                            void **req);
+H5_DLL herr_t H5VLattr_write(void *attr, hid_t connector_id, hid_t dtype_id, const void *buf, hid_t dxpl_id,
+                             void **req);
+H5_DLL herr_t H5VLattr_get(void *obj, hid_t connector_id, H5VL_attr_get_args_t *args, hid_t dxpl_id,
+                           void **req);
+H5_DLL herr_t H5VLattr_specific(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                                H5VL_attr_specific_args_t *args, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLattr_optional(void *obj, hid_t connector_id, H5VL_optional_args_t *args, hid_t dxpl_id,
+                                void **req);
+H5_DLL herr_t H5VLattr_close(void *attr, hid_t connector_id, hid_t dxpl_id, void **req);
+
+/* Public wrappers for dataset callbacks */
+H5_DLL void  *H5VLdataset_create(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                                 const char *name, hid_t lcpl_id, hid_t type_id, hid_t space_id, hid_t dcpl_id,
+                                 hid_t dapl_id, hid_t dxpl_id, void **req);
+H5_DLL void  *H5VLdataset_open(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                               const char *name, hid_t dapl_id, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLdataset_read(size_t count, void *dset[], hid_t connector_id, hid_t mem_type_id[],
+                               hid_t mem_space_id[], hid_t file_space_id[], hid_t plist_id, void *buf[],
+                               void **req);
+H5_DLL herr_t H5VLdataset_write(size_t count, void *dset[], hid_t connector_id, hid_t mem_type_id[],
+                                hid_t mem_space_id[], hid_t file_space_id[], hid_t plist_id,
+                                const void *buf[], void **req);
+H5_DLL herr_t H5VLdataset_get(void *dset, hid_t connector_id, H5VL_dataset_get_args_t *args, hid_t dxpl_id,
+                              void **req);
+H5_DLL herr_t H5VLdataset_specific(void *obj, hid_t connector_id, H5VL_dataset_specific_args_t *args,
+                                   hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLdataset_optional(void *obj, hid_t connector_id, H5VL_optional_args_t *args, hid_t dxpl_id,
+                                   void **req);
+H5_DLL herr_t H5VLdataset_close(void *dset, hid_t connector_id, hid_t dxpl_id, void **req);
+
+/* Public wrappers for named datatype callbacks */
+H5_DLL void  *H5VLdatatype_commit(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                                  const char *name, hid_t type_id, hid_t lcpl_id, hid_t tcpl_id, hid_t tapl_id,
+                                  hid_t dxpl_id, void **req);
+H5_DLL void  *H5VLdatatype_open(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                                const char *name, hid_t tapl_id, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLdatatype_get(void *dt, hid_t connector_id, H5VL_datatype_get_args_t *args, hid_t dxpl_id,
+                               void **req);
+H5_DLL herr_t H5VLdatatype_specific(void *obj, hid_t connector_id, H5VL_datatype_specific_args_t *args,
+                                    hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLdatatype_optional(void *obj, hid_t connector_id, H5VL_optional_args_t *args, hid_t dxpl_id,
+                                    void **req);
+H5_DLL herr_t H5VLdatatype_close(void *dt, hid_t connector_id, hid_t dxpl_id, void **req);
+
+/* Public wrappers for file callbacks */
+H5_DLL void  *H5VLfile_create(const char *name, unsigned flags, hid_t fcpl_id, hid_t fapl_id, hid_t dxpl_id,
+                              void **req);
+H5_DLL void  *H5VLfile_open(const char *name, unsigned flags, hid_t fapl_id, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLfile_get(void *file, hid_t connector_id, H5VL_file_get_args_t *args, hid_t dxpl_id,
+                           void **req);
+H5_DLL herr_t H5VLfile_specific(void *obj, hid_t connector_id, H5VL_file_specific_args_t *args, hid_t dxpl_id,
+                                void **req);
+H5_DLL herr_t H5VLfile_optional(void *obj, hid_t connector_id, H5VL_optional_args_t *args, hid_t dxpl_id,
+                                void **req);
+H5_DLL herr_t H5VLfile_close(void *file, hid_t connector_id, hid_t dxpl_id, void **req);
+
+/* Public wrappers for group callbacks */
+H5_DLL void  *H5VLgroup_create(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                               const char *name, hid_t lcpl_id, hid_t gcpl_id, hid_t gapl_id, hid_t dxpl_id,
+                               void **req);
+H5_DLL void  *H5VLgroup_open(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                             const char *name, hid_t gapl_id, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLgroup_get(void *obj, hid_t connector_id, H5VL_group_get_args_t *args, hid_t dxpl_id,
+                            void **req);
+H5_DLL herr_t H5VLgroup_specific(void *obj, hid_t connector_id, H5VL_group_specific_args_t *args,
+                                 hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLgroup_optional(void *obj, hid_t connector_id, H5VL_optional_args_t *args, hid_t dxpl_id,
+                                 void **req);
+H5_DLL herr_t H5VLgroup_close(void *grp, hid_t connector_id, hid_t dxpl_id, void **req);
+
+/* Public wrappers for link callbacks */
+H5_DLL herr_t H5VLlink_create(H5VL_link_create_args_t *args, void *obj, const H5VL_loc_params_t *loc_params,
+                              hid_t connector_id, hid_t lcpl_id, hid_t lapl_id, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLlink_copy(void *src_obj, const H5VL_loc_params_t *loc_params1, void *dst_obj,
+                            const H5VL_loc_params_t *loc_params2, hid_t connector_id, hid_t lcpl_id,
+                            hid_t lapl_id, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLlink_move(void *src_obj, const H5VL_loc_params_t *loc_params1, void *dst_obj,
+                            const H5VL_loc_params_t *loc_params2, hid_t connector_id, hid_t lcpl_id,
+                            hid_t lapl_id, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLlink_get(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                           H5VL_link_get_args_t *args, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLlink_specific(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                                H5VL_link_specific_args_t *args, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLlink_optional(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                                H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
+
+/* Public wrappers for object callbacks */
+H5_DLL void  *H5VLobject_open(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                              H5I_type_t *opened_type, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLobject_copy(void *src_obj, const H5VL_loc_params_t *loc_params1, const char *src_name,
+                              void *dst_obj, const H5VL_loc_params_t *loc_params2, const char *dst_name,
+                              hid_t connector_id, hid_t ocpypl_id, hid_t lcpl_id, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLobject_get(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                             H5VL_object_get_args_t *args, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLobject_specific(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                                  H5VL_object_specific_args_t *args, hid_t dxpl_id, void **req);
+H5_DLL herr_t H5VLobject_optional(void *obj, const H5VL_loc_params_t *loc_params, hid_t connector_id,
+                                  H5VL_optional_args_t *args, hid_t dxpl_id, void **req);
+
+/* Public wrappers for connector/container introspection callbacks */
+H5_DLL herr_t H5VLintrospect_get_conn_cls(void *obj, hid_t connector_id, H5VL_get_conn_lvl_t lvl,
+                                          const H5VL_class_t **conn_cls);
+H5_DLL herr_t H5VLintrospect_get_cap_flags(const void *info, hid_t connector_id, uint64_t *cap_flags);
+H5_DLL herr_t H5VLintrospect_opt_query(void *obj, hid_t connector_id, H5VL_subclass_t subcls, int opt_type,
+                                       uint64_t *flags);
+
+/* Public wrappers for asynchronous request callbacks */
+H5_DLL herr_t H5VLrequest_wait(void *req, hid_t connector_id, uint64_t timeout,
+                               H5VL_request_status_t *status);
+H5_DLL herr_t H5VLrequest_notify(void *req, hid_t connector_id, H5VL_request_notify_t cb, void *ctx);
+H5_DLL herr_t H5VLrequest_cancel(void *req, hid_t connector_id, H5VL_request_status_t *status);
+H5_DLL herr_t H5VLrequest_specific(void *req, hid_t connector_id, H5VL_request_specific_args_t *args);
+H5_DLL herr_t H5VLrequest_optional(void *req, hid_t connector_id, H5VL_optional_args_t *args);
+H5_DLL herr_t H5VLrequest_free(void *req, hid_t connector_id);
+
+/* Public wrappers for blob callbacks */
+H5_DLL herr_t H5VLblob_put(void *obj, hid_t connector_id, const void *buf, size_t size, void *blob_id,
+                           void *ctx);
+H5_DLL herr_t H5VLblob_get(void *obj, hid_t connector_id, const void *blob_id, void *buf, size_t size,
+                           void *ctx);
+H5_DLL herr_t H5VLblob_specific(void *obj, hid_t connector_id, void *blob_id,
+                                H5VL_blob_specific_args_t *args);
+H5_DLL herr_t H5VLblob_optional(void *obj, hid_t connector_id, void *blob_id, H5VL_optional_args_t *args);
+
+/* Public wrappers for token callbacks */
+H5_DLL herr_t H5VLtoken_cmp(void *obj, hid_t connector_id, const H5O_token_t *token1,
+                            const H5O_token_t *token2, int *cmp_value);
+H5_DLL herr_t H5VLtoken_to_str(void *obj, H5I_type_t obj_type, hid_t connector_id, const H5O_token_t *token,
+                               char **token_str);
+H5_DLL herr_t H5VLtoken_from_str(void *obj, H5I_type_t obj_type, hid_t connector_id, const char *token_str,
+                                 H5O_token_t *token);
+
+/* Public wrappers for generic 'optional' callback */
+H5_DLL herr_t H5VLoptional(void *obj, hid_t connector_id, H5VL_optional_args_t *args, hid_t dxpl_id,
+                           void **req);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5VLconnector_passthru_H */
diff --git a/install/include/H5VLnative.h b/install/include/H5VLnative.h
new file mode 100644
index 0000000000..6eaefb63b9
--- /dev/null
+++ b/install/include/H5VLnative.h
@@ -0,0 +1,534 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the native VOL connector.
+ */
+
+#ifndef H5VLnative_H
+#define H5VLnative_H
+
+/* Public headers needed by this file */
+#include "H5Apublic.h"  /* Attributes                           */
+#include "H5VLpublic.h" /* Virtual Object Layer                 */
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/* Identifier for the native VOL connector */
+#define H5VL_NATIVE (H5VL_native_register())
+
+/* Characteristics of the native VOL connector */
+#define H5VL_NATIVE_NAME    "native"
+#define H5VL_NATIVE_VALUE   H5_VOL_NATIVE /* enum value */
+#define H5VL_NATIVE_VERSION 0
+
+/* Values for VOL connector attribute optional VOL operations */
+/* NOTE: If new values are added here, the H5VL__native_introspect_opt_query
+ *      routine must be updated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+#define H5VL_NATIVE_ATTR_ITERATE_OLD 0 /* H5Aiterate (deprecated routine) */
+#endif                                 /* H5_NO_DEPRECATED_SYMBOLS */
+/* NOTE: If values over 1023 are added, the H5VL_RESERVED_NATIVE_OPTIONAL macro
+ *      must be updated.
+ */
+
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+/* Parameters for attribute 'iterate old' operation */
+typedef struct H5VL_native_attr_iterate_old_t {
+    hid_t           loc_id;
+    unsigned       *attr_num;
+    H5A_operator1_t op;
+    void           *op_data;
+} H5VL_native_attr_iterate_old_t;
+
+/* Parameters for native connector's attribute 'optional' operations */
+typedef union H5VL_native_attr_optional_args_t {
+    /* H5VL_NATIVE_ATTR_ITERATE_OLD */
+    H5VL_native_attr_iterate_old_t iterate_old;
+} H5VL_native_attr_optional_args_t;
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+/* Values for native VOL connector dataset optional VOL operations */
+/* NOTE: If new values are added here, the H5VL__native_introspect_opt_query
+ *      routine must be updated.
+ */
+#define H5VL_NATIVE_DATASET_FORMAT_CONVERT          0  /* H5Dformat_convert (internal) */
+#define H5VL_NATIVE_DATASET_GET_CHUNK_INDEX_TYPE    1  /* H5Dget_chunk_index_type      */
+#define H5VL_NATIVE_DATASET_GET_CHUNK_STORAGE_SIZE  2  /* H5Dget_chunk_storage_size    */
+#define H5VL_NATIVE_DATASET_GET_NUM_CHUNKS          3  /* H5Dget_num_chunks            */
+#define H5VL_NATIVE_DATASET_GET_CHUNK_INFO_BY_IDX   4  /* H5Dget_chunk_info            */
+#define H5VL_NATIVE_DATASET_GET_CHUNK_INFO_BY_COORD 5  /* H5Dget_chunk_info_by_coord   */
+#define H5VL_NATIVE_DATASET_CHUNK_READ              6  /* H5Dchunk_read                */
+#define H5VL_NATIVE_DATASET_CHUNK_WRITE             7  /* H5Dchunk_write               */
+#define H5VL_NATIVE_DATASET_GET_VLEN_BUF_SIZE       8  /* H5Dvlen_get_buf_size         */
+#define H5VL_NATIVE_DATASET_GET_OFFSET              9  /* H5Dget_offset                */
+#define H5VL_NATIVE_DATASET_CHUNK_ITER              10 /* H5Dchunk_iter                */
+/* NOTE: If values over 1023 are added, the H5VL_RESERVED_NATIVE_OPTIONAL macro
+ *      must be updated.
+ */
+
+/* Parameters for native connector's dataset 'chunk read' operation */
+typedef struct H5VL_native_dataset_chunk_read_t {
+    const hsize_t *offset;
+    uint32_t       filters;
+    void          *buf;
+} H5VL_native_dataset_chunk_read_t;
+
+/* Parameters for native connector's dataset 'chunk write' operation */
+typedef struct H5VL_native_dataset_chunk_write_t {
+    const hsize_t *offset;
+    uint32_t       filters;
+    uint32_t       size;
+    const void    *buf;
+} H5VL_native_dataset_chunk_write_t;
+
+/* Parameters for native connector's dataset 'get vlen buf size' operation */
+typedef struct H5VL_native_dataset_get_vlen_buf_size_t {
+    hid_t    type_id;
+    hid_t    space_id;
+    hsize_t *size; /* Size of variable-length data buffer (OUT) */
+} H5VL_native_dataset_get_vlen_buf_size_t;
+
+/* Parameters for native connector's dataset 'get chunk storage size' operation */
+typedef struct H5VL_native_dataset_get_chunk_storage_size_t {
+    const hsize_t *offset; /* Offset of chunk */
+    hsize_t       *size;   /* Size of chunk (OUT) */
+} H5VL_native_dataset_get_chunk_storage_size_t;
+
+/* Parameters for native connector's dataset 'get num chunks' operation */
+typedef struct H5VL_native_dataset_get_num_chunks_t {
+    hid_t    space_id; /* Space selection */
+    hsize_t *nchunks;  /* # of chunk for space selection (OUT) */
+} H5VL_native_dataset_get_num_chunks_t;
+
+/* Parameters for native connector's dataset 'get chunk info by idx' operation */
+typedef struct H5VL_native_dataset_get_chunk_info_by_idx_t {
+    hid_t     space_id;    /* Space selection */
+    hsize_t   chk_index;   /* Chunk index within space */
+    hsize_t  *offset;      /* Chunk coordinates (OUT) */
+    unsigned *filter_mask; /* Filter mask for chunk (OUT) */
+    haddr_t  *addr;        /* Address of chunk in file (OUT) */
+    hsize_t  *size;        /* Size of chunk in file (OUT) */
+} H5VL_native_dataset_get_chunk_info_by_idx_t;
+
+/* Parameters for native connector's dataset 'get chunk info by coord' operation */
+typedef struct H5VL_native_dataset_get_chunk_info_by_coord_t {
+    const hsize_t *offset;      /* Chunk coordinates */
+    unsigned      *filter_mask; /* Filter mask for chunk (OUT) */
+    haddr_t       *addr;        /* Address of chunk in file (OUT) */
+    hsize_t       *size;        /* Size of chunk in file (OUT) */
+} H5VL_native_dataset_get_chunk_info_by_coord_t;
+
+/* Parameters for native connector's dataset 'optional' operations */
+typedef union H5VL_native_dataset_optional_args_t {
+    /* H5VL_NATIVE_DATASET_FORMAT_CONVERT */
+    /* No args */
+
+    /* H5VL_NATIVE_DATASET_GET_CHUNK_INDEX_TYPE */
+    struct {
+        H5D_chunk_index_t *idx_type; /* Type of chunk index (OUT) */
+    } get_chunk_idx_type;
+
+    /* H5VL_NATIVE_DATASET_GET_CHUNK_STORAGE_SIZE */
+    H5VL_native_dataset_get_chunk_storage_size_t get_chunk_storage_size;
+
+    /* H5VL_NATIVE_DATASET_GET_NUM_CHUNKS */
+    H5VL_native_dataset_get_num_chunks_t get_num_chunks;
+
+    /* H5VL_NATIVE_DATASET_GET_CHUNK_INFO_BY_IDX */
+    H5VL_native_dataset_get_chunk_info_by_idx_t get_chunk_info_by_idx;
+
+    /* H5VL_NATIVE_DATASET_GET_CHUNK_INFO_BY_COORD */
+    H5VL_native_dataset_get_chunk_info_by_coord_t get_chunk_info_by_coord;
+
+    /* H5VL_NATIVE_DATASET_CHUNK_READ */
+    H5VL_native_dataset_chunk_read_t chunk_read;
+
+    /* H5VL_NATIVE_DATASET_CHUNK_WRITE */
+    H5VL_native_dataset_chunk_write_t chunk_write;
+
+    /* H5VL_NATIVE_DATASET_GET_VLEN_BUF_SIZE */
+    H5VL_native_dataset_get_vlen_buf_size_t get_vlen_buf_size;
+
+    /* H5VL_NATIVE_DATASET_GET_OFFSET */
+    struct {
+        haddr_t *offset; /* Contiguous dataset's offset in the file (OUT) */
+    } get_offset;
+
+    /* H5VL_NATIVE_DATASET_CHUNK_ITER */
+    struct {
+        H5D_chunk_iter_op_t op;      /* Chunk iteration callback */
+        void               *op_data; /* Context to pass to iteration callback */
+    } chunk_iter;
+
+} H5VL_native_dataset_optional_args_t;
+
+/* Values for native VOL connector file optional VOL operations */
+/* NOTE: If new values are added here, the H5VL__native_introspect_opt_query
+ *      routine must be updated.
+ */
+#define H5VL_NATIVE_FILE_CLEAR_ELINK_CACHE            0  /* H5Fclear_elink_file_cache            */
+#define H5VL_NATIVE_FILE_GET_FILE_IMAGE               1  /* H5Fget_file_image                    */
+#define H5VL_NATIVE_FILE_GET_FREE_SECTIONS            2  /* H5Fget_free_sections                 */
+#define H5VL_NATIVE_FILE_GET_FREE_SPACE               3  /* H5Fget_freespace                     */
+#define H5VL_NATIVE_FILE_GET_INFO                     4  /* H5Fget_info1/2                       */
+#define H5VL_NATIVE_FILE_GET_MDC_CONF                 5  /* H5Fget_mdc_config                    */
+#define H5VL_NATIVE_FILE_GET_MDC_HR                   6  /* H5Fget_mdc_hit_rate                  */
+#define H5VL_NATIVE_FILE_GET_MDC_SIZE                 7  /* H5Fget_mdc_size                      */
+#define H5VL_NATIVE_FILE_GET_SIZE                     8  /* H5Fget_filesize                      */
+#define H5VL_NATIVE_FILE_GET_VFD_HANDLE               9  /* H5Fget_vfd_handle                    */
+#define H5VL_NATIVE_FILE_RESET_MDC_HIT_RATE           10 /* H5Freset_mdc_hit_rate_stats          */
+#define H5VL_NATIVE_FILE_SET_MDC_CONFIG               11 /* H5Fset_mdc_config                    */
+#define H5VL_NATIVE_FILE_GET_METADATA_READ_RETRY_INFO 12 /* H5Fget_metadata_read_retry_info      */
+#define H5VL_NATIVE_FILE_START_SWMR_WRITE             13 /* H5Fstart_swmr_write                  */
+#define H5VL_NATIVE_FILE_START_MDC_LOGGING            14 /* H5Fstart_mdc_logging                 */
+#define H5VL_NATIVE_FILE_STOP_MDC_LOGGING             15 /* H5Fstop_mdc_logging                  */
+#define H5VL_NATIVE_FILE_GET_MDC_LOGGING_STATUS       16 /* H5Fget_mdc_logging_status            */
+#define H5VL_NATIVE_FILE_FORMAT_CONVERT               17 /* H5Fformat_convert                    */
+#define H5VL_NATIVE_FILE_RESET_PAGE_BUFFERING_STATS   18 /* H5Freset_page_buffering_stats        */
+#define H5VL_NATIVE_FILE_GET_PAGE_BUFFERING_STATS     19 /* H5Fget_page_buffering_stats          */
+#define H5VL_NATIVE_FILE_GET_MDC_IMAGE_INFO           20 /* H5Fget_mdc_image_info                */
+#define H5VL_NATIVE_FILE_GET_EOA                      21 /* H5Fget_eoa                           */
+#define H5VL_NATIVE_FILE_INCR_FILESIZE                22 /* H5Fincrement_filesize                */
+#define H5VL_NATIVE_FILE_SET_LIBVER_BOUNDS            23 /* H5Fset_latest_format/libver_bounds   */
+#define H5VL_NATIVE_FILE_GET_MIN_DSET_OHDR_FLAG       24 /* H5Fget_dset_no_attrs_hint            */
+#define H5VL_NATIVE_FILE_SET_MIN_DSET_OHDR_FLAG       25 /* H5Fset_dset_no_attrs_hint            */
+#ifdef H5_HAVE_PARALLEL
+#define H5VL_NATIVE_FILE_GET_MPI_ATOMICITY 26 /* H5Fget_mpi_atomicity                 */
+#define H5VL_NATIVE_FILE_SET_MPI_ATOMICITY 27 /* H5Fset_mpi_atomicity                 */
+#endif
+#define H5VL_NATIVE_FILE_POST_OPEN 28 /* Adjust file after open, with wrapping context */
+/* NOTE: If values over 1023 are added, the H5VL_RESERVED_NATIVE_OPTIONAL macro
+ *      must be updated.
+ */
+
+/* Parameters for native connector's file 'get file image' operation */
+typedef struct H5VL_native_file_get_file_image_t {
+    size_t  buf_size;  /* Size of file image buffer */
+    void   *buf;       /* Buffer for file image (OUT) */
+    size_t *image_len; /* Size of file image (OUT) */
+} H5VL_native_file_get_file_image_t;
+
+/* Parameters for native connector's file 'get free sections' operation */
+typedef struct H5VL_native_file_get_free_sections_t {
+    H5F_mem_t        type;       /* Type of file memory to query */
+    H5F_sect_info_t *sect_info;  /* Array of sections (OUT) */
+    size_t           nsects;     /* Size of section array */
+    size_t          *sect_count; /* Actual # of sections of type (OUT) */
+} H5VL_native_file_get_free_sections_t;
+
+/* Parameters for native connector's file 'get freespace' operation */
+typedef struct H5VL_native_file_get_freespace_t {
+    hsize_t *size; /* Size of free space (OUT) */
+} H5VL_native_file_get_freespace_t;
+
+/* Parameters for native connector's file 'get info' operation */
+typedef struct H5VL_native_file_get_info_t {
+    H5I_type_t   type;  /* Type of object */
+    H5F_info2_t *finfo; /* Pointer to file info (OUT) */
+} H5VL_native_file_get_info_t;
+
+/* Parameters for native connector's file 'get metadata cache size' operation */
+typedef struct H5VL_native_file_get_mdc_size_t {
+    size_t   *max_size;        /* Maximum amount of cached data (OUT) */
+    size_t   *min_clean_size;  /* Minimum amount of cached data to keep clean (OUT) */
+    size_t   *cur_size;        /* Current amount of cached data (OUT) */
+    uint32_t *cur_num_entries; /* Current # of cached entries (OUT) */
+} H5VL_native_file_get_mdc_size_t;
+
+/* Parameters for native connector's file 'get VFD handle' operation */
+typedef struct H5VL_native_file_get_vfd_handle_t {
+    hid_t  fapl_id;
+    void **file_handle; /* File handle from VFD (OUT) */
+} H5VL_native_file_get_vfd_handle_t;
+
+/* Parameters for native connector's file 'get MDC logging status' operation */
+typedef struct H5VL_native_file_get_mdc_logging_status_t {
+    hbool_t *is_enabled;           /* Whether logging is enabled (OUT) */
+    hbool_t *is_currently_logging; /* Whether currently logging (OUT) */
+} H5VL_native_file_get_mdc_logging_status_t;
+
+/* Parameters for native connector's file 'get page buffering stats' operation */
+typedef struct H5VL_native_file_get_page_buffering_stats_t {
+    unsigned *accesses;  /* Metadata/raw data page access counts (OUT) */
+    unsigned *hits;      /* Metadata/raw data page hit counts (OUT) */
+    unsigned *misses;    /* Metadata/raw data page miss counts (OUT) */
+    unsigned *evictions; /* Metadata/raw data page eviction counts (OUT) */
+    unsigned *bypasses;  /* Metadata/raw data page bypass counts (OUT) */
+} H5VL_native_file_get_page_buffering_stats_t;
+
+/* Parameters for native connector's file 'get MDC image info' operation */
+typedef struct H5VL_native_file_get_mdc_image_info_t {
+    haddr_t *addr; /* Address of image (OUT) */
+    hsize_t *len;  /* Length of image (OUT) */
+} H5VL_native_file_get_mdc_image_info_t;
+
+/* Parameters for native connector's file 'set libver bounds' operation */
+typedef struct H5VL_native_file_set_libver_bounds_t {
+    H5F_libver_t low;  /* Lowest version possible */
+    H5F_libver_t high; /* Highest version possible */
+} H5VL_native_file_set_libver_bounds_t;
+
+/* Parameters for native connector's file 'optional' operations */
+typedef union H5VL_native_file_optional_args_t {
+    /* H5VL_NATIVE_FILE_CLEAR_ELINK_CACHE */
+    /* No args */
+
+    /* H5VL_NATIVE_FILE_GET_FILE_IMAGE */
+    H5VL_native_file_get_file_image_t get_file_image;
+
+    /* H5VL_NATIVE_FILE_GET_FREE_SECTIONS */
+    H5VL_native_file_get_free_sections_t get_free_sections;
+
+    /* H5VL_NATIVE_FILE_GET_FREE_SPACE */
+    H5VL_native_file_get_freespace_t get_freespace;
+
+    /* H5VL_NATIVE_FILE_GET_INFO */
+    H5VL_native_file_get_info_t get_info;
+
+    /* H5VL_NATIVE_FILE_GET_MDC_CONF */
+    struct {
+        H5AC_cache_config_t *config; /* Pointer to MDC config (OUT) */
+    } get_mdc_config;
+
+    /* H5VL_NATIVE_FILE_GET_MDC_HR */
+    struct {
+        double *hit_rate; /* Metadata cache hit rate (OUT) */
+    } get_mdc_hit_rate;
+
+    /* H5VL_NATIVE_FILE_GET_MDC_SIZE */
+    H5VL_native_file_get_mdc_size_t get_mdc_size;
+
+    /* H5VL_NATIVE_FILE_GET_SIZE */
+    struct {
+        hsize_t *size; /* Size of file (OUT) */
+    } get_size;
+
+    /* H5VL_NATIVE_FILE_GET_VFD_HANDLE */
+    H5VL_native_file_get_vfd_handle_t get_vfd_handle;
+
+    /* H5VL_NATIVE_FILE_RESET_MDC_HIT_RATE */
+    /* No args */
+
+    /* H5VL_NATIVE_FILE_SET_MDC_CONFIG */
+    struct {
+        const H5AC_cache_config_t *config; /* Pointer to new MDC config */
+    } set_mdc_config;
+
+    /* H5VL_NATIVE_FILE_GET_METADATA_READ_RETRY_INFO */
+    struct {
+        H5F_retry_info_t *info; /* Pointer to metadata read retry info (OUT) */
+    } get_metadata_read_retry_info;
+
+    /* H5VL_NATIVE_FILE_START_SWMR_WRITE */
+    /* No args */
+
+    /* H5VL_NATIVE_FILE_START_MDC_LOGGING */
+    /* No args */
+
+    /* H5VL_NATIVE_FILE_STOP_MDC_LOGGING */
+    /* No args */
+
+    /* H5VL_NATIVE_FILE_GET_MDC_LOGGING_STATUS */
+    H5VL_native_file_get_mdc_logging_status_t get_mdc_logging_status;
+
+    /* H5VL_NATIVE_FILE_FORMAT_CONVERT */
+    /* No args */
+
+    /* H5VL_NATIVE_FILE_RESET_PAGE_BUFFERING_STATS */
+    /* No args */
+
+    /* H5VL_NATIVE_FILE_GET_PAGE_BUFFERING_STATS */
+    H5VL_native_file_get_page_buffering_stats_t get_page_buffering_stats;
+
+    /* H5VL_NATIVE_FILE_GET_MDC_IMAGE_INFO */
+    H5VL_native_file_get_mdc_image_info_t get_mdc_image_info;
+
+    /* H5VL_NATIVE_FILE_GET_EOA */
+    struct {
+        haddr_t *eoa; /* End of allocated file address space (OUT) */
+    } get_eoa;
+
+    /* H5VL_NATIVE_FILE_INCR_FILESIZE */
+    struct {
+        hsize_t increment; /* Amount to increment file size */
+    } increment_filesize;
+
+    /* H5VL_NATIVE_FILE_SET_LIBVER_BOUNDS */
+    H5VL_native_file_set_libver_bounds_t set_libver_bounds;
+
+    /* H5VL_NATIVE_FILE_GET_MIN_DSET_OHDR_FLAG */
+    struct {
+        hbool_t *minimize; /* Flag whether dataset object headers are minimal (OUT) */
+    } get_min_dset_ohdr_flag;
+
+    /* H5VL_NATIVE_FILE_SET_MIN_DSET_OHDR_FLAG */
+    struct {
+        hbool_t minimize; /* Flag whether dataset object headers should be minimal */
+    } set_min_dset_ohdr_flag;
+
+#ifdef H5_HAVE_PARALLEL
+    /* H5VL_NATIVE_FILE_GET_MPI_ATOMICITY */
+    struct {
+        hbool_t *flag; /* Flag whether MPI atomicity is set for files (OUT) */
+    } get_mpi_atomicity;
+
+    /* H5VL_NATIVE_FILE_SET_MPI_ATOMICITY */
+    struct {
+        hbool_t flag; /* Flag whether to set MPI atomicity for files */
+    } set_mpi_atomicity;
+#endif /* H5_HAVE_PARALLEL */
+
+    /* H5VL_NATIVE_FILE_POST_OPEN */
+    /* No args */
+} H5VL_native_file_optional_args_t;
+
+/* Values for native VOL connector group optional VOL operations */
+/* NOTE: If new values are added here, the H5VL__native_introspect_opt_query
+ *      routine must be updated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+#define H5VL_NATIVE_GROUP_ITERATE_OLD 0 /* HG5Giterate (deprecated routine) */
+#define H5VL_NATIVE_GROUP_GET_OBJINFO 1 /* HG5Gget_objinfo (deprecated routine) */
+#endif                                  /* H5_NO_DEPRECATED_SYMBOLS */
+/* NOTE: If values over 1023 are added, the H5VL_RESERVED_NATIVE_OPTIONAL macro
+ *      must be updated.
+ */
+
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+/* Parameters for group 'iterate old' operation */
+typedef struct H5VL_native_group_iterate_old_t {
+    H5VL_loc_params_t loc_params; /* Location parameters for iteration */
+    hsize_t           idx;        /* Index of link to begin iteration at */
+    hsize_t          *last_obj;   /* Index of last link looked at (OUT) */
+    H5G_iterate_t     op;         /* Group (link) operator callback */
+    void             *op_data;    /* Context to pass to iterator callback */
+} H5VL_native_group_iterate_old_t;
+
+/* Parameters for group 'get objinfo' operation */
+typedef struct H5VL_native_group_get_objinfo_t {
+    H5VL_loc_params_t loc_params;  /* Location parameters for iteration */
+    hbool_t           follow_link; /* Whether to follow links for query */
+    H5G_stat_t       *statbuf;     /* Pointer to object info struct (OUT) */
+} H5VL_native_group_get_objinfo_t;
+
+/* Parameters for native connector's group 'optional' operations */
+typedef union H5VL_native_group_optional_args_t {
+    /* H5VL_NATIVE_GROUP_ITERATE_OLD */
+    H5VL_native_group_iterate_old_t iterate_old;
+
+    /* H5VL_NATIVE_GROUP_GET_OBJINFO */
+    H5VL_native_group_get_objinfo_t get_objinfo;
+} H5VL_native_group_optional_args_t;
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+/* Values for native VOL connector object optional VOL operations */
+/* NOTE: If new values are added here, the H5VL__native_introspect_opt_query
+ *      routine must be updated.
+ */
+#define H5VL_NATIVE_OBJECT_GET_COMMENT              0 /* H5G|H5Oget_comment, H5Oget_comment_by_name   */
+#define H5VL_NATIVE_OBJECT_SET_COMMENT              1 /* H5G|H5Oset_comment, H5Oset_comment_by_name   */
+#define H5VL_NATIVE_OBJECT_DISABLE_MDC_FLUSHES      2 /* H5Odisable_mdc_flushes                       */
+#define H5VL_NATIVE_OBJECT_ENABLE_MDC_FLUSHES       3 /* H5Oenable_mdc_flushes                        */
+#define H5VL_NATIVE_OBJECT_ARE_MDC_FLUSHES_DISABLED 4 /* H5Oare_mdc_flushes_disabled                  */
+#define H5VL_NATIVE_OBJECT_GET_NATIVE_INFO          5 /* H5Oget_native_info(_by_idx, _by_name)        */
+/* NOTE: If values over 1023 are added, the H5VL_RESERVED_NATIVE_OPTIONAL macro
+ *      must be updated.
+ */
+
+/* Parameters for native connector's object 'get comment' operation */
+typedef struct H5VL_native_object_get_comment_t {
+    size_t  buf_size;    /* Size of comment buffer */
+    void   *buf;         /* Buffer for comment (OUT) */
+    size_t *comment_len; /* Actual size of comment (OUT) */
+} H5VL_native_object_get_comment_t;
+
+/* Parameters for object 'get native info' operation */
+typedef struct H5VL_native_object_get_native_info_t {
+    unsigned           fields; /* Fields to retrieve */
+    H5O_native_info_t *ninfo;  /* Native info (OUT) */
+} H5VL_native_object_get_native_info_t;
+
+/* Parameters for native connector's object 'optional' operations */
+typedef union H5VL_native_object_optional_args_t {
+    /* H5VL_NATIVE_OBJECT_GET_COMMENT */
+    H5VL_native_object_get_comment_t get_comment;
+
+    /* H5VL_NATIVE_OBJECT_SET_COMMENT */
+    struct {
+        const char *comment; /* Comment string to set for the object (IN) */
+    } set_comment;
+
+    /* H5VL_NATIVE_OBJECT_DISABLE_MDC_FLUSHES */
+    /* No args */
+
+    /* H5VL_NATIVE_OBJECT_ENABLE_MDC_FLUSHES */
+    /* No args */
+
+    /* H5VL_NATIVE_OBJECT_ARE_MDC_FLUSHES_DISABLED */
+    struct {
+        hbool_t *flag; /* Flag whether metadata cache flushes are disabled for this object (OUT) */
+    } are_mdc_flushes_disabled;
+
+    /* H5VL_NATIVE_OBJECT_GET_NATIVE_INFO */
+    H5VL_native_object_get_native_info_t get_native_info;
+} H5VL_native_object_optional_args_t;
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Token <--> address converters */
+/**
+ * \ingroup H5VLNAT
+ */
+H5_DLL herr_t H5VLnative_addr_to_token(hid_t loc_id, haddr_t addr, H5O_token_t *token);
+/**
+ * \ingroup H5VLNAT
+ */
+H5_DLL herr_t H5VLnative_token_to_addr(hid_t loc_id, H5O_token_t token, haddr_t *addr);
+
+/* Not really public but must be included here */
+H5_DLL hid_t H5VL_native_register(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5VLnative_H */
diff --git a/install/include/H5VLpassthru.h b/install/include/H5VLpassthru.h
new file mode 100644
index 0000000000..ec396cc8eb
--- /dev/null
+++ b/install/include/H5VLpassthru.h
@@ -0,0 +1,47 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Purpose:	The public header file for the pass-through VOL connector.
+ */
+
+#ifndef H5VLpassthru_H
+#define H5VLpassthru_H
+
+/* Public headers needed by this file */
+#include "H5VLpublic.h" /* Virtual Object Layer                 */
+
+/* Identifier for the pass-through VOL connector */
+#define H5VL_PASSTHRU (H5VL_pass_through_register())
+
+/* Characteristics of the pass-through VOL connector */
+#define H5VL_PASSTHRU_NAME    "pass_through"
+#define H5VL_PASSTHRU_VALUE   1 /* VOL connector ID */
+#define H5VL_PASSTHRU_VERSION 0
+
+/* Pass-through VOL connector info */
+typedef struct H5VL_pass_through_info_t {
+    hid_t under_vol_id;   /* VOL ID for under VOL */
+    void *under_vol_info; /* VOL info for under VOL */
+} H5VL_pass_through_info_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+H5_DLL hid_t H5VL_pass_through_register(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5VLpassthru_H */
diff --git a/install/include/H5VLpublic.h b/install/include/H5VLpublic.h
new file mode 100644
index 0000000000..30a2b5dd62
--- /dev/null
+++ b/install/include/H5VLpublic.h
@@ -0,0 +1,423 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5VL (VOL) module.
+ */
+
+#ifndef H5VLpublic_H
+#define H5VLpublic_H
+
+#include "H5public.h"  /* Generic Functions                        */
+#include "H5Ipublic.h" /* Identifiers                              */
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/**
+ * \ingroup H5VLDEF
+ * \brief Version number of VOL class struct & callbacks
+ *
+ * \details Each VOL connector must set the 'version' field in the H5VL_class_t
+ *          struct to the version of the H5VL_class_t struct that the connector
+ *          implements.  The HDF5 library will reject connectors with
+ *          incompatible structs.
+ */
+#define H5VL_VERSION 3
+
+/* VOL connector identifier values
+ * These are H5VL_class_value_t values, NOT hid_t values!
+ */
+/**
+ * \ingroup H5VLDEF
+ * Invalid ID for VOL connector ID
+ */
+#define H5_VOL_INVALID (-1)
+/**
+ * \ingroup H5VLDEF
+ * Native HDF5 file format VOL connector
+ */
+#define H5_VOL_NATIVE 0
+/**
+ * \ingroup H5VLDEF
+ * VOL connector IDs below this value are reserved for library use
+ */
+#define H5_VOL_RESERVED 256
+/**
+ * \ingroup H5VLDEF
+ * Maximum VOL connector ID
+ */
+#define H5_VOL_MAX 65535
+
+/*
+ * Capability flags for VOL connectors
+ */
+#define H5VL_CAP_FLAG_NONE          0x0000000000000000 /**< No special connector capabilities */
+#define H5VL_CAP_FLAG_THREADSAFE    0x0000000000000001 /**< Connector is threadsafe */
+#define H5VL_CAP_FLAG_ASYNC         0x0000000000000002 /**< Connector performs operations asynchronously*/
+#define H5VL_CAP_FLAG_NATIVE_FILES  0x0000000000000004 /**< Connector produces native file format */
+#define H5VL_CAP_FLAG_ATTR_BASIC    0x0000000000000008 /**< H5A create/delete/exists/open/close/read/write */
+#define H5VL_CAP_FLAG_ATTR_MORE     0x0000000000000010 /**< All other H5A API calls */
+#define H5VL_CAP_FLAG_DATASET_BASIC 0x0000000000000020 /**< H5D create/open/close/read/write */
+#define H5VL_CAP_FLAG_DATASET_MORE  0x0000000000000040 /**< All other H5D API calls */
+#define H5VL_CAP_FLAG_FILE_BASIC    0x0000000000000080 /**< H5F create/open/close/read/write */
+#define H5VL_CAP_FLAG_FILE_MORE     0x0000000000000100 /**< All other H5F API calls */
+#define H5VL_CAP_FLAG_GROUP_BASIC   0x0000000000000200 /**< H5G create/open/close */
+#define H5VL_CAP_FLAG_GROUP_MORE    0x0000000000000400 /**< All other H5G API calls*/
+#define H5VL_CAP_FLAG_LINK_BASIC    0x0000000000000800 /**< H5L exists/delete */
+#define H5VL_CAP_FLAG_LINK_MORE     0x0000000000001000 /**< All other H5L API calls */
+#define H5VL_CAP_FLAG_MAP_BASIC                                                                              \
+    0x0000000000002000 /**< H5M create/open/close/get*type/get_count/put/get/exists/delete */
+#define H5VL_CAP_FLAG_MAP_MORE         0x0000000000004000 /**< All other H5M API calls */
+#define H5VL_CAP_FLAG_OBJECT_BASIC     0x0000000000008000 /**< H5O open/close/exists */
+#define H5VL_CAP_FLAG_OBJECT_MORE      0x0000000000010000 /**< All other H5O API calls */
+#define H5VL_CAP_FLAG_REF_BASIC        0x0000000000020000 /**< H5Rdestroy */
+#define H5VL_CAP_FLAG_REF_MORE         0x0000000000040000 /**< All other H5R API calls */
+#define H5VL_CAP_FLAG_OBJ_REF          0x0000000000080000 /**< Connector supports object references */
+#define H5VL_CAP_FLAG_REG_REF          0x0000000000100000 /**< Connector supports regional references */
+#define H5VL_CAP_FLAG_ATTR_REF         0x0000000000200000 /**< Connector supports attribute references */
+#define H5VL_CAP_FLAG_STORED_DATATYPES 0x0000000000400000 /**< Connector supports stored datatypes */
+#define H5VL_CAP_FLAG_CREATION_ORDER   0x0000000000800000 /**< Connector tracks creation order */
+#define H5VL_CAP_FLAG_ITERATE          0x0000000001000000 /**< Connector supports iteration functions */
+#define H5VL_CAP_FLAG_STORAGE_SIZE     0x0000000002000000 /**< Connector can return a meaningful storage size */
+#define H5VL_CAP_FLAG_BY_IDX           0x0000000004000000 /**< "by index" API calls are supported */
+#define H5VL_CAP_FLAG_GET_PLIST                                                                              \
+    0x0000000008000000 /**< Connector can return the property lists used to create an object */
+#define H5VL_CAP_FLAG_FLUSH_REFRESH  0x0000000010000000 /**< flush/refresh calls are supported */
+#define H5VL_CAP_FLAG_EXTERNAL_LINKS 0x0000000020000000 /**< External links are supported */
+#define H5VL_CAP_FLAG_HARD_LINKS     0x0000000040000000 /**< Hard links are supported */
+#define H5VL_CAP_FLAG_SOFT_LINKS     0x0000000080000000 /**< Soft links are supported */
+#define H5VL_CAP_FLAG_UD_LINKS       0x0000000100000000 /**< User-defined links are supported */
+#define H5VL_CAP_FLAG_TRACK_TIMES    0x0000000200000000 /**< Connector tracks creation, etc. times */
+#define H5VL_CAP_FLAG_MOUNT          0x0000000400000000 /**< H5Fmount/unmount supported */
+#define H5VL_CAP_FLAG_FILTERS        0x0000000800000000 /**< Connector implements a filter pipeline */
+#define H5VL_CAP_FLAG_FILL_VALUES    0x0000001000000000 /**< Connector allows fill values to be set */
+
+/**
+ * \ingroup H5VLDEF
+ *
+ * Flags to return from H5VLquery_optional API and 'opt_query' callbacks
+ *
+ * \details Operations which access multiple objects' data or metadata in a
+ *          container should be registered as file-level optional operations.
+ *          (e.g. "H5Dwrite_multi" takes a list of datasets to write data to, so
+ *          a VOL connector that implemented it should register it as an optional
+ *          file operation, and pass-through VOL connectors that are stacked above
+ *          the connector that registered it should assume that dataset elements
+ *          for _any_ dataset in the file could be written to)
+ */
+#define H5VL_OPT_QUERY_SUPPORTED       0x0001 /**< VOL connector supports this operation */
+#define H5VL_OPT_QUERY_READ_DATA       0x0002 /**< Operation reads data for object */
+#define H5VL_OPT_QUERY_WRITE_DATA      0x0004 /**< Operation writes data for object */
+#define H5VL_OPT_QUERY_QUERY_METADATA  0x0008 /**< Operation reads metadata for object */
+#define H5VL_OPT_QUERY_MODIFY_METADATA 0x0010 /**< Operation modifies metadata for object */
+#define H5VL_OPT_QUERY_COLLECTIVE                                                                            \
+    0x0020 /**< Operation is collective (operations without this flag are assumed to be independent) */
+#define H5VL_OPT_QUERY_NO_ASYNC  0x0040 /**< Operation may NOT be executed asynchronously */
+#define H5VL_OPT_QUERY_MULTI_OBJ 0x0080 /**< Operation involves multiple objects */
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/**
+ * \ingroup H5VLDEF
+ *
+ * \brief VOL connector identifiers.
+ *
+ * \details Values 0 through 255 are for connectors defined by the HDF5
+ *          library. Values 256 through 511 are available for testing new
+ *          connectors. Subsequent values should be obtained from the HDF5
+ *          development team at mailto:help@hdfgroup.org.
+ */
+//! <!-- [H5VL_class_value_t_snip] -->
+typedef int H5VL_class_value_t;
+//! <!-- [H5VL_class_value_t_snip] -->
+
+/**
+ * \ingroup H5VLDEF
+ * \details Enum type for each VOL subclass
+ *          (Used for various queries, etc)
+ */
+typedef enum H5VL_subclass_t {
+    H5VL_SUBCLS_NONE,     /**< Operations outside of a subclass */
+    H5VL_SUBCLS_INFO,     /**< 'Info' subclass */
+    H5VL_SUBCLS_WRAP,     /**< 'Wrap' subclass */
+    H5VL_SUBCLS_ATTR,     /**< 'Attribute' subclass */
+    H5VL_SUBCLS_DATASET,  /**< 'Dataset' subclass */
+    H5VL_SUBCLS_DATATYPE, /**< 'Named datatype' subclass */
+    H5VL_SUBCLS_FILE,     /**< 'File' subclass */
+    H5VL_SUBCLS_GROUP,    /**< 'Group' subclass */
+    H5VL_SUBCLS_LINK,     /**< 'Link' subclass */
+    H5VL_SUBCLS_OBJECT,   /**< 'Object' subclass */
+    H5VL_SUBCLS_REQUEST,  /**< 'Request' subclass */
+    H5VL_SUBCLS_BLOB,     /**< 'Blob' subclass */
+    H5VL_SUBCLS_TOKEN     /**< 'Token' subclass */
+                          /* NOTE: if more operations are added, the
+                           * H5VL_opt_vals_g[] array size should be updated.
+                           */
+} H5VL_subclass_t;
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \ingroup H5VL
+ * \brief Registers a new VOL connector by name
+ *
+ * \param[in] connector_name Connector name
+ * \vipl_id
+ * \return \hid_t{VOL connector}
+ *
+ * \details H5VLregister_connector_by_name() registers a new VOL connector with
+ *          the name \p connector_name as a member of the virtual object layer
+ *          class. This VOL connector identifier is good until the library is
+ *          closed or the connector is unregistered.
+ *
+ *          \p vipl_id is either #H5P_DEFAULT or the identifier of a VOL
+ *          initialization property list of class #H5P_VOL_INITIALIZE created
+ *          with H5Pcreate(). When created, this property list contains no
+ *          library properties. If a VOL connector author decides that
+ *          initialization-specific data are needed, they can be added to the
+ *          empty list and retrieved by the connector in the VOL connector's
+ *          initialize callback. Use of the VOL initialization property list is
+ *          uncommon, as most VOL-specific properties are added to the file
+ *          access property list via the connector's API calls which set the
+ *          VOL connector for the file open/create. For more information, see
+ *          \ref_vol_doc.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL hid_t H5VLregister_connector_by_name(const char *connector_name, hid_t vipl_id);
+/**
+ * \ingroup H5VL
+ * \brief Registers a new VOL connector by value
+ *
+ * \param[in] connector_value Connector value
+ * \vipl_id
+ * \return \hid_t{VOL connector}
+ *
+ * \details H5VLregister_connector_by_value() registers a new VOL connector
+ *          with value connector_value as a member of the virtual object layer
+ *          class. This VOL connector identifier is good until the library is
+ *          closed or the connector is unregistered.
+ *
+ *          \p connector_value has a type of H5VL_class_value_t, which is
+ *          defined in H5VLpublic.h as follows:
+ *          \snippet this H5VL_class_value_t_snip
+ *
+ *          Valid VOL connector identifiers can have values from 0 through 255
+ *          for connectors defined by the HDF5 library. Values 256 through 511
+ *          are available for testing new connectors. Subsequent values should
+ *          be obtained by contacting the The HDF Help Desk.
+ *
+ *          \p vipl_id is either #H5P_DEFAULT or the identifier of a VOL
+ *          initialization property list of class #H5P_VOL_INITIALIZE created
+ *          with H5Pcreate(). When created, this property list contains no
+ *          library properties. If a VOL connector author decides that
+ *          initialization-specific data are needed, they can be added to the
+ *          empty list and retrieved by the connector in the VOL connector's
+ *          initialize callback. Use of the VOL initialization property list is
+ *          uncommon, as most VOL-specific properties are added to the file
+ *          access property list via the connector's API calls which set the
+ *          VOL connector for the file open/create. For more information, see
+ *          the \ref_vol_doc.
+ *
+ * \since 1.12.0
+ *
+ */
+H5_DLL hid_t H5VLregister_connector_by_value(H5VL_class_value_t connector_value, hid_t vipl_id);
+/**
+ * \ingroup H5VL
+ * \brief Tests whether a VOL class has been registered under a certain name
+ *
+ * \param[in] name Alleged name of connector
+ * \return \htri_t
+ *
+ * \details H5VLis_connector_registered_by_name() tests whether a VOL class has
+ *          been registered or not, according to the supplied connector name
+ *          \p name.
+ *
+ * \since 1.12.0
+ */
+H5_DLL htri_t H5VLis_connector_registered_by_name(const char *name);
+/**
+ * \ingroup H5VL
+ * \brief Tests whether a VOL class has been registered for a given value
+ *
+ * \param[in] connector_value Connector value
+ * \return \htri_t
+ *
+ * \details H5VLis_connector_registered_by_value() tests whether a VOL class
+ *          has been registered, according to the supplied connector value \p
+ *          connector_value.
+ *
+ *          \p connector_value has a type of H5VL_class_value_t, which is
+ *          defined in H5VLpublic.h as follows:
+ *          \snippet this H5VL_class_value_t_snip
+ *
+ *          Valid VOL connector identifiers can have values from 0 through 255
+ *          for connectors defined by the HDF5 library. Values 256 through 511
+ *          are available for testing new connectors. Subsequent values should
+ *          be obtained by contacting the The HDF Help Desk.
+ *
+ * \since 1.12.0
+ */
+H5_DLL htri_t H5VLis_connector_registered_by_value(H5VL_class_value_t connector_value);
+/**
+ * \ingroup H5VL
+ * \brief Retrieves the VOL connector identifier for a given object identifier
+ *
+ * \obj_id
+ * \return \hid_t{VOL connector}
+ *
+ * \details H5VLget_connector_id() retrieves the registered VOL connector
+ *          identifier for the specified object identifier \p obj_id. The VOL
+ *          connector identifier must be closed with H5VLclose() when no longer
+ *          in use.
+ *
+ * \since 1.12.0
+ */
+H5_DLL hid_t H5VLget_connector_id(hid_t obj_id);
+/**
+ * \ingroup H5VL
+ * \brief Retrieves the identifier for a registered VOL connector name
+ *
+ * \param[in] name Connector name
+ * \return \hid_t{VOL connector}
+ *
+ * \details H5VLget_connector_id_by_name() retrieves the identifier for a
+ *          registered VOL connector with the name \p name. The identifier must
+ *          be closed with H5VLclose() when no longer in use.
+ *
+ * \since 1.12.0
+ */
+H5_DLL hid_t H5VLget_connector_id_by_name(const char *name);
+/**
+ * \ingroup H5VL
+ * \brief Retrieves the identifier for a registered VOL connector value
+ *
+ * \param[in] connector_value Connector value
+ * \return \hid_t{VOL connector}
+ *
+ * \details H5VLget_connector_id_by_value() retrieves the identifier for a
+ *          registered VOL connector with the value \p connector_value. The
+ *          identifier will need to be closed by H5VLclose().
+ *
+ *          \p connector_value has a type of H5VL_class_value_t, which is
+ *          defined in H5VLpublic.h as follows:
+ *          \snippet this H5VL_class_value_t_snip
+ *
+ *          Valid VOL connector identifiers can have values from 0 through 255
+ *          for connectors defined by the HDF5 library. Values 256 through 511
+ *          are available for testing new connectors. Subsequent values should
+ *          be obtained by contacting the The HDF Help Desk.
+ *
+ * \since 1.12.0
+ */
+H5_DLL hid_t H5VLget_connector_id_by_value(H5VL_class_value_t connector_value);
+/**
+ * \ingroup H5VL
+ * \brief Retrieves a connector name for a VOL
+ *
+ * \obj_id{id} or file identifier
+ * \param[out] name Connector name
+ * \param[in] size Maximum length of the name to retrieve
+ * \return Returns the length of the connector name on success, and a negative value on failure.
+ *
+ * \details H5VLget_connector_name() retrieves up to \p size elements of the
+ *          VOL name \p name associated with the object or file identifier \p
+ *          id.
+ *
+ *          Passing in a NULL pointer for size will return the size of the
+ *          connector name. This can be used to determine the size of the
+ *          buffer to allocate for the name.
+ *
+ * \since 1.12.0
+ */
+H5_DLL ssize_t H5VLget_connector_name(hid_t id, char *name /*out*/, size_t size);
+/**
+ * \ingroup H5VL
+ * \brief Closes a VOL connector identifier
+ *
+ * \param[in] connector_id Connector identifier
+ * \return \herr_t
+ *
+ * \details H5VLclose() closes a VOL connector identifier. This does not affect
+ *          the file access property lists which have been defined to use this
+ *          VOL connector or files which are already opened under this
+ *          connector.
+ *
+ * \since 1.12.0
+ */
+H5_DLL herr_t H5VLclose(hid_t connector_id);
+/**
+ * \ingroup H5VL
+ * \brief Removes a VOL connector identifier from the library
+ *
+ * \param[in] connector_id Connector identifier
+ * \return \herr_t
+ *
+ * \details H5VLunregister_connector() removes a VOL connector identifier from
+ *          the library. This does not affect the file access property lists
+ *          which have been defined to use the VOL connector or any files which
+ *          are already opened with this connector.
+ *
+ * \attention H5VLunregister_connector() will fail if attempting to unregister
+ *            the native VOL connector.
+ *
+ * \since 1.12.0
+ */
+H5_DLL herr_t H5VLunregister_connector(hid_t connector_id);
+/**
+ * \ingroup H5VL
+ * \brief Determine if a VOL connector supports a particular
+ *        optional callback operation.
+ *
+ * \obj_id
+ * \param[in] subcls VOL subclass
+ * \param[in] opt_type Option type
+ * \param[out] flags Operation flags
+ * \return \herr_t
+ *
+ * \since 1.12.1
+ */
+H5_DLL herr_t H5VLquery_optional(hid_t obj_id, H5VL_subclass_t subcls, int opt_type, uint64_t *flags);
+/**
+ * \ingroup H5VL
+ * \brief Determines whether an object ID represents a native
+ *        VOL connector object.
+ *
+ * \obj_id
+ * \param[out] is_native Boolean determining whether object is a native VOL connector object
+ * \return \herr_t
+ *
+ * \since 1.12.2
+ */
+H5_DLL herr_t H5VLobject_is_native(hid_t obj_id, hbool_t *is_native);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* H5VLpublic_H */
diff --git a/install/include/H5Zdevelop.h b/install/include/H5Zdevelop.h
new file mode 100644
index 0000000000..736c2830ef
--- /dev/null
+++ b/install/include/H5Zdevelop.h
@@ -0,0 +1,439 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the H5Z (data filter) developer
+ *      support routines.
+ */
+
+#ifndef H5Zdevelop_H
+#define H5Zdevelop_H
+
+/* Include package's public header */
+#include "H5Zpublic.h"
+
+/*****************/
+/* Public Macros */
+/*****************/
+
+/**
+ * Current version of the H5Z_class_t struct
+ */
+#define H5Z_CLASS_T_VERS (1)
+
+/*******************/
+/* Public Typedefs */
+/*******************/
+
+/**
+ * Structure for filter callback property
+ */
+typedef struct H5Z_cb_t {
+    H5Z_filter_func_t func;
+    void             *op_data;
+} H5Z_cb_t;
+
+/**
+ * \brief This callback determines if a filter can be applied to the dataset
+ *        with the characteristics provided
+ *
+ * \dcpl_id
+ * \type_id
+ * \space_id
+ *
+ * \return \htri_t
+ *
+ * \details Before a dataset gets created, the \ref H5Z_can_apply_func_t
+ *          callbacks for any filters used in the dataset creation property list
+ *          are called with the dataset's dataset creation property list, the
+ *          dataset's datatype and a dataspace describing a chunk (for chunked
+ *          dataset storage).
+ *
+ *          The \ref H5Z_can_apply_func_t callback must determine if the
+ *          combination of the dataset creation property list setting, the
+ *          datatype and the dataspace represent a valid combination to apply
+ *          this filter to.  For example, some cases of invalid combinations may
+ *          involve the filter not operating correctly on certain datatypes (or
+ *          certain datatype sizes), or certain sizes of the chunk dataspace.
+ *
+ *          The \ref H5Z_can_apply_func_t callback can be the NULL pointer, in
+ *          which case, the library will assume that it can apply to any
+ *          combination of dataset creation property list values, datatypes and
+ *          dataspaces.
+ *
+ *          The \ref H5Z_can_apply_func_t callback returns positive a valid
+ *          combination, zero for an invalid combination and negative for an
+ *          error.
+ */
+//! <!-- [H5Z_can_apply_func_t_snip] -->
+typedef htri_t (*H5Z_can_apply_func_t)(hid_t dcpl_id, hid_t type_id, hid_t space_id);
+//! <!-- [H5Z_can_apply_func_t_snip] -->
+
+/**
+ * \brief The filter operation callback function, defining a filter's operation
+ *        on data
+ *
+ * \dcpl_id
+ * \type_id
+ * \space_id
+ *
+ * \return \herr_t
+ *
+ * \details After the \ref H5Z_can_apply_func_t callbacks are checked for new
+ *          datasets, the \ref H5Z_set_local_func_t callbacks for any filters
+ *          used in the dataset creation property list are called. These
+ *          callbacks receive the dataset's private copy of the dataset creation
+ *          property list passed in to H5Dcreate() (i.e. not the actual property
+ *          list passed in to H5Dcreate()) and the datatype ID passed in to
+ *          H5Dcreate() (which is not copied and should not be modified) and a
+ *          dataspace describing the chunk (for chunked dataset storage) (which
+ *          should also not be modified).
+ *
+ *          The \ref H5Z_set_local_func_t callback must set any parameters that
+ *          are specific to this dataset, based on the combination of the
+ *          dataset creation property list values, the datatype and the
+ *          dataspace. For example, some filters perform different actions based
+ *          on different datatypes (or datatype sizes) or different number of
+ *          dimensions or dataspace sizes.
+ *
+ *          The \ref H5Z_set_local_func_t callback can be the NULL pointer, in
+ *          which case, the library will assume that there are no
+ *          dataset-specific settings for this filter.
+ *
+ *          The \ref H5Z_set_local_func_t callback must return non-negative on
+ *          success and negative for an error.
+ */
+//! <!-- [H5Z_set_local_func_t_snip] -->
+typedef herr_t (*H5Z_set_local_func_t)(hid_t dcpl_id, hid_t type_id, hid_t space_id);
+//! <!-- [H5Z_set_local_func_t_snip] -->
+
+/**
+ * \brief The filter operation callback function, defining a filter's operation
+ *        on data
+ *
+ * \param[in] flags Bit vector specifying certain general properties of the filter
+ * \param[in] cd_nelmts Number of elements in \p cd_values
+ * \param[in] cd_values Auxiliary data for the filter
+ * \param[in] nbytes The number of valid bytes in \p buf to be filtered
+ * \param[in,out] buf_size The size of \p buf
+ * \param[in,out] buf The filter buffer
+ *
+ * \return Returns the number of valid bytes of data contained in \p buf. In the
+ *         case of failure, the return value is 0 (zero) and all pointer
+ *         arguments are left unchanged.
+ *
+ * \details A filter gets definition flags and invocation flags (defined
+ *          above), the client data array and size defined when the filter was
+ *          added to the pipeline, the size in bytes of the data on which to
+ *          operate, and pointers to a buffer and its allocated size.
+ *
+ *          The filter should store the result in the supplied buffer if
+ *          possible, otherwise it can allocate a new buffer, freeing the
+ *          original. The allocated size of the new buffer should be returned
+ *          through the \p buf_size pointer and the new buffer through the \p
+ *          buf pointer.
+ *
+ *          The return value from the filter is the number of bytes in the
+ *          output buffer. If an error occurs then the function should return
+ *          zero and leave all pointer arguments unchanged.
+ */
+//! <!-- [H5Z_func_t_snip] -->
+typedef size_t (*H5Z_func_t)(unsigned int flags, size_t cd_nelmts, const unsigned int cd_values[],
+                             size_t nbytes, size_t *buf_size, void **buf);
+//! <!-- [H5Z_func_t_snip] -->
+
+/**
+ * The filter table maps filter identification numbers to structs that
+ * contain a pointers to the filter function and timing statistics.
+ */
+//! <!-- [H5Z_class2_t_snip] -->
+typedef struct H5Z_class2_t {
+    int                  version;         /**< Version number of the H5Z_class_t struct     */
+    H5Z_filter_t         id;              /**< Filter ID number                             */
+    unsigned             encoder_present; /**< Does this filter have an encoder?            */
+    unsigned             decoder_present; /**< Does this filter have a decoder?             */
+    const char          *name;            /**< Comment for debugging                        */
+    H5Z_can_apply_func_t can_apply;       /**< The "can apply" callback for a filter        */
+    H5Z_set_local_func_t set_local;       /**< The "set local" callback for a filter        */
+    H5Z_func_t           filter;          /**< The actual filter function                   */
+} H5Z_class2_t;
+//! <!-- [H5Z_class2_t_snip] -->
+
+/********************/
+/* Public Variables */
+/********************/
+
+/*********************/
+/* Public Prototypes */
+/*********************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \ingroup H5Z
+ *
+ * \brief Registers a new filter with the HDF5 library
+ *
+ * \param[in] cls A pointer to a buffer for the struct containing the
+ *                filter-definition
+ *
+ * \return \herr_t
+ *
+ * \details H5Zregister() registers a new filter with the HDF5 library.
+ *
+ * \details Making a new filter available to an application is a two-step
+ *          process. The first step is to write the three filter callback
+ *          functions described below: \c can_apply, \c set_local, and \c
+ *          filter. This call to H5Zregister(), registering the filter with the
+ *          library, is the second step. The can_apply and set_local fields can
+ *          be set to NULL if they are not required for the filter being
+ *          registered.
+ *
+ *          H5Zregister() accepts a single parameter, a pointer to a buffer for
+ *          the \p cls data structure. That data structure must conform to one
+ *          of the following definitions:
+ *          \snippet this H5Z_class1_t_snip
+ *          or
+ *          \snippet this H5Z_class2_t_snip
+ *
+ *          \c version is a library-defined value reporting the version number
+ *          of the #H5Z_class_t struct. This currently must be set to
+ *          #H5Z_CLASS_T_VERS.
+ *
+ *          \c id is the identifier for the new filter. This is a user-defined
+ *          value between #H5Z_FILTER_RESERVED and #H5Z_FILTER_MAX. These
+ *          values are defined in the HDF5 source file H5Zpublic.h, but the
+ *          symbols #H5Z_FILTER_RESERVED and #H5Z_FILTER_MAX should always be
+ *          used instead of the literal values.
+ *
+ *          \c encoder_present is a library-defined value indicating whether
+ *          the filter's encoding capability is available to the application.
+ *
+ *          \c decoder_present is a library-defined value indicating whether
+ *          the filter's encoding capability is available to the application.
+ *
+ *          \c name is a descriptive comment used for debugging, may contain a
+ *          descriptive name for the filter, and may be the null pointer.
+ *
+ *          \c can_apply, described in detail below, is a user-defined callback
+ *          function that determines whether the combination of the dataset
+ *          creation property list values, the datatype, and the dataspace
+ *          represent a valid combination to apply this filter to.
+ *
+ *          \c set_local, described in detail below, is a user-defined callback
+ *          function that sets any parameters that are specific to this
+ *          dataset, based on the combination of the dataset creation property
+ *          list values, the datatype, and the dataspace.
+ *
+ *          \c filter, described in detail below, is a user-defined callback
+ *          function which performs the action of the filter.
+ *
+ *          The statistics associated with a filter are not reset by this
+ *          function; they accumulate over the life of the library.
+ *
+ *          #H5Z_class_t is a macro that maps to either H5Z_class1_t or
+ *          H5Z_class2_t, depending on the needs of the application. To affect
+ *          only this macro, H5Z_class_t_vers may be defined as either 1 or 2.
+ *          Otherwise, it will behave in the same manner as other API
+ *          compatibility macros. See API Compatibility Macros in HDF5 for more
+ *          information. H5Z_class1_t matches the #H5Z_class_t structure that is
+ *          used in the 1.6.x versions of the HDF5 library.
+ *
+ *          H5Zregister() will automatically detect which structure type has
+ *          been passed in, regardless of the mapping of the #H5Z_class_t macro.
+ *          However, the application must make sure that the fields are filled
+ *          in according to the correct structure definition if the macro is
+ *          used to declare the structure.
+ *
+ *          \Bold{The callback functions:}\n Before H5Zregister() can link a
+ *          filter into an application, three callback functions must be
+ *          defined as described in the HDF5 library header file H5Zpublic.h.
+ *
+ *          When a filter is applied to the fractal heap for a group (e.g.,
+ *          when compressing group metadata) and if they can apply and set local
+ *          callback functions that have been defined for that filter, HDF5 passes
+ *          the value -1 for all parameters for those callback functions. This
+ *          is done to ensure that the filter will not be applied to groups if
+ *          it relies on these parameters, as they are not applicable to group
+ *          fractal heaps; to operate on group fractal heaps, a filter must be
+ *          capable of operating on an opaque block of binary data.
+ *
+ *          The \Emph{can-apply} callback function must return a positive value
+ *          for a valid combination, zero for an invalid combination, and a
+ *          negative value for an error.
+ *          \snippet this H5Z_can_apply_func_t_snip
+ *
+ *          Before a dataset is created, the \Emph{can apply} callbacks for any
+ *          filters used in the dataset creation property list are called with
+ *          the dataset's dataset creation property list, \c dcpl_id, the
+ *          dataset's datatype, \p type_id, and a dataspace describing a chunk,
+ *          \p space_id, (for chunked dataset storage).
+ *
+ *          This callback must determine whether the combination of the dataset
+ *          creation property list settings, the datatype, and the dataspace
+ *          represent a valid combination to which to apply this filter. For
+ *          example, an invalid combination may involve the filter not
+ *          operating correctly on certain datatypes, on certain datatype
+ *          sizes, or on certain sizes of the chunk dataspace. If this filter
+ *          is enabled through H5Pset_filter() as optional and the can apply
+ *          function returns 0, the library will skip the filter in the filter
+ *          pipeline.
+ *
+ *          This callback can be the NULL pointer, in which case the library
+ *          will assume that the filter can be applied to a dataset with any
+ *          combination of dataset creation property list values, datatypes,
+ *          and dataspaces.
+ *
+ *          The \Emph{set local} callback function is defined as follows:
+ *          \snippet this H5Z_set_local_func_t_snip
+ *
+ *          After the can apply callbacks are checked for a new dataset, the
+ *          \Emph{set local} callback functions for any filters used in the
+ *          dataset creation property list are called. These callbacks receive
+ *          \c dcpl_id, the dataset's private copy of the dataset creation
+ *          property list passed into H5Dcreate() (i.e. not the actual
+ *          property list passed into H5Dcreate()); \c type_id, the datatype
+ *          identifier passed into H5Dcreate(), which is not copied and should
+ *          not be modified; and \c space_id, a dataspace describing the chunk
+ *          (for chunked dataset storage), which should also not be modified.
+ *
+ *          The set local callback must set any filter parameters that are
+ *          specific to this dataset, based on the combination of the dataset
+ *          creation property list values, the datatype, and the dataspace. For
+ *          example, some filters perform different actions based on different
+ *          datatypes, datatype sizes, numbers of dimensions, or dataspace
+ *          sizes.
+ *
+ *          The \Emph{set local} callback may be the NULL pointer, in which
+ *          case, the library will assume that there are no dataset-specific
+ *          settings for this filter.
+ *
+ *          The \Emph{set local} callback function must return a non-negative
+ *          value on success and a negative value for an error.
+ *
+ *          The \Emph{filter operation} callback function, defining the
+ *          filter's operation on the data, is defined as follows:
+ *          \snippet this H5Z_func_t_snip
+ *
+ *          The parameters \c flags, \c cd_nelmts, and \c cd_values are the
+ *          same as for the function H5Pset_filter(). The one exception is that
+ *          an additional flag, #H5Z_FLAG_REVERSE, is set when the filter is
+ *          called as part of the input pipeline.
+ *
+ *          The parameter \c buf points to the input buffer which has a size of
+ *          \c buf_size bytes, \c nbytes of which are valid data.
+ *
+ *          The filter should perform the transformation in place if possible.
+ *          If the transformation cannot be done in place, then the filter
+ *          should allocate a new buffer and assign it to \c buf, assigning
+ *          the allocated size of that buffer to \c buf_size. The old
+ *          buffer should be freed by the filter.
+ *
+ *          Some care must be taken with the functions that allocate and free
+ *          memory. Standard C library functions like malloc(3) and free(3)
+ *          will work in many cases, but if there is a mismatch between the
+ *          memory allocators used in the library and any filter that
+ *          reallocates a buffer, there could be problems. This is most often
+ *          the case with Windows and/or when debugging memory allocators are being
+ *          used. In both cases, the "state" of the memory allocator lies in
+ *          different libraries and will get corrupted if you allocate in one
+ *          library and free in another. Windows adds the C standard library
+ *          via dlls that can vary with Visual Studio version and debug vs.
+ *          release builds. Static links to the MSVC CRT can also introduce
+ *          a new memory allocator state.
+ *
+ *          The library does provide H5allocate_memory() and H5free_memory()
+ *          functions that will use the library's allocation and free functions,
+ *          however using these functions will require linking your filter to
+ *          a particular version of the library, which may be inconvenient.
+ *
+ *          If successful, the \Emph{filter operation} callback function
+ *          returns the number of valid bytes of data contained in \c buf. In
+ *          the case of failure, the return value is 0 (zero) and all pointer
+ *          arguments are left unchanged.
+ *
+ * \version 1.8.6 Return type for the \Emph{can apply} callback function,
+ *                \ref H5Z_can_apply_func_t, changed to \ref htri_t.
+ * \version 1.8.5 Semantics of the \Emph{can apply} and \Emph{set local}
+ *                callback functions changed to accommodate the use of filters
+ *                with group fractal heaps.
+ * \version 1.8.3 #H5Z_class_t renamed to H5Z_class2_t, H5Z_class1_t structure
+ *                introduced for backwards compatibility with release 1.6.x,
+ *                and #H5Z_class_t macro introduced in this release. Function
+ *                modified to accept either structure type.
+ * \version 1.8.0 The fields \c version, \c encoder_present, and
+ *                \c decoder_present were added to the #H5Z_class_t \c struct
+ *                in this release.
+ * \version 1.6.0 This function was substantially revised in Release 1.6.0 with
+ *                a new #H5Z_class_t struct and new set local and can apply
+ *                callback functions.
+ *
+ */
+H5_DLL herr_t H5Zregister(const void *cls);
+/**
+ * \ingroup H5Z
+ *
+ * \brief Unregisters a filter.
+ *
+ * \param[in] id Identifier of the filter to be unregistered.
+ * \return \herr_t
+ *
+ * \details H5Zunregister() unregisters the filter specified in \p id.
+ *
+ * \details This function first iterates through all opened datasets and
+ *          groups. If an open object that uses this filter is found, the
+ *          function will fail with a message indicating that an object using
+ *          the filter is still open. All open files are then flushed to make
+ *          sure that all cached data that may use this filter are written out.
+ *
+ *          If the application is a parallel program, all processes that
+ *          participate in collective data writing should call this function to
+ *          ensure that all data is flushed.
+ *
+ *          After a call to H5Zunregister(), the filter specified in filter
+ *          will no longer be available to the application.
+ *
+ * \version 1.8.12 Function modified to check for open objects using the
+ *                 filter.
+ * \since 1.6.0
+ */
+H5_DLL herr_t H5Zunregister(H5Z_filter_t id);
+
+#ifdef __cplusplus
+}
+#endif
+
+/* Symbols defined for compatibility with previous versions of the HDF5 API.
+ *
+ * Use of these symbols is deprecated.
+ */
+#ifndef H5_NO_DEPRECATED_SYMBOLS
+
+/**
+ * The filter table maps filter identification numbers to structs that
+ * contain a pointers to the filter function and timing statistics.
+ */
+//! <!-- [H5Z_class1_t_snip] -->
+typedef struct H5Z_class1_t {
+    H5Z_filter_t         id;        /**< Filter ID number			     */
+    const char          *name;      /**< Comment for debugging		     */
+    H5Z_can_apply_func_t can_apply; /**< The "can apply" callback for a filter */
+    H5Z_set_local_func_t set_local; /**< The "set local" callback for a filter */
+    H5Z_func_t           filter;    /**< The actual filter function		     */
+} H5Z_class1_t;
+//! <!-- [H5Z_class1_t_snip] -->
+
+#endif /* H5_NO_DEPRECATED_SYMBOLS */
+
+#endif /* H5Zdevelop_H */
diff --git a/install/include/H5Zpublic.h b/install/include/H5Zpublic.h
new file mode 100644
index 0000000000..d906e3c9c5
--- /dev/null
+++ b/install/include/H5Zpublic.h
@@ -0,0 +1,315 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef H5Zpublic_H
+#define H5Zpublic_H
+
+#include "H5public.h" /* Generic Functions                        */
+
+/**
+ * \brief Filter identifiers
+ *
+ * \details Values 0 through 255 are for filters defined by the HDF5 library.
+ *          Values 256 through 511 are available for testing new filters.
+ *          Subsequent values should be obtained from the HDF5 development team
+ *          at mailto:help@hdfgroup.org. These values will never change because
+ *          they appear in the HDF5 files.
+ */
+typedef int H5Z_filter_t;
+
+/* Filter IDs */
+/**
+ * no filter
+ */
+#define H5Z_FILTER_ERROR (-1)
+/**
+ * reserved indefinitely
+ */
+#define H5Z_FILTER_NONE 0
+/**
+ * deflation like gzip
+ */
+#define H5Z_FILTER_DEFLATE 1
+/**
+ * shuffle the data
+ */
+#define H5Z_FILTER_SHUFFLE 2
+/**
+ * fletcher32 checksum of EDC
+ */
+#define H5Z_FILTER_FLETCHER32 3
+/**
+ * szip compression
+ */
+#define H5Z_FILTER_SZIP 4
+/**
+ * nbit compression
+ */
+#define H5Z_FILTER_NBIT 5
+/**
+ * scale+offset compression
+ */
+#define H5Z_FILTER_SCALEOFFSET 6
+/**
+ * filter ids below this value are reserved for library use
+ */
+#define H5Z_FILTER_RESERVED 256
+/**
+ * maximum filter id
+ */
+#define H5Z_FILTER_MAX 65535
+
+/* General macros */
+/**
+ * Symbol to remove all filters in H5Premove_filter()
+ */
+#define H5Z_FILTER_ALL 0
+/**
+ * Maximum number of filters allowed in a pipeline
+ *
+ * \internal (should probably be allowed to be an unlimited amount, but
+ *            currently each filter uses a bit in a 32-bit field, so the format
+ *            would have to be changed to accommodate that)
+ */
+#define H5Z_MAX_NFILTERS 32
+
+/* Flags for filter definition (stored) */
+/**
+ * definition flag mask
+ */
+#define H5Z_FLAG_DEFMASK 0x00ff
+/**
+ * filter is mandatory
+ */
+#define H5Z_FLAG_MANDATORY 0x0000
+/**
+ * filter is optional
+ */
+#define H5Z_FLAG_OPTIONAL 0x0001
+
+/* Additional flags for filter invocation (not stored) */
+/**
+ * invocation flag mask
+ */
+#define H5Z_FLAG_INVMASK 0xff00
+/**
+ * reverse direction; read
+ */
+#define H5Z_FLAG_REVERSE 0x0100
+/**
+ * skip EDC filters for read
+ */
+#define H5Z_FLAG_SKIP_EDC 0x0200
+
+/* Special parameters for szip compression */
+/* [These are aliases for the similar definitions in szlib.h, which we can't
+ * include directly due to the duplication of various symbols with the zlib.h
+ * header file] */
+/**
+ * \ingroup SZIP */
+#define H5_SZIP_ALLOW_K13_OPTION_MASK 1
+/**
+ * \ingroup SZIP */
+#define H5_SZIP_CHIP_OPTION_MASK 2
+/**
+ * \ingroup SZIP */
+#define H5_SZIP_EC_OPTION_MASK 4
+/**
+ * \ingroup SZIP */
+#define H5_SZIP_NN_OPTION_MASK 32
+/**
+ * \ingroup SZIP */
+#define H5_SZIP_MAX_PIXELS_PER_BLOCK 32
+
+/* Macros for the shuffle filter */
+/**
+ * \ingroup SHUFFLE
+ * Number of parameters that users can set for the shuffle filter
+ */
+#define H5Z_SHUFFLE_USER_NPARMS 0
+/**
+ * \ingroup SHUFFLE
+ * Total number of parameters for the shuffle filter
+ */
+#define H5Z_SHUFFLE_TOTAL_NPARMS 1
+
+/* Macros for the szip filter */
+/**
+ * \ingroup SZIP
+ * Number of parameters that users can set for SZIP
+ */
+#define H5Z_SZIP_USER_NPARMS 2
+/**
+ * \ingroup SZIP
+ * Total number of parameters for SZIP filter
+ */
+#define H5Z_SZIP_TOTAL_NPARMS 4
+/**
+ * \ingroup SZIP
+ * "User" parameter for option mask
+ */
+#define H5Z_SZIP_PARM_MASK 0
+/**
+ * \ingroup SZIP
+ * "User" parameter for pixels-per-block
+ */
+#define H5Z_SZIP_PARM_PPB 1
+/**
+ * \ingroup SZIP
+ * "Local" parameter for bits-per-pixel
+ */
+#define H5Z_SZIP_PARM_BPP 2
+/**
+ * \ingroup SZIP
+ * "Local" parameter for pixels-per-scanline
+ */
+#define H5Z_SZIP_PARM_PPS 3
+
+/* Macros for the nbit filter */
+/**
+ * \ingroup NBIT
+ * Number of parameters that users can set for the N-bit filter
+ */
+#define H5Z_NBIT_USER_NPARMS 0 /* Number of parameters that users can set */
+
+/* Macros for the scale offset filter */
+/**
+ * \ingroup SCALEOFFSET
+ * Number of parameters that users can set for the scale-offset filter
+ */
+#define H5Z_SCALEOFFSET_USER_NPARMS 2
+
+/* Special parameters for ScaleOffset filter*/
+/**
+ * \ingroup SCALEOFFSET */
+#define H5Z_SO_INT_MINBITS_DEFAULT 0
+/**
+ * \ingroup SCALEOFFSET */
+typedef enum H5Z_SO_scale_type_t {
+    H5Z_SO_FLOAT_DSCALE = 0,
+    H5Z_SO_FLOAT_ESCALE = 1,
+    H5Z_SO_INT          = 2
+} H5Z_SO_scale_type_t;
+
+/**
+ * \ingroup FLETCHER32
+ * Values to decide if EDC is enabled for reading data
+ */
+typedef enum H5Z_EDC_t {
+    H5Z_ERROR_EDC   = -1, /**< error value */
+    H5Z_DISABLE_EDC = 0,
+    H5Z_ENABLE_EDC  = 1,
+    H5Z_NO_EDC      = 2 /**< sentinel */
+} H5Z_EDC_t;
+
+/* Bit flags for H5Zget_filter_info */
+#define H5Z_FILTER_CONFIG_ENCODE_ENABLED (0x0001)
+#define H5Z_FILTER_CONFIG_DECODE_ENABLED (0x0002)
+
+/**
+ * Return values for filter callback function
+ */
+typedef enum H5Z_cb_return_t {
+    H5Z_CB_ERROR = -1, /**< error value */
+    H5Z_CB_FAIL  = 0,  /**< I/O should fail if filter fails. */
+    H5Z_CB_CONT  = 1,  /**< I/O continues if filter fails.   */
+    H5Z_CB_NO    = 2   /**< sentinel */
+} H5Z_cb_return_t;
+
+//! <!-- [H5Z_filter_func_t_snip] -->
+/**
+ *  Filter callback function definition
+ */
+typedef H5Z_cb_return_t (*H5Z_filter_func_t)(H5Z_filter_t filter, void *buf, size_t buf_size, void *op_data);
+//! <!-- [H5Z_filter_func_t_snip] -->
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \ingroup H5Z
+ *
+ * \brief Determines whether a filter is available
+ *
+ * \param[in] id Filter identifier
+ * \return \htri_t
+ *
+ * \details H5Zfilter_avail() determines whether the filter specified in \p id
+ *          is available to the application.
+ *
+ * \since 1.6.0
+ */
+H5_DLL htri_t H5Zfilter_avail(H5Z_filter_t id);
+/**
+ * \ingroup H5Z
+ *
+ * \brief Retrieves information about a filter
+ *
+ * \param[in] filter Filter identifier
+ * \param[out] filter_config_flags A bit field encoding the returned filter
+ *                                 information
+ * \return \herr_t
+ *
+ * \details H5Zget_filter_info() retrieves information about a filter. At
+ *          present, this means that the function retrieves a filter's
+ *          configuration flags, indicating whether the filter is configured to
+ *          decode data, encode data, neither, or both.
+ *
+ *          If \p filter_config_flags is not set to NULL prior to the function
+ *          call, the returned parameter contains a bit field specifying the
+ *          available filter configuration. The configuration flag values can
+ *          then be determined through a series of bitwise AND operations, as
+ *          described below.
+ *
+ *          Valid filter configuration flags include the following:
+ *          <table>
+ *            <tr><td>#H5Z_FILTER_CONFIG_ENCODE_ENABLED</td>
+ *                <td>Encoding is enabled for this filter</td></tr>
+ *            <tr><td>#H5Z_FILTER_CONFIG_DECODE_ENABLED</td>
+ *                <td>Decoding is enabled for this filter</td></tr>
+ *          </table>
+ *
+ *          A bitwise AND of the returned \p filter_config_flags and a valid
+ *          filter configuration flag will reveal whether the related
+ *          configuration option is available. For example, if the value of
+ *          \code
+ *          H5Z_FILTER_CONFIG_ENCODE_ENABLED & filter_config_flags
+ *          \endcode
+ *          is true, i.e., greater than 0 (zero), the queried filter
+ *          is configured to encode data; if the value is \c false, i.e., equal to
+ *          0 (zero), the filter is not so configured.
+ *
+ *          If a filter is not encode-enabled, the corresponding \c H5Pset_*
+ *          function will return an error if the filter is added to a dataset
+ *          creation property list (which is required if the filter is to be
+ *          used to encode that dataset). For example, if the
+ *          #H5Z_FILTER_CONFIG_ENCODE_ENABLED flag is not returned for the SZIP
+ *          filter, #H5Z_FILTER_SZIP, a call to H5Pset_szip() will fail.
+ *
+ *          If a filter is not decode-enabled, the application will not be able
+ *          to read an existing file encoded with that filter.
+ *
+ *          This function should be called, and the returned \p
+ *          filter_config_flags should be analyzed, before calling any other function,
+ *          such as H5Pset_szip(), that might require a particular filter
+ *          configuration.
+ *
+ * \since 1.6.3
+ */
+H5_DLL herr_t H5Zget_filter_info(H5Z_filter_t filter, unsigned int *filter_config_flags);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _H5Zpublic_H */
diff --git a/install/include/H5api_adpt.h b/install/include/H5api_adpt.h
new file mode 100644
index 0000000000..a9c34ae253
--- /dev/null
+++ b/install/include/H5api_adpt.h
@@ -0,0 +1,251 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * H5api_adpt.h
+ * Used for the HDF5 dll project
+ */
+#ifndef H5API_ADPT_H
+#define H5API_ADPT_H
+
+/* This will only be defined if HDF5 was built with CMake */
+#ifdef H5_BUILT_AS_DYNAMIC_LIB
+
+#if defined(hdf5_shared_EXPORTS)
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5_DLL    __declspec(dllexport)
+#define H5_DLLVAR extern __declspec(dllexport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5_DLL    __attribute__((visibility("default")))
+#define H5_DLLVAR extern __attribute__((visibility("default")))
+#endif
+#else
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5_DLL    __declspec(dllimport)
+#define H5_DLLVAR __declspec(dllimport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5_DLL    __attribute__((visibility("default")))
+#define H5_DLLVAR extern __attribute__((visibility("default")))
+#endif
+#endif
+
+#ifndef H5_DLL
+#define H5_DLL
+#define H5_DLLVAR extern
+#endif /* _HDF5DLL_ */
+
+#if defined(hdf5_test_shared_EXPORTS)
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5TEST_DLL    __declspec(dllexport)
+#define H5TEST_DLLVAR extern __declspec(dllexport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5TEST_DLL    __attribute__((visibility("default")))
+#define H5TEST_DLLVAR extern __attribute__((visibility("default")))
+#endif
+#else
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5TEST_DLL    __declspec(dllimport)
+#define H5TEST_DLLVAR __declspec(dllimport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5TEST_DLL    __attribute__((visibility("default")))
+#define H5TEST_DLLVAR extern __attribute__((visibility("default")))
+#endif
+#endif
+
+#ifndef H5TEST_DLL
+#define H5TEST_DLL
+#define H5TEST_DLLVAR extern
+#endif /* H5TEST_DLL */
+
+#if defined(hdf5_tools_shared_EXPORTS)
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5TOOLS_DLL    __declspec(dllexport)
+#define H5TOOLS_DLLVAR extern __declspec(dllexport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5TOOLS_DLL    __attribute__((visibility("default")))
+#define H5TOOLS_DLLVAR extern __attribute__((visibility("default")))
+#endif
+#else
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5TOOLS_DLL    __declspec(dllimport)
+#define H5TOOLS_DLLVAR __declspec(dllimport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5TOOLS_DLL    __attribute__((visibility("default")))
+#define H5TOOLS_DLLVAR extern __attribute__((visibility("default")))
+#endif
+#endif
+
+#ifndef H5TOOLS_DLL
+#define H5TOOLS_DLL
+#define H5TOOLS_DLLVAR extern
+#endif /* H5TOOLS_DLL */
+
+#if defined(hdf5_cpp_shared_EXPORTS)
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5_DLLCPP    __declspec(dllexport)
+#define H5_DLLCPPVAR extern __declspec(dllexport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5_DLLCPP    __attribute__((visibility("default")))
+#define H5_DLLCPPVAR extern __attribute__((visibility("default")))
+#endif
+#else
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5_DLLCPP    __declspec(dllimport)
+#define H5_DLLCPPVAR __declspec(dllimport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5_DLLCPP    __attribute__((visibility("default")))
+#define H5_DLLCPPVAR extern __attribute__((visibility("default")))
+#endif
+#endif
+
+#ifndef H5_DLLCPP
+#define H5_DLLCPP
+#define H5_DLLCPPVAR extern
+#endif /* H5_DLLCPP */
+
+#if defined(hdf5_hl_shared_EXPORTS)
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5_HLDLL    __declspec(dllexport)
+#define H5_HLDLLVAR extern __declspec(dllexport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5_HLDLL    __attribute__((visibility("default")))
+#define H5_HLDLLVAR extern __attribute__((visibility("default")))
+#endif
+#else
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5_HLDLL    __declspec(dllimport)
+#define H5_HLDLLVAR __declspec(dllimport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5_HLDLL    __attribute__((visibility("default")))
+#define H5_HLDLLVAR extern __attribute__((visibility("default")))
+#endif
+#endif
+
+#ifndef H5_HLDLL
+#define H5_HLDLL
+#define H5_HLDLLVAR extern
+#endif /* H5_HLDLL */
+
+#if defined(hdf5_hl_cpp_shared_EXPORTS)
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5_HLCPPDLL    __declspec(dllexport)
+#define H5_HLCPPDLLVAR extern __declspec(dllexport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5_HLCPPDLL    __attribute__((visibility("default")))
+#define H5_HLCPPDLLVAR extern __attribute__((visibility("default")))
+#endif
+#else
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5_HLCPPDLL    __declspec(dllimport)
+#define H5_HLCPPDLLVAR __declspec(dllimport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5_HLCPPDLL    __attribute__((visibility("default")))
+#define H5_HLCPPDLLVAR extern __attribute__((visibility("default")))
+#endif
+#endif
+
+#ifndef H5_HLCPPDLL
+#define H5_HLCPPDLL
+#define H5_HLCPPDLLVAR extern
+#endif /* H5_HLCPPDLL */
+
+#if defined(hdf5_f90cstub_shared_EXPORTS)
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5_FCDLL    __declspec(dllexport)
+#define H5_FCDLLVAR extern __declspec(dllexport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5_FCDLL    __attribute__((visibility("default")))
+#define H5_FCDLLVAR extern __attribute__((visibility("default")))
+#endif
+#else
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5_FCDLL    __declspec(dllimport)
+#define H5_FCDLLVAR __declspec(dllimport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5_FCDLL    __attribute__((visibility("default")))
+#define H5_FCDLLVAR extern __attribute__((visibility("default")))
+#endif
+#endif
+
+#ifndef H5_FCDLL
+#define H5_FCDLL
+#define H5_FCDLLVAR extern
+#endif /* H5_FCDLL */
+
+#if defined(hdf5_test_f90cstub_shared_EXPORTS)
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5_FCTESTDLL    __declspec(dllexport)
+#define H5_FCTESTDLLVAR extern __declspec(dllexport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5_FCTESTDLL    __attribute__((visibility("default")))
+#define H5_FCTESTDLLVAR extern __attribute__((visibility("default")))
+#endif
+#else
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define H5_FCTESTDLL    __declspec(dllimport)
+#define H5_FCTESTDLLVAR __declspec(dllimport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define H5_FCTESTDLL    __attribute__((visibility("default")))
+#define H5_FCTESTDLLVAR extern __attribute__((visibility("default")))
+#endif
+#endif
+
+#ifndef H5_FCTESTDLL
+#define H5_FCTESTDLL
+#define H5_FCTESTDLLVAR extern
+#endif /* H5_FCTESTDLL */
+
+#if defined(hdf5_hl_f90cstub_shared_EXPORTS)
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define HDF5_HL_F90CSTUBDLL    __declspec(dllexport)
+#define HDF5_HL_F90CSTUBDLLVAR extern __declspec(dllexport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define HDF5_HL_F90CSTUBDLL    __attribute__((visibility("default")))
+#define HDF5_HL_F90CSTUBDLLVAR extern __attribute__((visibility("default")))
+#endif
+#else
+#if defined(_MSC_VER) /* MSVC Compiler Case */
+#define HDF5_HL_F90CSTUBDLL    __declspec(dllimport)
+#define HDF5_HL_F90CSTUBDLLVAR __declspec(dllimport)
+#elif (__GNUC__ >= 4) /* GCC 4.x has support for visibility options */
+#define HDF5_HL_F90CSTUBDLL    __attribute__((visibility("default")))
+#define HDF5_HL_F90CSTUBDLLVAR extern __attribute__((visibility("default")))
+#endif
+#endif
+
+#ifndef HDF5_HL_F90CSTUBDLL
+#define HDF5_HL_F90CSTUBDLL
+#define HDF5_HL_F90CSTUBDLLVAR extern
+#endif /* HDF5_HL_F90CSTUBDLL */
+
+#else
+#define H5_DLL
+#define H5_DLLVAR extern
+#define H5TEST_DLL
+#define H5TEST_DLLVAR extern
+#define H5TOOLS_DLL
+#define H5TOOLS_DLLVAR extern
+#define H5_DLLCPP
+#define H5_DLLCPPVAR extern
+#define H5_HLDLL
+#define H5_HLDLLVAR extern
+#define H5_HLCPPDLL
+#define H5_HLCPPDLLVAR extern
+#define H5_FCDLL
+#define H5_FCDLLVAR extern
+#define H5_FCTESTDLL
+#define H5_FCTESTDLLVAR extern
+#define HDF5_HL_F90CSTUBDLL
+#define HDF5_HL_F90CSTUBDLLVAR extern
+#endif /* H5_BUILT_AS_DYNAMIC_LIB */
+
+#endif /* H5API_ADPT_H */
diff --git a/install/include/H5encode.h b/install/include/H5encode.h
new file mode 100644
index 0000000000..5be75d57f7
--- /dev/null
+++ b/install/include/H5encode.h
@@ -0,0 +1,292 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * File-independent encode/decode routines
+ */
+
+#ifndef H5encode_H
+#define H5encode_H
+
+/***********/
+/* Headers */
+/***********/
+#include "H5MMprivate.h" /* Memory management                        */
+
+/**************************/
+/* Library Private Macros */
+/**************************/
+
+/*
+ * Encode and decode macros for file meta-data.
+ * Currently, all file meta-data is little-endian.
+ */
+
+#define INT16ENCODE(p, i)                                                                                    \
+    do {                                                                                                     \
+        *(p) = (uint8_t)((unsigned)(i)&0xff);                                                                \
+        (p)++;                                                                                               \
+        *(p) = (uint8_t)(((unsigned)(i) >> 8) & 0xff);                                                       \
+        (p)++;                                                                                               \
+    } while (0)
+
+#define UINT16ENCODE(p, i)                                                                                   \
+    do {                                                                                                     \
+        *(p) = (uint8_t)((unsigned)(i)&0xff);                                                                \
+        (p)++;                                                                                               \
+        *(p) = (uint8_t)(((unsigned)(i) >> 8) & 0xff);                                                       \
+        (p)++;                                                                                               \
+    } while (0)
+
+#define INT32ENCODE(p, i)                                                                                    \
+    do {                                                                                                     \
+        *(p) = (uint8_t)((uint32_t)(i)&0xff);                                                                \
+        (p)++;                                                                                               \
+        *(p) = (uint8_t)(((uint32_t)(i) >> 8) & 0xff);                                                       \
+        (p)++;                                                                                               \
+        *(p) = (uint8_t)(((uint32_t)(i) >> 16) & 0xff);                                                      \
+        (p)++;                                                                                               \
+        *(p) = (uint8_t)(((uint32_t)(i) >> 24) & 0xff);                                                      \
+        (p)++;                                                                                               \
+    } while (0)
+
+#define UINT32ENCODE(p, i)                                                                                   \
+    do {                                                                                                     \
+        *(p) = (uint8_t)((i)&0xff);                                                                          \
+        (p)++;                                                                                               \
+        *(p) = (uint8_t)(((i) >> 8) & 0xff);                                                                 \
+        (p)++;                                                                                               \
+        *(p) = (uint8_t)(((i) >> 16) & 0xff);                                                                \
+        (p)++;                                                                                               \
+        *(p) = (uint8_t)(((i) >> 24) & 0xff);                                                                \
+        (p)++;                                                                                               \
+    } while (0)
+
+/* Encode an unsigned integer into a variable-sized buffer */
+/* (Assumes that the high bits of the integer are zero) */
+#define ENCODE_VAR(p, typ, n, l)                                                                             \
+    do {                                                                                                     \
+        typ      _n = (n);                                                                                   \
+        size_t   _i;                                                                                         \
+        uint8_t *_p = (uint8_t *)(p);                                                                        \
+                                                                                                             \
+        for (_i = 0; _i < l; _i++, _n >>= 8)                                                                 \
+            *_p++ = (uint8_t)(_n & 0xff);                                                                    \
+        (p) = (uint8_t *)(p) + l;                                                                            \
+    } while (0)
+
+/* Encode a 32-bit unsigned integer into a variable-sized buffer */
+/* (Assumes that the high bits of the integer are zero) */
+#define UINT32ENCODE_VAR(p, n, l) ENCODE_VAR(p, uint32_t, n, l)
+
+#define INT64ENCODE(p, n)                                                                                    \
+    do {                                                                                                     \
+        int64_t  _n = (n);                                                                                   \
+        size_t   _i;                                                                                         \
+        uint8_t *_p = (uint8_t *)(p);                                                                        \
+                                                                                                             \
+        for (_i = 0; _i < sizeof(int64_t); _i++, _n >>= 8)                                                   \
+            *_p++ = (uint8_t)(_n & 0xff);                                                                    \
+        for (/*void*/; _i < 8; _i++)                                                                         \
+            *_p++ = (uint8_t)((n) < 0 ? 0xff : 0);                                                           \
+        (p) = (uint8_t *)(p) + 8;                                                                            \
+    } while (0)
+
+#define UINT64ENCODE(p, n)                                                                                   \
+    do {                                                                                                     \
+        uint64_t _n = (n);                                                                                   \
+        size_t   _i;                                                                                         \
+        uint8_t *_p = (uint8_t *)(p);                                                                        \
+                                                                                                             \
+        for (_i = 0; _i < sizeof(uint64_t); _i++, _n >>= 8)                                                  \
+            *_p++ = (uint8_t)(_n & 0xff);                                                                    \
+        for (/*void*/; _i < 8; _i++)                                                                         \
+            *_p++ = 0;                                                                                       \
+        (p) = (uint8_t *)(p) + 8;                                                                            \
+    } while (0)
+
+/* Encode a 64-bit unsigned integer into a variable-sized buffer */
+/* (Assumes that the high bits of the integer are zero) */
+#define UINT64ENCODE_VAR(p, n, l) ENCODE_VAR(p, uint64_t, n, l)
+
+#define H5_ENCODE_UNSIGNED(p, n)                                                                             \
+    do {                                                                                                     \
+        HDcompile_assert(sizeof(unsigned) == sizeof(uint32_t));                                              \
+        UINT32ENCODE(p, n);                                                                                  \
+    } while (0)
+
+/* Assumes the endianness of uint64_t is the same as double */
+#define H5_ENCODE_DOUBLE(p, n)                                                                               \
+    do {                                                                                                     \
+        uint64_t _n;                                                                                         \
+        size_t   _u;                                                                                         \
+        uint8_t *_p = (uint8_t *)(p);                                                                        \
+                                                                                                             \
+        HDcompile_assert(sizeof(double) == 8);                                                               \
+        HDcompile_assert(sizeof(double) == sizeof(uint64_t));                                                \
+        H5MM_memcpy(&_n, &n, sizeof(double));                                                                \
+        for (_u = 0; _u < sizeof(uint64_t); _u++, _n >>= 8)                                                  \
+            *_p++ = (uint8_t)(_n & 0xff);                                                                    \
+        (p) = (uint8_t *)(p) + 8;                                                                            \
+    } while (0)
+
+/* DECODE converts little endian bytes pointed by p to integer values and store
+ * it in i.  For signed values, need to do sign-extension when converting
+ * the last byte which carries the sign bit.
+ * The macros does not require i be of a certain byte sizes.  It just requires
+ * i be big enough to hold the intended value range.  E.g. INT16DECODE works
+ * correctly even if i is actually a 64bit int like in a Cray.
+ */
+
+#define INT16DECODE(p, i)                                                                                    \
+    do {                                                                                                     \
+        (i) = (int16_t)((*(p)&0xff));                                                                        \
+        (p)++;                                                                                               \
+        (i) |= (int16_t)(((*(p)&0xff) << 8) | ((*(p)&0x80) ? ~0xffff : 0x0));                                \
+        (p)++;                                                                                               \
+    } while (0)
+
+#define UINT16DECODE(p, i)                                                                                   \
+    do {                                                                                                     \
+        (i) = (uint16_t)(*(p)&0xff);                                                                         \
+        (p)++;                                                                                               \
+        (i) |= (uint16_t)((*(p)&0xff) << 8);                                                                 \
+        (p)++;                                                                                               \
+    } while (0)
+
+#define INT32DECODE(p, i)                                                                                    \
+    do {                                                                                                     \
+        (i) = ((int32_t)(*(p)&0xff));                                                                        \
+        (p)++;                                                                                               \
+        (i) |= ((int32_t)(*(p)&0xff) << 8);                                                                  \
+        (p)++;                                                                                               \
+        (i) |= ((int32_t)(*(p)&0xff) << 16);                                                                 \
+        (p)++;                                                                                               \
+        (i) |= ((int32_t)(((*(p) & (unsigned)0xff) << 24) | ((*(p)&0x80) ? ~0xffffffffULL : 0x0ULL)));       \
+        (p)++;                                                                                               \
+    } while (0)
+
+#define UINT32DECODE(p, i)                                                                                   \
+    do {                                                                                                     \
+        (i) = (uint32_t)(*(p)&0xff);                                                                         \
+        (p)++;                                                                                               \
+        (i) |= ((uint32_t)(*(p)&0xff) << 8);                                                                 \
+        (p)++;                                                                                               \
+        (i) |= ((uint32_t)(*(p)&0xff) << 16);                                                                \
+        (p)++;                                                                                               \
+        (i) |= ((uint32_t)(*(p)&0xff) << 24);                                                                \
+        (p)++;                                                                                               \
+    } while (0)
+
+/* Decode a variable-sized buffer */
+/* (Assumes that the high bits of the integer will be zero) */
+#define DECODE_VAR(p, n, l)                                                                                  \
+    do {                                                                                                     \
+        size_t _i;                                                                                           \
+                                                                                                             \
+        n = 0;                                                                                               \
+        (p) += l;                                                                                            \
+        for (_i = 0; _i < l; _i++)                                                                           \
+            n = (n << 8) | *(--p);                                                                           \
+        (p) += l;                                                                                            \
+    } while (0)
+
+/* Decode a variable-sized buffer into a 32-bit unsigned integer */
+/* (Assumes that the high bits of the integer will be zero) */
+#define UINT32DECODE_VAR(p, n, l) DECODE_VAR(p, n, l)
+
+#define INT64DECODE(p, n)                                                                                    \
+    do {                                                                                                     \
+        /* WE DON'T CHECK FOR OVERFLOW! */                                                                   \
+        size_t _i;                                                                                           \
+                                                                                                             \
+        n = 0;                                                                                               \
+        (p) += 8;                                                                                            \
+        for (_i = 0; _i < sizeof(int64_t); _i++)                                                             \
+            n = (n << 8) | *(--p);                                                                           \
+        (p) += 8;                                                                                            \
+    } while (0)
+
+#define UINT64DECODE(p, n)                                                                                   \
+    do {                                                                                                     \
+        /* WE DON'T CHECK FOR OVERFLOW! */                                                                   \
+        size_t _i;                                                                                           \
+                                                                                                             \
+        n = 0;                                                                                               \
+        (p) += 8;                                                                                            \
+        for (_i = 0; _i < sizeof(uint64_t); _i++)                                                            \
+            n = (n << 8) | *(--p);                                                                           \
+        (p) += 8;                                                                                            \
+    } while (0)
+
+/* Decode a variable-sized buffer into a 64-bit unsigned integer */
+/* (Assumes that the high bits of the integer will be zero) */
+#define UINT64DECODE_VAR(p, n, l) DECODE_VAR(p, n, l)
+
+#define H5_DECODE_UNSIGNED(p, n)                                                                             \
+    do {                                                                                                     \
+        HDcompile_assert(sizeof(unsigned) == sizeof(uint32_t));                                              \
+        UINT32DECODE(p, n);                                                                                  \
+    } while (0)
+
+/* Assumes the endianness of uint64_t is the same as double */
+#define H5_DECODE_DOUBLE(p, n)                                                                               \
+    do {                                                                                                     \
+        uint64_t _n;                                                                                         \
+        size_t   _u;                                                                                         \
+                                                                                                             \
+        HDcompile_assert(sizeof(double) == 8);                                                               \
+        HDcompile_assert(sizeof(double) == sizeof(uint64_t));                                                \
+        _n = 0;                                                                                              \
+        (p) += 8;                                                                                            \
+        for (_u = 0; _u < sizeof(uint64_t); _u++)                                                            \
+            _n = (_n << 8) | *(--p);                                                                         \
+        H5MM_memcpy(&(n), &_n, sizeof(double));                                                              \
+        (p) += 8;                                                                                            \
+    } while (0)
+
+/* Macros to encode/decode offset/length's for storing in the file */
+#define H5_ENCODE_LENGTH_LEN(p, l, s)                                                                        \
+    do {                                                                                                     \
+        switch (s) {                                                                                         \
+            case 4:                                                                                          \
+                UINT32ENCODE(p, l);                                                                          \
+                break;                                                                                       \
+            case 8:                                                                                          \
+                UINT64ENCODE(p, l);                                                                          \
+                break;                                                                                       \
+            case 2:                                                                                          \
+                UINT16ENCODE(p, l);                                                                          \
+                break;                                                                                       \
+            default:                                                                                         \
+                assert("bad sizeof size" && 0);                                                              \
+        }                                                                                                    \
+    } while (0)
+
+#define H5_DECODE_LENGTH_LEN(p, l, s)                                                                        \
+    do {                                                                                                     \
+        switch (s) {                                                                                         \
+            case 4:                                                                                          \
+                UINT32DECODE(p, l);                                                                          \
+                break;                                                                                       \
+            case 8:                                                                                          \
+                UINT64DECODE(p, l);                                                                          \
+                break;                                                                                       \
+            case 2:                                                                                          \
+                UINT16DECODE(p, l);                                                                          \
+                break;                                                                                       \
+            default:                                                                                         \
+                assert("bad sizeof size" && 0);                                                              \
+        }                                                                                                    \
+    } while (0)
+
+#endif /* H5encode_H */
diff --git a/install/include/H5overflow.h b/install/include/H5overflow.h
new file mode 100644
index 0000000000..5003873227
--- /dev/null
+++ b/install/include/H5overflow.h
@@ -0,0 +1,2953 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Generated automatically by bin/make_overflow -- do not edit */
+/* Add new types to H5overflow.txt file */
+
+
+#ifndef H5overflow_H
+#define H5overflow_H
+
+
+/* Each type in this file is tested for assignment to the other types,
+ *      and range checks are defined for bad assignments at run-time.
+ */
+
+/* Assignment checks for unsigned */
+
+/* src: unsigned, dst: int8_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_INT8_T
+    #define ASSIGN_unsigned_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_INT8_T
+    #define ASSIGN_unsigned_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_INT8_T */
+    #define ASSIGN_unsigned_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: int8_t */
+
+/* src: unsigned, dst: int */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_INT
+    #define ASSIGN_unsigned_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_INT
+    #define ASSIGN_unsigned_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_INT */
+    #define ASSIGN_unsigned_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: int */
+
+/* src: unsigned, dst: long */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_LONG
+    #define ASSIGN_unsigned_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_LONG
+    #define ASSIGN_unsigned_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_LONG */
+    #define ASSIGN_unsigned_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: long */
+
+/* src: unsigned, dst: int64_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_INT64_T
+    #define ASSIGN_unsigned_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_INT64_T
+    #define ASSIGN_unsigned_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_INT64_T */
+    #define ASSIGN_unsigned_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: int64_t */
+
+/* src: unsigned, dst: uint8_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_UINT8_T
+    #define ASSIGN_unsigned_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_UINT8_T
+    #define ASSIGN_unsigned_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_unsigned_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: uint8_t */
+
+/* src: unsigned, dst: uint16_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_UINT16_T
+    #define ASSIGN_unsigned_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_UINT16_T
+    #define ASSIGN_unsigned_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_unsigned_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: uint16_t */
+
+/* src: unsigned, dst: uint32_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_UINT32_T
+    #define ASSIGN_unsigned_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_UINT32_T
+    #define ASSIGN_unsigned_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_unsigned_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: uint32_t */
+
+/* src: unsigned, dst: uint64_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_UINT64_T
+    #define ASSIGN_unsigned_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_UINT64_T
+    #define ASSIGN_unsigned_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_unsigned_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: uint64_t */
+
+/* src: unsigned, dst: ptrdiff_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_unsigned_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_unsigned_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_unsigned_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: ptrdiff_t */
+
+/* src: unsigned, dst: size_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_SIZE_T
+    #define ASSIGN_unsigned_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_SIZE_T
+    #define ASSIGN_unsigned_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_unsigned_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: size_t */
+
+/* src: unsigned, dst: ssize_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_unsigned_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_unsigned_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_unsigned_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: ssize_t */
+
+/* src: unsigned, dst: haddr_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_HADDR_T
+    #define ASSIGN_unsigned_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_HADDR_T
+    #define ASSIGN_unsigned_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_unsigned_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: haddr_t */
+
+/* src: unsigned, dst: hsize_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_unsigned_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_unsigned_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_unsigned_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: hsize_t */
+
+/* src: unsigned, dst: hssize_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_unsigned_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_unsigned_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_unsigned_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: hssize_t */
+
+/* src: unsigned, dst: h5_stat_size_t */
+#if H5_SIZEOF_UNSIGNED < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_unsigned_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UNSIGNED > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_unsigned_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UNSIGNED == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_unsigned_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: unsigned dst: h5_stat_size_t */
+
+
+/* Assignment checks for int8_t */
+
+/* src: int8_t, dst: unsigned */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_int8_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_int8_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_int8_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: unsigned */
+
+/* src: int8_t, dst: int */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_INT
+    #define ASSIGN_int8_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_INT
+    #define ASSIGN_int8_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_INT */
+    #define ASSIGN_int8_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: int */
+
+/* src: int8_t, dst: long */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_LONG
+    #define ASSIGN_int8_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_LONG
+    #define ASSIGN_int8_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_LONG */
+    #define ASSIGN_int8_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: long */
+
+/* src: int8_t, dst: int64_t */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_int8_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_int8_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_int8_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: int64_t */
+
+/* src: int8_t, dst: uint8_t */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_int8_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_int8_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_int8_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: uint8_t */
+
+/* src: int8_t, dst: uint16_t */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_int8_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_int8_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_int8_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: uint16_t */
+
+/* src: int8_t, dst: uint32_t */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_int8_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_int8_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_int8_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: uint32_t */
+
+/* src: int8_t, dst: uint64_t */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_int8_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_int8_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_int8_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: uint64_t */
+
+/* src: int8_t, dst: ptrdiff_t */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_int8_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_int8_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_int8_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: ptrdiff_t */
+
+/* src: int8_t, dst: size_t */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_int8_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_int8_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_int8_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: size_t */
+
+/* src: int8_t, dst: ssize_t */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_int8_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_int8_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_int8_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: ssize_t */
+
+/* src: int8_t, dst: haddr_t */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_int8_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_int8_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_int8_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: haddr_t */
+
+/* src: int8_t, dst: hsize_t */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_int8_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_int8_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_int8_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: hsize_t */
+
+/* src: int8_t, dst: hssize_t */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_int8_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_int8_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_int8_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: hssize_t */
+
+/* src: int8_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_INT8_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_int8_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT8_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_int8_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT8_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_int8_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int8_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for int */
+
+/* src: int, dst: unsigned */
+#if H5_SIZEOF_INT < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_int_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_int_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_int_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: unsigned */
+
+/* src: int, dst: int8_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_INT8_T
+    #define ASSIGN_int_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_INT8_T
+    #define ASSIGN_int_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_INT8_T */
+    #define ASSIGN_int_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: int8_t */
+
+/* src: int, dst: long */
+#if H5_SIZEOF_INT < H5_SIZEOF_LONG
+    #define ASSIGN_int_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_LONG
+    #define ASSIGN_int_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_LONG */
+    #define ASSIGN_int_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: long */
+
+/* src: int, dst: int64_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_INT64_T
+    #define ASSIGN_int_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_INT64_T
+    #define ASSIGN_int_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_INT64_T */
+    #define ASSIGN_int_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: int64_t */
+
+/* src: int, dst: uint8_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_UINT8_T
+    #define ASSIGN_int_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_UINT8_T
+    #define ASSIGN_int_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_int_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: uint8_t */
+
+/* src: int, dst: uint16_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_UINT16_T
+    #define ASSIGN_int_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_UINT16_T
+    #define ASSIGN_int_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_int_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: uint16_t */
+
+/* src: int, dst: uint32_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_UINT32_T
+    #define ASSIGN_int_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_UINT32_T
+    #define ASSIGN_int_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_int_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: uint32_t */
+
+/* src: int, dst: uint64_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_UINT64_T
+    #define ASSIGN_int_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_UINT64_T
+    #define ASSIGN_int_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_int_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: uint64_t */
+
+/* src: int, dst: ptrdiff_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_int_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_int_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_int_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: ptrdiff_t */
+
+/* src: int, dst: size_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_SIZE_T
+    #define ASSIGN_int_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_SIZE_T
+    #define ASSIGN_int_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_int_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: size_t */
+
+/* src: int, dst: ssize_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_int_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_int_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_int_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: ssize_t */
+
+/* src: int, dst: haddr_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_HADDR_T
+    #define ASSIGN_int_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_HADDR_T
+    #define ASSIGN_int_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_int_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: haddr_t */
+
+/* src: int, dst: hsize_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_int_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_int_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_int_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: hsize_t */
+
+/* src: int, dst: hssize_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_int_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_int_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_int_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: hssize_t */
+
+/* src: int, dst: h5_stat_size_t */
+#if H5_SIZEOF_INT < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_int_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_int_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_int_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int dst: h5_stat_size_t */
+
+
+/* Assignment checks for long */
+
+/* src: long, dst: unsigned */
+#if H5_SIZEOF_LONG < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_long_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_long_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_long_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: unsigned */
+
+/* src: long, dst: int8_t */
+#if H5_SIZEOF_LONG < H5_SIZEOF_INT8_T
+    #define ASSIGN_long_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_INT8_T
+    #define ASSIGN_long_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_INT8_T */
+    #define ASSIGN_long_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: int8_t */
+
+/* src: long, dst: int */
+#if H5_SIZEOF_LONG < H5_SIZEOF_INT
+    #define ASSIGN_long_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_INT
+    #define ASSIGN_long_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_INT */
+    #define ASSIGN_long_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: int */
+
+/* src: long, dst: int64_t */
+#if H5_SIZEOF_LONG < H5_SIZEOF_INT64_T
+    #define ASSIGN_long_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_INT64_T
+    #define ASSIGN_long_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_INT64_T */
+    #define ASSIGN_long_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: int64_t */
+
+/* src: long, dst: uint8_t */
+#if H5_SIZEOF_LONG < H5_SIZEOF_UINT8_T
+    #define ASSIGN_long_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_UINT8_T
+    #define ASSIGN_long_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_long_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: uint8_t */
+
+/* src: long, dst: uint16_t */
+#if H5_SIZEOF_LONG < H5_SIZEOF_UINT16_T
+    #define ASSIGN_long_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_UINT16_T
+    #define ASSIGN_long_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_long_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: uint16_t */
+
+/* src: long, dst: uint32_t */
+#if H5_SIZEOF_LONG < H5_SIZEOF_UINT32_T
+    #define ASSIGN_long_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_UINT32_T
+    #define ASSIGN_long_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_long_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: uint32_t */
+
+/* src: long, dst: uint64_t */
+#if H5_SIZEOF_LONG < H5_SIZEOF_UINT64_T
+    #define ASSIGN_long_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_UINT64_T
+    #define ASSIGN_long_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_long_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: uint64_t */
+
+/* src: long, dst: ptrdiff_t */
+#if H5_SIZEOF_LONG < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_long_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_long_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_long_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: ptrdiff_t */
+
+/* src: long, dst: size_t */
+#if H5_SIZEOF_LONG < H5_SIZEOF_SIZE_T
+    #define ASSIGN_long_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_SIZE_T
+    #define ASSIGN_long_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_long_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: size_t */
+
+/* src: long, dst: ssize_t */
+#if H5_SIZEOF_LONG < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_long_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_long_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_long_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: ssize_t */
+
+/* src: long, dst: haddr_t */
+#if H5_SIZEOF_LONG < H5_SIZEOF_HADDR_T
+    #define ASSIGN_long_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_HADDR_T
+    #define ASSIGN_long_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_long_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: haddr_t */
+
+/* src: long, dst: hsize_t */
+#if H5_SIZEOF_LONG < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_long_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_long_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_long_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: hsize_t */
+
+/* src: long, dst: hssize_t */
+#if H5_SIZEOF_LONG < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_long_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_long_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_long_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: hssize_t */
+
+/* src: long, dst: h5_stat_size_t */
+#if H5_SIZEOF_LONG < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_long_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_LONG > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_long_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_LONG == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_long_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: long dst: h5_stat_size_t */
+
+
+/* Assignment checks for int64_t */
+
+/* src: int64_t, dst: unsigned */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_int64_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_int64_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_int64_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: unsigned */
+
+/* src: int64_t, dst: int8_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_INT8_T
+    #define ASSIGN_int64_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_INT8_T
+    #define ASSIGN_int64_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_INT8_T */
+    #define ASSIGN_int64_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: int8_t */
+
+/* src: int64_t, dst: int */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_INT
+    #define ASSIGN_int64_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_INT
+    #define ASSIGN_int64_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_INT */
+    #define ASSIGN_int64_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: int */
+
+/* src: int64_t, dst: long */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_LONG
+    #define ASSIGN_int64_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_LONG
+    #define ASSIGN_int64_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_LONG */
+    #define ASSIGN_int64_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: long */
+
+/* src: int64_t, dst: uint8_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_int64_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_int64_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_int64_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: uint8_t */
+
+/* src: int64_t, dst: uint16_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_int64_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_int64_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_int64_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: uint16_t */
+
+/* src: int64_t, dst: uint32_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_int64_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_int64_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_int64_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: uint32_t */
+
+/* src: int64_t, dst: uint64_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_int64_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_int64_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_int64_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: uint64_t */
+
+/* src: int64_t, dst: ptrdiff_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_int64_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_int64_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_int64_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: ptrdiff_t */
+
+/* src: int64_t, dst: size_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_int64_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_int64_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_int64_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: size_t */
+
+/* src: int64_t, dst: ssize_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_int64_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_int64_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_int64_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: ssize_t */
+
+/* src: int64_t, dst: haddr_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_int64_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_int64_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_int64_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: haddr_t */
+
+/* src: int64_t, dst: hsize_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_int64_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_int64_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_int64_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: hsize_t */
+
+/* src: int64_t, dst: hssize_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_int64_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_int64_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_int64_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: hssize_t */
+
+/* src: int64_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_INT64_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_int64_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_INT64_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_int64_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_INT64_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_int64_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: int64_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for uint8_t */
+
+/* src: uint8_t, dst: unsigned */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint8_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint8_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_uint8_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: unsigned */
+
+/* src: uint8_t, dst: int8_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_INT8_T
+    #define ASSIGN_uint8_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_INT8_T
+    #define ASSIGN_uint8_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_INT8_T */
+    #define ASSIGN_uint8_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: int8_t */
+
+/* src: uint8_t, dst: int */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_INT
+    #define ASSIGN_uint8_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_INT
+    #define ASSIGN_uint8_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_INT */
+    #define ASSIGN_uint8_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: int */
+
+/* src: uint8_t, dst: long */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_LONG
+    #define ASSIGN_uint8_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_LONG
+    #define ASSIGN_uint8_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_LONG */
+    #define ASSIGN_uint8_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: long */
+
+/* src: uint8_t, dst: int64_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_uint8_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_uint8_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_uint8_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: int64_t */
+
+/* src: uint8_t, dst: uint16_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_uint8_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_uint8_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_uint8_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: uint16_t */
+
+/* src: uint8_t, dst: uint32_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_uint8_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_uint8_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_uint8_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: uint32_t */
+
+/* src: uint8_t, dst: uint64_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_uint8_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_uint8_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_uint8_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: uint64_t */
+
+/* src: uint8_t, dst: ptrdiff_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint8_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint8_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_uint8_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: ptrdiff_t */
+
+/* src: uint8_t, dst: size_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint8_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint8_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_uint8_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: size_t */
+
+/* src: uint8_t, dst: ssize_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint8_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint8_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_uint8_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: ssize_t */
+
+/* src: uint8_t, dst: haddr_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint8_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint8_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_uint8_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: haddr_t */
+
+/* src: uint8_t, dst: hsize_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint8_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint8_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_uint8_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: hsize_t */
+
+/* src: uint8_t, dst: hssize_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint8_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint8_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_uint8_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: hssize_t */
+
+/* src: uint8_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_UINT8_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint8_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT8_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint8_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT8_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_uint8_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint8_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for uint16_t */
+
+/* src: uint16_t, dst: unsigned */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint16_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint16_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_uint16_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: unsigned */
+
+/* src: uint16_t, dst: int8_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_INT8_T
+    #define ASSIGN_uint16_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_INT8_T
+    #define ASSIGN_uint16_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_INT8_T */
+    #define ASSIGN_uint16_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: int8_t */
+
+/* src: uint16_t, dst: int */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_INT
+    #define ASSIGN_uint16_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_INT
+    #define ASSIGN_uint16_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_INT */
+    #define ASSIGN_uint16_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: int */
+
+/* src: uint16_t, dst: long */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_LONG
+    #define ASSIGN_uint16_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_LONG
+    #define ASSIGN_uint16_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_LONG */
+    #define ASSIGN_uint16_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: long */
+
+/* src: uint16_t, dst: int64_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_uint16_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_uint16_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_uint16_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: int64_t */
+
+/* src: uint16_t, dst: uint8_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_uint16_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_uint16_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_uint16_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: uint8_t */
+
+/* src: uint16_t, dst: uint32_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_uint16_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_uint16_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_uint16_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: uint32_t */
+
+/* src: uint16_t, dst: uint64_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_uint16_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_uint16_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_uint16_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: uint64_t */
+
+/* src: uint16_t, dst: ptrdiff_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint16_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint16_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_uint16_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: ptrdiff_t */
+
+/* src: uint16_t, dst: size_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint16_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint16_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_uint16_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: size_t */
+
+/* src: uint16_t, dst: ssize_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint16_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint16_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_uint16_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: ssize_t */
+
+/* src: uint16_t, dst: haddr_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint16_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint16_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_uint16_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: haddr_t */
+
+/* src: uint16_t, dst: hsize_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint16_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint16_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_uint16_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: hsize_t */
+
+/* src: uint16_t, dst: hssize_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint16_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint16_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_uint16_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: hssize_t */
+
+/* src: uint16_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_UINT16_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint16_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT16_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint16_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT16_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_uint16_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint16_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for uint32_t */
+
+/* src: uint32_t, dst: unsigned */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint32_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint32_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_uint32_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: unsigned */
+
+/* src: uint32_t, dst: int8_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_INT8_T
+    #define ASSIGN_uint32_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_INT8_T
+    #define ASSIGN_uint32_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_INT8_T */
+    #define ASSIGN_uint32_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: int8_t */
+
+/* src: uint32_t, dst: int */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_INT
+    #define ASSIGN_uint32_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_INT
+    #define ASSIGN_uint32_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_INT */
+    #define ASSIGN_uint32_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: int */
+
+/* src: uint32_t, dst: long */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_LONG
+    #define ASSIGN_uint32_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_LONG
+    #define ASSIGN_uint32_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_LONG */
+    #define ASSIGN_uint32_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: long */
+
+/* src: uint32_t, dst: int64_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_uint32_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_uint32_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_uint32_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: int64_t */
+
+/* src: uint32_t, dst: uint8_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_uint32_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_uint32_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_uint32_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: uint8_t */
+
+/* src: uint32_t, dst: uint16_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_uint32_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_uint32_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_uint32_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: uint16_t */
+
+/* src: uint32_t, dst: uint64_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_uint32_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_uint32_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_uint32_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: uint64_t */
+
+/* src: uint32_t, dst: ptrdiff_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint32_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint32_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_uint32_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: ptrdiff_t */
+
+/* src: uint32_t, dst: size_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint32_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint32_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_uint32_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: size_t */
+
+/* src: uint32_t, dst: ssize_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint32_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint32_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_uint32_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: ssize_t */
+
+/* src: uint32_t, dst: haddr_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint32_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint32_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_uint32_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: haddr_t */
+
+/* src: uint32_t, dst: hsize_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint32_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint32_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_uint32_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: hsize_t */
+
+/* src: uint32_t, dst: hssize_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint32_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint32_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_uint32_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: hssize_t */
+
+/* src: uint32_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_UINT32_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint32_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT32_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint32_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT32_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_uint32_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint32_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for uint64_t */
+
+/* src: uint64_t, dst: unsigned */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint64_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_uint64_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_uint64_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: unsigned */
+
+/* src: uint64_t, dst: int8_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_INT8_T
+    #define ASSIGN_uint64_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_INT8_T
+    #define ASSIGN_uint64_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_INT8_T */
+    #define ASSIGN_uint64_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: int8_t */
+
+/* src: uint64_t, dst: int */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_INT
+    #define ASSIGN_uint64_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_INT
+    #define ASSIGN_uint64_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_INT */
+    #define ASSIGN_uint64_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: int */
+
+/* src: uint64_t, dst: long */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_LONG
+    #define ASSIGN_uint64_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_LONG
+    #define ASSIGN_uint64_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_LONG */
+    #define ASSIGN_uint64_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: long */
+
+/* src: uint64_t, dst: int64_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_uint64_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_uint64_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_uint64_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: int64_t */
+
+/* src: uint64_t, dst: uint8_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_uint64_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_uint64_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_uint64_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: uint8_t */
+
+/* src: uint64_t, dst: uint16_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_uint64_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_uint64_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_uint64_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: uint16_t */
+
+/* src: uint64_t, dst: uint32_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_uint64_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_uint64_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_uint64_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: uint32_t */
+
+/* src: uint64_t, dst: ptrdiff_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint64_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_uint64_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_uint64_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: ptrdiff_t */
+
+/* src: uint64_t, dst: size_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint64_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_uint64_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_uint64_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: size_t */
+
+/* src: uint64_t, dst: ssize_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint64_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_uint64_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_uint64_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: ssize_t */
+
+/* src: uint64_t, dst: haddr_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint64_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_uint64_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_uint64_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: haddr_t */
+
+/* src: uint64_t, dst: hsize_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint64_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_uint64_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_uint64_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: hsize_t */
+
+/* src: uint64_t, dst: hssize_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint64_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_uint64_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_uint64_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: hssize_t */
+
+/* src: uint64_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_UINT64_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint64_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_UINT64_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_uint64_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_UINT64_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_uint64_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: uint64_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for ptrdiff_t */
+
+/* src: ptrdiff_t, dst: unsigned */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_ptrdiff_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_ptrdiff_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_ptrdiff_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: unsigned */
+
+/* src: ptrdiff_t, dst: int8_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_INT8_T
+    #define ASSIGN_ptrdiff_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_INT8_T
+    #define ASSIGN_ptrdiff_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_INT8_T */
+    #define ASSIGN_ptrdiff_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: int8_t */
+
+/* src: ptrdiff_t, dst: int */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_INT
+    #define ASSIGN_ptrdiff_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_INT
+    #define ASSIGN_ptrdiff_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_INT */
+    #define ASSIGN_ptrdiff_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: int */
+
+/* src: ptrdiff_t, dst: long */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_LONG
+    #define ASSIGN_ptrdiff_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_LONG
+    #define ASSIGN_ptrdiff_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_LONG */
+    #define ASSIGN_ptrdiff_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: long */
+
+/* src: ptrdiff_t, dst: int64_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_ptrdiff_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_ptrdiff_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_ptrdiff_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: int64_t */
+
+/* src: ptrdiff_t, dst: uint8_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_ptrdiff_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_ptrdiff_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_ptrdiff_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: uint8_t */
+
+/* src: ptrdiff_t, dst: uint16_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_ptrdiff_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_ptrdiff_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_ptrdiff_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: uint16_t */
+
+/* src: ptrdiff_t, dst: uint32_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_ptrdiff_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_ptrdiff_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_ptrdiff_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: uint32_t */
+
+/* src: ptrdiff_t, dst: uint64_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_ptrdiff_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_ptrdiff_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_ptrdiff_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: uint64_t */
+
+/* src: ptrdiff_t, dst: size_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_ptrdiff_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_ptrdiff_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_ptrdiff_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: size_t */
+
+/* src: ptrdiff_t, dst: ssize_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_ptrdiff_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_ptrdiff_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_ptrdiff_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: ssize_t */
+
+/* src: ptrdiff_t, dst: haddr_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_ptrdiff_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_ptrdiff_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_ptrdiff_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: haddr_t */
+
+/* src: ptrdiff_t, dst: hsize_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_ptrdiff_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_ptrdiff_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_ptrdiff_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: hsize_t */
+
+/* src: ptrdiff_t, dst: hssize_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_ptrdiff_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_ptrdiff_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_ptrdiff_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: hssize_t */
+
+/* src: ptrdiff_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_PTRDIFF_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_ptrdiff_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_PTRDIFF_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_ptrdiff_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_PTRDIFF_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_ptrdiff_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ptrdiff_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for size_t */
+
+/* src: size_t, dst: unsigned */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_size_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_size_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_size_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: unsigned */
+
+/* src: size_t, dst: int8_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_INT8_T
+    #define ASSIGN_size_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_INT8_T
+    #define ASSIGN_size_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_INT8_T */
+    #define ASSIGN_size_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: int8_t */
+
+/* src: size_t, dst: int */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_INT
+    #define ASSIGN_size_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_INT
+    #define ASSIGN_size_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_INT */
+    #define ASSIGN_size_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: int */
+
+/* src: size_t, dst: long */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_LONG
+    #define ASSIGN_size_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_LONG
+    #define ASSIGN_size_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_LONG */
+    #define ASSIGN_size_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: long */
+
+/* src: size_t, dst: int64_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_size_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_size_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_size_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: int64_t */
+
+/* src: size_t, dst: uint8_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_size_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_size_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_size_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: uint8_t */
+
+/* src: size_t, dst: uint16_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_size_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_size_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_size_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: uint16_t */
+
+/* src: size_t, dst: uint32_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_size_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_size_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_size_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: uint32_t */
+
+/* src: size_t, dst: uint64_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_size_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_size_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_size_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: uint64_t */
+
+/* src: size_t, dst: ptrdiff_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_size_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_size_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_size_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: ptrdiff_t */
+
+/* src: size_t, dst: ssize_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_size_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_size_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_size_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: ssize_t */
+
+/* src: size_t, dst: haddr_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_size_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_size_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_size_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: haddr_t */
+
+/* src: size_t, dst: hsize_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_size_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_size_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_size_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: hsize_t */
+
+/* src: size_t, dst: hssize_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_size_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_size_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_size_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: hssize_t */
+
+/* src: size_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_SIZE_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_size_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SIZE_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_size_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SIZE_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_size_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: size_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for ssize_t */
+
+/* src: ssize_t, dst: unsigned */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_ssize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_ssize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_ssize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: unsigned */
+
+/* src: ssize_t, dst: int8_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_INT8_T
+    #define ASSIGN_ssize_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_INT8_T
+    #define ASSIGN_ssize_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_INT8_T */
+    #define ASSIGN_ssize_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: int8_t */
+
+/* src: ssize_t, dst: int */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_INT
+    #define ASSIGN_ssize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_INT
+    #define ASSIGN_ssize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_INT */
+    #define ASSIGN_ssize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: int */
+
+/* src: ssize_t, dst: long */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_LONG
+    #define ASSIGN_ssize_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_LONG
+    #define ASSIGN_ssize_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_LONG */
+    #define ASSIGN_ssize_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: long */
+
+/* src: ssize_t, dst: int64_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_ssize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_ssize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_ssize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: int64_t */
+
+/* src: ssize_t, dst: uint8_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_ssize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_ssize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_ssize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: uint8_t */
+
+/* src: ssize_t, dst: uint16_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_ssize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_ssize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_ssize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: uint16_t */
+
+/* src: ssize_t, dst: uint32_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_ssize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_ssize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_ssize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: uint32_t */
+
+/* src: ssize_t, dst: uint64_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_ssize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_ssize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_ssize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: uint64_t */
+
+/* src: ssize_t, dst: ptrdiff_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_ssize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_ssize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_ssize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: ptrdiff_t */
+
+/* src: ssize_t, dst: size_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_ssize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_ssize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_ssize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: size_t */
+
+/* src: ssize_t, dst: haddr_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_ssize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_ssize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_ssize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: haddr_t */
+
+/* src: ssize_t, dst: hsize_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_ssize_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_ssize_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_ssize_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: hsize_t */
+
+/* src: ssize_t, dst: hssize_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_ssize_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_ssize_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_ssize_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: hssize_t */
+
+/* src: ssize_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_SSIZE_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_ssize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_SSIZE_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_ssize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_SSIZE_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_ssize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: ssize_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for haddr_t */
+
+/* src: haddr_t, dst: unsigned */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_haddr_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_haddr_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_haddr_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: unsigned */
+
+/* src: haddr_t, dst: int8_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_INT8_T
+    #define ASSIGN_haddr_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_INT8_T
+    #define ASSIGN_haddr_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_INT8_T */
+    #define ASSIGN_haddr_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: int8_t */
+
+/* src: haddr_t, dst: int */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_INT
+    #define ASSIGN_haddr_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_INT
+    #define ASSIGN_haddr_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_INT */
+    #define ASSIGN_haddr_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: int */
+
+/* src: haddr_t, dst: long */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_LONG
+    #define ASSIGN_haddr_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_LONG
+    #define ASSIGN_haddr_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_LONG */
+    #define ASSIGN_haddr_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: long */
+
+/* src: haddr_t, dst: int64_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_haddr_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_haddr_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_haddr_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: int64_t */
+
+/* src: haddr_t, dst: uint8_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_haddr_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_haddr_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_haddr_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: uint8_t */
+
+/* src: haddr_t, dst: uint16_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_haddr_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_haddr_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_haddr_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: uint16_t */
+
+/* src: haddr_t, dst: uint32_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_haddr_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_haddr_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_haddr_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: uint32_t */
+
+/* src: haddr_t, dst: uint64_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_haddr_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_haddr_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_haddr_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: uint64_t */
+
+/* src: haddr_t, dst: ptrdiff_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_haddr_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_haddr_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_haddr_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: ptrdiff_t */
+
+/* src: haddr_t, dst: size_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_haddr_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_haddr_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_haddr_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: size_t */
+
+/* src: haddr_t, dst: ssize_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_haddr_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_haddr_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_haddr_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: ssize_t */
+
+/* src: haddr_t, dst: hsize_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_haddr_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_haddr_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_haddr_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: hsize_t */
+
+/* src: haddr_t, dst: hssize_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_haddr_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_haddr_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_haddr_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: hssize_t */
+
+/* src: haddr_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_HADDR_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_haddr_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HADDR_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_haddr_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HADDR_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_haddr_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: haddr_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for hsize_t */
+
+/* src: hsize_t, dst: unsigned */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_hsize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_hsize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_hsize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: unsigned */
+
+/* src: hsize_t, dst: int8_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_INT8_T
+    #define ASSIGN_hsize_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_INT8_T
+    #define ASSIGN_hsize_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_INT8_T */
+    #define ASSIGN_hsize_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: int8_t */
+
+/* src: hsize_t, dst: int */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_INT
+    #define ASSIGN_hsize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_INT
+    #define ASSIGN_hsize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_INT */
+    #define ASSIGN_hsize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: int */
+
+/* src: hsize_t, dst: long */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_LONG
+    #define ASSIGN_hsize_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_LONG
+    #define ASSIGN_hsize_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_LONG */
+    #define ASSIGN_hsize_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: long */
+
+/* src: hsize_t, dst: int64_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_hsize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_hsize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_hsize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: int64_t */
+
+/* src: hsize_t, dst: uint8_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_hsize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_hsize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_hsize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: uint8_t */
+
+/* src: hsize_t, dst: uint16_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_hsize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_hsize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_hsize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: uint16_t */
+
+/* src: hsize_t, dst: uint32_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_hsize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_hsize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_hsize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: uint32_t */
+
+/* src: hsize_t, dst: uint64_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_hsize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_hsize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_hsize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: uint64_t */
+
+/* src: hsize_t, dst: ptrdiff_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_hsize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_hsize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_hsize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: ptrdiff_t */
+
+/* src: hsize_t, dst: size_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_hsize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_hsize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_hsize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: size_t */
+
+/* src: hsize_t, dst: ssize_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_hsize_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_hsize_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_hsize_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: ssize_t */
+
+/* src: hsize_t, dst: haddr_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_hsize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_hsize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_hsize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: haddr_t */
+
+/* src: hsize_t, dst: hssize_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_hsize_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_hsize_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_hsize_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: hssize_t */
+
+/* src: hsize_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_HSIZE_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_hsize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSIZE_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_hsize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSIZE_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_hsize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hsize_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for hssize_t */
+
+/* src: hssize_t, dst: unsigned */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_hssize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_hssize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_hssize_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: unsigned */
+
+/* src: hssize_t, dst: int8_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_INT8_T
+    #define ASSIGN_hssize_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_INT8_T
+    #define ASSIGN_hssize_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_INT8_T */
+    #define ASSIGN_hssize_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: int8_t */
+
+/* src: hssize_t, dst: int */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_INT
+    #define ASSIGN_hssize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_INT
+    #define ASSIGN_hssize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_INT */
+    #define ASSIGN_hssize_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: int */
+
+/* src: hssize_t, dst: long */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_LONG
+    #define ASSIGN_hssize_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_LONG
+    #define ASSIGN_hssize_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_LONG */
+    #define ASSIGN_hssize_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: long */
+
+/* src: hssize_t, dst: int64_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_hssize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_hssize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_hssize_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: int64_t */
+
+/* src: hssize_t, dst: uint8_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_hssize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_hssize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_hssize_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: uint8_t */
+
+/* src: hssize_t, dst: uint16_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_hssize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_hssize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_hssize_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: uint16_t */
+
+/* src: hssize_t, dst: uint32_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_hssize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_hssize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_hssize_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: uint32_t */
+
+/* src: hssize_t, dst: uint64_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_hssize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_hssize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_hssize_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: uint64_t */
+
+/* src: hssize_t, dst: ptrdiff_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_hssize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_hssize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_hssize_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: ptrdiff_t */
+
+/* src: hssize_t, dst: size_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_hssize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_hssize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_hssize_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: size_t */
+
+/* src: hssize_t, dst: ssize_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_hssize_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_hssize_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_hssize_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: ssize_t */
+
+/* src: hssize_t, dst: haddr_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_hssize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_hssize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_hssize_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: haddr_t */
+
+/* src: hssize_t, dst: hsize_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_hssize_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_hssize_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_hssize_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: hsize_t */
+
+/* src: hssize_t, dst: h5_stat_size_t */
+#if H5_SIZEOF_HSSIZE_T < H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_hssize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_HSSIZE_T > H5_SIZEOF_H5_STAT_SIZE_T
+    #define ASSIGN_hssize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_HSSIZE_T == H5_SIZEOF_H5_STAT_SIZE_T */
+    #define ASSIGN_hssize_t_TO_h5_stat_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SIGNED_TO_UNSIGNED(dst, dsttype, src, srctype)
+#endif /* src: hssize_t dst: h5_stat_size_t */
+
+
+/* Assignment checks for h5_stat_size_t */
+
+/* src: h5_stat_size_t, dst: unsigned */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_UNSIGNED
+    #define ASSIGN_h5_stat_size_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_UNSIGNED
+    #define ASSIGN_h5_stat_size_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_UNSIGNED */
+    #define ASSIGN_h5_stat_size_t_TO_unsigned(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: unsigned */
+
+/* src: h5_stat_size_t, dst: int8_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_INT8_T
+    #define ASSIGN_h5_stat_size_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_INT8_T
+    #define ASSIGN_h5_stat_size_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_INT8_T */
+    #define ASSIGN_h5_stat_size_t_TO_int8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: int8_t */
+
+/* src: h5_stat_size_t, dst: int */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_INT
+    #define ASSIGN_h5_stat_size_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_INT
+    #define ASSIGN_h5_stat_size_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_INT */
+    #define ASSIGN_h5_stat_size_t_TO_int(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: int */
+
+/* src: h5_stat_size_t, dst: long */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_LONG
+    #define ASSIGN_h5_stat_size_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_LONG
+    #define ASSIGN_h5_stat_size_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_LONG */
+    #define ASSIGN_h5_stat_size_t_TO_long(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: long */
+
+/* src: h5_stat_size_t, dst: int64_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_INT64_T
+    #define ASSIGN_h5_stat_size_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_INT64_T
+    #define ASSIGN_h5_stat_size_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_INT64_T */
+    #define ASSIGN_h5_stat_size_t_TO_int64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: int64_t */
+
+/* src: h5_stat_size_t, dst: uint8_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_UINT8_T
+    #define ASSIGN_h5_stat_size_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_UINT8_T
+    #define ASSIGN_h5_stat_size_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_UINT8_T */
+    #define ASSIGN_h5_stat_size_t_TO_uint8_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: uint8_t */
+
+/* src: h5_stat_size_t, dst: uint16_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_UINT16_T
+    #define ASSIGN_h5_stat_size_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_UINT16_T
+    #define ASSIGN_h5_stat_size_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_UINT16_T */
+    #define ASSIGN_h5_stat_size_t_TO_uint16_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: uint16_t */
+
+/* src: h5_stat_size_t, dst: uint32_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_UINT32_T
+    #define ASSIGN_h5_stat_size_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_UINT32_T
+    #define ASSIGN_h5_stat_size_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_UINT32_T */
+    #define ASSIGN_h5_stat_size_t_TO_uint32_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: uint32_t */
+
+/* src: h5_stat_size_t, dst: uint64_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_UINT64_T
+    #define ASSIGN_h5_stat_size_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_UINT64_T
+    #define ASSIGN_h5_stat_size_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_UINT64_T */
+    #define ASSIGN_h5_stat_size_t_TO_uint64_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: uint64_t */
+
+/* src: h5_stat_size_t, dst: ptrdiff_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_h5_stat_size_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_PTRDIFF_T
+    #define ASSIGN_h5_stat_size_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_PTRDIFF_T */
+    #define ASSIGN_h5_stat_size_t_TO_ptrdiff_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: ptrdiff_t */
+
+/* src: h5_stat_size_t, dst: size_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_SIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_SIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_SIZE_T */
+    #define ASSIGN_h5_stat_size_t_TO_size_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: size_t */
+
+/* src: h5_stat_size_t, dst: ssize_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_SSIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_SSIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_SSIZE_T */
+    #define ASSIGN_h5_stat_size_t_TO_ssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: ssize_t */
+
+/* src: h5_stat_size_t, dst: haddr_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_HADDR_T
+    #define ASSIGN_h5_stat_size_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_HADDR_T
+    #define ASSIGN_h5_stat_size_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_HADDR_T */
+    #define ASSIGN_h5_stat_size_t_TO_haddr_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: haddr_t */
+
+/* src: h5_stat_size_t, dst: hsize_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_HSIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_HSIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_HSIZE_T */
+    #define ASSIGN_h5_stat_size_t_TO_hsize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_SAME_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: hsize_t */
+
+/* src: h5_stat_size_t, dst: hssize_t */
+#if H5_SIZEOF_H5_STAT_SIZE_T < H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_LARGER_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#elif H5_SIZEOF_H5_STAT_SIZE_T > H5_SIZEOF_HSSIZE_T
+    #define ASSIGN_h5_stat_size_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SMALLER_SIZE(dst, dsttype, src, srctype)
+#else /* H5_SIZEOF_H5_STAT_SIZE_T == H5_SIZEOF_HSSIZE_T */
+    #define ASSIGN_h5_stat_size_t_TO_hssize_t(dst, dsttype, src, srctype) \
+        ASSIGN_TO_SAME_SIZE_UNSIGNED_TO_SIGNED(dst, dsttype, src, srctype)
+#endif /* src: h5_stat_size_t dst: hssize_t */
+
+#endif /* H5overflow_H */
+
diff --git a/install/include/H5pubconf.h b/install/include/H5pubconf.h
new file mode 100644
index 0000000000..cef68e432e
--- /dev/null
+++ b/install/include/H5pubconf.h
@@ -0,0 +1,660 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* H5pubconf.h  Generated By CMake during the configuration */
+
+#ifndef H5_CONFIG_H_
+#define H5_CONFIG_H_
+
+/* Define if this is a Windows machine */
+/* #undef H5_HAVE_WINDOWS */
+
+/* Define if using MinGW */
+/* #undef H5_HAVE_MINGW */
+
+/* Define if on the Windows platform and using the Win32 API */
+/* #undef H5_HAVE_WIN32_API */
+
+/* Define if using a Windows compiler (i.e. Visual Studio) */
+/* #undef H5_HAVE_VISUAL_STUDIO */
+
+/* Define the default plugins path to compile */
+#define H5_DEFAULT_PLUGINDIR "/usr/local/hdf5/lib/plugin"
+
+/* Define if dev_t is a scalar */
+#define H5_DEV_T_IS_SCALAR 1
+
+/* Define if your system is IBM ppc64le and cannot convert some long double
+   values correctly. */
+/* #undef H5_DISABLE_SOME_LDOUBLE_CONV */
+
+/* Define to dummy `main' function (if any) required to link to the Fortran
+   libraries. */
+/* #undef H5_FC_DUMMY_MAIN */
+
+/* Define if F77 and FC dummy `main' functions are identical. */
+/* #undef H5_FC_DUMMY_MAIN_EQ_F77 */
+
+/* Define to a macro mangling the given C identifier (in lower and upper
+   case), which must not contain underscores, for linking with Fortran. */
+#define H5_FC_FUNC(name,NAME) name ## _
+
+/* As FC_FUNC, but for C identifiers containing underscores. */
+#define H5_FC_FUNC_(name,NAME) name ## _
+
+/* Define if Fortran C_LONG_DOUBLE is different from C_DOUBLE */
+#define H5_FORTRAN_C_LONG_DOUBLE_IS_UNIQUE 
+
+/* Define if we have Fortran C_LONG_DOUBLE */
+#define H5_FORTRAN_HAVE_C_LONG_DOUBLE 
+
+/* Define if we have Fortran intrinsic C_SIZEOF */
+/* #undef H5_FORTRAN_HAVE_C_SIZEOF */
+
+/* Define if we have Fortran intrinsic SIZEOF */
+/* #undef H5_FORTRAN_HAVE_SIZEOF */
+
+/* Define if we have Fortran intrinsic STORAGE_SIZE */
+/* #undef H5_FORTRAN_HAVE_STORAGE_SIZE */
+
+/* Determine the size of C long double */
+/* #undef H5_FORTRAN_SIZEOF_LONG_DOUBLE */
+
+/* Define Fortran compiler ID */
+#define H5_Fortran_COMPILER_ID 
+
+/* Define number of valid Fortran INTEGER KINDs (must be defined before F_IKIND)*/
+/* #undef H5_H5CONFIG_F_NUM_IKIND */
+
+/* Define valid Fortran INTEGER KINDs */
+/* #undef H5_H5CONFIG_F_IKIND */
+
+/* Define number of valid Fortran REAL KINDs (must be defined before F_RKIND) */
+/* #undef H5_H5CONFIG_F_NUM_RKIND */
+
+/* Define valid Fortran REAL KINDs */
+/* #undef H5_H5CONFIG_F_RKIND */
+
+/* Define valid Fortran REAL KINDs Sizeof */
+/* #undef H5_H5CONFIG_F_RKIND_SIZEOF */
+
+/* Define to 1 if you have the `alarm' function. */
+#define H5_HAVE_ALARM 1
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define H5_HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the `asprintf' function. */
+#define H5_HAVE_ASPRINTF 1
+
+/* Define if the __attribute__(()) extension is present */
+#define H5_HAVE_ATTRIBUTE 1
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#define H5_HAVE_CLOCK_GETTIME 1
+
+/* Define to 1 if CLOCK_MONOTONIC_COARSE is available */
+#define H5_HAVE_CLOCK_MONOTONIC_COARSE 1
+
+/* Define if the function stack tracing code is to be compiled in */
+/* #undef H5_HAVE_CODESTACK */
+
+/* Define to 1 if you have the <curl/curl.h> header file. */
+/* #undef H5_HAVE_CURL_CURL_H */
+
+/* Define if Darwin or Mac OS X */
+/* #undef H5_HAVE_DARWIN */
+
+/* Define if the direct I/O virtual file driver (VFD) should be compiled */
+/* #undef H5_HAVE_DIRECT */
+
+/* Define to 1 if you have the <dirent.h> header file. */
+#define H5_HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define H5_HAVE_DLFCN_H 1
+
+/* Define if library information should be embedded in the executables */
+#define H5_HAVE_EMBEDDED_LIBINFO 1
+
+/* Define to 1 if you have the `fcntl' function. */
+#define H5_HAVE_FCNTL 1
+
+/* Define to 1 if you have the <features.h> header file. */
+#define H5_HAVE_FEATURES_H 1
+
+/* Define if support for deflate (zlib) filter is enabled */
+#define H5_HAVE_FILTER_DEFLATE 1
+
+/* Define if support for szip filter is enabled */
+/* #undef H5_HAVE_FILTER_SZIP */
+
+/* Determine if __float128 is available */
+/* #undef H5_HAVE_FLOAT128 */
+
+/* Define to 1 if you have the `flock' function. */
+#define H5_HAVE_FLOCK 1
+
+/* Define to 1 if you have the `fork' function. */
+#define H5_HAVE_FORK 1
+
+/* Define to 1 if you have the `fseeko' function. */
+#define H5_HAVE_FSEEKO 1
+
+/* Determine if INTEGER*16 is available */
+/* #undef H5_HAVE_Fortran_INTEGER_SIZEOF_16 */
+
+/* Define to 1 if you have the `GetConsoleScreenBufferInfo' function. */
+/* #undef H5_HAVE_GETCONSOLESCREENBUFFERINFO */
+
+/* Define to 1 if you have the `gethostname' function. */
+#define H5_HAVE_GETHOSTNAME 1
+
+/* Define to 1 if you have the `getrusage' function. */
+#define H5_HAVE_GETRUSAGE 1
+
+/* Define to 1 if you have the `gettextinfo' function. */
+/* #undef H5_HAVE_GETTEXTINFO */
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define H5_HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the <hdfs.h> header file. */
+/* #undef H5_HAVE_HDFS_H */
+
+/* Define if parallel library will contain instrumentation to detect correct
+   optimization operation */
+/* #undef H5_HAVE_INSTRUMENTED_LIBRARY */
+
+/* Define if IOC VFD is built */
+/* #undef H5_HAVE_IOC_VFD */
+
+/* Define to 1 if you have the `ioctl' function. */
+#define H5_HAVE_IOCTL 1
+
+/* Define to 1 if you have the `crypto' library (-lcrypto). */
+/* #undef H5_HAVE_LIBCRYPTO */
+
+/* Define to 1 if you have the `curl' library (-lcurl). */
+/* #undef H5_HAVE_LIBCURL */
+
+/* Define to 1 if you have the `dl' library (-ldl). */
+#define H5_HAVE_LIBDL 1
+
+/* Proceed to build with libhdfs */
+/* #undef H5_HAVE_LIBHDFS */
+
+/* Define to 1 if you have the `jvm' library (-ljvm). */
+/* #undef H5_HAVE_LIBJVM */
+
+/* Define to 1 if you have the `m' library (-lm). */
+#define H5_HAVE_LIBM 1
+
+/* Define to 1 if you have the `pthread' library (-lpthread). */
+/* #undef H5_HAVE_LIBPTHREAD */
+
+/* Define to 1 if you have the `sz' library (-lsz). */
+/* #undef H5_HAVE_LIBSZ */
+
+/* Define to 1 if you have the `ws2_32' library (-lws2_32). */
+/* #undef H5_HAVE_LIBWS2_32 */
+
+/* Define to 1 if you have the `z' library (-lz). */
+#define H5_HAVE_LIBZ 1
+
+/* Define to 1 if you have the `lseek64' function. */
+#define H5_HAVE_LSEEK64 1
+
+/* Define if the map API (H5M) should be compiled */
+/* #undef H5_HAVE_MAP_API */
+
+/* Define whether the Mirror virtual file driver (VFD) will be compiled */
+/* #undef H5_HAVE_MIRROR_VFD */
+
+/* Define if MPI_Comm_c2f and MPI_Comm_f2c exist */
+/* #undef H5_HAVE_MPI_MULTI_LANG_Comm */
+
+/* Define if MPI_Info_c2f and MPI_Info_f2c exist */
+/* #undef H5_HAVE_MPI_MULTI_LANG_Info */
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#define H5_HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define H5_HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <openssl/evp.h> header file. */
+/* #undef H5_HAVE_OPENSSL_EVP_H */
+
+/* Define to 1 if you have the <openssl/hmac.h> header file. */
+/* #undef H5_HAVE_OPENSSL_HMAC_H */
+
+/* Define to 1 if you have the <openssl/sha.h> header file. */
+/* #undef H5_HAVE_OPENSSL_SHA_H */
+
+/* Define if we have parallel support */
+/* #undef H5_HAVE_PARALLEL */
+
+/* Define if we have support for writing to filtered datasets in parallel */
+/* #undef H5_HAVE_PARALLEL_FILTERED_WRITES */
+
+/* Define if both pread and pwrite exist. */
+#define H5_HAVE_PREADWRITE 1
+
+/* Define to 1 if you have the <pthread.h> header file. */
+#define H5_HAVE_PTHREAD_H 1
+
+/* Define to 1 if 'pthread_condattr_setclock()' is available */
+/* #undef H5_HAVE_PTHREAD_CONDATTR_SETCLOCK */
+
+/* Define to 1 if PTHREAD_MUTEX_ADAPTIVE_NP is available */
+/* #undef H5_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP */
+
+/* Define to 1 if you have the <pwd.h> header file. */
+#define H5_HAVE_PWD_H 1
+
+/* Define to 1 if you have the <quadmath.h> header file. */
+#define H5_HAVE_QUADMATH_H 1
+
+/* Define to 1 if you have the `random' function. */
+#define H5_HAVE_RANDOM 1
+
+/* Define to 1 if you have the `rand_r' function. */
+#define H5_HAVE_RAND_R 1
+
+/* Define whether the Read-Only S3 virtual file driver (VFD) should be
+   compiled */
+/* #undef H5_HAVE_ROS3_VFD */
+
+/* Define to 1 if you have the `stat64' function. */
+#define H5_HAVE_STAT64 1
+
+/* Define if struct stat has the st_blocks field */
+#define H5_HAVE_STAT_ST_BLOCKS 1
+
+/* Define to 1 if you have the `strcasestr' function. */
+#define H5_HAVE_STRCASESTR 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define H5_HAVE_STRDUP 1
+
+/* Define if struct text_info is defined */
+/* #undef H5_HAVE_STRUCT_TEXT_INFO */
+
+/* Define if struct videoconfig is defined */
+/* #undef H5_HAVE_STRUCT_VIDEOCONFIG */
+
+/* Define if Subfiling VFD is built */
+/* #undef H5_HAVE_SUBFILING_VFD */
+
+/* Define if have stdatomic.h for Subfiling VFD */
+/* #undef H5_HAVE_STDATOMIC_H */
+
+/* Define to 1 if you have the `symlink' function. */
+#define H5_HAVE_SYMLINK 1
+
+/* Define to 1 if you have the <sys/file.h> header file. */
+#define H5_HAVE_SYS_FILE_H 1
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define H5_HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#define H5_HAVE_SYS_RESOURCE_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define H5_HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define H5_HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define H5_HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define H5_HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <szlib.h> header file. */
+/* #undef H5_HAVE_SZLIB_H */
+
+#if defined(_WIN32) && !defined(H5_BUILT_AS_DYNAMIC_LIB)
+/* Not supported on WIN32 platforms with static linking */
+/* #undef H5_HAVE_THREADSAFE */
+#else
+/* Define if we have thread safe support */
+/* #undef H5_HAVE_THREADSAFE */
+#endif
+
+/* Define if timezone is a global variable */
+#define H5_HAVE_TIMEZONE 1
+
+/* Define if the ioctl TIOCGETD is defined */
+#define H5_HAVE_TIOCGETD 1
+
+/* Define if the ioctl TIOGWINSZ is defined */
+#define H5_HAVE_TIOCGWINSZ 1
+
+/* Define to 1 if you have the `tmpfile' function. */
+#define H5_HAVE_TMPFILE 1
+
+/* Define if tm_gmtoff is a member of struct tm */
+#define H5_HAVE_TM_GMTOFF 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define H5_HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define H5_HAVE_VASPRINTF 1
+
+/* Define to 1 if you have the `waitpid' function. */
+#define H5_HAVE_WAITPID 1
+
+/* Define to 1 if you have the 'InitOnceExecuteOnce' function. */
+/* #undef H5_HAVE_WIN_THREADS */
+
+/* Define if your system has window style path name. */
+/* #undef H5_HAVE_WINDOW_PATH */
+
+/* Define to 1 if you have the <zlib.h> header file. */
+#define H5_HAVE_ZLIB_H 1
+
+/* Define to 1 if you have the `_getvideoconfig' function. */
+/* #undef H5_HAVE__GETVIDEOCONFIG */
+
+/* Define to 1 if you have the `_scrsize' function. */
+/* #undef H5_HAVE__SCRSIZE */
+
+/* Define if the library will ignore file locks when disabled */
+#define H5_IGNORE_DISABLED_FILE_LOCKS 1
+
+/* Define if the high-level library headers should be included in hdf5.h */
+#define H5_INCLUDE_HL 1
+
+/* Define if new-style references should be used with dimension scales */
+/* #undef H5_DIMENSION_SCALES_WITH_NEW_REF */
+
+/* Define if your system can convert long double to (unsigned) long long
+   values correctly. */
+#define H5_LDOUBLE_TO_LLONG_ACCURATE 1
+
+/* Define if your system converts long double to (unsigned) long values with
+   special algorithm. */
+/* #undef H5_LDOUBLE_TO_LONG_SPECIAL */
+
+/* Define if your system can convert (unsigned) long long to long double
+   values correctly. */
+#define H5_LLONG_TO_LDOUBLE_CORRECT 1
+
+/* Define if your system can convert (unsigned) long to long double values
+   with special algorithm. */
+/* #undef H5_LONG_TO_LDOUBLE_SPECIAL */
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+/* #undef H5_LT_OBJDIR */
+
+/* Define if deprecated public API symbols are disabled */
+/* #undef H5_NO_DEPRECATED_SYMBOLS */
+
+/* Name of package */
+#define H5_PACKAGE "hdf5"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define H5_PACKAGE_BUGREPORT "help@hdfgroup.org"
+
+/* Define to the full name of this package. */
+#define H5_PACKAGE_NAME "HDF5"
+
+/* Define to the full name and version of this package. */
+#define H5_PACKAGE_STRING "HDF5 1.15.0"
+
+/* Define to the one symbol short name of this package. */
+#define H5_PACKAGE_TARNAME "hdf5"
+
+/* Define to the home page for this package. */
+#define H5_PACKAGE_URL "http://www.hdfgroup.org"
+
+/* Define to the version of this package. */
+#define H5_PACKAGE_VERSION "1.15.0"
+
+/* Determine the maximum decimal precision in C */
+#define H5_PAC_C_MAX_REAL_PRECISION 
+
+/* Define Fortran Maximum Real Decimal Precision */
+#define H5_PAC_FC_MAX_REAL_PRECISION 
+
+/* The size of `bool', as computed by sizeof. */
+#define H5_SIZEOF_BOOL 1
+
+/* The size of `char', as computed by sizeof. */
+#define H5_SIZEOF_CHAR 1
+
+/* The size of `double', as computed by sizeof. */
+#define H5_SIZEOF_DOUBLE 8
+
+/* The size of `float', as computed by sizeof. */
+#define H5_SIZEOF_FLOAT 4
+
+/* The size of `int', as computed by sizeof. */
+#define H5_SIZEOF_INT 4
+
+/* The size of `int16_t', as computed by sizeof. */
+#define H5_SIZEOF_INT16_T 2
+
+/* The size of `int32_t', as computed by sizeof. */
+#define H5_SIZEOF_INT32_T 4
+
+/* The size of `int64_t', as computed by sizeof. */
+#define H5_SIZEOF_INT64_T 8
+
+/* The size of `int8_t', as computed by sizeof. */
+#define H5_SIZEOF_INT8_T 1
+
+/* The size of `int_fast16_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_FAST16_T 8
+
+/* The size of `int_fast32_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_FAST32_T 8
+
+/* The size of `int_fast64_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_FAST64_T 8
+
+/* The size of `int_fast8_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_FAST8_T 1
+
+/* The size of `int_least16_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_LEAST16_T 2
+
+/* The size of `int_least32_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_LEAST32_T 4
+
+/* The size of `int_least64_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_LEAST64_T 8
+
+/* The size of `int_least8_t', as computed by sizeof. */
+#define H5_SIZEOF_INT_LEAST8_T 1
+
+#if !defined(__APPLE__)
+
+/* The size of `size_t', as computed by sizeof. */
+#define H5_SIZEOF_SIZE_T 8
+
+/* The size of `ssize_t', as computed by sizeof. */
+#define H5_SIZEOF_SSIZE_T 8
+
+/* The size of `long', as computed by sizeof. */
+#define H5_SIZEOF_LONG 8
+
+/* The size of `long double', as computed by sizeof. */
+#define H5_SIZEOF_LONG_DOUBLE 16
+
+#else
+
+  /* On Apple, to support Universal Binaries (where multiple CPU
+     architectures exist in one library/executable), we can't assume
+     the machine doing the compiling has the same endianness or type
+     sizes as all the various architectures (PowerPC, Intel, ARM). */
+
+  # if defined(__LP64__) && __LP64__
+  #define H5_SIZEOF_LONG 8
+  #define H5_SIZEOF_SIZE_T 8
+  #define H5_SIZEOF_SSIZE_T 8
+  # else
+  #define H5_SIZEOF_LONG 4
+  #define H5_SIZEOF_SIZE_T 4
+  #define H5_SIZEOF_SSIZE_T 4
+  # endif
+
+  # if defined(__i386__) || defined(__x86_64__)
+  #define H5_SIZEOF_LONG_DOUBLE 16
+  # elif defined(__aarch64__)
+  #define H5_SIZEOF_LONG_DOUBLE 8
+  # else
+  #define H5_SIZEOF_LONG_DOUBLE 16
+  # endif
+
+#endif
+
+/* The size of `long long', as computed by sizeof. */
+#if !defined(__APPLE__)
+ #define H5_SIZEOF_LONG_LONG 8
+#else
+ #define H5_SIZEOF_LONG_LONG 8
+#endif
+
+/* The size of `off64_t', as computed by sizeof. */
+#define H5_SIZEOF_OFF64_T 8
+
+/* The size of `off_t', as computed by sizeof. */
+#define H5_SIZEOF_OFF_T 8
+
+/* The size of `ptrdiff_t', as computed by sizeof. */
+#define H5_SIZEOF_PTRDIFF_T 8
+
+/* The size of `short', as computed by sizeof. */
+#define H5_SIZEOF_SHORT 2
+
+/* The size of `time_t', as computed by sizeof. */
+#define H5_SIZEOF_TIME_T 8
+
+/* The size of `uint16_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT16_T 2
+
+/* The size of `uint32_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT32_T 4
+
+/* The size of `uint64_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT64_T 8
+
+/* The size of `uint8_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT8_T 1
+
+/* The size of `uint_fast16_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_FAST16_T 8
+
+/* The size of `uint_fast32_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_FAST32_T 8
+
+/* The size of `uint_fast64_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_FAST64_T 8
+
+/* The size of `uint_fast8_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_FAST8_T 1
+
+/* The size of `uint_least16_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_LEAST16_T 2
+
+/* The size of `uint_least32_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_LEAST32_T 4
+
+/* The size of `uint_least64_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_LEAST64_T 8
+
+/* The size of `uint_least8_t', as computed by sizeof. */
+#define H5_SIZEOF_UINT_LEAST8_T 1
+
+/* The size of `unsigned', as computed by sizeof. */
+#define H5_SIZEOF_UNSIGNED 4
+
+/* The size of `_Quad', as computed by sizeof. */
+#define H5_SIZEOF__QUAD 
+
+/* The size of `__float128', as computed by sizeof. */
+#define H5_SIZEOF___FLOAT128 
+
+/* Define if strict file format checks are enabled */
+/* #undef H5_STRICT_FORMAT_CHECKS */
+
+/* Define if your system supports pthread_attr_setscope(&attribute,
+   PTHREAD_SCOPE_SYSTEM) call. */
+#define H5_SYSTEM_SCOPE_THREADS 1
+
+/* Define using v1.6 public API symbols by default */
+/* #undef H5_USE_16_API_DEFAULT */
+
+/* Define using v1.8 public API symbols by default */
+/* #undef H5_USE_18_API_DEFAULT */
+
+/* Define using v1.10 public API symbols by default */
+/* #undef H5_USE_110_API_DEFAULT */
+
+/* Define using v1.12 public API symbols by default */
+/* #undef H5_USE_112_API_DEFAULT */
+
+/* Define using v1.14 public API symbols by default */
+/* #undef H5_USE_114_API_DEFAULT */
+
+/* Define using v1.16 public API symbols by default */
+#define H5_USE_116_API_DEFAULT 1
+
+/* Define if the library will use file locking */
+#define H5_USE_FILE_LOCKING 1
+
+/* Define if a memory checking tool will be used on the library, to cause
+   library to be very picky about memory operations and also disable the
+   internal free list manager code. */
+/* #undef H5_USING_MEMCHECKER */
+
+/* Version number of package */
+#define H5_VERSION "1.15.0"
+
+/* Data accuracy is preferred to speed during data conversions */
+#define H5_WANT_DATA_ACCURACY 1
+
+/* Check exception handling functions during data conversions */
+#define H5_WANT_DCONV_EXCEPTION 1
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if !defined(__APPLE__)
+# ifndef WORDS_BIGENDIAN
+#  undef WORDS_BIGENDIAN
+# endif
+#else
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#endif
+
+/* #undef WORDS_BIGENDIAN */
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef H5__FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef H5__LARGE_FILES */
+
+/* Define to `long int' if <sys/types.h> does not define. */
+/* #undef H5_off_t */
+
+/* Define to `long' if <sys/types.h> does not define. */
+/* #undef H5_ssize_t */
+
+#endif
diff --git a/install/include/H5public.h b/install/include/H5public.h
new file mode 100644
index 0000000000..8fce3f47db
--- /dev/null
+++ b/install/include/H5public.h
@@ -0,0 +1,851 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This file contains public declarations for the HDF5 module.
+ */
+#ifndef H5public_H
+#define H5public_H
+
+/* Include files for public use... */
+/*
+ * Since H5pubconf.h is a generated header file, it is messy to try
+ * to put a #ifndef H5pubconf_H ... #endif guard in it.
+ * HDF5 has set an internal rule that it is being included here.
+ * Source files should NOT include H5pubconf.h directly but include
+ * it via H5public.h.  The #ifndef H5public_H guard above would
+ * prevent repeated include.
+ */
+#include "H5pubconf.h" /* From configure */
+
+/* API Version macro wrapper definitions */
+#include "H5version.h"
+
+#ifdef H5_HAVE_FEATURES_H
+#include <features.h> /* For setting POSIX, BSD, etc. compatibility */
+#endif
+
+/* C library header files for things that appear in HDF5 public headers */
+#ifdef __cplusplus
+#include <cinttypes>
+#else
+#include <inttypes.h>
+#endif
+#include <limits.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+
+/* Unlike most sys/ headers, which are POSIX-only, sys/types.h is available
+ * on Windows, though it doesn't necessarily contain all the POSIX types
+ * we need for HDF5 (e.g. ssize_t).
+ */
+#ifdef H5_HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#ifdef H5_HAVE_PARALLEL
+/* Don't link against MPI C++ bindings */
+#ifndef MPICH_SKIP_MPICXX
+#define MPICH_SKIP_MPICXX 1
+#endif
+#ifndef OMPI_SKIP_MPICXX
+#define OMPI_SKIP_MPICXX 1
+#endif
+#include <mpi.h>
+#ifndef MPI_FILE_NULL /* MPIO may be defined in mpi.h already */
+#include <mpio.h>
+#endif
+#endif
+
+/* Macro to hide a symbol from further preprocessor substitutions */
+#define H5_NO_EXPAND(x) (x)
+
+/* Version numbers */
+/**
+ * For major interface/format changes
+ */
+#define H5_VERS_MAJOR 1
+/**
+ * For minor interface/format changes
+ */
+#define H5_VERS_MINOR 15
+/**
+ * For tweaks, bug-fixes, or development
+ */
+#define H5_VERS_RELEASE 0
+/**
+ * For pre-releases like \c snap0. Empty string for official releases.
+ */
+#define H5_VERS_SUBRELEASE ""
+/**
+ * Full version string
+ */
+#define H5_VERS_INFO "HDF5 library version: 1.15.0"
+
+#define H5check() H5check_version(H5_VERS_MAJOR, H5_VERS_MINOR, H5_VERS_RELEASE)
+
+/* macros for comparing the version */
+/**
+ * \brief Determines whether the version of the library being used is greater
+ *        than or equal to the specified version
+ *
+ * \param[in] Maj Major version number - A non-negative integer value
+ * \param[in] Min Minor version number - A non-negative integer value
+ * \param[in] Rel Release version number - A non-negative integer value
+ * \returns A value of 1 is returned if the library version is greater than
+ *          or equal to the version number specified.\n
+ *          A value of 0 is returned if the library version is less than the
+ *          version number specified.\n
+ *          A library version is greater than the specified version number if
+ *          its major version is larger than the specified major version
+ *          number. If the major version numbers are the same, it is greater
+ *          than the specified version number if its minor version is larger
+ *          than the specified minor version number. If the minor version
+ *          numbers are the same, then a library version would be greater than
+ *          the specified version number if its release number is larger than
+ *          the specified release number.
+ *
+ * \details The #H5_VERSION_GE and #H5_VERSION_LE macros are used at compile
+ *          time to conditionally include or exclude code based on the version
+ *          of the HDF5 library against which an application will be linked.
+ *
+ *          The #H5_VERSION_GE macro compares the version of the HDF5 library
+ *          being used against the version number specified in the parameters.
+ *
+ *          For more information about release versioning, see \ref_h5lib_relver.
+ *
+ * \since 1.8.7
+ *
+ */
+#define H5_VERSION_GE(Maj, Min, Rel)                                                                         \
+    (((H5_VERS_MAJOR == Maj) && (H5_VERS_MINOR == Min) && (H5_VERS_RELEASE >= Rel)) ||                       \
+     ((H5_VERS_MAJOR == Maj) && (H5_VERS_MINOR > Min)) || (H5_VERS_MAJOR > Maj))
+
+/**
+ * \brief Determines whether the version of the library being used is less
+ *        than or equal to the specified version
+ *
+ * \param[in] Maj Major version number - A non-negative integer value
+ * \param[in] Min Minor version number - A non-negative integer value
+ * \param[in] Rel Release version number - A non-negative integer value
+ * \returns A value of 1 is returned if the library version is less than
+ *          or equal to the version number specified.\n
+ *          A value of 0 is returned if the library version is greater than the
+ *          version number specified.\n
+ *          A library version is less than the specified version number if
+ *          its major version is smaller than the specified major version
+ *          number. If the major version numbers are the same, it is smaller
+ *          than the specified version number if its minor version is smaller
+ *          than the specified minor version number. If the minor version
+ *          numbers are the same, then a library version would be smaller than
+ *          the specified version number if its release number is smaller than
+ *          the specified release number.
+ *
+ * \details The #H5_VERSION_GE and #H5_VERSION_LE macros are used at compile
+ *          time to conditionally include or exclude code based on the version
+ *          of the HDF5 library against which an application will be linked.
+ *
+ *          The #H5_VERSION_LE macro compares the version of the HDF5 library
+ *          being used against the version number specified in the parameters.
+ *
+ *          For more information about release versioning, see \ref_h5lib_relver.
+ *
+ * \since 1.8.7
+ *
+ */
+#define H5_VERSION_LE(Maj, Min, Rel)                                                                         \
+    (((H5_VERS_MAJOR == Maj) && (H5_VERS_MINOR == Min) && (H5_VERS_RELEASE <= Rel)) ||                       \
+     ((H5_VERS_MAJOR == Maj) && (H5_VERS_MINOR < Min)) || (H5_VERS_MAJOR < Maj))
+
+/* Macros for various environment variables that HDF5 interprets */
+/**
+ * Used to specify the name of an HDF5 Virtual File Driver to use as
+ * the default file driver for file access. Setting this environment
+ * variable overrides the default file driver for File Access Property
+ * Lists.
+ */
+#define HDF5_DRIVER "HDF5_DRIVER"
+/**
+ * Used to specify a configuration string for the HDF5 Virtual File
+ * Driver being used for file access.
+ */
+#define HDF5_DRIVER_CONFIG "HDF5_DRIVER_CONFIG"
+/**
+ * Used to specify the name of an HDF5 Virtual Object Layer Connector
+ * to use as the default VOL connector for file access. Setting this
+ * environment variable overrides the default VOL connector for File
+ * Access Property Lists.
+ */
+#define HDF5_VOL_CONNECTOR "HDF5_VOL_CONNECTOR"
+/**
+ * Used to specify a delimiter-separated (currently, ';' for Windows
+ * and ':' for other systems) list of paths that HDF5 should search
+ * when loading plugins.
+ */
+#define HDF5_PLUGIN_PATH "HDF5_PLUGIN_PATH"
+/**
+ * Used to control the loading of HDF5 plugins at runtime. If this
+ * environment variable is set to the special string "::" (defined
+ * in H5PLpublic.h as H5PL_NO_PLUGIN), then dynamic loading of any
+ * HDF5 plugins will be disabled. No other values are valid for this
+ * environment variable.
+ */
+#define HDF5_PLUGIN_PRELOAD "HDF5_PLUGIN_PRELOAD"
+/**
+ * Used to control whether HDF5 uses file locking when creating or
+ * opening a file. Valid values for this environment variable are
+ * as follows:
+ *
+ *  "TRUE" or "1"  - Request that file locks should be used
+ *  "FALSE" or "0" - Request that file locks should NOT be used
+ *  "BEST_EFFORT"  - Request that file locks should be used and
+ *                     that any locking errors caused by file
+ *                     locking being disabled on the system
+ *                     should be ignored
+ */
+#define HDF5_USE_FILE_LOCKING "HDF5_USE_FILE_LOCKING"
+/**
+ * Used to instruct HDF5 not to cleanup files created during testing.
+ */
+#define HDF5_NOCLEANUP "HDF5_NOCLEANUP"
+
+/**
+ * Status return values.  Failed integer functions in HDF5 result almost
+ * always in a negative value (unsigned failing functions sometimes return
+ * zero for failure) while successful return is non-negative (often zero).
+ * The negative failure value is most commonly -1, but don't bet on it.
+ *
+ * The proper way to detect failure is something like:
+ * \code
+ * if((dset = H5Dopen2(file, name)) < 0)
+ *    fprintf(stderr, "unable to open the requested dataset\n");
+ * \endcode
+ */
+typedef int herr_t;
+
+/**
+ * C99-style Boolean type. Successful return values are zero (false) or positive
+ * (true). The typical true value is 1 but don't bet on it.
+ *
+ * \deprecated Now that we require C99, hbool_t is typedef'd to C99's bool
+ *             and hbool_t is considered deprecated. Due to its long-standing,
+ *             widespread use, we have no plans to remove the hbool_t typedef
+ *             from the public API, though we will probably switch to using
+ *             bool in the public API starting in the next major release of HDF5.
+ * \attention Boolean functions cannot fail.
+ */
+#include <stdbool.h>
+typedef bool hbool_t;
+/**
+ * Three-valued Boolean type. Functions that return #htri_t however return zero
+ * (false), positive (true), or negative (failure).
+ *
+ * The proper way to test for truth from a #htri_t function is:
+ * \code
+ * if ((retval = H5Tcommitted(type)) > 0) {
+ *     printf("data type is committed\n");
+ * } else if (!retval) {
+ *     printf("data type is not committed\n");
+ * } else {
+ *     printf("error determining whether data type is committed\n");
+ * }
+ * \endcode
+ */
+typedef int htri_t;
+
+/* The signed version of size_t
+ *
+ * ssize_t is POSIX and not defined in any C standard. It's used in some
+ * public HDF5 API calls so this work-around will define it if it's not
+ * present.
+ *
+ * Use of ssize_t should be discouraged in new code.
+ */
+#if H5_SIZEOF_SSIZE_T == 0
+/* Undefine this size, we will re-define it in one of the sections below */
+#undef H5_SIZEOF_SSIZE_T
+#if H5_SIZEOF_SIZE_T == H5_SIZEOF_INT
+typedef int ssize_t;
+#define H5_SIZEOF_SSIZE_T H5_SIZEOF_INT
+#elif H5_SIZEOF_SIZE_T == H5_SIZEOF_LONG
+typedef long ssize_t;
+#define H5_SIZEOF_SSIZE_T H5_SIZEOF_LONG
+#elif H5_SIZEOF_SIZE_T == H5_SIZEOF_LONG_LONG
+typedef long long ssize_t;
+#define H5_SIZEOF_SSIZE_T H5_SIZEOF_LONG_LONG
+#else /* Can't find matching type for ssize_t */
+#error "nothing appropriate for ssize_t"
+#endif
+#endif
+
+/**
+ * The size of file objects.
+ *
+ * \internal Defined as a (minimum) 64-bit integer type.
+ */
+typedef uint64_t hsize_t;
+
+#ifdef H5_HAVE_PARALLEL
+#define HSIZE_AS_MPI_TYPE MPI_UINT64_T
+#endif
+
+/**
+ * The size of file objects. Used when negative values are needed to indicate errors.
+ *
+ * \internal Defined as a (minimum) 64-bit integer type. Use of hssize_t
+ * should be discouraged in new code.
+ */
+typedef int64_t hssize_t;
+#define PRIdHSIZE          PRId64
+#define PRIiHSIZE          PRIi64
+#define PRIoHSIZE          PRIo64
+#define PRIuHSIZE          PRIu64
+#define PRIxHSIZE          PRIx64
+#define PRIXHSIZE          PRIX64
+#define H5_SIZEOF_HSIZE_T  8
+#define H5_SIZEOF_HSSIZE_T 8
+#define HSIZE_UNDEF        UINT64_MAX
+
+/**
+ * The address of an object in the file.
+ *
+ * \internal Defined as a (minimum) 64-bit unsigned integer type.
+ */
+typedef uint64_t haddr_t;
+#define PRIdHADDR           PRId64
+#define PRIoHADDR           PRIo64
+#define PRIuHADDR           PRIu64
+#define PRIxHADDR           PRIx64
+#define PRIXHADDR           PRIX64
+#define H5_SIZEOF_HADDR_T   8
+#define HADDR_UNDEF         UINT64_MAX
+#define H5_PRINTF_HADDR_FMT "%" PRIuHADDR
+#define HADDR_MAX           (HADDR_UNDEF - 1)
+
+#ifdef H5_HAVE_PARALLEL
+#define HADDR_AS_MPI_TYPE MPI_UINT64_T
+#endif
+
+//! <!-- [H5_iter_order_t_snip] -->
+/**
+ * Common iteration orders
+ */
+typedef enum {
+    H5_ITER_UNKNOWN = -1, /**< Unknown order */
+    H5_ITER_INC,          /**< Increasing order */
+    H5_ITER_DEC,          /**< Decreasing order */
+    H5_ITER_NATIVE,       /**< No particular order, whatever is fastest */
+    H5_ITER_N             /**< Number of iteration orders */
+} H5_iter_order_t;
+//! <!-- [H5_iter_order_t_snip] -->
+
+/* Iteration callback values */
+/* (Actually, any positive value will cause the iterator to stop and pass back
+ *      that positive value to the function that called the iterator)
+ */
+#define H5_ITER_ERROR (-1) /**< Error, stop iteration */
+#define H5_ITER_CONT  (0)  /**< Continue iteration */
+#define H5_ITER_STOP  (1)  /**< Stop iteration, short-circuit success */
+
+//! <!-- [H5_index_t_snip] -->
+/**
+ * The types of indices on links in groups/attributes on objects.
+ * Primarily used for "<do> <foo> by index" routines and for iterating over
+ * links in groups/attributes on objects.
+ */
+typedef enum H5_index_t {
+    H5_INDEX_UNKNOWN = -1, /**< Unknown index type                   */
+    H5_INDEX_NAME,         /**< Index on names                       */
+    H5_INDEX_CRT_ORDER,    /**< Index on creation order              */
+    H5_INDEX_N             /**< Number of indices defined            */
+} H5_index_t;
+//! <!-- [H5_index_t_snip] -->
+
+/**
+ * Storage info struct used by H5O_info_t and H5F_info_t
+ */
+//! <!-- [H5_ih_info_t_snip] -->
+typedef struct H5_ih_info_t {
+    hsize_t index_size; /**< btree and/or list */
+    hsize_t heap_size;
+} H5_ih_info_t;
+//! <!-- [H5_ih_info_t_snip] -->
+
+/**
+ * The maximum size allowed for tokens
+ * \details Tokens are unique and permanent identifiers that are
+ *          used to reference HDF5 objects in a container. This allows
+ *          for 128-bit tokens
+ */
+#define H5O_MAX_TOKEN_SIZE (16)
+
+//! <!-- [H5O_token_t_snip] -->
+/**
+ * Type for object tokens
+ *
+ * \internal (Hoisted here, since it's used by both the
+ *            H5Lpublic.h and H5Opublic.h headers)
+ */
+typedef struct H5O_token_t {
+    uint8_t __data[H5O_MAX_TOKEN_SIZE];
+} H5O_token_t;
+//! <!-- [H5O_token_t_snip] -->
+
+/**
+ * Library shutdown callback, used by H5atclose().
+ */
+typedef void (*H5_atclose_func_t)(void *ctx);
+
+/* API adapter header (defines H5_DLL, etc.) */
+#include "H5api_adpt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Functions in H5.c */
+/**
+ * \ingroup H5
+ * \brief Initializes the HDF5 library
+ * \return \herr_t
+ *
+ * \details H5open() initializes the HDF5 library.
+ *
+ * \details When the HDF5 library is used in a C application, the library is
+ *          automatically initialized when the first HDf5 function call is
+ *          issued. If one finds that an HDF5 library function is failing
+ *          inexplicably, H5open() can be called first. It is safe to call
+ *          H5open() before an application issues any other function calls to
+ *          the HDF5 library, as there are no damaging side effects in calling
+ *          it more than once.
+ */
+H5_DLL herr_t H5open(void);
+/**
+ * \ingroup H5
+ * \brief Registers a callback for the library to invoke when it's closing.
+ * \param[in] func The function pointer to invoke
+ * \param[in] ctx Context to pass to \p func when invoked
+ * \return \herr_t
+ *
+ * \details H5atclose() registers a callback that the HDF5 library will invoke
+ *          when closing.  The full capabilities of the HDF5 library are
+ *          available to callbacks invoked through this mechanism, and library
+ *          shutdown will only begin in earnest when all callbacks have been
+ *          invoked and have returned.
+ *
+ *          Registered callbacks are invoked in LIFO order, similar to the
+ *          Standard C 'atexit' routine.  For example, if 'func1' is registered,
+ *          then 'func2', when the library is closing 'func2', will
+ *          be invoked first, then 'func1'.
+ *
+ *          The \p ctx pointer will be passed to \p func when it's invoked.
+ *          NULL is allowed for \p ctx.
+ *
+ *          If the HDF5 library is initialized and closed more than once, the
+ *          \p func callback must be registered within each open/close cycle.
+ *
+ * \since 1.14.0
+ */
+H5_DLL herr_t H5atclose(H5_atclose_func_t func, void *ctx);
+/**
+ * \ingroup H5
+ * \brief Flushes all data to disk, closes all open objects, and releases memory
+ * \return \herr_t
+ *
+ * \details H5close() flushes all data to disk, closes all open HDF5 objects,
+ *          and cleans up all memory used by the HDF5 library. This function is
+ *          generally called when the application calls exit(), but may be
+ *          called earlier in the event of an emergency shutdown or out of a
+ *          desire to free all resources used by the HDF5 library.
+ */
+H5_DLL herr_t H5close(void);
+/**
+ * \ingroup H5
+ * \brief Instructs library not to install atexit() cleanup routine
+ * \return \herr_t
+ *
+ * \details H5dont_atexit() indicates to the library that an atexit() cleanup
+ *          routine should not be installed. The major purpose for using this
+ *          function is in situations where the library is dynamically linked
+ *          into an application and is un-linked from the application before
+ *          exit() gets called. In those situations, a routine installed with
+ *          atexit() would jump to a routine that was no longer in memory,
+ *          causing errors.
+ *
+ * \attention In order to be effective, this routine \Emph{must} be called
+ *            before any other HDF5 function calls, and must be called each
+ *            time the library is loaded/linked into the application (the first
+ *            time and after it's been unloaded).
+ */
+H5_DLL herr_t H5dont_atexit(void);
+/**
+ * \ingroup H5
+ * \brief Garbage collects on all free-lists of all types
+ * \return \herr_t
+ *
+ * \details H5garbage_collect() walks through all garbage collection routines
+ *          of the library, freeing any unused memory.
+ *
+ *          It is not required that H5garbage_collect() be called at any
+ *          particular time; it is only necessary for certain situations where
+ *          the application has performed actions that cause the library to
+ *          allocate many objects. The application should call
+ *          H5garbage_collect() if it eventually releases those objects and
+ *          wants to reduce the memory used by the library from the peak usage
+ *          required.
+ *
+ * \note The library automatically garbage collects all the free lists when the
+ *       application ends.
+ */
+H5_DLL herr_t H5garbage_collect(void);
+/**
+ * \ingroup H5
+ * \brief Sets free-list size limits
+ *
+ * \param[in] reg_global_lim The cumulative limit, in bytes, on memory used for
+ *                           all regular free lists (Default: 1MB)
+ * \param[in] reg_list_lim The limit, in bytes, on memory used for each regular
+ *                         free list (Default: 64KB)
+ * \param[in] arr_global_lim The cumulative limit, in bytes, on memory used for
+ *                           all array free lists (Default: 4MB)
+ * \param[in] arr_list_lim The limit, in bytes, on memory used for each array
+ *                         free list (Default: 256KB)
+ * \param[in] blk_global_lim The cumulative limit, in bytes, on memory used for
+ *                           all block free lists and, separately, for all
+ *                           factory free lists (Default: 16MB)
+ * \param[in] blk_list_lim The limit, in bytes, on memory used for each block
+ *                         or factory free list (Default: 1MB)
+ * \return \herr_t
+ *
+ * \details H5set_free_list_limits() sets size limits on all types of free
+ *          lists. The HDF5 library uses free lists internally to manage
+ *          memory. The types of free lists used are as follows:
+ *          \li Regular free lists manage memory for single internal data
+ *              structures.
+ *          \li Array free lists manage memory for arrays of internal
+ *              data structures.
+ *          \li Block free lists manage memory for arbitrarily-sized blocks
+ *              of bytes.
+ *          \li Factory free lists manage memory for fixed-size blocks of
+ *              bytes.
+ *
+ *          The parameters specify global and per-list limits; for example, \p
+ *          reg_global_limit and \p reg_list_limit limit the accumulated size
+ *          of all regular free lists and the size of each individual regular
+ *          free list, respectively. Therefore, if an application sets a 1Mb
+ *          limit on each of the global lists, up to 4Mb of total storage might
+ *          be allocated, 1Mb for each of the regular, array, block, and
+ *          factory type lists.
+ *
+ *          The settings specified for block free lists are duplicated for
+ *          factory free lists. Therefore, increasing the global limit on block
+ *          free lists by x bytes will increase the potential free list memory
+ *          usage by 2x bytes.
+ *
+ *          Using a value of -1 for a limit means that no limit is set for the
+ *          specified type of free list.
+ *
+ * \version 1.8.3 Function changed in this release to set factory free list
+ *                memory limits.
+ *
+ * \since 1.6.0
+ */
+H5_DLL herr_t H5set_free_list_limits(int reg_global_lim, int reg_list_lim, int arr_global_lim,
+                                     int arr_list_lim, int blk_global_lim, int blk_list_lim);
+/**
+ * \ingroup H5
+ * \brief Gets the current size of the free lists used to manage memory
+ *
+ * \param[out] reg_size The current size of all "regular" free list memory used
+ * \param[out] arr_size The current size of all "array" free list memory used
+ * \param[out] blk_size The current size of all "block" free list memory used
+ * \param[out] fac_size The current size of all "factory" free list memory used
+ * \return \herr_t
+ *
+ * \details H5get_free_list_sizes() obtains the current size of the different
+ *          kinds of free lists that the library uses to manage memory. The
+ *          free list sizes can be set with H5set_free_list_limits() and
+ *          garbage collected with H5garbage_collect(). These lists are global
+ *          for the entire library.
+ *
+ * \since 1.10.7
+ */
+H5_DLL herr_t H5get_free_list_sizes(size_t *reg_size, size_t *arr_size, size_t *blk_size, size_t *fac_size);
+/**
+ * \ingroup H5
+ * \brief Returns the HDF library release number
+ *
+ * \param[out] majnum The major version number of the library
+ * \param[out] minnum The minor version number of the library
+ * \param[out] relnum The release version number of the library
+ * \return \herr_t
+ *
+ * \details H5get_libversion() retrieves the major, minor, and release numbers
+ *          of the version of the HDF5 library which is linked to the
+ *          application.
+ *
+ */
+H5_DLL herr_t H5get_libversion(unsigned *majnum, unsigned *minnum, unsigned *relnum);
+/**
+ * \ingroup H5
+ * \brief Verifies that HDF5 library versions are consistent
+ *
+ * \param[in] majnum HDF5 library major version number
+ * \param[in] minnum HDF5 library minor version number
+ * \param[in] relnum HDF5 library release number
+ * \return \herr_t
+ *
+ * \details H5check_version() verifies that the version of the HDF5 library
+ *          with which an application was compiled, as indicated by the passed
+ *          parameters, matches the version of the HDF5 library against which
+ *          the application is currently linked.
+ *
+ *          \p majnum is the major version number of the HDF library with which
+ *          the application was compiled, \p minnum is the minor version
+ *          number, and \p relnum is the release number. Consider the following
+ *          example:
+ *
+ *          An official HDF5 release is labelled as follows:
+ *          HDF5 Release \Code{\<majnum\>.\<minnum\>.\<relnum\>}\n
+ *          For example, in HDF5 Release 1.8.5:
+ *          \li 1 is the major version number, \p majnum.
+ *          \li 8 is the minor version number, \p minnum.
+ *          \li 5 is the release number, \p relnum.
+ *
+ *          As stated above, H5check_version() first verifies that the version
+ *          of the HDF5 library with which an application was compiled matches
+ *          the version of the HDF5 library against which the application is
+ *          currently linked. If this check fails, H5check_version() causes the
+ *          application to abort (by means of a standard C abort() call) and
+ *          prints information that is usually useful for debugging. This
+ *          precaution is taken to avoid the risks of data corruption or
+ *          segmentation faults.
+ *
+ *          The most common cause of this failure is that an application was
+ *          compiled with one version of HDF5 and is dynamically linked with a
+ *          different version different version.
+ *
+ *          If the above test passes, H5check_version() proceeds to verify the
+ *          consistency of additional library version information. This is
+ *          designed to catch source code inconsistencies that do not normally
+ *          cause failures; if this check reveals an inconsistency, an
+ *          informational warning is printed but the application is allowed to
+ *          run.
+ *
+ */
+H5_DLL herr_t H5check_version(unsigned majnum, unsigned minnum, unsigned relnum);
+/**
+ * \ingroup H5
+ * \brief Checks whether the HDF5 library is closing.
+ * \param[out] is_terminating Flag indicating whether library is shutting down
+ * \return \herr_t
+ *
+ * \details H5is_library_terminating() queries whether the HDF5 library is in
+ *          the process of shutting down.  The \p is_terminating flag will only
+ *          be set to true after shutdown starts, it will be false before the
+ *          library has been initialized, while the library is initialized, and
+ *          after it has been closed.  The value of \p is_terminating is
+ *          undefined if this routine fails.
+ *
+ * \since 1.14.0
+ */
+H5_DLL herr_t H5is_library_terminating(hbool_t *is_terminating);
+/**
+ * \ingroup H5
+ * \brief Determines whether the HDF5 library was built with the thread-safety
+ *        feature enabled
+ *
+ * \param[out] is_ts Boolean value indicating whether the library was built
+ *                   with thread-safety enabled
+ * \return \herr_t
+ *
+ * \details The HDF5 library, although not internally multi-threaded, can be
+ *          built with a thread-safety feature enabled that protects internal
+ *          data structures with a mutex. In certain circumstances, it may be
+ *          useful to determine, at run-time, whether the linked HDF5 library
+ *          was built with the thread-safety feature enabled.
+ */
+H5_DLL herr_t H5is_library_threadsafe(hbool_t *is_ts);
+/**
+ * \ingroup H5
+ * \brief Frees memory allocated by the HDF5 library
+ *
+ * \param[in] mem Buffer to be freed. Can be NULL
+ * \return \herr_t
+ *
+ * \details H5free_memory() frees the memory that has been allocated by the caller
+ *          with H5allocate_memory() or by the HDF5 library on behalf of the
+ *          caller.
+ *
+ *          H5Tget_member_name() provides an example of memory allocation on
+ *          behalf of the caller: The function returns a buffer containing the
+ *          name of a compound datatype member. It is the caller's
+ *          responsibility to eventually free that buffer with H5free_memory().
+ *
+ * \attention It is especially important to use this function to free memory
+ *            allocated by the library on Windows. The C standard library is
+ *            implemented in dynamic link libraries (DLLs) known as the C
+ *            run-time (CRT). Each version of Visual Studio comes with two CRT
+ *            DLLs (debug and release) and allocating and freeing across DLL
+ *            boundaries can cause resource leaks and subtle bugs due to heap
+ *            corruption.\n
+ *            Only use this function to free memory allocated by the HDF5
+ *            Library. It will generally not be safe to use this function to
+ *            free memory allocated by any other means.\n
+ *            Even when using this function, it is still best to ensure that
+ *            all components of a C application are built with the same version
+ *            of Visual Studio and build (debug or release) and thus linked
+ *            against the same CRT.
+ *
+ * \see H5allocate_memory(), H5resize_memory()
+ *
+ * \since 1.8.13
+ *
+ */
+H5_DLL herr_t H5free_memory(void *mem);
+/**
+ * \ingroup H5
+ * \brief Allocates memory that will be freed later internally.
+ *
+ * \param[in] size The size in bytes of the buffer to be allocated
+ * \param[in] clear Flag whether the new buffer is to be initialized with 0
+ *
+ * \return On success, returns pointer to newly allocated buffer or returns
+ *         NULL if size is 0 (zero).\n
+ *         Returns NULL on failure.
+ *
+ * \details H5allocate_memory() allocates a memory buffer of size bytes that
+ *          will later be freed internally by the HDF5 library.
+ *
+ *          The boolean \p clear parameter specifies whether the buffer should
+ *          be initialized. If clear is \c true, all bits in the buffer are to be
+ *          set to 0 (zero); if clear is \c false, the buffer will not be
+ *          initialized.
+ *
+ *          This function is intended to have the semantics of malloc() and
+ *          calloc(). However, unlike malloc() and calloc(), which allow for a
+ *          "special" pointer to be returned instead of NULL, this function
+ *          always returns NULL on failure or when size is set to 0 (zero).
+ *
+ * \note At this time, the only intended use for this function is to allocate
+ *       memory that will be returned to the library as a data buffer from a
+ *       third-party filter.
+ *
+ * \attention To avoid heap corruption, allocated memory should be freed using
+ *            the same library that initially allocated it. In most cases, the
+ *            HDF5 API uses resources that are allocated and freed either
+ *            entirely by the user or entirely by the library, so this is not a
+ *            problem. In rare cases, however, HDF5 API calls will free the memory
+ *            that the user allocated. This function allows the user to safely
+ *            allocate this memory.\n
+ *            It is particularly important to use this function to allocate
+ *            memory in Microsoft Windows environments. In Windows, the C
+ *            standard library is implemented in dynamic link libraries (DLLs)
+ *            known as the C run-time (CRT). Each version of Visual Studio
+ *            comes with multiple versions of the CRT DLLs (debug, release, et
+ *            cetera) and allocating and freeing memory across DLL boundaries
+ *            can cause resource leaks and subtle bugs due to heap corruption.\n
+ *            Even when using this function, it is best where possible to
+ *            ensure that all components of a C application are built with the
+ *            same version of Visual Studio and configuration (Debug or
+ *            Release), and thus linked against the same CRT.\n
+ *            Use this function only to allocate memory inside third-party HDF5
+ *            filters. It will generally not be safe to use this function to
+ *            allocate memory for any other purpose.
+ *
+ * \see H5free_memory(), H5resize_memory()
+ *
+ * \since 1.8.15
+ *
+ */
+H5_DLL void *H5allocate_memory(size_t size, hbool_t clear);
+/**
+ * \ingroup H5
+ * \brief Resizes and, if required, re-allocates memory that will later be
+ *        freed internally by the HDF5 library
+ *
+ * \param[in] mem Pointer to a buffer to be resized. May be NULL
+ * \param[in] size New size of the buffer, in bytes
+
+ *
+ * \return On success, returns pointer to resized or reallocated buffer
+ *         or returns NULL if size is 0 (zero).\n
+ *         Returns NULL on failure.
+ *
+ * \details H5resize_memory() takes a pointer to an existing buffer and resizes
+ *          the buffer to match the value in \p size. If necessary, the buffer
+ *          is reallocated. If \p size is 0, the buffer is released.
+ *
+ *          The input buffer must either be NULL or have been allocated by
+ *          H5allocate_memory() since the input buffer may be freed by the
+ *          library.
+ *
+ *          For certain behaviors, the pointer \p mem may be passed in as NULL.
+ *
+ *          This function is intended to have the semantics of realloc():
+ *
+ *          <table>
+ *            <tr><td>\Code{H5resize_memory(buffer, size)}</td>
+ *                <td>Resizes buffer. Returns pointer to resized buffer.</td></tr>
+ *            <tr><td>\Code{H5resize_memory(NULL, size)}</td>
+ *                <td>Allocates memory using HDF5 Library allocator.
+ *                    Returns pointer to new buffer</td></tr>
+ *            <tr><td>\Code{H5resize_memory(buffer, 0)}</td>
+ *                <td>Frees memory using HDF5 Library allocator.
+ *                    Returns NULL.</td></tr>
+ *            <tr><td>\Code{H5resize_memory(NULL, 0)}</td>
+ *                <td>Returns NULL (undefined in C standard).</td></tr>
+ *          </table>
+ *
+ *          Unlike realloc(), which allows for a "special pointer to be
+ *          returned instead of NULL, this function always returns NULL on
+ *          failure or when size is 0 (zero).
+ *
+ * \note At this time, the only intended use for this function is to resize or
+ *       reallocate memory that will be returned to the library (and eventually
+ *       to the user) as a data buffer from a third-party HDF5 filter.
+ *
+ * \attention To avoid heap corruption, allocated memory should be freed using
+ *            the same library that initially allocated it. In most cases, the
+ *            HDF5 API uses resources that are allocated and freed either
+ *            entirely by the user or entirely by the library, so this is not a
+ *            problem. In rare cases, however, HDF5 API calls will free memory
+ *            that the user allocated. This function allows the user to safely
+ *            allocate this memory.\n
+ *            It is particularly important to use this function to resize
+ *            memory on Microsoft Windows systems. In Windows, the C standard
+ *            library is implemented in dynamic link libraries (DLLs) known as
+ *            the C run-time (CRT). Each version of Visual Studio comes with
+ *            multiple versions of the CRT DLLs (debug, release, et cetera) and
+ *            allocating and freeing memory across DLL boundaries can cause
+ *            resource leaks and subtle bugs due to heap corruption.\n
+ *            Even when using this function, it is still best to ensure that
+ *            all components of a C application are built with the same version
+ *            of Visual Studio and the same configuration (Debug or Release),
+ *            and thus linked against the same CRT.\n
+ *            Only use this function to resize memory inside third-party HDF5
+ *            filters. It will generally not be safe to use this function to
+ *            resize memory for any other purpose.
+ *
+ * \see H5allocate_memory(), H5free_memory()
+ *
+ * \since 1.8.15
+ *
+ */
+H5_DLL void *H5resize_memory(void *mem, size_t size);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* H5public_H */
diff --git a/install/include/H5version.h b/install/include/H5version.h
new file mode 100644
index 0000000000..f227ac7f35
--- /dev/null
+++ b/install/include/H5version.h
@@ -0,0 +1,1342 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* Generated automatically by bin/make_vers -- do not edit */
+/* Add new versioned symbols to H5vers.txt file */
+
+
+#ifndef H5version_H
+#define H5version_H
+
+
+/* If a particular default "global" version of the library's interfaces is
+ *      chosen, set the corresponding version macro for API symbols.
+ *
+ */
+
+#if defined(H5_USE_16_API_DEFAULT) && !defined(H5_USE_16_API)
+  #define H5_USE_16_API 1
+#endif /* H5_USE_16_API_DEFAULT && !H5_USE_16_API */
+
+#if defined(H5_USE_18_API_DEFAULT) && !defined(H5_USE_18_API)
+  #define H5_USE_18_API 1
+#endif /* H5_USE_18_API_DEFAULT && !H5_USE_18_API */
+
+#if defined(H5_USE_110_API_DEFAULT) && !defined(H5_USE_110_API)
+  #define H5_USE_110_API 1
+#endif /* H5_USE_110_API_DEFAULT && !H5_USE_110_API */
+
+#if defined(H5_USE_112_API_DEFAULT) && !defined(H5_USE_112_API)
+  #define H5_USE_112_API 1
+#endif /* H5_USE_112_API_DEFAULT && !H5_USE_112_API */
+
+#if defined(H5_USE_114_API_DEFAULT) && !defined(H5_USE_114_API)
+  #define H5_USE_114_API 1
+#endif /* H5_USE_114_API_DEFAULT && !H5_USE_114_API */
+
+
+/* Issue error if contradicting macros have been defined. */
+/* (Can't use an older (deprecated) API version if deprecated symbols have been disabled) */
+#if (defined(H5_USE_16_API) || defined(H5_USE_18_API) || defined(H5_USE_110_API) || defined(H5_USE_112_API) || defined(H5_USE_114_API)) && defined(H5_NO_DEPRECATED_SYMBOLS)
+  #error "Can't choose old API versions when deprecated APIs are disabled"
+#endif /* (defined(H5_USE_16_API) || defined(H5_USE_18_API) || defined(H5_USE_110_API) || defined(H5_USE_112_API) || defined(H5_USE_114_API)) && defined(H5_NO_DEPRECATED_SYMBOLS) */
+
+
+/* If a particular "global" version of the library's interfaces is chosen,
+ *      set the versions for the API symbols affected.
+ *
+ * Note: If an application has already chosen a particular version for an
+ *      API symbol, the individual API version macro takes priority.
+ */
+
+#ifdef H5_USE_16_API
+
+/*************/
+/* Functions */
+/*************/
+
+#if !defined(H5Acreate_vers)
+  #define H5Acreate_vers 1
+#endif /* !defined(H5Acreate_vers) */
+
+#if !defined(H5Aiterate_vers)
+  #define H5Aiterate_vers 1
+#endif /* !defined(H5Aiterate_vers) */
+
+#if !defined(H5Dcreate_vers)
+  #define H5Dcreate_vers 1
+#endif /* !defined(H5Dcreate_vers) */
+
+#if !defined(H5Dopen_vers)
+  #define H5Dopen_vers 1
+#endif /* !defined(H5Dopen_vers) */
+
+#if !defined(H5Eclear_vers)
+  #define H5Eclear_vers 1
+#endif /* !defined(H5Eclear_vers) */
+
+#if !defined(H5Eget_auto_vers)
+  #define H5Eget_auto_vers 1
+#endif /* !defined(H5Eget_auto_vers) */
+
+#if !defined(H5Eprint_vers)
+  #define H5Eprint_vers 1
+#endif /* !defined(H5Eprint_vers) */
+
+#if !defined(H5Epush_vers)
+  #define H5Epush_vers 1
+#endif /* !defined(H5Epush_vers) */
+
+#if !defined(H5Eset_auto_vers)
+  #define H5Eset_auto_vers 1
+#endif /* !defined(H5Eset_auto_vers) */
+
+#if !defined(H5Ewalk_vers)
+  #define H5Ewalk_vers 1
+#endif /* !defined(H5Ewalk_vers) */
+
+#if !defined(H5Gcreate_vers)
+  #define H5Gcreate_vers 1
+#endif /* !defined(H5Gcreate_vers) */
+
+#if !defined(H5Gopen_vers)
+  #define H5Gopen_vers 1
+#endif /* !defined(H5Gopen_vers) */
+
+#if !defined(H5Pget_filter_vers)
+  #define H5Pget_filter_vers 1
+#endif /* !defined(H5Pget_filter_vers) */
+
+#if !defined(H5Pget_filter_by_id_vers)
+  #define H5Pget_filter_by_id_vers 1
+#endif /* !defined(H5Pget_filter_by_id_vers) */
+
+#if !defined(H5Pinsert_vers)
+  #define H5Pinsert_vers 1
+#endif /* !defined(H5Pinsert_vers) */
+
+#if !defined(H5Pregister_vers)
+  #define H5Pregister_vers 1
+#endif /* !defined(H5Pregister_vers) */
+
+#if !defined(H5Rdereference_vers)
+  #define H5Rdereference_vers 1
+#endif /* !defined(H5Rdereference_vers) */
+
+#if !defined(H5Rget_obj_type_vers)
+  #define H5Rget_obj_type_vers 1
+#endif /* !defined(H5Rget_obj_type_vers) */
+
+#if !defined(H5Tarray_create_vers)
+  #define H5Tarray_create_vers 1
+#endif /* !defined(H5Tarray_create_vers) */
+
+#if !defined(H5Tcommit_vers)
+  #define H5Tcommit_vers 1
+#endif /* !defined(H5Tcommit_vers) */
+
+#if !defined(H5Tget_array_dims_vers)
+  #define H5Tget_array_dims_vers 1
+#endif /* !defined(H5Tget_array_dims_vers) */
+
+#if !defined(H5Topen_vers)
+  #define H5Topen_vers 1
+#endif /* !defined(H5Topen_vers) */
+
+/************/
+/* Typedefs */
+/************/
+
+#if !defined(H5E_auto_t_vers)
+  #define H5E_auto_t_vers 1
+#endif /* !defined(H5E_auto_t_vers) */
+
+#if !defined(H5Z_class_t_vers)
+  #define H5Z_class_t_vers 1
+#endif /* !defined(H5Z_class_t_vers) */
+
+#endif /* H5_USE_16_API */
+
+#ifdef H5_USE_18_API
+
+/*************/
+/* Functions */
+/*************/
+
+#if !defined(H5Acreate_vers)
+  #define H5Acreate_vers 2
+#endif /* !defined(H5Acreate_vers) */
+
+#if !defined(H5Aiterate_vers)
+  #define H5Aiterate_vers 2
+#endif /* !defined(H5Aiterate_vers) */
+
+#if !defined(H5Dcreate_vers)
+  #define H5Dcreate_vers 2
+#endif /* !defined(H5Dcreate_vers) */
+
+#if !defined(H5Dopen_vers)
+  #define H5Dopen_vers 2
+#endif /* !defined(H5Dopen_vers) */
+
+#if !defined(H5Eclear_vers)
+  #define H5Eclear_vers 2
+#endif /* !defined(H5Eclear_vers) */
+
+#if !defined(H5Eget_auto_vers)
+  #define H5Eget_auto_vers 2
+#endif /* !defined(H5Eget_auto_vers) */
+
+#if !defined(H5Eprint_vers)
+  #define H5Eprint_vers 2
+#endif /* !defined(H5Eprint_vers) */
+
+#if !defined(H5Epush_vers)
+  #define H5Epush_vers 2
+#endif /* !defined(H5Epush_vers) */
+
+#if !defined(H5Eset_auto_vers)
+  #define H5Eset_auto_vers 2
+#endif /* !defined(H5Eset_auto_vers) */
+
+#if !defined(H5Ewalk_vers)
+  #define H5Ewalk_vers 2
+#endif /* !defined(H5Ewalk_vers) */
+
+#if !defined(H5Fget_info_vers)
+  #define H5Fget_info_vers 1
+#endif /* !defined(H5Fget_info_vers) */
+
+#if !defined(H5Gcreate_vers)
+  #define H5Gcreate_vers 2
+#endif /* !defined(H5Gcreate_vers) */
+
+#if !defined(H5Gopen_vers)
+  #define H5Gopen_vers 2
+#endif /* !defined(H5Gopen_vers) */
+
+#if !defined(H5Lget_info_vers)
+  #define H5Lget_info_vers 1
+#endif /* !defined(H5Lget_info_vers) */
+
+#if !defined(H5Lget_info_by_idx_vers)
+  #define H5Lget_info_by_idx_vers 1
+#endif /* !defined(H5Lget_info_by_idx_vers) */
+
+#if !defined(H5Literate_vers)
+  #define H5Literate_vers 1
+#endif /* !defined(H5Literate_vers) */
+
+#if !defined(H5Literate_by_name_vers)
+  #define H5Literate_by_name_vers 1
+#endif /* !defined(H5Literate_by_name_vers) */
+
+#if !defined(H5Lvisit_vers)
+  #define H5Lvisit_vers 1
+#endif /* !defined(H5Lvisit_vers) */
+
+#if !defined(H5Lvisit_by_name_vers)
+  #define H5Lvisit_by_name_vers 1
+#endif /* !defined(H5Lvisit_by_name_vers) */
+
+#if !defined(H5Oget_info_vers)
+  #define H5Oget_info_vers 1
+#endif /* !defined(H5Oget_info_vers) */
+
+#if !defined(H5Oget_info_by_idx_vers)
+  #define H5Oget_info_by_idx_vers 1
+#endif /* !defined(H5Oget_info_by_idx_vers) */
+
+#if !defined(H5Oget_info_by_name_vers)
+  #define H5Oget_info_by_name_vers 1
+#endif /* !defined(H5Oget_info_by_name_vers) */
+
+#if !defined(H5Ovisit_vers)
+  #define H5Ovisit_vers 1
+#endif /* !defined(H5Ovisit_vers) */
+
+#if !defined(H5Ovisit_by_name_vers)
+  #define H5Ovisit_by_name_vers 1
+#endif /* !defined(H5Ovisit_by_name_vers) */
+
+#if !defined(H5Pget_filter_vers)
+  #define H5Pget_filter_vers 2
+#endif /* !defined(H5Pget_filter_vers) */
+
+#if !defined(H5Pget_filter_by_id_vers)
+  #define H5Pget_filter_by_id_vers 2
+#endif /* !defined(H5Pget_filter_by_id_vers) */
+
+#if !defined(H5Pinsert_vers)
+  #define H5Pinsert_vers 2
+#endif /* !defined(H5Pinsert_vers) */
+
+#if !defined(H5Pregister_vers)
+  #define H5Pregister_vers 2
+#endif /* !defined(H5Pregister_vers) */
+
+#if !defined(H5Rdereference_vers)
+  #define H5Rdereference_vers 1
+#endif /* !defined(H5Rdereference_vers) */
+
+#if !defined(H5Rget_obj_type_vers)
+  #define H5Rget_obj_type_vers 2
+#endif /* !defined(H5Rget_obj_type_vers) */
+
+#if !defined(H5Sencode_vers)
+  #define H5Sencode_vers 1
+#endif /* !defined(H5Sencode_vers) */
+
+#if !defined(H5Tarray_create_vers)
+  #define H5Tarray_create_vers 2
+#endif /* !defined(H5Tarray_create_vers) */
+
+#if !defined(H5Tcommit_vers)
+  #define H5Tcommit_vers 2
+#endif /* !defined(H5Tcommit_vers) */
+
+#if !defined(H5Tget_array_dims_vers)
+  #define H5Tget_array_dims_vers 2
+#endif /* !defined(H5Tget_array_dims_vers) */
+
+#if !defined(H5Topen_vers)
+  #define H5Topen_vers 2
+#endif /* !defined(H5Topen_vers) */
+
+/************/
+/* Typedefs */
+/************/
+
+#if !defined(H5E_auto_t_vers)
+  #define H5E_auto_t_vers 2
+#endif /* !defined(H5E_auto_t_vers) */
+
+#if !defined(H5O_info_t_vers)
+  #define H5O_info_t_vers 1
+#endif /* !defined(H5O_info_t_vers) */
+
+#if !defined(H5O_iterate_t_vers)
+  #define H5O_iterate_t_vers 1
+#endif /* !defined(H5O_iterate_t_vers) */
+
+#if !defined(H5Z_class_t_vers)
+  #define H5Z_class_t_vers 2
+#endif /* !defined(H5Z_class_t_vers) */
+
+#endif /* H5_USE_18_API */
+
+#ifdef H5_USE_110_API
+
+/*************/
+/* Functions */
+/*************/
+
+#if !defined(H5Acreate_vers)
+  #define H5Acreate_vers 2
+#endif /* !defined(H5Acreate_vers) */
+
+#if !defined(H5Aiterate_vers)
+  #define H5Aiterate_vers 2
+#endif /* !defined(H5Aiterate_vers) */
+
+#if !defined(H5Dcreate_vers)
+  #define H5Dcreate_vers 2
+#endif /* !defined(H5Dcreate_vers) */
+
+#if !defined(H5Dopen_vers)
+  #define H5Dopen_vers 2
+#endif /* !defined(H5Dopen_vers) */
+
+#if !defined(H5Eclear_vers)
+  #define H5Eclear_vers 2
+#endif /* !defined(H5Eclear_vers) */
+
+#if !defined(H5Eget_auto_vers)
+  #define H5Eget_auto_vers 2
+#endif /* !defined(H5Eget_auto_vers) */
+
+#if !defined(H5Eprint_vers)
+  #define H5Eprint_vers 2
+#endif /* !defined(H5Eprint_vers) */
+
+#if !defined(H5Epush_vers)
+  #define H5Epush_vers 2
+#endif /* !defined(H5Epush_vers) */
+
+#if !defined(H5Eset_auto_vers)
+  #define H5Eset_auto_vers 2
+#endif /* !defined(H5Eset_auto_vers) */
+
+#if !defined(H5Ewalk_vers)
+  #define H5Ewalk_vers 2
+#endif /* !defined(H5Ewalk_vers) */
+
+#if !defined(H5Fget_info_vers)
+  #define H5Fget_info_vers 2
+#endif /* !defined(H5Fget_info_vers) */
+
+#if !defined(H5Gcreate_vers)
+  #define H5Gcreate_vers 2
+#endif /* !defined(H5Gcreate_vers) */
+
+#if !defined(H5Gopen_vers)
+  #define H5Gopen_vers 2
+#endif /* !defined(H5Gopen_vers) */
+
+#if !defined(H5Lget_info_vers)
+  #define H5Lget_info_vers 1
+#endif /* !defined(H5Lget_info_vers) */
+
+#if !defined(H5Lget_info_by_idx_vers)
+  #define H5Lget_info_by_idx_vers 1
+#endif /* !defined(H5Lget_info_by_idx_vers) */
+
+#if !defined(H5Literate_vers)
+  #define H5Literate_vers 1
+#endif /* !defined(H5Literate_vers) */
+
+#if !defined(H5Literate_by_name_vers)
+  #define H5Literate_by_name_vers 1
+#endif /* !defined(H5Literate_by_name_vers) */
+
+#if !defined(H5Lvisit_vers)
+  #define H5Lvisit_vers 1
+#endif /* !defined(H5Lvisit_vers) */
+
+#if !defined(H5Lvisit_by_name_vers)
+  #define H5Lvisit_by_name_vers 1
+#endif /* !defined(H5Lvisit_by_name_vers) */
+
+#if !defined(H5Oget_info_vers)
+  #define H5Oget_info_vers 1
+#endif /* !defined(H5Oget_info_vers) */
+
+#if !defined(H5Oget_info_by_idx_vers)
+  #define H5Oget_info_by_idx_vers 1
+#endif /* !defined(H5Oget_info_by_idx_vers) */
+
+#if !defined(H5Oget_info_by_name_vers)
+  #define H5Oget_info_by_name_vers 1
+#endif /* !defined(H5Oget_info_by_name_vers) */
+
+#if !defined(H5Ovisit_vers)
+  #define H5Ovisit_vers 1
+#endif /* !defined(H5Ovisit_vers) */
+
+#if !defined(H5Ovisit_by_name_vers)
+  #define H5Ovisit_by_name_vers 1
+#endif /* !defined(H5Ovisit_by_name_vers) */
+
+#if !defined(H5Pencode_vers)
+  #define H5Pencode_vers 1
+#endif /* !defined(H5Pencode_vers) */
+
+#if !defined(H5Pget_filter_vers)
+  #define H5Pget_filter_vers 2
+#endif /* !defined(H5Pget_filter_vers) */
+
+#if !defined(H5Pget_filter_by_id_vers)
+  #define H5Pget_filter_by_id_vers 2
+#endif /* !defined(H5Pget_filter_by_id_vers) */
+
+#if !defined(H5Pinsert_vers)
+  #define H5Pinsert_vers 2
+#endif /* !defined(H5Pinsert_vers) */
+
+#if !defined(H5Pregister_vers)
+  #define H5Pregister_vers 2
+#endif /* !defined(H5Pregister_vers) */
+
+#if !defined(H5Rdereference_vers)
+  #define H5Rdereference_vers 2
+#endif /* !defined(H5Rdereference_vers) */
+
+#if !defined(H5Rget_obj_type_vers)
+  #define H5Rget_obj_type_vers 2
+#endif /* !defined(H5Rget_obj_type_vers) */
+
+#if !defined(H5Sencode_vers)
+  #define H5Sencode_vers 1
+#endif /* !defined(H5Sencode_vers) */
+
+#if !defined(H5Tarray_create_vers)
+  #define H5Tarray_create_vers 2
+#endif /* !defined(H5Tarray_create_vers) */
+
+#if !defined(H5Tcommit_vers)
+  #define H5Tcommit_vers 2
+#endif /* !defined(H5Tcommit_vers) */
+
+#if !defined(H5Tget_array_dims_vers)
+  #define H5Tget_array_dims_vers 2
+#endif /* !defined(H5Tget_array_dims_vers) */
+
+#if !defined(H5Topen_vers)
+  #define H5Topen_vers 2
+#endif /* !defined(H5Topen_vers) */
+
+/************/
+/* Typedefs */
+/************/
+
+#if !defined(H5E_auto_t_vers)
+  #define H5E_auto_t_vers 2
+#endif /* !defined(H5E_auto_t_vers) */
+
+#if !defined(H5O_info_t_vers)
+  #define H5O_info_t_vers 1
+#endif /* !defined(H5O_info_t_vers) */
+
+#if !defined(H5O_iterate_t_vers)
+  #define H5O_iterate_t_vers 1
+#endif /* !defined(H5O_iterate_t_vers) */
+
+#if !defined(H5Z_class_t_vers)
+  #define H5Z_class_t_vers 2
+#endif /* !defined(H5Z_class_t_vers) */
+
+#endif /* H5_USE_110_API */
+
+#ifdef H5_USE_112_API
+
+/*************/
+/* Functions */
+/*************/
+
+#if !defined(H5Acreate_vers)
+  #define H5Acreate_vers 2
+#endif /* !defined(H5Acreate_vers) */
+
+#if !defined(H5Aiterate_vers)
+  #define H5Aiterate_vers 2
+#endif /* !defined(H5Aiterate_vers) */
+
+#if !defined(H5Dcreate_vers)
+  #define H5Dcreate_vers 2
+#endif /* !defined(H5Dcreate_vers) */
+
+#if !defined(H5Dopen_vers)
+  #define H5Dopen_vers 2
+#endif /* !defined(H5Dopen_vers) */
+
+#if !defined(H5Eclear_vers)
+  #define H5Eclear_vers 2
+#endif /* !defined(H5Eclear_vers) */
+
+#if !defined(H5Eget_auto_vers)
+  #define H5Eget_auto_vers 2
+#endif /* !defined(H5Eget_auto_vers) */
+
+#if !defined(H5Eprint_vers)
+  #define H5Eprint_vers 2
+#endif /* !defined(H5Eprint_vers) */
+
+#if !defined(H5Epush_vers)
+  #define H5Epush_vers 2
+#endif /* !defined(H5Epush_vers) */
+
+#if !defined(H5Eset_auto_vers)
+  #define H5Eset_auto_vers 2
+#endif /* !defined(H5Eset_auto_vers) */
+
+#if !defined(H5Ewalk_vers)
+  #define H5Ewalk_vers 2
+#endif /* !defined(H5Ewalk_vers) */
+
+#if !defined(H5Fget_info_vers)
+  #define H5Fget_info_vers 2
+#endif /* !defined(H5Fget_info_vers) */
+
+#if !defined(H5Gcreate_vers)
+  #define H5Gcreate_vers 2
+#endif /* !defined(H5Gcreate_vers) */
+
+#if !defined(H5Gopen_vers)
+  #define H5Gopen_vers 2
+#endif /* !defined(H5Gopen_vers) */
+
+#if !defined(H5Lget_info_vers)
+  #define H5Lget_info_vers 2
+#endif /* !defined(H5Lget_info_vers) */
+
+#if !defined(H5Lget_info_by_idx_vers)
+  #define H5Lget_info_by_idx_vers 2
+#endif /* !defined(H5Lget_info_by_idx_vers) */
+
+#if !defined(H5Literate_vers)
+  #define H5Literate_vers 2
+#endif /* !defined(H5Literate_vers) */
+
+#if !defined(H5Literate_by_name_vers)
+  #define H5Literate_by_name_vers 2
+#endif /* !defined(H5Literate_by_name_vers) */
+
+#if !defined(H5Lvisit_vers)
+  #define H5Lvisit_vers 2
+#endif /* !defined(H5Lvisit_vers) */
+
+#if !defined(H5Lvisit_by_name_vers)
+  #define H5Lvisit_by_name_vers 2
+#endif /* !defined(H5Lvisit_by_name_vers) */
+
+#if !defined(H5Oget_info_vers)
+  #define H5Oget_info_vers 3
+#endif /* !defined(H5Oget_info_vers) */
+
+#if !defined(H5Oget_info_by_idx_vers)
+  #define H5Oget_info_by_idx_vers 3
+#endif /* !defined(H5Oget_info_by_idx_vers) */
+
+#if !defined(H5Oget_info_by_name_vers)
+  #define H5Oget_info_by_name_vers 3
+#endif /* !defined(H5Oget_info_by_name_vers) */
+
+#if !defined(H5Ovisit_vers)
+  #define H5Ovisit_vers 3
+#endif /* !defined(H5Ovisit_vers) */
+
+#if !defined(H5Ovisit_by_name_vers)
+  #define H5Ovisit_by_name_vers 3
+#endif /* !defined(H5Ovisit_by_name_vers) */
+
+#if !defined(H5Pencode_vers)
+  #define H5Pencode_vers 2
+#endif /* !defined(H5Pencode_vers) */
+
+#if !defined(H5Pget_filter_vers)
+  #define H5Pget_filter_vers 2
+#endif /* !defined(H5Pget_filter_vers) */
+
+#if !defined(H5Pget_filter_by_id_vers)
+  #define H5Pget_filter_by_id_vers 2
+#endif /* !defined(H5Pget_filter_by_id_vers) */
+
+#if !defined(H5Pinsert_vers)
+  #define H5Pinsert_vers 2
+#endif /* !defined(H5Pinsert_vers) */
+
+#if !defined(H5Pregister_vers)
+  #define H5Pregister_vers 2
+#endif /* !defined(H5Pregister_vers) */
+
+#if !defined(H5Rdereference_vers)
+  #define H5Rdereference_vers 2
+#endif /* !defined(H5Rdereference_vers) */
+
+#if !defined(H5Rget_obj_type_vers)
+  #define H5Rget_obj_type_vers 2
+#endif /* !defined(H5Rget_obj_type_vers) */
+
+#if !defined(H5Sencode_vers)
+  #define H5Sencode_vers 2
+#endif /* !defined(H5Sencode_vers) */
+
+#if !defined(H5Tarray_create_vers)
+  #define H5Tarray_create_vers 2
+#endif /* !defined(H5Tarray_create_vers) */
+
+#if !defined(H5Tcommit_vers)
+  #define H5Tcommit_vers 2
+#endif /* !defined(H5Tcommit_vers) */
+
+#if !defined(H5Tget_array_dims_vers)
+  #define H5Tget_array_dims_vers 2
+#endif /* !defined(H5Tget_array_dims_vers) */
+
+#if !defined(H5Topen_vers)
+  #define H5Topen_vers 2
+#endif /* !defined(H5Topen_vers) */
+
+/************/
+/* Typedefs */
+/************/
+
+#if !defined(H5E_auto_t_vers)
+  #define H5E_auto_t_vers 2
+#endif /* !defined(H5E_auto_t_vers) */
+
+#if !defined(H5O_info_t_vers)
+  #define H5O_info_t_vers 2
+#endif /* !defined(H5O_info_t_vers) */
+
+#if !defined(H5O_iterate_t_vers)
+  #define H5O_iterate_t_vers 2
+#endif /* !defined(H5O_iterate_t_vers) */
+
+#if !defined(H5Z_class_t_vers)
+  #define H5Z_class_t_vers 2
+#endif /* !defined(H5Z_class_t_vers) */
+
+#endif /* H5_USE_112_API */
+
+#ifdef H5_USE_114_API
+
+/*************/
+/* Functions */
+/*************/
+
+#if !defined(H5Acreate_vers)
+  #define H5Acreate_vers 2
+#endif /* !defined(H5Acreate_vers) */
+
+#if !defined(H5Aiterate_vers)
+  #define H5Aiterate_vers 2
+#endif /* !defined(H5Aiterate_vers) */
+
+#if !defined(H5Dcreate_vers)
+  #define H5Dcreate_vers 2
+#endif /* !defined(H5Dcreate_vers) */
+
+#if !defined(H5Dopen_vers)
+  #define H5Dopen_vers 2
+#endif /* !defined(H5Dopen_vers) */
+
+#if !defined(H5Eclear_vers)
+  #define H5Eclear_vers 2
+#endif /* !defined(H5Eclear_vers) */
+
+#if !defined(H5Eget_auto_vers)
+  #define H5Eget_auto_vers 2
+#endif /* !defined(H5Eget_auto_vers) */
+
+#if !defined(H5Eprint_vers)
+  #define H5Eprint_vers 2
+#endif /* !defined(H5Eprint_vers) */
+
+#if !defined(H5Epush_vers)
+  #define H5Epush_vers 2
+#endif /* !defined(H5Epush_vers) */
+
+#if !defined(H5Eset_auto_vers)
+  #define H5Eset_auto_vers 2
+#endif /* !defined(H5Eset_auto_vers) */
+
+#if !defined(H5Ewalk_vers)
+  #define H5Ewalk_vers 2
+#endif /* !defined(H5Ewalk_vers) */
+
+#if !defined(H5Fget_info_vers)
+  #define H5Fget_info_vers 2
+#endif /* !defined(H5Fget_info_vers) */
+
+#if !defined(H5Gcreate_vers)
+  #define H5Gcreate_vers 2
+#endif /* !defined(H5Gcreate_vers) */
+
+#if !defined(H5Gopen_vers)
+  #define H5Gopen_vers 2
+#endif /* !defined(H5Gopen_vers) */
+
+#if !defined(H5Lget_info_vers)
+  #define H5Lget_info_vers 2
+#endif /* !defined(H5Lget_info_vers) */
+
+#if !defined(H5Lget_info_by_idx_vers)
+  #define H5Lget_info_by_idx_vers 2
+#endif /* !defined(H5Lget_info_by_idx_vers) */
+
+#if !defined(H5Literate_vers)
+  #define H5Literate_vers 2
+#endif /* !defined(H5Literate_vers) */
+
+#if !defined(H5Literate_by_name_vers)
+  #define H5Literate_by_name_vers 2
+#endif /* !defined(H5Literate_by_name_vers) */
+
+#if !defined(H5Lvisit_vers)
+  #define H5Lvisit_vers 2
+#endif /* !defined(H5Lvisit_vers) */
+
+#if !defined(H5Lvisit_by_name_vers)
+  #define H5Lvisit_by_name_vers 2
+#endif /* !defined(H5Lvisit_by_name_vers) */
+
+#if !defined(H5Oget_info_vers)
+  #define H5Oget_info_vers 3
+#endif /* !defined(H5Oget_info_vers) */
+
+#if !defined(H5Oget_info_by_idx_vers)
+  #define H5Oget_info_by_idx_vers 3
+#endif /* !defined(H5Oget_info_by_idx_vers) */
+
+#if !defined(H5Oget_info_by_name_vers)
+  #define H5Oget_info_by_name_vers 3
+#endif /* !defined(H5Oget_info_by_name_vers) */
+
+#if !defined(H5Ovisit_vers)
+  #define H5Ovisit_vers 3
+#endif /* !defined(H5Ovisit_vers) */
+
+#if !defined(H5Ovisit_by_name_vers)
+  #define H5Ovisit_by_name_vers 3
+#endif /* !defined(H5Ovisit_by_name_vers) */
+
+#if !defined(H5Pencode_vers)
+  #define H5Pencode_vers 2
+#endif /* !defined(H5Pencode_vers) */
+
+#if !defined(H5Pget_filter_vers)
+  #define H5Pget_filter_vers 2
+#endif /* !defined(H5Pget_filter_vers) */
+
+#if !defined(H5Pget_filter_by_id_vers)
+  #define H5Pget_filter_by_id_vers 2
+#endif /* !defined(H5Pget_filter_by_id_vers) */
+
+#if !defined(H5Pinsert_vers)
+  #define H5Pinsert_vers 2
+#endif /* !defined(H5Pinsert_vers) */
+
+#if !defined(H5Pregister_vers)
+  #define H5Pregister_vers 2
+#endif /* !defined(H5Pregister_vers) */
+
+#if !defined(H5Rdereference_vers)
+  #define H5Rdereference_vers 2
+#endif /* !defined(H5Rdereference_vers) */
+
+#if !defined(H5Rget_obj_type_vers)
+  #define H5Rget_obj_type_vers 2
+#endif /* !defined(H5Rget_obj_type_vers) */
+
+#if !defined(H5Sencode_vers)
+  #define H5Sencode_vers 2
+#endif /* !defined(H5Sencode_vers) */
+
+#if !defined(H5Tarray_create_vers)
+  #define H5Tarray_create_vers 2
+#endif /* !defined(H5Tarray_create_vers) */
+
+#if !defined(H5Tcommit_vers)
+  #define H5Tcommit_vers 2
+#endif /* !defined(H5Tcommit_vers) */
+
+#if !defined(H5Tget_array_dims_vers)
+  #define H5Tget_array_dims_vers 2
+#endif /* !defined(H5Tget_array_dims_vers) */
+
+#if !defined(H5Topen_vers)
+  #define H5Topen_vers 2
+#endif /* !defined(H5Topen_vers) */
+
+/************/
+/* Typedefs */
+/************/
+
+#if !defined(H5E_auto_t_vers)
+  #define H5E_auto_t_vers 2
+#endif /* !defined(H5E_auto_t_vers) */
+
+#if !defined(H5O_info_t_vers)
+  #define H5O_info_t_vers 2
+#endif /* !defined(H5O_info_t_vers) */
+
+#if !defined(H5O_iterate_t_vers)
+  #define H5O_iterate_t_vers 2
+#endif /* !defined(H5O_iterate_t_vers) */
+
+#if !defined(H5Z_class_t_vers)
+  #define H5Z_class_t_vers 2
+#endif /* !defined(H5Z_class_t_vers) */
+
+#endif /* H5_USE_114_API */
+
+
+/* Choose the correct version of each API symbol, defaulting to the latest
+ *      version of each.  The "best" name for API parameters/data structures
+ *      that have changed definitions is also set.  An error is issued for
+ *      specifying an invalid API version.
+ */
+
+/*************/
+/* Functions */
+/*************/
+
+#if !defined(H5Acreate_vers) || H5Acreate_vers == 2
+  #ifndef H5Acreate_vers
+    #define H5Acreate_vers 2
+  #endif /* H5Acreate_vers */
+  #define H5Acreate H5Acreate2
+#elif H5Acreate_vers == 1
+  #define H5Acreate H5Acreate1
+#else /* H5Acreate_vers */
+  #error "H5Acreate_vers set to invalid value"
+#endif /* H5Acreate_vers */
+
+#if !defined(H5Aiterate_vers) || H5Aiterate_vers == 2
+  #ifndef H5Aiterate_vers
+    #define H5Aiterate_vers 2
+  #endif /* H5Aiterate_vers */
+  #define H5Aiterate H5Aiterate2
+  #define H5A_operator_t H5A_operator2_t
+#elif H5Aiterate_vers == 1
+  #define H5Aiterate H5Aiterate1
+  #define H5A_operator_t H5A_operator1_t
+#else /* H5Aiterate_vers */
+  #error "H5Aiterate_vers set to invalid value"
+#endif /* H5Aiterate_vers */
+
+#if !defined(H5Dcreate_vers) || H5Dcreate_vers == 2
+  #ifndef H5Dcreate_vers
+    #define H5Dcreate_vers 2
+  #endif /* H5Dcreate_vers */
+  #define H5Dcreate H5Dcreate2
+#elif H5Dcreate_vers == 1
+  #define H5Dcreate H5Dcreate1
+#else /* H5Dcreate_vers */
+  #error "H5Dcreate_vers set to invalid value"
+#endif /* H5Dcreate_vers */
+
+#if !defined(H5Dopen_vers) || H5Dopen_vers == 2
+  #ifndef H5Dopen_vers
+    #define H5Dopen_vers 2
+  #endif /* H5Dopen_vers */
+  #define H5Dopen H5Dopen2
+#elif H5Dopen_vers == 1
+  #define H5Dopen H5Dopen1
+#else /* H5Dopen_vers */
+  #error "H5Dopen_vers set to invalid value"
+#endif /* H5Dopen_vers */
+
+#if !defined(H5Eclear_vers) || H5Eclear_vers == 2
+  #ifndef H5Eclear_vers
+    #define H5Eclear_vers 2
+  #endif /* H5Eclear_vers */
+  #define H5Eclear H5Eclear2
+#elif H5Eclear_vers == 1
+  #define H5Eclear H5Eclear1
+#else /* H5Eclear_vers */
+  #error "H5Eclear_vers set to invalid value"
+#endif /* H5Eclear_vers */
+
+#if !defined(H5Eget_auto_vers) || H5Eget_auto_vers == 2
+  #ifndef H5Eget_auto_vers
+    #define H5Eget_auto_vers 2
+  #endif /* H5Eget_auto_vers */
+  #define H5Eget_auto H5Eget_auto2
+#elif H5Eget_auto_vers == 1
+  #define H5Eget_auto H5Eget_auto1
+#else /* H5Eget_auto_vers */
+  #error "H5Eget_auto_vers set to invalid value"
+#endif /* H5Eget_auto_vers */
+
+#if !defined(H5Eprint_vers) || H5Eprint_vers == 2
+  #ifndef H5Eprint_vers
+    #define H5Eprint_vers 2
+  #endif /* H5Eprint_vers */
+  #define H5Eprint H5Eprint2
+#elif H5Eprint_vers == 1
+  #define H5Eprint H5Eprint1
+#else /* H5Eprint_vers */
+  #error "H5Eprint_vers set to invalid value"
+#endif /* H5Eprint_vers */
+
+#if !defined(H5Epush_vers) || H5Epush_vers == 2
+  #ifndef H5Epush_vers
+    #define H5Epush_vers 2
+  #endif /* H5Epush_vers */
+  #define H5Epush H5Epush2
+#elif H5Epush_vers == 1
+  #define H5Epush H5Epush1
+#else /* H5Epush_vers */
+  #error "H5Epush_vers set to invalid value"
+#endif /* H5Epush_vers */
+
+#if !defined(H5Eset_auto_vers) || H5Eset_auto_vers == 2
+  #ifndef H5Eset_auto_vers
+    #define H5Eset_auto_vers 2
+  #endif /* H5Eset_auto_vers */
+  #define H5Eset_auto H5Eset_auto2
+#elif H5Eset_auto_vers == 1
+  #define H5Eset_auto H5Eset_auto1
+#else /* H5Eset_auto_vers */
+  #error "H5Eset_auto_vers set to invalid value"
+#endif /* H5Eset_auto_vers */
+
+#if !defined(H5Ewalk_vers) || H5Ewalk_vers == 2
+  #ifndef H5Ewalk_vers
+    #define H5Ewalk_vers 2
+  #endif /* H5Ewalk_vers */
+  #define H5Ewalk H5Ewalk2
+  #define H5E_error_t H5E_error2_t
+  #define H5E_walk_t H5E_walk2_t
+#elif H5Ewalk_vers == 1
+  #define H5Ewalk H5Ewalk1
+  #define H5E_error_t H5E_error1_t
+  #define H5E_walk_t H5E_walk1_t
+#else /* H5Ewalk_vers */
+  #error "H5Ewalk_vers set to invalid value"
+#endif /* H5Ewalk_vers */
+
+#if !defined(H5Fget_info_vers) || H5Fget_info_vers == 2
+  #ifndef H5Fget_info_vers
+    #define H5Fget_info_vers 2
+  #endif /* H5Fget_info_vers */
+  #define H5Fget_info H5Fget_info2
+  #define H5F_info_t H5F_info2_t
+#elif H5Fget_info_vers == 1
+  #define H5Fget_info H5Fget_info1
+  #define H5F_info_t H5F_info1_t
+#else /* H5Fget_info_vers */
+  #error "H5Fget_info_vers set to invalid value"
+#endif /* H5Fget_info_vers */
+
+#if !defined(H5Gcreate_vers) || H5Gcreate_vers == 2
+  #ifndef H5Gcreate_vers
+    #define H5Gcreate_vers 2
+  #endif /* H5Gcreate_vers */
+  #define H5Gcreate H5Gcreate2
+#elif H5Gcreate_vers == 1
+  #define H5Gcreate H5Gcreate1
+#else /* H5Gcreate_vers */
+  #error "H5Gcreate_vers set to invalid value"
+#endif /* H5Gcreate_vers */
+
+#if !defined(H5Gopen_vers) || H5Gopen_vers == 2
+  #ifndef H5Gopen_vers
+    #define H5Gopen_vers 2
+  #endif /* H5Gopen_vers */
+  #define H5Gopen H5Gopen2
+#elif H5Gopen_vers == 1
+  #define H5Gopen H5Gopen1
+#else /* H5Gopen_vers */
+  #error "H5Gopen_vers set to invalid value"
+#endif /* H5Gopen_vers */
+
+#if !defined(H5Lget_info_vers) || H5Lget_info_vers == 2
+  #ifndef H5Lget_info_vers
+    #define H5Lget_info_vers 2
+  #endif /* H5Lget_info_vers */
+  #define H5Lget_info H5Lget_info2
+  #define H5L_info_t H5L_info2_t
+#elif H5Lget_info_vers == 1
+  #define H5Lget_info H5Lget_info1
+  #define H5L_info_t H5L_info1_t
+#else /* H5Lget_info_vers */
+  #error "H5Lget_info_vers set to invalid value"
+#endif /* H5Lget_info_vers */
+
+#if !defined(H5Lget_info_by_idx_vers) || H5Lget_info_by_idx_vers == 2
+  #ifndef H5Lget_info_by_idx_vers
+    #define H5Lget_info_by_idx_vers 2
+  #endif /* H5Lget_info_by_idx_vers */
+  #define H5Lget_info_by_idx H5Lget_info_by_idx2
+  #define H5L_info_t H5L_info2_t
+#elif H5Lget_info_by_idx_vers == 1
+  #define H5Lget_info_by_idx H5Lget_info_by_idx1
+  #define H5L_info_t H5L_info1_t
+#else /* H5Lget_info_by_idx_vers */
+  #error "H5Lget_info_by_idx_vers set to invalid value"
+#endif /* H5Lget_info_by_idx_vers */
+
+#if !defined(H5Literate_vers) || H5Literate_vers == 2
+  #ifndef H5Literate_vers
+    #define H5Literate_vers 2
+  #endif /* H5Literate_vers */
+  #define H5Literate H5Literate2
+  #define H5L_iterate_t H5L_iterate2_t
+#elif H5Literate_vers == 1
+  #define H5Literate H5Literate1
+  #define H5L_iterate_t H5L_iterate1_t
+#else /* H5Literate_vers */
+  #error "H5Literate_vers set to invalid value"
+#endif /* H5Literate_vers */
+
+#if !defined(H5Literate_by_name_vers) || H5Literate_by_name_vers == 2
+  #ifndef H5Literate_by_name_vers
+    #define H5Literate_by_name_vers 2
+  #endif /* H5Literate_by_name_vers */
+  #define H5Literate_by_name H5Literate_by_name2
+  #define H5L_iterate_t H5L_iterate2_t
+#elif H5Literate_by_name_vers == 1
+  #define H5Literate_by_name H5Literate_by_name1
+  #define H5L_iterate_t H5L_iterate1_t
+#else /* H5Literate_by_name_vers */
+  #error "H5Literate_by_name_vers set to invalid value"
+#endif /* H5Literate_by_name_vers */
+
+#if !defined(H5Lvisit_vers) || H5Lvisit_vers == 2
+  #ifndef H5Lvisit_vers
+    #define H5Lvisit_vers 2
+  #endif /* H5Lvisit_vers */
+  #define H5Lvisit H5Lvisit2
+  #define H5L_iterate_t H5L_iterate2_t
+#elif H5Lvisit_vers == 1
+  #define H5Lvisit H5Lvisit1
+  #define H5L_iterate_t H5L_iterate1_t
+#else /* H5Lvisit_vers */
+  #error "H5Lvisit_vers set to invalid value"
+#endif /* H5Lvisit_vers */
+
+#if !defined(H5Lvisit_by_name_vers) || H5Lvisit_by_name_vers == 2
+  #ifndef H5Lvisit_by_name_vers
+    #define H5Lvisit_by_name_vers 2
+  #endif /* H5Lvisit_by_name_vers */
+  #define H5Lvisit_by_name H5Lvisit_by_name2
+  #define H5L_iterate_t H5L_iterate2_t
+#elif H5Lvisit_by_name_vers == 1
+  #define H5Lvisit_by_name H5Lvisit_by_name1
+  #define H5L_iterate_t H5L_iterate1_t
+#else /* H5Lvisit_by_name_vers */
+  #error "H5Lvisit_by_name_vers set to invalid value"
+#endif /* H5Lvisit_by_name_vers */
+
+#if !defined(H5Oget_info_vers) || H5Oget_info_vers == 3
+  #ifndef H5Oget_info_vers
+    #define H5Oget_info_vers 3
+  #endif /* H5Oget_info_vers */
+  #define H5Oget_info H5Oget_info3
+#elif H5Oget_info_vers == 2
+  #define H5Oget_info H5Oget_info2
+#elif H5Oget_info_vers == 1
+  #define H5Oget_info H5Oget_info1
+#else /* H5Oget_info_vers */
+  #error "H5Oget_info_vers set to invalid value"
+#endif /* H5Oget_info_vers */
+
+#if !defined(H5Oget_info_by_idx_vers) || H5Oget_info_by_idx_vers == 3
+  #ifndef H5Oget_info_by_idx_vers
+    #define H5Oget_info_by_idx_vers 3
+  #endif /* H5Oget_info_by_idx_vers */
+  #define H5Oget_info_by_idx H5Oget_info_by_idx3
+#elif H5Oget_info_by_idx_vers == 2
+  #define H5Oget_info_by_idx H5Oget_info_by_idx2
+#elif H5Oget_info_by_idx_vers == 1
+  #define H5Oget_info_by_idx H5Oget_info_by_idx1
+#else /* H5Oget_info_by_idx_vers */
+  #error "H5Oget_info_by_idx_vers set to invalid value"
+#endif /* H5Oget_info_by_idx_vers */
+
+#if !defined(H5Oget_info_by_name_vers) || H5Oget_info_by_name_vers == 3
+  #ifndef H5Oget_info_by_name_vers
+    #define H5Oget_info_by_name_vers 3
+  #endif /* H5Oget_info_by_name_vers */
+  #define H5Oget_info_by_name H5Oget_info_by_name3
+#elif H5Oget_info_by_name_vers == 2
+  #define H5Oget_info_by_name H5Oget_info_by_name2
+#elif H5Oget_info_by_name_vers == 1
+  #define H5Oget_info_by_name H5Oget_info_by_name1
+#else /* H5Oget_info_by_name_vers */
+  #error "H5Oget_info_by_name_vers set to invalid value"
+#endif /* H5Oget_info_by_name_vers */
+
+#if !defined(H5Ovisit_vers) || H5Ovisit_vers == 3
+  #ifndef H5Ovisit_vers
+    #define H5Ovisit_vers 3
+  #endif /* H5Ovisit_vers */
+  #define H5Ovisit H5Ovisit3
+#elif H5Ovisit_vers == 2
+  #define H5Ovisit H5Ovisit2
+#elif H5Ovisit_vers == 1
+  #define H5Ovisit H5Ovisit1
+#else /* H5Ovisit_vers */
+  #error "H5Ovisit_vers set to invalid value"
+#endif /* H5Ovisit_vers */
+
+#if !defined(H5Ovisit_by_name_vers) || H5Ovisit_by_name_vers == 3
+  #ifndef H5Ovisit_by_name_vers
+    #define H5Ovisit_by_name_vers 3
+  #endif /* H5Ovisit_by_name_vers */
+  #define H5Ovisit_by_name H5Ovisit_by_name3
+#elif H5Ovisit_by_name_vers == 2
+  #define H5Ovisit_by_name H5Ovisit_by_name2
+#elif H5Ovisit_by_name_vers == 1
+  #define H5Ovisit_by_name H5Ovisit_by_name1
+#else /* H5Ovisit_by_name_vers */
+  #error "H5Ovisit_by_name_vers set to invalid value"
+#endif /* H5Ovisit_by_name_vers */
+
+#if !defined(H5Pencode_vers) || H5Pencode_vers == 2
+  #ifndef H5Pencode_vers
+    #define H5Pencode_vers 2
+  #endif /* H5Pencode_vers */
+  #define H5Pencode H5Pencode2
+#elif H5Pencode_vers == 1
+  #define H5Pencode H5Pencode1
+#else /* H5Pencode_vers */
+  #error "H5Pencode_vers set to invalid value"
+#endif /* H5Pencode_vers */
+
+#if !defined(H5Pget_filter_vers) || H5Pget_filter_vers == 2
+  #ifndef H5Pget_filter_vers
+    #define H5Pget_filter_vers 2
+  #endif /* H5Pget_filter_vers */
+  #define H5Pget_filter H5Pget_filter2
+#elif H5Pget_filter_vers == 1
+  #define H5Pget_filter H5Pget_filter1
+#else /* H5Pget_filter_vers */
+  #error "H5Pget_filter_vers set to invalid value"
+#endif /* H5Pget_filter_vers */
+
+#if !defined(H5Pget_filter_by_id_vers) || H5Pget_filter_by_id_vers == 2
+  #ifndef H5Pget_filter_by_id_vers
+    #define H5Pget_filter_by_id_vers 2
+  #endif /* H5Pget_filter_by_id_vers */
+  #define H5Pget_filter_by_id H5Pget_filter_by_id2
+#elif H5Pget_filter_by_id_vers == 1
+  #define H5Pget_filter_by_id H5Pget_filter_by_id1
+#else /* H5Pget_filter_by_id_vers */
+  #error "H5Pget_filter_by_id_vers set to invalid value"
+#endif /* H5Pget_filter_by_id_vers */
+
+#if !defined(H5Pinsert_vers) || H5Pinsert_vers == 2
+  #ifndef H5Pinsert_vers
+    #define H5Pinsert_vers 2
+  #endif /* H5Pinsert_vers */
+  #define H5Pinsert H5Pinsert2
+#elif H5Pinsert_vers == 1
+  #define H5Pinsert H5Pinsert1
+#else /* H5Pinsert_vers */
+  #error "H5Pinsert_vers set to invalid value"
+#endif /* H5Pinsert_vers */
+
+#if !defined(H5Pregister_vers) || H5Pregister_vers == 2
+  #ifndef H5Pregister_vers
+    #define H5Pregister_vers 2
+  #endif /* H5Pregister_vers */
+  #define H5Pregister H5Pregister2
+#elif H5Pregister_vers == 1
+  #define H5Pregister H5Pregister1
+#else /* H5Pregister_vers */
+  #error "H5Pregister_vers set to invalid value"
+#endif /* H5Pregister_vers */
+
+#if !defined(H5Rdereference_vers) || H5Rdereference_vers == 2
+  #ifndef H5Rdereference_vers
+    #define H5Rdereference_vers 2
+  #endif /* H5Rdereference_vers */
+  #define H5Rdereference H5Rdereference2
+#elif H5Rdereference_vers == 1
+  #define H5Rdereference H5Rdereference1
+#else /* H5Rdereference_vers */
+  #error "H5Rdereference_vers set to invalid value"
+#endif /* H5Rdereference_vers */
+
+#if !defined(H5Rget_obj_type_vers) || H5Rget_obj_type_vers == 2
+  #ifndef H5Rget_obj_type_vers
+    #define H5Rget_obj_type_vers 2
+  #endif /* H5Rget_obj_type_vers */
+  #define H5Rget_obj_type H5Rget_obj_type2
+#elif H5Rget_obj_type_vers == 1
+  #define H5Rget_obj_type H5Rget_obj_type1
+#else /* H5Rget_obj_type_vers */
+  #error "H5Rget_obj_type_vers set to invalid value"
+#endif /* H5Rget_obj_type_vers */
+
+#if !defined(H5Sencode_vers) || H5Sencode_vers == 2
+  #ifndef H5Sencode_vers
+    #define H5Sencode_vers 2
+  #endif /* H5Sencode_vers */
+  #define H5Sencode H5Sencode2
+#elif H5Sencode_vers == 1
+  #define H5Sencode H5Sencode1
+#else /* H5Sencode_vers */
+  #error "H5Sencode_vers set to invalid value"
+#endif /* H5Sencode_vers */
+
+#if !defined(H5Tarray_create_vers) || H5Tarray_create_vers == 2
+  #ifndef H5Tarray_create_vers
+    #define H5Tarray_create_vers 2
+  #endif /* H5Tarray_create_vers */
+  #define H5Tarray_create H5Tarray_create2
+#elif H5Tarray_create_vers == 1
+  #define H5Tarray_create H5Tarray_create1
+#else /* H5Tarray_create_vers */
+  #error "H5Tarray_create_vers set to invalid value"
+#endif /* H5Tarray_create_vers */
+
+#if !defined(H5Tcommit_vers) || H5Tcommit_vers == 2
+  #ifndef H5Tcommit_vers
+    #define H5Tcommit_vers 2
+  #endif /* H5Tcommit_vers */
+  #define H5Tcommit H5Tcommit2
+#elif H5Tcommit_vers == 1
+  #define H5Tcommit H5Tcommit1
+#else /* H5Tcommit_vers */
+  #error "H5Tcommit_vers set to invalid value"
+#endif /* H5Tcommit_vers */
+
+#if !defined(H5Tget_array_dims_vers) || H5Tget_array_dims_vers == 2
+  #ifndef H5Tget_array_dims_vers
+    #define H5Tget_array_dims_vers 2
+  #endif /* H5Tget_array_dims_vers */
+  #define H5Tget_array_dims H5Tget_array_dims2
+#elif H5Tget_array_dims_vers == 1
+  #define H5Tget_array_dims H5Tget_array_dims1
+#else /* H5Tget_array_dims_vers */
+  #error "H5Tget_array_dims_vers set to invalid value"
+#endif /* H5Tget_array_dims_vers */
+
+#if !defined(H5Topen_vers) || H5Topen_vers == 2
+  #ifndef H5Topen_vers
+    #define H5Topen_vers 2
+  #endif /* H5Topen_vers */
+  #define H5Topen H5Topen2
+#elif H5Topen_vers == 1
+  #define H5Topen H5Topen1
+#else /* H5Topen_vers */
+  #error "H5Topen_vers set to invalid value"
+#endif /* H5Topen_vers */
+
+/************/
+/* Typedefs */
+/************/
+
+#if !defined(H5E_auto_t_vers) || H5E_auto_t_vers == 2
+  #ifndef H5E_auto_t_vers
+    #define H5E_auto_t_vers 2
+  #endif /* H5E_auto_t_vers */
+  #define H5E_auto_t H5E_auto2_t
+#elif H5E_auto_t_vers == 1
+  #define H5E_auto_t H5E_auto1_t
+#else /* H5E_auto_t_vers */
+  #error "H5E_auto_t_vers set to invalid value"
+#endif /* H5E_auto_t_vers */
+
+
+#if !defined(H5O_info_t_vers) || H5O_info_t_vers == 2
+  #ifndef H5O_info_t_vers
+    #define H5O_info_t_vers 2
+  #endif /* H5O_info_t_vers */
+  #define H5O_info_t H5O_info2_t
+#elif H5O_info_t_vers == 1
+  #define H5O_info_t H5O_info1_t
+#else /* H5O_info_t_vers */
+  #error "H5O_info_t_vers set to invalid value"
+#endif /* H5O_info_t_vers */
+
+
+#if !defined(H5O_iterate_t_vers) || H5O_iterate_t_vers == 2
+  #ifndef H5O_iterate_t_vers
+    #define H5O_iterate_t_vers 2
+  #endif /* H5O_iterate_t_vers */
+  #define H5O_iterate_t H5O_iterate2_t
+#elif H5O_iterate_t_vers == 1
+  #define H5O_iterate_t H5O_iterate1_t
+#else /* H5O_iterate_t_vers */
+  #error "H5O_iterate_t_vers set to invalid value"
+#endif /* H5O_iterate_t_vers */
+
+
+#if !defined(H5Z_class_t_vers) || H5Z_class_t_vers == 2
+  #ifndef H5Z_class_t_vers
+    #define H5Z_class_t_vers 2
+  #endif /* H5Z_class_t_vers */
+  #define H5Z_class_t H5Z_class2_t
+#elif H5Z_class_t_vers == 1
+  #define H5Z_class_t H5Z_class1_t
+#else /* H5Z_class_t_vers */
+  #error "H5Z_class_t_vers set to invalid value"
+#endif /* H5Z_class_t_vers */
+
+#endif /* H5version_H */
+
diff --git a/install/include/hdf5.h b/install/include/hdf5.h
new file mode 100644
index 0000000000..5be0efe245
--- /dev/null
+++ b/install/include/hdf5.h
@@ -0,0 +1,81 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This is the main public HDF5 include file.  Put further information in
+ * a particular header file and include that here, don't fill this file with
+ * lots of gunk...
+ */
+#ifndef HDF5_H
+#define HDF5_H
+
+#include "H5public.h"
+#include "H5Apublic.h"  /* Attributes                               */
+#include "H5ACpublic.h" /* Metadata cache                           */
+#include "H5Dpublic.h"  /* Datasets                                 */
+#include "H5Epublic.h"  /* Errors                                   */
+#include "H5ESpublic.h" /* Event Sets                               */
+#include "H5Fpublic.h"  /* Files                                    */
+#include "H5FDpublic.h" /* File drivers                             */
+#include "H5Gpublic.h"  /* Groups                                   */
+#include "H5Ipublic.h"  /* ID management                            */
+#include "H5Lpublic.h"  /* Links                                    */
+#include "H5Mpublic.h"  /* Maps                                     */
+#include "H5MMpublic.h" /* Memory management                        */
+#include "H5Opublic.h"  /* Object headers                           */
+#include "H5Ppublic.h"  /* Property lists                           */
+#include "H5PLpublic.h" /* Plugins                                  */
+#include "H5Rpublic.h"  /* References                               */
+#include "H5Spublic.h"  /* Dataspaces                               */
+#include "H5Tpublic.h"  /* Datatypes                                */
+#include "H5VLpublic.h" /* Virtual Object Layer                     */
+#include "H5Zpublic.h"  /* Data filters                             */
+
+/* Plugin/component developer headers */
+#include "H5ESdevelop.h" /* Event Sets */
+#include "H5FDdevelop.h" /* File drivers */
+#include "H5Idevelop.h"  /* ID management */
+#include "H5Ldevelop.h"  /* Links */
+#include "H5Tdevelop.h"  /* Datatypes */
+#include "H5TSdevelop.h" /* Threadsafety */
+#include "H5Zdevelop.h"  /* Data filters */
+
+/* Virtual object layer (VOL) connector developer support */
+#include "H5VLconnector.h"          /* VOL connector author routines */
+#include "H5VLconnector_passthru.h" /* Pass-through VOL connector author routines */
+#include "H5VLnative.h"             /* Native VOL connector macros, for VOL connector authors */
+
+/* Predefined file drivers */
+#include "H5FDcore.h"     /* Files stored entirely in memory          */
+#include "H5FDdirect.h"   /* Linux direct I/O                         */
+#include "H5FDfamily.h"   /* File families                            */
+#include "H5FDhdfs.h"     /* Hadoop HDFS                              */
+#include "H5FDlog.h"      /* sec2 driver with I/O logging (for debugging) */
+#include "H5FDmirror.h"   /* Mirror VFD and IPC definitions           */
+#include "H5FDmpi.h"      /* MPI-based file drivers                   */
+#include "H5FDmulti.h"    /* Usage-partitioned file family            */
+#include "H5FDonion.h"    /* Onion file I/O                           */
+#include "H5FDros3.h"     /* R/O S3 "file" I/O                        */
+#include "H5FDsec2.h"     /* POSIX unbuffered file I/O                */
+#include "H5FDsplitter.h" /* Twin-channel (R/W & R/O) I/O passthrough */
+#include "H5FDstdio.h"    /* Standard C buffered I/O                  */
+#ifdef H5_HAVE_WINDOWS
+#include "H5FDwindows.h" /* Win32 I/O                                */
+#endif
+#include "H5FDsubfiling.h" /* Subfiling VFD                            */
+#include "H5FDioc.h"       /* I/O Concentrator VFD                     */
+
+/* Virtual object layer (VOL) connectors */
+#include "H5VLnative.h"   /* Native VOL connector                     */
+#include "H5VLpassthru.h" /* Pass-through VOL connector               */
+
+#endif
diff --git a/install/include/hdf5_hl.h b/install/include/hdf5_hl.h
new file mode 100644
index 0000000000..7757b392e1
--- /dev/null
+++ b/install/include/hdf5_hl.h
@@ -0,0 +1,31 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Copyright by The HDF Group.                                               *
+ * All rights reserved.                                                      *
+ *                                                                           *
+ * This file is part of HDF5.  The full HDF5 copyright notice, including     *
+ * terms governing use, modification, and redistribution, is contained in    *
+ * the COPYING file, which can be found at the root of the source code       *
+ * distribution tree, or in https://www.hdfgroup.org/licenses.               *
+ * If you do not have access to either file, you may request a copy from     *
+ * help@hdfgroup.org.                                                        *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * This is the main public HDF5 High Level include file.  Put further
+ * information in a particular header file and include that here, don't
+ * fill this file with lots of gunk...
+ */
+
+#ifndef HDF5_HL_H
+#define HDF5_HL_H
+
+#include "hdf5.h"       /* hdf5 main library */
+#include "H5DOpublic.h" /* dataset optimization */
+#include "H5DSpublic.h" /* dimension scales */
+#include "H5LTpublic.h" /* lite */
+#include "H5IMpublic.h" /* image */
+#include "H5TBpublic.h" /* table */
+#include "H5PTpublic.h" /* packet table */
+#include "H5LDpublic.h" /* lite dataset */
+
+#endif /*HDF5_HL_H*/
diff --git a/install/share/COPYING b/install/share/COPYING
new file mode 100644
index 0000000000..9bd0402525
--- /dev/null
+++ b/install/share/COPYING
@@ -0,0 +1,106 @@
+Copyright Notice and License Terms for 
+HDF5 (Hierarchical Data Format 5) Software Library and Utilities
+-----------------------------------------------------------------------------
+
+HDF5 (Hierarchical Data Format 5) Software Library and Utilities
+Copyright 2006 by The HDF Group. 
+
+NCSA HDF5 (Hierarchical Data Format 5) Software Library and Utilities
+Copyright 1998-2006 by The Board of Trustees of the University of Illinois. 
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without 
+modification, are permitted for any purpose (including commercial purposes) 
+provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, 
+   this list of conditions, and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice, 
+   this list of conditions, and the following disclaimer in the documentation 
+   and/or materials provided with the distribution.
+
+3. Neither the name of The HDF Group, the name of the University, nor the 
+   name of any Contributor may be used to endorse or promote products derived 
+   from this software without specific prior written permission from 
+   The HDF Group, the University, or the Contributor, respectively.
+
+DISCLAIMER: 
+THIS SOFTWARE IS PROVIDED BY THE HDF GROUP AND THE CONTRIBUTORS 
+"AS IS" WITH NO WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED. IN NO 
+EVENT SHALL THE HDF GROUP OR THE CONTRIBUTORS BE LIABLE FOR ANY DAMAGES 
+SUFFERED BY THE USERS ARISING OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
+ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ 
+You are under no obligation whatsoever to provide any bug fixes, patches, or 
+upgrades to the features, functionality or performance of the source code 
+("Enhancements") to anyone; however, if you choose to make your Enhancements 
+available either publicly, or directly to The HDF Group, without imposing a 
+separate written license agreement for such Enhancements, then you hereby 
+grant the following license: a non-exclusive, royalty-free perpetual license 
+to install, use, modify, prepare derivative works, incorporate into other 
+computer software, distribute, and sublicense such enhancements or derivative 
+works thereof, in binary and source code form.
+
+-----------------------------------------------------------------------------
+-----------------------------------------------------------------------------
+
+Limited portions of HDF5 were developed by Lawrence Berkeley National 
+Laboratory (LBNL). LBNL's Copyright Notice and Licensing Terms can be
+found here: COPYING_LBNL_HDF5 file in this directory or at 
+https://raw.githubusercontent.com/hdfgroup/hdf5/develop/COPYING_LBNL_HDF5. 
+
+-----------------------------------------------------------------------------
+-----------------------------------------------------------------------------
+
+Contributors:   National Center for Supercomputing Applications (NCSA) at 
+the University of Illinois, Fortner Software, Unidata Program Center 
+(netCDF), The Independent JPEG Group (JPEG), Jean-loup Gailly and Mark Adler 
+(gzip), and Digital Equipment Corporation (DEC).
+
+-----------------------------------------------------------------------------
+ 
+Portions of HDF5 were developed with support from the Lawrence Berkeley 
+National Laboratory (LBNL) and the United States Department of Energy 
+under Prime Contract No. DE-AC02-05CH11231.
+
+-----------------------------------------------------------------------------
+
+Portions of HDF5 were developed with support from Lawrence Livermore 
+National Laboratory and the United States Department of Energy under 
+Prime Contract No. DE-AC52-07NA27344.
+
+-----------------------------------------------------------------------------
+
+Portions of HDF5 were developed with support from the University of 
+California, Lawrence Livermore National Laboratory (UC LLNL).  
+The following statement applies to those portions of the product and must 
+be retained in any redistribution of source code, binaries, documentation, 
+and/or accompanying materials:
+
+   This work was partially produced at the University of California, 
+   Lawrence Livermore National Laboratory (UC LLNL) under contract 
+   no. W-7405-ENG-48 (Contract 48) between the U.S. Department of Energy 
+   (DOE) and The Regents of the University of California (University) 
+   for the operation of UC LLNL.
+
+   DISCLAIMER: 
+   THIS WORK WAS PREPARED AS AN ACCOUNT OF WORK SPONSORED BY AN AGENCY OF 
+   THE UNITED STATES GOVERNMENT. NEITHER THE UNITED STATES GOVERNMENT NOR 
+   THE UNIVERSITY OF CALIFORNIA NOR ANY OF THEIR EMPLOYEES, MAKES ANY 
+   WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY OR RESPONSIBILITY 
+   FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION, 
+   APPARATUS, PRODUCT, OR PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE 
+   WOULD NOT INFRINGE PRIVATELY- OWNED RIGHTS. REFERENCE HEREIN TO ANY 
+   SPECIFIC COMMERCIAL PRODUCTS, PROCESS, OR SERVICE BY TRADE NAME, 
+   TRADEMARK, MANUFACTURER, OR OTHERWISE, DOES NOT NECESSARILY CONSTITUTE 
+   OR IMPLY ITS ENDORSEMENT, RECOMMENDATION, OR FAVORING BY THE UNITED 
+   STATES GOVERNMENT OR THE UNIVERSITY OF CALIFORNIA. THE VIEWS AND 
+   OPINIONS OF AUTHORS EXPRESSED HEREIN DO NOT NECESSARILY STATE OR REFLECT 
+   THOSE OF THE UNITED STATES GOVERNMENT OR THE UNIVERSITY OF CALIFORNIA, 
+   AND SHALL NOT BE USED FOR ADVERTISING OR PRODUCT ENDORSEMENT PURPOSES.
+
+-----------------------------------------------------------------------------
+
+
diff --git a/install/share/RELEASE.txt b/install/share/RELEASE.txt
new file mode 100644
index 0000000000..824905ba93
--- /dev/null
+++ b/install/share/RELEASE.txt
@@ -0,0 +1,1317 @@
+HDF5 version 1.15.0 currently under development
+================================================================================
+
+
+INTRODUCTION
+============
+
+This document describes the differences between this release and the previous
+HDF5 release. It contains information on the platforms tested and known
+problems in this release. For more details check the HISTORY*.txt files in the
+HDF5 source.
+
+Note that documentation in the links below will be updated at the time of each
+final release.
+
+Links to HDF5 documentation can be found on The HDF5 web page:
+
+     https://portal.hdfgroup.org/display/HDF5/HDF5
+
+The official HDF5 releases can be obtained from:
+
+     https://www.hdfgroup.org/downloads/hdf5/
+
+Changes from Release to Release and New Features in the HDF5-1.16.x release series
+can be found at:
+
+     https://portal.hdfgroup.org/display/HDF5/Release+Specific+Information
+
+If you have any questions or comments, please send them to the HDF Help Desk:
+
+     help@hdfgroup.org
+
+
+CONTENTS
+========
+
+- New Features
+- Support for new platforms and languages
+- Bug Fixes since HDF5-1.14.0
+- Platforms Tested
+- Known Problems
+- CMake vs. Autotools installations
+
+
+New Features
+============
+
+    Configuration:
+    -------------
+    - Added new option for CMake to mark tests as SKIPPED.
+
+      HDF5_DISABLE_TESTS_REGEX is a REGEX string that will be checked with
+      test names and if there is a match then that test's property will be
+      set to DISABLED. HDF5_DISABLE_TESTS_REGEX can be initialized on the
+      command line: "-DHDF5_DISABLE_TESTS_REGEX:STRING=<regex>"
+      See CMake documentation for regex-specification.
+
+    - Added defaults to CMake for long double conversion checks
+
+      HDF5 performs a couple of checks at build time to see if long double
+      values can be converted correctly (IBM's Power architecture uses a
+      special format for long doubles). These checks were performed using
+      TRY_RUN, which is a problem when cross-compiling.
+
+      These checks now use default values appropriate for most non-Power
+      systems when cross-compiling. The cache values can be pre-set if
+      necessary, which will preempt both the TRY_RUN and the default.
+
+      Affected values:
+        H5_LDOUBLE_TO_LONG_SPECIAL      (default no)
+        H5_LONG_TO_LDOUBLE_SPECIAL      (default no)
+        H5_LDOUBLE_TO_LLONG_ACCURATE    (default yes)
+        H5_LLONG_TO_LDOUBLE_CORRECT     (default yes)
+        H5_DISABLE_SOME_LDOUBLE_CONV    (default no)
+
+      Fixes GitHub #3585
+
+    - Improved support for Intel oneAPI
+
+      * Separates the old 'classic' Intel compiler settings and warnings
+        from the oneAPI settings
+      * Uses `-check nouninit` in debug builds to avoid false positives
+        when building H5_buildiface with `-check all`
+      * Both Autotools and CMake
+
+    - Added new options for CMake and Autotools to control the Doxygen
+      warnings as errors setting.
+
+        * HDF5_ENABLE_DOXY_WARNINGS: ON/OFF (Default: ON)
+        * --enable-doxygen-errors: enable/disable (Default: enable)
+
+      The default will fail compile if the doxygen parsing generates warnings.
+      The option can be disabled if certain versions of doxygen have parsing
+      issues. i.e. 1.9.5, 1.9.8.
+
+      Addresses GitHub issue #3398
+
+    - Added support for AOCC and classic Flang w/ the Autotools
+
+      * Adds a config/clang-fflags options file to support Flang
+      * Corrects missing "-Wl," from linker options in the libtool wrappers
+        when using Flang, the MPI Fortran compiler wrappers, and building
+        the shared library. This would often result in unrecognized options
+        like -soname.
+      * Enable -nomp w/ Flang to avoid linking to the OpenMPI library.
+
+      CMake can build the parallel, shared library w/ Fortran using AOCC
+      and Flang, so no changes were needed for that build system.
+
+      Fixes GitHub issues #3439, #1588, #366, #280
+
+    - Converted the build of libaec and zlib to use FETCH_CONTENT with CMake.
+
+      Using the CMake FetchContent module, the external filters can populate
+      content at configure time via any method supported by the ExternalProject
+      module. Whereas ExternalProject_Add() downloads at build time, the
+      FetchContent module makes content available immediately, allowing the
+      configure step to use the content in commands like add_subdirectory(),
+      include() or file() operations.
+
+      Removed HDF options for using FETCH_CONTENT explicitly:
+          BUILD_SZIP_WITH_FETCHCONTENT:BOOL
+          BUILD_ZLIB_WITH_FETCHCONTENT:BOOL
+
+    - Thread-safety + static library disabled on Windows w/ CMake
+
+      The thread-safety feature requires hooks in DllMain(), which is only
+      present in the shared library.
+
+      We previously just warned about this, but now any CMake configuration
+      that tries to build thread-safety and the static library will fail.
+      This cannot be overridden with ALLOW_UNSUPPORTED.
+
+      Fixes GitHub issue #3613
+
+    - Autotools builds now build the szip filter by default when an appropriate
+      library is found
+
+      Since libaec is prevalent and BSD-licensed for both encoding and
+      decoding, we build the szip filter by default now.
+
+      Both autotools and CMake build systems will process the szip filter the same as
+      the zlib filter is processed.
+
+    - Removed CMake cross-compiling variables
+
+      * HDF5_USE_PREGEN
+      * HDF5_BATCH_H5DETECT
+
+      These were used to work around H5detect and H5make_libsettings and
+      are no longer required.
+
+    - Running H5make_libsettings is no longer required for cross-compiling
+
+      The functionality of H5make_libsettings is now handled via template files,
+      so H5make_libsettings has been removed.
+
+    - Running H5detect is no longer required for cross-compiling
+
+      The functionality of H5detect is now exercised at library startup,
+      so H5detect has been removed.
+
+    - Updated HDF5 API tests CMake code to support VOL connectors
+
+      * Implemented support for fetching, building and testing HDF5
+        VOL connectors during the library build process and documented
+        the feature under doc/cmake-vols-fetchcontent.md
+
+      * Implemented the HDF5_TEST_API_INSTALL option that enables
+        installation of the HDF5 API tests on the system
+
+    - Added new CMake options for building and running HDF5 API tests
+      (Experimental)
+
+      HDF5 API tests are an experimental feature, primarily targeted
+      toward HDF5 VOL connector authors, that is currently being developed.
+      These tests exercise the HDF5 API and are being integrated back
+      into the HDF5 library from the HDF5 VOL tests repository
+      (https://github.com/HDFGroup/vol-tests). To support this feature,
+      the following new options have been added to CMake:
+
+        * HDF5_TEST_API: ON/OFF (Default: OFF)
+
+          Controls whether the HDF5 API tests will be built. These tests
+          will only be run during testing of HDF5 if the HDF5_TEST_SERIAL
+          (for serial tests) and HDF5_TEST_PARALLEL (for parallel tests)
+          options are enabled.
+
+        * HDF5_TEST_API_INSTALL: ON/OFF (Default: OFF)
+
+          Controls whether the HDF5 API test executables will be installed
+          on the system alongside the HDF5 library. This option is currently
+          not functional.
+
+        * HDF5_TEST_API_ENABLE_ASYNC: ON/OFF (Default: OFF)
+
+          Controls whether the HDF5 Async API tests will be built. These
+          tests will only be run if the VOL connector used supports Async
+          operations.
+
+        * HDF5_TEST_API_ENABLE_DRIVER: ON/OFF (Default: OFF)
+
+          Controls whether to build the HDF5 API test driver program. This
+          test driver program is useful for VOL connectors that use a
+          client/server model where the server needs to be up and running
+          before the VOL connector can function. This option is currently
+          not functional.
+
+        * HDF5_TEST_API_SERVER: String (Default: "")
+
+          Used to specify a path to the server executable that the test
+          driver program should execute.
+
+    - Added support for CMake presets file.
+
+      CMake supports two main files, CMakePresets.json and CMakeUserPresets.json,
+      that allow users to specify common configure options and share them with others.
+      HDF added a CMakePresets.json file of a typical configuration and support
+      file, config/cmake-presets/hidden-presets.json. 
+      Also added a section to INSTALL_CMake.txt with very basic explanation of the
+      process to use CMakePresets.
+
+    - Deprecated and removed old SZIP library in favor of LIBAEC library
+
+      LIBAEC library has been used in HDF5 binaries as the szip library of choice
+      for a few years. We are removing the options for using the old SZIP library.
+
+      Also removed the config/cmake/FindSZIP.cmake file.
+
+    - Enabled instrumentation of the library by default in CMake for parallel
+      debug builds
+
+      HDF5 can be configured to instrument portions of the parallel library to
+      aid in debugging. Autotools builds of HDF5 turn this capability on by
+      default for parallel debug builds and off by default for other build types.
+      CMake has been updated to match this behavior.
+
+    - Added new option to build libaec and zlib inline with CMake.
+
+      Using the CMake FetchContent module, the external filters can populate
+      content at configure time via any method supported by the ExternalProject
+      module. Whereas ExternalProject_Add() downloads at build time, the
+      FetchContent module makes content available immediately, allowing the
+      configure step to use the content in commands like add_subdirectory(),
+      include() or file() operations.
+
+      The HDF options (and defaults) for using this are:
+          BUILD_SZIP_WITH_FETCHCONTENT:BOOL=OFF
+          LIBAEC_USE_LOCALCONTENT:BOOL=OFF
+          BUILD_ZLIB_WITH_FETCHCONTENT:BOOL=OFF
+          ZLIB_USE_LOCALCONTENT:BOOL=OFF
+
+      The CMake variables to control the path and file names:
+          LIBAEC_TGZ_ORIGPATH:STRING
+          LIBAEC_TGZ_ORIGNAME:STRING
+          ZLIB_TGZ_ORIGPATH:STRING
+          ZLIB_TGZ_ORIGNAME:STRING
+
+      See the CMakeFilters.cmake and config/cmake/cacheinit.cmake files for usage.
+
+    - Added the CMake variable HDF5_ENABLE_ROS3_VFD to the HDF5 CMake config
+      file hdf5-config.cmake. This allows to easily detect if the library
+      has been built with or without read-only S3 functionality.
+
+    Library:
+    --------
+    - Added a simple cache to the read-only S3 (ros3) VFD
+
+      The read-only S3 VFD now caches the first N bytes of a file stored
+      in S3 to avoid a lot of small I/O operations when opening files.
+      This cache is per-file and created when the file is opened.
+
+      N is currently 16 MiB or the size of the file, whichever is smaller.
+
+      Addresses GitHub issue #3381
+
+    - Added new API function H5Pget_actual_selection_io_mode()
+
+      This function allows the user to determine if the library performed
+      selection I/O, vector I/O, or scalar (legacy) I/O during the last HDF5
+      operation performed with the provided DXPL.
+
+    - Added support for in-place type conversion in most cases
+
+      In-place type conversion allows the library to perform type conversion
+      without an intermediate type conversion buffer.  This can improve
+      performance by allowing I/O in a single operation over the entire
+      selection instead of being limited by the size of the intermediate buffer.
+      Implemented for I/O on contiguous and chunked datasets when the selection
+      is contiguous in memory and when the memory datatype is not smaller than
+      the file datatype.
+
+    - Changed selection I/O to be on by default when using the MPIO file driver
+
+    - Added support for selection I/O in the MPIO file driver
+
+      Previously, only vector I/O operations were supported.  Support for
+      selection I/O should improve performance and reduce memory uses in some
+      cases.
+
+    - Changed the error handling for a not found path in the find plugin process.
+
+      While attempting to load a plugin the HDF5 library will fail if one of the
+      directories in the plugin paths does not exist, even if there are more paths
+      to check. Instead of exiting the function with an error, just logged the error
+      and continue processing the list of paths to check.
+
+    - Implemented support for temporary security credentials for the Read-Only
+      S3 (ROS3) file driver.
+
+      When using temporary security credentials, one also needs to specify a
+      session/security token next to the access key id and secret access key.
+      This token can be specified by the new API function H5Pset_fapl_ros3_token().
+      The API function H5Pget_fapl_ros3_token() can be used to retrieve
+      the currently set token.
+
+    - Added a Subfiling VFD configuration file prefix environment variable
+
+      The Subfiling VFD now checks for values set in a new environment
+      variable "H5FD_SUBFILING_CONFIG_FILE_PREFIX" to determine if the
+      application has specified a pathname prefix to apply to the file
+      path for its configuration file. For example, this can be useful
+      for cases where the application wishes to write subfiles to a
+      machine's node-local storage while placing the subfiling configuration
+      file on a file system readable by all machine nodes.
+
+    - Added H5Pset_selection_io(), H5Pget_selection_io(), and
+      H5Pget_no_selection_io_cause() API functions to manage the selection I/O
+      feature.  This can be used to enable collective I/O with type conversion,
+      or it can be used with custom VFDs that support vector or selection I/O.
+
+    - Added H5Pset_modify_write_buf() and H5Pget_modify_write_buf() API
+      functions to allow the library to modify the contents of write buffers, in
+      order to avoid malloc/memcpy.  Currently only used for type conversion
+      with selection I/O.
+
+
+    Parallel Library:
+    -----------------
+    - Added optimized support for the parallel compression feature when
+      using the multi-dataset I/O API routines collectively
+
+      Previously, calling H5Dwrite_multi/H5Dread_multi collectively in parallel
+      with a list containing one or more filtered datasets would cause HDF5 to
+      break out of the optimized multi-dataset I/O mode and instead perform I/O
+      by looping over each dataset in the I/O request. The library has now been
+      updated to perform I/O in a more optimized manner in this case by first
+      performing I/O on all the filtered datasets at once and then performing
+      I/O on all the unfiltered datasets at once.
+
+    - Changed H5Pset_evict_on_close so that it can be called with a parallel
+      build of HDF5
+
+      Previously, H5Pset_evict_on_close would always fail when called from a
+      parallel build of HDF5, stating that the feature is not supported with
+      parallel HDF5. This failure would occur even if a parallel build of HDF5
+      was used with a serial HDF5 application. H5Pset_evict_on_close can now
+      be called regardless of the library build type and the library will
+      instead fail during H5Fcreate/H5Fopen if the "evict on close" property
+      has been set to true and the file is being opened for parallel access
+      with more than 1 MPI process.
+
+
+    Fortran Library:
+    ----------------
+
+    - Added Fortran APIs:
+      h5vlnative_addr_to_token_f and h5vlnative_token_to_address_f
+
+    - Fixed an uninitialized error return value for hdferr
+      to return the error state of the h5aopen_by_idx_f API.
+
+    - Added h5pget_vol_cap_flags_f and related Fortran VOL
+      capability definitions.
+
+    - Fortran async APIs H5A, H5D, H5ES, H5G, H5F, H5L and H5O were added.
+
+    - Added Fortran APIs:
+      h5pset_selection_io_f, h5pget_selection_io_f,
+      h5pget_actual_selection_io_mode_f,
+      h5pset_modify_write_buf_f, h5pget_modify_write_buf_f
+
+    - Added Fortran APIs:
+      h5get_free_list_sizes_f, h5dwrite_chunk_f, h5dread_chunk_f,
+      h5fget_info_f, h5lvisit_f, h5lvisit_by_name_f,
+      h5pget_no_selection_io_cause_f, h5pget_mpio_no_collective_cause_f,
+      h5sselect_shape_same_f, h5sselect_intersect_block_f,
+      h5pget_file_space_page_size_f, h5pset_file_space_page_size_f,
+      h5pget_file_space_strategy_f, h5pset_file_space_strategy_f
+
+    - Removed "-commons" linking option on Darwin, as COMMON and EQUIVALENCE
+      are no longer used in the Fortran source.
+
+      Fixes GitHub issue #3571
+
+    C++ Library:
+    ------------
+    -
+
+
+    Java Library:
+    -------------
+    -
+
+
+    Tools:
+    ------
+    -
+
+
+    High-Level APIs:
+    ----------------
+    - Added Fortran HL API: h5doappend_f
+
+
+    C Packet Table API:
+    -------------------
+    -
+
+
+    Internal header file:
+    ---------------------
+    -
+
+
+    Documentation:
+    --------------
+    -
+
+
+Support for new platforms, languages and compilers
+==================================================
+    -
+    
+Bug Fixes since HDF5-1.14.0 release
+===================================
+    Library
+    -------
+    - Suppressed floating-point exceptions in H5T init code
+
+      The floating-point datatype initialization code in H5Tinit_float.c
+      could raise FE_INVALID exceptions while munging bits and performing
+      comparisons that might involve NaN. This was not a problem when the
+      initialization code was executed in H5detect at compile time (prior
+      to 1.14.3), but now that the code is executed at library startup
+      (1.14.3+), these exceptions can be caught by user code, as is the
+      default in the NAG Fortran compiler.
+
+      Starting in 1.14.4, we now suppress floating-point exceptions while
+      initializing the floating-point types and clear FE_INVALID before
+      restoring the original environment.
+
+      Fixes GitHub #3831
+
+    - Fixed a file handle leak in the core VFD
+
+      When opening a file with the core VFD and a file image, if the file
+      already exists, the file check would leak the POSIX file handle.
+
+      Fixes GitHub issue #635
+
+    - Fixed some issues with chunk index metadata not getting read
+      collectively when collective metadata reads are enabled
+
+      When looking up dataset chunks during I/O, the parallel library
+      temporarily disables collective metadata reads since it's generally
+      unlikely that the application will read the same chunks from all
+      MPI ranks. Leaving collective metadata reads enabled during
+      chunk lookups can lead to hangs or other bad behavior depending
+      on the chunk indexing structure used for the dataset in question.
+      However, due to the way that dataset chunk index metadata was
+      previously loaded in a deferred manner, this could mean that
+      the metadata for the main chunk index structure or its
+      accompanying pieces of metadata (e.g., fixed array data blocks)
+      could end up being read independently if these chunk lookup
+      operations are the first chunk index-related operation that
+      occurs on a dataset. This behavior is generally observed when
+      opening a dataset for which the metadata isn't in the metadata
+      cache yet and then immediately performing I/O on that dataset.
+      This behavior is not generally observed when creating a dataset
+      and then performing I/O on it, as the relevant metadata will
+      usually be in the metadata cache as a side effect of creating
+      the chunk index structures during dataset creation. 
+
+      This issue has been fixed by adding callbacks to the different
+      chunk indexing structure classes that allow more explicit control
+      over when chunk index metadata gets loaded. When collective
+      metadata reads are enabled, the necessary index metadata will now
+      get loaded collectively by all MPI ranks at the start of dataset
+      I/O to ensure that the ranks don't unintentionally read this
+      metadata independently further on. These changes fix collective
+      loading of the main chunk index structure, as well as v2 B-tree
+      root nodes, extensible array index blocks and fixed array data
+      blocks. There are still pieces of metadata that cannot currently
+      be loaded collectively, however, such as extensible array data
+      blocks, data block pages and super blocks, as well as fixed array
+      data block pages. These pieces of metadata are not necessarily
+      read in by all MPI ranks since this depends on which chunks the
+      ranks have selected in the dataset. Therefore, reading of these
+      pieces of metadata remains an independent operation.
+
+    - Fixed potential hangs in parallel library during collective I/O with
+      independent metadata writes
+
+      When performing collective parallel writes to a dataset where metadata
+      writes are requested as (or left as the default setting of) independent,
+      hangs could potentially occur during metadata cache sync points. This
+      was due to incorrect management of the internal state tracking whether
+      an I/O operation should be collective or not, causing the library to
+      attempt collective writes of metadata when they were meant to be
+      independent writes. During the metadata cache sync points, if the number
+      of cache entries being flushed was a multiple of the number of MPI ranks
+      in the MPI communicator used to access the HDF5 file, an equal amount of
+      collective MPI I/O calls were made and the dataset write call would be
+      successful. However, when the number of cache entries being flushed was
+      NOT a multiple of the number of MPI ranks, the ranks with more entries
+      than others would get stuck in an MPI_File_set_view call, while other
+      ranks would get stuck in a post-write MPI_Barrier call. This issue has
+      been fixed by correctly switching to independent I/O temporarily when
+      writing metadata independently during collective dataset I/O.
+
+    - Dropped support for MPI-2
+
+      The MPI-2 supporting artifacts have been removed due to the cessation
+      of MPI-2 maintenance and testing since version HDF5 1.12.
+
+    - Fixed a bug with the way the Subfiling VFD assigns I/O concentrators
+
+      During a file open operation, the Subfiling VFD determines the topology
+      of the application and uses that to select a subset of MPI ranks that
+      I/O will be forwarded to, called I/O concentrators. The code for this
+      had previously assumed that the parallel job launcher application (e.g.,
+      mpirun, srun, etc.) would distribute MPI ranks sequentially among a node
+      until all processors on that node have been assigned before going on to
+      the next node. When the launcher application mapped MPI ranks to nodes
+      in a different fashion, such as round-robin, this could cause the Subfiling
+      VFD to incorrectly map MPI ranks as I/O concentrators, leading to missing
+      subfiles.
+
+    - Fixed performance regression with some compound type conversions
+
+      In-place type conversion was introduced for most use cases in 1.14.2.
+      While being able to use the read buffer for type conversion potentially
+      improves performance by performing the entire I/O at once, it also
+      disables the optimized compound type conversion used when the destination
+      is a subset of the source. Disabled in-place type conversion when using
+      this optimized conversion and there is no benefit in terms of the I/O
+      size.
+
+    - Fixed an assertion in a previous fix for CVE-2016-4332
+
+      An assert could fail when processing corrupt files that have invalid
+      shared message flags (as in CVE-2016-4332).
+
+      The assert statement in question has been replaced with pointer checks
+      that don't raise errors. Since the function is in cleanup code, we do
+      our best to close and free things, even when presented with partially
+      initialized structs.
+
+      Fixes CVE-2016-4332 and HDFFV-9950 (confirmed via the cve_hdf5 repo)
+
+    - Fixed a file space allocation bug in the parallel library for chunked
+      datasets
+
+      With the addition of support for incremental file space allocation for
+      chunked datasets with filters applied to them that are created/accessed
+      in parallel, a bug was introduced to the library's parallel file space
+      allocation code. This could cause file space to not be allocated correctly
+      for datasets without filters applied to them that are created with serial
+      file access and later opened with parallel file access. In turn, this could
+      cause parallel writes to those datasets to place incorrect data in the file.
+
+    - Fixed an assertion failure in Parallel HDF5 when a file can't be created
+      due to an invalid library version bounds setting
+
+      An assertion failure could occur in H5MF_settle_raw_data_fsm when a file
+      can't be created with Parallel HDF5 due to specifying the use of a paged,
+      persistent file free space manager
+      (H5Pset_file_space_strategy(..., H5F_FSPACE_STRATEGY_PAGE, 1, ...)) with
+      an invalid library version bounds combination
+      (H5Pset_libver_bounds(..., H5F_LIBVER_EARLIEST, H5F_LIBVER_V18)). This
+      has now been fixed.
+
+    - Fixed bugs in selection I/O
+
+      Previously, the library could fail in some cases when performing selection
+      I/O with type conversion.
+
+    - Fixed CVE-2018-13867
+
+      A corrupt file containing an invalid local heap datablock address
+      could trigger an assert failure when the metadata cache attempted
+      to load the datablock from storage.
+
+      The local heap now verifies that the datablock address is valid
+      when the local heap header information is parsed.
+
+    - Fixed CVE-2018-11202
+
+      A malformed file could result in chunk index memory leaks. Under most
+      conditions (i.e., when the --enable-using-memchecker option is NOT
+      used), this would result in a small memory leak and and infinite loop
+      and abort when shutting down the library. The infinite loop would be
+      due to the "free list" package not being able to clear its resources
+      so the library couldn't shut down. When the "using a memory checker"
+      option is used, the free lists are disabled so there is just a memory
+      leak with no abort on library shutdown.
+
+      The chunk index resources are now correctly cleaned up when reading
+      misparsed files and valgrind confirms no memory leaks.
+
+    - Fixed an issue where an assert statement was converted to an
+      incorrect error check statement
+
+      An assert statement in the library dealing with undefined dataset data
+      fill values was converted to an improper error check that would always
+      trigger when a dataset's fill value was set to NULL (undefined). This
+      has now been fixed.
+
+    - Fixed an assertion failure when attempting to use the Subfiling IOC
+      VFD directly
+
+      The Subfiling feature makes use of two Virtual File Drivers, the
+      Subfiling VFD and the IOC (I/O Concentrator) VFD. The two VFDs are
+      intended to be stacked together such that the Subfiling VFD sits
+      "on top" of the IOC VFD and routes I/O requests through it; using the
+      IOC VFD alone is currently unsupported. The IOC VFD has been fixed so
+      that an error message is displayed in this situation rather than causing
+      an assertion failure.
+
+    - Fixed a potential bug when copying empty enum datatypes
+
+      Copying an empty enum datatype (including implicitly, as when an enum
+      is a part of a compound datatype) would fail in an assert in debug
+      mode and could fail in release mode depending on how the platform
+      handles undefined behavior regarding size 0 memory allocations and
+      using memcpy with a NULL src pointer.
+
+      The library is now more careful about using memory operations when
+      copying empty enum datatypes and will not error or raise an assert.
+
+    - Added an AAPL check to H5Acreate
+
+      A check was added to H5Acreate to ensure that a failure is correctly
+      returned when an invalid Attribute Access Property List is passed
+      in to the function. The HDF5 API tests were failing for certain
+      build types due to this condition not being checked previously.
+
+    - Fixed a bug in H5Ocopy that could generate invalid HDF5 files
+
+      H5Ocopy was missing a check to determine whether the new object's
+      object header version is greater than version 1. Without this check,
+      copying of objects with object headers that are smaller than a
+      certain size would cause H5Ocopy to create an object header for the
+      new object that has a gap in the header data. According to the
+      HDF5 File Format Specification, this is not allowed for version
+      1 of the object header format.
+
+      Fixes GitHub issue #2653
+
+    - Fixed H5Pget_vol_cap_flags and H5Pget_vol_id to accept H5P_DEFAULT
+
+      H5Pget_vol_cap_flags and H5Pget_vol_id were updated to correctly
+      accept H5P_DEFAULT for the 'plist_id' FAPL parameter. Previously,
+      they would fail if provided with H5P_DEFAULT as the FAPL.
+
+    - Fixed ROS3 VFD anonymous credential usage with h5dump and h5ls
+
+      ROS3 VFD anonymous credential functionality became broken in h5dump
+      and h5ls in the HDF5 1.14.0 release with the added support for VFD
+      plugins, which changed the way that the tools handled setting of
+      credential information that the VFD uses. The tools could be
+      provided the command-line option of "--s3-cred=(,,)" as a workaround
+      for anonymous credential usage, but the documentation for this
+      option stated that anonymous credentials could be used by simply
+      omitting the option. The latter functionality has been restored.
+
+      Fixes GitHub issue #2406
+
+    - Fixed memory leaks when processing malformed object header continuation messages
+
+      Malformed object header continuation messages can result in a too-small
+      buffer being passed to the decode function, which could lead to reading
+      past the end of the buffer. Additionally, errors in processing these
+      malformed messages can lead to allocated memory not being cleaned up.
+
+      This fix adds bounds checking and cleanup code to the object header
+      continuation message processing.
+
+      Fixes GitHub issue #2604
+
+    - Fixed memory leaks, aborts, and overflows in H5O EFL decode
+
+      The external file list code could call assert(), read past buffer
+      boundaries, and not properly clean up resources when parsing malformed
+      external data files messages.
+
+      This fix cleans up allocated memory, adds buffer bounds checks, and
+      converts asserts to HDF5 error checking.
+
+      Fixes GitHub issue #2605
+
+    - Fixed potential heap buffer overflow in decoding of link info message
+
+      Detections of buffer overflow were added for decoding version, index
+      flags, link creation order value, and the next three addresses.  The
+      checkings will remove the potential invalid read of any of these
+      values that could be triggered by a malformed file.
+
+      Fixes GitHub issue #2603
+
+    - Memory leak
+
+      Memory leak was detected when running h5dump with "pov".  The memory was allocated
+      via H5FL__malloc() in hdf5/src/H5FL.c
+
+      The fuzzed file "pov" was an HDF5 file containing an illegal continuation message.
+      When deserializing the object header chunks for the file, memory is allocated for the
+      array of continuation messages (cont_msg_info->msgs) in continuation message info struct.
+      As error is encountered in loading the illegal message, the memory allocated for
+      cont_msg_info->msgs needs to be freed.
+
+      Fixes GitHub issue #2599
+
+    - Fixed memory leaks that could occur when reading a dataset from a
+      malformed file
+
+      When attempting to read layout, pline, and efl information for a
+      dataset, memory leaks could occur if attempting to read pline/efl
+      information threw an error, which is due to the memory that was 
+      allocated for pline and efl not being properly cleaned up on error.  
+
+      Fixes GitHub issue #2602
+
+    - Fixed potential heap buffer overrun in group info header decoding from malformed file
+
+      H5O__ginfo_decode could sometimes read past allocated memory when parsing a
+      group info message from the header of a malformed file.
+  
+      It now checks buffer size before each read to properly throw an error in these cases.
+  
+      Fixes GitHub issue #2601
+      
+    - Fixed potential buffer overrun issues in some object header decode routines
+
+      Several checks were added to H5O__layout_decode and H5O__sdspace_decode to
+      ensure that memory buffers don't get overrun when decoding buffers read from
+      a (possibly corrupted) HDF5 file.
+
+    - Fixed a heap buffer overflow that occurs when reading from
+      a dataset with a compact layout within a malformed HDF5 file
+
+      During opening of a dataset that has a compact layout, the
+      library allocates a buffer that stores the dataset's raw data.
+      The dataset's object header that gets written to the file
+      contains information about how large of a buffer the library
+      should allocate. If this object header is malformed such that
+      it causes the library to allocate a buffer that is too small
+      to hold the dataset's raw data, future I/O to the dataset can
+      result in heap buffer overflows. To fix this issue, an extra
+      check is now performed for compact datasets to ensure that
+      the size of the allocated buffer matches the expected size
+      of the dataset's raw data (as calculated from the dataset's
+      dataspace and datatype information). If the two sizes do not
+      match, opening of the dataset will fail.
+
+      Fixes GitHub issue #2606
+
+    - Fixed a memory corruption issue that can occur when reading
+      from a dataset using a hyperslab selection in the file
+      dataspace and a point selection in the memory dataspace
+
+      When reading from a dataset using a hyperslab selection in
+      the dataset's file dataspace and a point selection in the
+      dataset's memory dataspace where the file dataspace's "rank"
+      is greater than the memory dataspace's "rank", memory corruption
+      could occur due to an incorrect number of selection points
+      being copied when projecting the point selection onto the
+      hyperslab selection's dataspace.
+
+    - Fixed issues in the Subfiling VFD when using the SELECT_IOC_EVERY_NTH_RANK
+      or SELECT_IOC_TOTAL I/O concentrator selection strategies
+
+      Multiple bugs involving these I/O concentrator selection strategies
+      were fixed, including:
+
+        * A bug that caused the selection strategy to be altered when
+          criteria for the strategy was specified in the
+          H5FD_SUBFILING_IOC_SELECTION_CRITERIA environment variable as
+          a single value, rather than in the old and undocumented
+          'integer:integer' format
+        * Two bugs which caused a request for 'N' I/O concentrators to
+          result in 'N - 1' I/O concentrators being assigned, which also
+          lead to issues if only 1 I/O concentrator was requested
+
+      Also added a regression test for these two I/O concentrator selection
+      strategies to prevent future issues. 
+
+    - Fix CVE-2021-37501 / GHSA-rfgw-5vq3-wrjf
+
+      Check for overflow when calculating on-disk attribute data size.
+
+      A bogus hdf5 file may contain dataspace messages with sizes
+      which lead to the on-disk data sizes to exceed what is addressable.
+      When calculating the size, make sure, the multiplication does not
+      overflow.
+      The test case was crafted in a way that the overflow caused the
+      size to be 0.
+
+      Fixes GitHub #2458
+
+    - Fixed an issue with collective metadata writes of global heap data
+
+      New test failures in parallel netCDF started occurring with debug
+      builds of HDF5 due to an assertion failure and this was reported in
+      GitHub issue #2433. The assertion failure began happening after the
+      collective metadata write pathway in the library was updated to use
+      vector I/O so that parallel-enabled HDF5 Virtual File Drivers (other
+      than the existing MPI I/O VFD) can support collective metadata writes.
+
+      The assertion failure was fixed by updating collective metadata writes
+      to treat global heap metadata as raw data, as done elsewhere in the
+      library. 
+
+      Fixes GitHub issue #2433
+
+    - Fixed buffer overflow error in image decoding function.
+
+      The error occurred in the function for decoding address from the specified
+      buffer, which is called many times from the function responsible for image
+      decoding. The length of the buffer is known in the image decoding function,
+      but no checks are produced, so the buffer overflow can occur in many places,
+      including callee functions for address decoding. 
+
+      The error was fixed by inserting corresponding checks for buffer overflow.
+
+      Fixes GitHub issue #2432
+
+    - Reading a H5std_string (std::string) via a C++ DataSet previously
+      truncated the string at the first null byte as if reading a C string.
+      Fixed length datasets are now read into H5std_string as a fixed length
+      string of the appropriate size. Variable length datasets will still be
+      truncated at the first null byte.
+
+      Fixes Github issue #3034
+
+    - Fixed write buffer overflow in H5O__alloc_chunk
+
+      The overflow was found by OSS-Fuzz https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=58658
+
+    Java Library
+    ------------
+    - Fixed switch case 'L' block missing a break statement.
+
+      The HDF5Array.arrayify method is missing a break statement in the case 'L': section
+      which causes it to fall through and throw an HDF5JavaException when attempting to
+      read an Array[Array[Long]].
+
+      The error was fixed by inserting a break statement at the end of the case 'L': sections.
+
+      Fixes GitHub issue #3056
+
+
+    Configuration
+    -------------
+    - Removed an Autotools configure hack that causes problems on MacOS
+
+      A sed line in configure.ac was added in the past to paper over some
+      problems with older versions of the Autotools that would add incorrect
+      linker flags. This hack is not needed with recent versions of the
+      Autotools and the sed line errors on MacOS (though this was a silent
+      error that didn't break the build) so the hack has been removed.
+
+      Fixes GitHub issue #3843
+
+    - Fixed an issue where the h5tools_test_utils test program was being
+      installed on the system for Autotools builds of HDF5
+
+      The h5tools_test_utils test program was mistakenly added to bin_PROGRAMS
+      in its Makefile.am configuration file, causing the executable to be
+      installed on the system. The executable is now added to noinst_PROGRAMS
+      instead and will no longer be installed on the system for Autotools builds
+      of HDF5. The CMake configuration code already avoids installing the
+      executable on the system.
+
+    - Fixed a configuration issue that prevented building of the Subfiling VFD on macOS
+
+      Checks were added to the CMake and Autotools code to verify that CLOCK_MONOTONIC_COARSE,
+      PTHREAD_MUTEX_ADAPTIVE_NP and pthread_condattr_setclock() are available before attempting
+      to use them in Subfiling VFD-related utility code. Without these checks, attempting
+      to build the Subfiling VFD on macOS would fail.
+
+    - Fixes the ordering of INCLUDES when building with CMake
+
+      Include directories in the source or build tree should come before other
+      directories to prioritize headers in the sources over installed ones.
+
+      Fixes GitHub #1027
+
+    - The accum test now passes on macOS 12+ (Monterey) w/ CMake
+
+      Due to changes in the way macOS handles LD_LIBRARY_PATH, the accum test
+      started failing on macOS 12+ when building with CMake. CMake has been
+      updated to set DYLD_LIBRARY_PATH on macOS and the test now passes.
+
+      Fixes GitHub #2994, #2261, and #1289
+
+    - Changed the default settings used by CMake for the GZIP filter
+
+      The default for the option HDF5_ENABLE_Z_LIB_SUPPORT was OFF. Now the default is ON.
+      This was done to match the defaults used by the autotools configure.ac.
+      In addition, the CMake message level for not finding a suitable filter library was
+      changed from FATAL_ERROR (which would halt the build process) to WARNING (which
+      will print a message to stderr). Associated files and documentation were changed to match.
+
+      In addition, the default settings in the config/cmake/cacheinit.cmake file were changed to
+      allow CMake to disable building the filters if the tgz file could not be found. The option
+      to allow CMake to download the file from the original Github location requires setting
+      the ZLIB_USE_LOCALCONTENT option to OFF for gzip. And setting the LIBAEC_USE_LOCALCONTENT
+      option to OFF for libaec (szip).
+
+      Fixes GitHub issue #2926
+
+    - Fixed syntax of generator expressions used by CMake
+
+      Add quotes around the generator expression should allow CMake to
+      correctly parse the expression. Generator expressions are typically
+      parsed after command arguments. If a generator expression contains
+      spaces, new lines, semicolons or other characters that may be
+      interpreted as command argument separators, the whole expression
+      should be surrounded by quotes when passed to a command. Failure to
+      do so may result in the expression being split and it may no longer
+      be recognized as a generator expression.
+
+      Fixes GitHub issue #2906
+
+    - Fixed improper include of Subfiling VFD build directory
+
+      With the release of the Subfiling Virtual File Driver feature, compiler
+      flags were added to the Autotools build's CPPFLAGS and AM_CPPFLAGS
+      variables to always include the Subfiling VFD source code directory,
+      regardless of whether the VFD is enabled and built or not. These flags
+      are needed because the header files for the VFD contain macros that are
+      assumed to always be available, such as H5FD_SUBFILING_NAME, so the
+      header files are unconditionally included in the HDF5 library. However,
+      these flags are only needed when building HDF5, so they belong in the
+      H5_CPPFLAGS variable instead. Inclusion in the CPPFLAGS and AM_CPPFLAGS
+      variables would export these flags to the h5cc and h5c++ wrapper scripts,
+      as well as the libhdf5.settings file, which would break builds of software
+      that use HDF5 and try to use or parse information out of these files after
+      deleting temporary HDF5 build directories.
+
+      Fixes GitHub issue #2621
+
+    - Correct the CMake generated pkg-config file
+
+      The pkg-config file generated by CMake had the order and placement of the
+      libraries wrong. Also added support for debug library names.
+
+      Changed the order of Libs.private libraries so that dependencies come after
+      dependents. Did not move the compression libraries into Requires.private
+      because there was not a way to determine if the compression libraries had
+      supported pkconfig files. Still recommend that the CMake config file method
+      be used for building projects with CMake.
+
+      Fixes GitHub issues #1546 and #2259
+
+    - Force lowercase Fortran module file names
+
+      The Cray Fortran compiler  uses  uppercase Fortran module file names, which
+      caused CMake installs to fail. A compiler option was added to use lowercase
+      instead.
+
+
+    Tools
+    -----
+
+    - Renamed h5fuse.sh to h5fuse
+
+      Addresses Discussion #3791
+
+
+    - Fixed an issue with unmatched MPI messages in ph5diff
+
+      The "manager" MPI rank in ph5diff was unintentionally sending "program end"
+      messages to its workers twice, leading to an error from MPICH similar to the
+      following:
+
+      Abort(810645519) on node 1 (rank 1 in comm 0): Fatal error in internal_Finalize: Other MPI error, error stack:
+      internal_Finalize(50)...........: MPI_Finalize failed
+      MPII_Finalize(394)..............:
+      MPIR_Comm_delete_internal(1224).: Communicator (handle=44000000) being freed has 1 unmatched message(s)
+      MPIR_Comm_release_always(1250)..:
+      MPIR_finalize_builtin_comms(154):
+
+    - Fixed an issue in h5repack for variable-length typed datasets
+
+      When repacking datasets into a new file, h5repack tries to determine whether
+      it can use H5Ocopy to copy each dataset into the new file, or if it needs to
+      manually re-create the dataset, then read data from the old dataset and write
+      it to the new dataset. H5repack was previously using H5Ocopy for datasets with
+      variable-length datatypes, but this can be problematic if the global heap
+      addresses involved do not match exactly between the old and new files. These
+      addresses could change for a variety of reasons, such as the command-line options
+      provided to h5repack, how h5repack allocate space in the repacked file, etc.      
+      Since H5Ocopy does not currently perform any translation when these addresses
+      change, datasets that were repacked with H5Ocopy could become unreadable in the
+      new file. H5repack has been fixed to repack variable-length typed datasets without
+      using H5Ocopy to ensure that the new datasets always have the correct global heap
+      addresses.
+    
+    - Names of objects with square brackets will have trouble without the
+      special argument, --no-compact-subset, on the h5dump command line.
+
+      h5diff did not have this option and now it has been added.
+
+      Fixes GitHub issue #2682
+
+    - In the tools traverse function - an error in either visit call
+      will bypass the cleanup of the local data variables.
+
+      Replaced the H5TOOLS_GOTO_ERROR with just H5TOOLS_ERROR.
+
+      Fixes GitHub issue #2598
+
+
+    Performance
+    -------------
+    -
+
+
+    Fortran API
+    -----------
+    -
+
+
+    High-Level Library
+    ------------------
+    -
+
+
+    Fortran High-Level APIs
+    -----------------------
+    -
+
+
+    Documentation
+    -------------
+    -
+
+
+    F90 APIs
+    --------
+    -
+
+
+    C++ APIs
+    --------
+    - 
+
+
+    Testing
+    -------
+    - Disabled running of MPI Atomicity tests for OpenMPI major versions < 5
+
+      Support for MPI atomicity operations is not implemented for major
+      versions of OpenMPI less than version 5. This would cause the MPI
+      atomicity tests for parallel HDF5 to sporadically fail when run
+      with OpenMPI. Testphdf5 now checks if OpenMPI is being used and will
+      skip running the atomicity tests if the major version of OpenMPI is
+      < 5.
+
+    - Fixed a testing failure in testphdf5 on Cray machines
+
+      On some Cray machines, what appears to be a bug in Cray MPICH was causing
+      calls to H5Fis_accessible to create a 0-byte file with strange Unix
+      permissions. This was causing an H5Fdelete file deletion test in the
+      testphdf5 program to fail due to a just-deleted HDF5 file appearing to
+      still be accessible on the file system. The issue in Cray MPICH has been
+      worked around for the time being by resetting the MPI_Info object on the
+      File Access Property List used to MPI_INFO_NULL before passing it to the
+      H5Fis_accessible call.
+
+    - A bug was fixed in the HDF5 API test random datatype generation code
+
+      A bug in the random datatype generation code could cause test failures
+      when trying to generate an enumeration datatype that has duplicated
+      name/value pairs in it. This has now been fixed.
+
+    - A bug was fixed in the HDF5 API test VOL connector registration checking code
+
+      The HDF5 API test code checks to see if the VOL connector specified by the
+      HDF5_VOL_CONNECTOR environment variable (if any) is registered with the library
+      before attempting to run tests with it so that testing can be skipped and an
+      error can be returned when a VOL connector fails to register successfully.
+      Previously, this code didn't account for VOL connectors that specify extra
+      configuration information in the HDF5_VOL_CONNECTOR environment variable and
+      would incorrectly report that the specified VOL connector isn't registered
+      due to including the configuration information as part of the VOL connector
+      name being checked for registration status. This has now been fixed.
+
+   - Fixed Fortran 2003 test with gfortran-v13, optimization levels O2,O3
+
+     Fixes failing Fortran 2003 test with gfortran, optimization level O2,O3
+     with -fdefault-real-16. Fixes GH #2928.
+
+
+Platforms Tested
+===================
+
+    Linux 5.16.14-200.fc35           GNU gcc (GCC) 11.2.1 20220127 (Red Hat 11.2.1-9)
+    #1 SMP x86_64  GNU/Linux         GNU Fortran (GCC) 11.2.1 20220127 (Red Hat 11.2.1-9)
+    Fedora35                         clang version 13.0.0 (Fedora 13.0.0-3.fc35)
+                                     (cmake and autotools)
+
+    Linux 5.19.0-1027-aws            GNU gcc (GCC) 11.3.0-1ubuntu1
+    #36-Ubuntu SMP x86_64 GNU/Linux  GNU Fortran (GCC) 11.3.0-1ubuntu1
+    Ubuntu 22.04                     Intel oneAPI DPC++/C++ Compiler, IFX 2023.1.0
+                                     Ubuntu clang version 14.0.0-1ubuntu1
+                                     (cmake and autotools)
+
+    Linux 5.15.0-1037-aws            GNU gcc (GCC) 9.4.0-1ubuntu1
+    #36-Ubuntu SMP x86_64 GNU/Linux  GNU Fortran (GCC) 9.4.0-1ubuntu1
+    Ubuntu 20.04                     Intel oneAPI DPC++/C++ Compiler, IFX 2023.1.0
+                                     Ubuntu clang version 10.0.0-4ubuntu1
+                                     (cmake and autotools)
+
+    Linux 5.14.21-cray_shasta_c      cray-mpich/8.1.25
+    #1 SMP x86_64 GNU/Linux            cce 15.0.1
+    (perlmutter)                       GCC 12.2.0
+                                       intel-oneapi/2023.1.0
+                                       nvidia/22.7
+                                     (cmake)
+
+    Linux 5.14.21-cray_shasta_c      cray-mpich/8.1.23
+    #1 SMP x86_64 GNU/Linux              cce 15.0.1
+    (crusher)                            GCC 12.2.0
+                                     (cmake)
+
+    Linux-4.14.0-115.21.2            spectrum-mpi/rolling-release
+    #1 SMP ppc64le GNU/Linux             clang 12.0.1, 14.0.5
+    (lassen)                             GCC 8.3.1
+                                         XL 16.1.1.2, 2021,09.22, 2022.08.05
+                                     (cmake)
+
+    Linux-4.12.14-197.99-default     cray-mpich/7.7.14
+    #1 SMP x86_64 GNU/Linux              cce 12.0.3
+    (theta)                              GCC 11.2.0
+                                         llvm 9.0
+                                         Intel 19.1.2
+
+    Linux 3.10.0-1160.36.2.el7.ppc64 gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
+    #1 SMP ppc64be GNU/Linux         g++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
+    Power8 (echidna)                 GNU Fortran (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)
+                                     IBM XL C for Linux, V13.1
+                                     IBM XL Fortran for Linux, V15.1
+
+    Linux 3.10.0-1160.24.1.el7       GNU C (gcc), Fortran (gfortran), C++ (g++)
+    #1 SMP x86_64 GNU/Linux          compilers:
+    Centos7                              Version 4.8.5 20150623 (Red Hat 4.8.5-4)
+    (jelly/kituo/moohan)                 Version 4.9.3, Version 5.3.0, Version 6.3.0,
+                                         Version 7.2.0, Version 8.3.0, Version 9.1.0
+                                         Version 10.2.0
+                                     Intel(R) C (icc), C++ (icpc), Fortran (icc)
+                                     compilers:
+                                         Version 17.0.0.098 Build 20160721
+                                     GNU C (gcc) and C++ (g++) 4.8.5 compilers
+                                         with NAG Fortran Compiler Release 6.1(Tozai)
+                                     Intel(R) C (icc) and C++ (icpc) 17.0.0.098 compilers
+                                         with NAG Fortran Compiler Release 6.1(Tozai)
+                                     MPICH 3.3 compiled with GCC 7.2.0
+                                     MPICH 4.0.3 compiled with GCC 7.2.0
+                                     OpenMPI 3.1.3 compiled with GCC 7.2.0
+                                     OpenMPI 4.1.2 compiled with GCC 9.1.0
+                                     PGI C, Fortran, C++ for 64-bit target on
+                                     x86_64;
+                                         Version 19.10-0
+                                     NVIDIA C, Fortran, C++ for 64-bit target on
+                                     x86_64;
+                                         Version 22.5-0
+                                     (autotools and cmake)
+
+    Linux-3.10.0-1160.0.0.1chaos     openmpi-4.1.2
+    #1 SMP x86_64 GNU/Linux              clang 6.0.0, 11.0.1
+    (quartz)                             GCC 7.3.0, 8.1.0
+                                         Intel 19.0.4, 2022.2, oneapi.2022.2
+
+    macOS Apple M1 11.6              Apple clang version 12.0.5 (clang-1205.0.22.11)
+    Darwin 20.6.0 arm64              gfortran GNU Fortran (Homebrew GCC 11.2.0) 11.1.0
+    (macmini-m1)                     Intel icc/icpc/ifort version 2021.3.0 202106092021.3.0 20210609
+
+    macOS Big Sur 11.3.1             Apple clang version 12.0.5 (clang-1205.0.22.9)
+    Darwin 20.4.0 x86_64             gfortran GNU Fortran (Homebrew GCC 10.2.0_3) 10.2.0
+    (bigsur-1)                       Intel icc/icpc/ifort version 2021.2.0 20210228
+
+    macOS High Sierra 10.13.6        Apple LLVM version 10.0.0 (clang-1000.10.44.4)
+    64-bit                           gfortran GNU Fortran (GCC) 6.3.0
+    (bear)                           Intel icc/icpc/ifort version 19.0.4.233 20190416
+
+    Mac OS X El Capitan 10.11.6      Apple clang version 7.3.0 from Xcode 7.3
+    64-bit                           gfortran GNU Fortran (GCC) 5.2.0
+    (osx1011test)                    Intel icc/icpc/ifort version 16.0.2
+
+    Linux 2.6.32-573.22.1.el6        GNU C (gcc), Fortran (gfortran), C++ (g++)
+    #1 SMP x86_64 GNU/Linux          compilers:
+    Centos6                              Version 4.4.7 20120313
+    (platypus)                           Version 4.9.3, 5.3.0, 6.2.0
+                                     MPICH 3.1.4 compiled with GCC 4.9.3
+                                     PGI C, Fortran, C++ for 64-bit target on
+                                     x86_64;
+                                         Version 19.10-0
+
+    Windows 10 x64                  Visual Studio 2019 w/ clang 12.0.0
+                                        with MSVC-like command-line (C/C++ only - cmake)
+                                    Visual Studio 2019 w/ Intel C/C++ only cmake)
+                                    Visual Studio 2022 w/ clang 15.0.1
+                                        with MSVC-like command-line (C/C++ only - cmake)
+                                    Visual Studio 2022 w/ Intel C/C++/Fortran oneAPI 2023 (cmake)
+                                    Visual Studio 2019 w/ MSMPI 10.1 (C only - cmake)
+
+
+Known Problems
+==============
+
+    When HDF5 is compiled with NVHPC versions 23.5 - 23.9 (additional versions may
+    also be applicable) and with -O2 (or higher) and -DNDEBUG, test failures occur
+    in the following tests:
+
+        H5PLUGIN-filter_plugin
+        H5TEST-flush2
+        H5TEST-testhdf5-base
+        MPI_TEST_t_filters_parallel
+
+    Since these tests pass with an optimization level of -O1 (and -O0) and it is
+    currently unclear whether the test failures are due to issues in HDF5 or issues
+    in the 'nvc' compiler, the maximum optimization level for NVHPC has been set
+    to -O1 until the test failures can be resolved. Note that even at -O1 optimization
+    level, there still appears to be a sporadic test failure in the Java JUnit tests
+    that has occasionally been seen in JUnit-TestH5Pfapl and JUnit-TestH5D. It is also
+    unclear whether this is an issue in HDF5 or with the 'nvc' compiler. Finally, note
+    that NVHPC 23.9 will fail to compile the test/tselect.c test file with a compiler
+    error of 'use of undefined value' when the optimization level is -O2 or higher.
+    Nvidia is aware of this issue and has suggested lowering the optimization level to
+    -O1 for the time being:
+    https://forums.developer.nvidia.com/t/hdf5-no-longer-compiles-with-nv-23-9/269045.
+
+    CMake files do not behave correctly with paths containing spaces.
+    Do not use spaces in paths because the required escaping for handling spaces
+    results in very complex and fragile build files.
+    ADB - 2019/05/07
+
+    At present, metadata cache images may not be generated by parallel
+    applications.  Parallel applications can read files with metadata cache
+    images, but since this is a collective operation, a deadlock is possible
+    if one or more processes do not participate.
+
+    CPP ptable test fails on both VS2017 and VS2019 with Intel compiler, JIRA
+    issue: HDFFV-10628.  This test will pass with VS2015 with Intel compiler.
+
+    The subsetting option in ph5diff currently will fail and should be avoided.
+    The subsetting option works correctly in serial h5diff.
+
+    Several tests currently fail on certain platforms:
+        MPI_TEST-t_bigio fails with spectrum-mpi on ppc64le platforms.
+
+        MPI_TEST-t_subfiling_vfd and MPI_TEST_EXAMPLES-ph5_subfiling fail with
+        cray-mpich on theta and with XL compilers on ppc64le platforms.
+
+        MPI_TEST_testphdf5_tldsc fails with cray-mpich 7.7 on cori and theta.
+
+    Known problems in previous releases can be found in the HISTORY*.txt files
+    in the HDF5 source. Please report any new problems found to
+    help@hdfgroup.org.
+
+
+CMake vs. Autotools installations
+=================================
+While both build systems produce similar results, there are differences.
+Each system produces the same set of folders on linux (only CMake works
+on standard Windows); bin, include, lib and share. Autotools places the
+COPYING and RELEASE.txt file in the root folder, CMake places them in
+the share folder.
+
+The bin folder contains the tools and the build scripts. Additionally, CMake
+creates dynamic versions of the tools with the suffix "-shared". Autotools
+installs one set of tools depending on the "--enable-shared" configuration
+option.
+  build scripts
+  -------------
+  Autotools: h5c++, h5cc, h5fc
+  CMake: h5c++, h5cc, h5hlc++, h5hlcc
+
+The include folder holds the header files and the fortran mod files. CMake
+places the fortran mod files into separate shared and static subfolders,
+while Autotools places one set of mod files into the include folder. Because
+CMake produces a tools library, the header files for tools will appear in
+the include folder.
+
+The lib folder contains the library files, and CMake adds the pkgconfig
+subfolder with the hdf5*.pc files used by the bin/build scripts created by
+the CMake build. CMake separates the C interface code from the fortran code by
+creating C-stub libraries for each Fortran library. In addition, only CMake
+installs the tools library. The names of the szip libraries are different
+between the build systems.
+
+The share folder will have the most differences because CMake builds include
+a number of CMake specific files for support of CMake's find_package and support
+for the HDF5 Examples CMake project.
+
+The issues with the gif tool are:
+    HDFFV-10592 CVE-2018-17433
+    HDFFV-10593 CVE-2018-17436
+    HDFFV-11048 CVE-2020-10809
+These CVE issues have not yet been addressed and are avoided by not building
+the gif tool by default. Enable building the High-Level tools with these options:
+    autotools:   --enable-hlgiftools
+    cmake:       HDF5_BUILD_HL_GIF_TOOLS=ON
diff --git a/install/share/USING_HDF5_CMake.txt b/install/share/USING_HDF5_CMake.txt
new file mode 100644
index 0000000000..27c421b831
--- /dev/null
+++ b/install/share/USING_HDF5_CMake.txt
@@ -0,0 +1,257 @@
+************************************************************************
+* Build and Install HDF5 Applications with CMake                       *
+************************************************************************
+
+Notes: This short instruction is written for users who want to quickly
+       build HDF5 applications using the CMake tools. Users can adapt
+       these instructions for their own applications. For more information,
+       see the "Minimum C Project Files for CMake" section.
+
+       More information about using CMake can be found at the KitWare
+       site, www.cmake.org.
+
+       CMake uses the command line; however, the visual CMake tool is
+       available for the configuration step. The steps are similar for
+       all of the operating systems supported by CMake.
+
+       NOTES:
+         1. Using CMake for building and using HDF5 is under active
+            development. While we have attempted to provide error-free
+            files, please understand that development with CMake has not
+            been extensively tested outside of HDF. The CMake specific
+            files may change before the next release.
+
+         2. CMake for HDF5 development should be usable on any system
+            where CMake is supported. Please send us any comments on how
+            CMake support can be improved on any system.
+
+         3. See the appendix at the bottom of this file for an example
+            of using a ctest script for building and testing. See
+            INSTALL_CMake.txt for more information.
+
+         4. See https://cmake.org/cmake/help/latest/command/find_package.html
+            for more information on the CMake "Config Mode Search Procedure".
+
+
+========================================================================
+I. Preconditions
+========================================================================
+
+   1. We suggest you obtain the latest CMake for your platform from the Kitware
+      web site. The HDF5 1.15.x product requires a minimum CMake version
+      of 3.18. If you are using VS2022, the minimum version is 3.21.
+
+   2. You have installed the HDF5 library built with CMake, by executing
+      the HDF Install Utility (the *.msi file in the binary package for
+      Windows or the *.sh on Linux). You can obtain pre-built binaries
+      from The HDF Group's website at www.hdfgroup.org.
+
+   3. Set the HDF5_ROOT CMake variable, -DHDF5_ROOT=<install_path>
+      or environment variable, set(ENV{HDF5_ROOT} "<install_path>")
+      to the installed location of HDF5.
+         On Windows:
+            HDF5_ROOT=C:/Program Files/HDF_Group/HDF5/1.15.x/
+         On unix:
+            HDF5_ROOT=<install root folder>/HDF_Group/HDF5/1.15.x/
+
+      If you are using shared libraries, you may need to add to the path
+      environment variable. Set the path environment variable to the
+      installed location of the library files for HDF5.
+         On Windows (*.dll):
+            PATH=%PATH%;C:/Program Files/HDF_Group/HDF5/1.15.x/bin
+         On unix (*.so):
+            LD_LIBRARY_PATH=$LD_LIBRARY_PATH:<install root folder>/HDF_Group/HDF5/1.15.x/lib
+
+      If you are using filter plugin libraries, you will need to set the
+      HDF5_PLUGIN_PATH environment variable.
+         On Windows:
+            HDF5_PLUGIN_PATH=C:/Program Files/HDF_Group/HDF5/1.15.x/lib/plugin
+         On unix:
+            HDF5_PLUGIN_PATH=<install root folder>/HDF_Group/HDF5/1.15.x/lib/plugin
+
+      (Note there are no quote characters used on Windows and all platforms
+      use forward slashes)
+
+   4. Created separate source and build directories.
+      (CMake commands are executed in the build directory)
+
+   5. Created a CMakeLists.txt file(s) for your source. See Section III
+      below.
+
+
+
+========================================================================
+II. Building HDF5 Applications with CMake
+========================================================================
+
+Go through these steps to build HDF5 applications with CMake.
+   (The application must support building with CMake.)
+
+   1. Run CMake
+   2. Configure the cache settings
+   3. Build HDF5 Applications
+   4. Test HDF5 Applications
+
+These steps are described in more detail below.
+
+
+
+   1. Run CMake
+
+      The visual CMake executable is named "cmake-gui.exe" on Windows and should be
+      available in your Start menu. For Linux, UNIX, and Mac users the
+      executable is named "cmake-gui" and can be found where CMake was
+      installed.
+
+      Specify the source and build directories. Make the build and source
+      directories different. For example on Windows, if the source is at
+      c:\MyHDFstuff\hdf5, then use c:\MyHDFstuff\hdf5\build or
+      c:\MyHDFstuff\build\hdf5 for the build directory.
+
+      PREFERRED:
+        Users can perform the configuration step without using the visual
+        cmake-gui program. The following is an example command line
+        configuration step executed within the build directory:
+
+        cmake -G "<generator>"  [-D<options>]  <sourcepath>
+
+        Where <generator> is
+            * MinGW Makefiles
+            * NMake Makefiles
+            * Unix Makefiles
+            * Visual Studio 14 2015
+            * Visual Studio 14 2015 Win64
+            * Visual Studio 15 2017
+            * Visual Studio 15 2017 Win64
+            * Visual Studio 16 2019
+            * ... in addition VS2019 will need to set the "-A" option,
+            * ... [Win32, x64, ARM, ARM64]
+            * Visual Studio 17 2022
+            * ... in addition VS2022 will need to set the "-A" option,
+            * ... [Win32, x64, ARM, ARM64]
+
+        <options> is:
+            * BUILD_TESTING:BOOL=ON
+            * BUILD_SHARED_LIBS:BOOL=[ON | OFF]
+
+   2. Configure the cache settings
+
+      2.1  Visual CMake users, click the Configure button. If this is the first time you are
+           running cmake-gui in this directory, you will be prompted for the
+           generator you wish to use (for example on Windows, Visual Studio 14 2015 Win64).
+           CMake will read in the CMakeLists.txt files from the source directory and
+           display options for the HDF5 project. After the first configure you
+           can adjust the cache settings and/or specify locations of other programs.
+
+           Any conflicts or new values will be highlighted by the configure
+           process in red. Once you are happy with all the settings and there are no
+           more values in red, click the Generate button to produce the appropriate
+           build files.
+
+           On Windows, if you are using a Visual Studio generator, the solution and
+           project files will be created in the build folder.
+
+           On linux, if you are using the Unix Makefiles generator, the Makefiles will
+           be created in the build folder.
+
+      2.2  Alternative command line example on Windows in c:\MyHDFstuff\hdf5\build directory:
+
+           cmake -G "Visual Studio 14 2015 Win64" -DBUILD_TESTING:BOOL=ON ..
+
+   3. Build HDF5 Applications
+
+      On Windows, you can build HDF5 applications using either the Visual Studio Environment
+      or the command line. The command line is normally used on linux, Unix, and Mac.
+
+      To build from the command line, navigate to your build directory and
+      execute the following:
+
+              cmake --build . --config {Debug | Release}
+
+      NOTE: "--config {Debug | Release}" may be optional on your platform. We
+            recommend choosing either Debug or Release on Windows. If you are
+            using the pre-built binaries from HDF, use Release.
+
+      3.1  If you wish to use the Visual Studio environment, open the solution
+           file in your build directory. Be sure to select either Debug or
+           Release and build the solution.
+
+   4. Test HDF5 Applications
+
+      To test the build, navigate to your build directory and execute:
+
+              ctest . -C {Debug | Release}
+
+      NOTE: "-C {Debug | Release}" may be optional on your platform. We
+            recommend choosing either Debug or Release to match the build
+            step on Windows.
+
+   5. The files that support building with CMake are all of the files in the
+      config/cmake folder, the CMakeLists.txt files in each source folder, and
+      CTestConfig.cmake. CTestConfig.cmake is specific to the internal testing
+      performed by The HDF Group. It should be altered for the user's
+      installation and needs. The cacheinit.cmake file settings are used by
+      The HDF Group for daily testing. It should be altered/ignored for the user's
+      installation and needs.
+
+
+
+========================================================================
+III. Minimum C Project Files for CMake
+========================================================================
+
+Given the preconditions in section I, create a CMakeLists.txt file at the
+source root. Include the following text in the file:
+
+##########################################################
+cmake_minimum_required (VERSION 3.18)
+project (HDF5MyApp C CXX)
+
+set (LIB_TYPE STATIC) # or SHARED
+string(TOLOWER ${LIB_TYPE} SEARCH_TYPE)
+
+find_package (HDF5 NAMES hdf5 COMPONENTS C ${SEARCH_TYPE})
+# find_package (HDF5) # Find non-cmake built HDF5
+set_directory_properties(PROPERTIES INCLUDE_DIRECTORIES "${HDF5_INCLUDE_DIR}")
+set (LINK_LIBS ${LINK_LIBS} ${HDF5_C_${LIB_TYPE}_LIBRARY})
+
+set (example hdf_example)
+
+add_executable (${example} ${PROJECT_SOURCE_DIR}/${example}.c)
+TARGET_C_PROPERTIES (${example} PRIVATE ${LIB_TYPE})
+target_link_libraries (${example} ${LINK_LIBS})
+
+enable_testing ()
+include (CTest)
+
+add_test (NAME test_example COMMAND ${example})
+##########################################################
+
+
+
+========================================================================
+IV. APPENDIX
+========================================================================
+
+Below is an example of a ctest script that can be used to build the examples.
+Adjust the values as necessary. Note that the defaults can be entered on the
+command line and the build folder is created as a sub-folder. Windows should
+adjust the forward slash to double backslashes, except for the HDF_DIR
+environment variable.
+
+NOTE: this file is available at the HDF web site:
+    https://portal.hdfgroup.org/display/support/Building+HDF5+with+CMake
+
+    HDF5_Examples.cmake
+    HDF5_Examples_options.cmake
+
+Also available at the HDF web site is a CMake application framework template.
+You can quickly add files to the framework and execute the script to compile
+your application with an installed HDF5 binary.
+
+
+========================================================================
+For further assistance, send email to help@hdfgroup.org
+========================================================================
+
+
diff --git a/poc b/poc
new file mode 100755
index 0000000000..e0206aafe5
Binary files /dev/null and b/poc differ
diff --git a/poc.c b/poc.c
new file mode 100644
index 0000000000..d79abf3255
--- /dev/null
+++ b/poc.c
@@ -0,0 +1,94 @@
+#include "hdf5.h"
+#include <stdlib.h>
+
+typedef struct src_t {
+     uint32_t a;
+     float b;
+  } src_t;
+
+typedef struct dst_t {
+     float b;
+  } dst_t;
+
+herr_t convert(hid_t src_id, hid_t dst_id, H5T_cdata_t *cdata,
+    size_t nelmts, size_t buf_stride, size_t bkg_stride, void *buf,
+    void *bkg, hid_t dxpl)
+{
+  herr_t retval = EXIT_SUCCESS;
+  switch (cdata->command)
+  {
+  case H5T_CONV_INIT:
+    printf("Initializing conversion function...\n");
+    break;
+  case H5T_CONV_CONV:
+    printf("Converting...\n");
+    for (size_t i = 0; i < nelmts; ++i)
+      ((dst_t*) buf)[i].b = ((src_t*) buf)[i].b;
+    break;
+  case H5T_CONV_FREE:
+    printf("Finalizing conversion function...\n");
+    break;
+  default:
+    break;
+  }
+  return retval;
+}
+
+int main() {
+  hid_t src = H5I_INVALID_HID;
+  hid_t dst = H5I_INVALID_HID;
+  hid_t file_id = H5I_INVALID_HID;
+  hid_t space_id = H5I_INVALID_HID;
+  hid_t dset_id = H5I_INVALID_HID;
+  
+  if ((src = H5Tcreate(H5T_COMPOUND, sizeof(struct src_t))) < 0) {
+    printf("src dtype creation failed\n");
+  }
+
+  if (H5Tinsert(src, "a", HOFFSET(struct src_t, a), H5T_NATIVE_UINT32) < 0) {
+    printf("dtype insertion failed\n");
+  }
+
+  if (H5Tinsert(src, "b", HOFFSET(struct src_t, b), H5T_NATIVE_FLOAT) < 0) {
+    printf("dtype insertion failed\n");
+  }
+
+  if ((dst = H5Tcreate(H5T_COMPOUND, sizeof(struct dst_t))) < 0) {
+    printf("dst dtype creation failed\n");
+  }
+
+  if (H5Tinsert(dst, "b", HOFFSET(struct dst_t, b), H5T_IEEE_F32LE) < 0) {
+    printf("dtype insertion failed\n");
+  }
+
+  if (H5Tregister(H5T_PERS_SOFT, "src_t->dst_t", src, dst, &convert) < 0) {
+    printf("conversion registration failed\n");
+  }
+
+  struct src_t buf[] = {{1, 1.0} , {2, 2.0}, {3, 3.0}, {4, 4.0} , {5, 5.0} };  
+  
+  if ((file_id = H5Fcreate("conversion_test.h5", H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT)) < 0) {
+    printf("file creation failed\n");
+  }
+
+  if ((space_id = H5Screate_simple(1, (const hsize_t[]) {5}, NULL)) < 0) {
+    printf("space creation failed\n");
+  }
+
+  if ((dset_id = H5Dcreate(file_id, "dset", dst, space_id, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT)) < 0) {
+    printf("dset creation failed\n");
+  }
+
+  printf("Beginning dataset write\n");
+
+  if (H5Dwrite(dset_id, src, space_id, H5S_ALL, H5P_DEFAULT, buf) < 0) {
+    printf("write failed\n");
+  }
+
+  H5Tclose(dst);
+  H5Tclose(src);
+  H5Fclose(file_id);
+  H5Sclose(space_id);
+  H5Dclose(dset_id);
+  return 0;
+}
diff --git a/reproduce_bug.sh b/reproduce_bug.sh
new file mode 100755
index 0000000000..b0107315fe
--- /dev/null
+++ b/reproduce_bug.sh
@@ -0,0 +1,21 @@
+#!/bin/bash -eu
+
+HDF5_REPO_PATH=$(pwd)
+
+mkdir build
+
+pushd build
+cmake .. \
+    -DCMAKE_BUILD_TYPE=Release \
+    -DCMAKE_INSTALL_PREFIX=$HDF5_REPO_PATH/install \
+    -DBUILD_SHARED_LIBS=ON \
+    -DHDF5_BUILD_TOOLS=ON \
+    -DHDF5_BUILD_EXAMPLES=OFF \
+    -DHDF5_BUILD_TESTS=OFF
+
+make -j16
+make install
+popd
+if [ ! -z "${CC:-}" ]; then
+    $CC $CFLAGS -o poc poc.c -I$HDF5_REPO_PATH/install/include -L$HDF5_REPO_PATH/install/lib -lhdf5 -Wl,-rpath=$HDF5_REPO_PATH/install/lib
+fi
diff --git a/src/H5Dscatgath.c b/src/H5Dscatgath.c
index 9b60d81b2b..2c699b2631 100644
--- a/src/H5Dscatgath.c
+++ b/src/H5Dscatgath.c
@@ -33,13 +33,14 @@
 
 /* Macro to determine if we're using H5D__compound_opt_read() */
 #define H5D__SCATGATH_USE_CMPD_OPT_READ(DSET_INFO, IN_PLACE_TCONV)                                           \
-    ((DSET_INFO)->type_info.cmpd_subset && H5T_SUBSET_FALSE != (DSET_INFO)->type_info.cmpd_subset->subset && \
-     !(IN_PLACE_TCONV))
+    ((DSET_INFO)->type_info.cmpd_subset != NULL &&                                                           \
+     H5T_SUBSET_FALSE != (DSET_INFO)->type_info.cmpd_subset->subset && !(IN_PLACE_TCONV))
 
 /* Macro to determine if we're using H5D__compound_opt_write() */
 #define H5D__SCATGATH_USE_CMPD_OPT_WRITE(DSET_INFO, IN_PLACE_TCONV)                                          \
-    ((DSET_INFO)->type_info.cmpd_subset && H5T_SUBSET_DST == (DSET_INFO)->type_info.cmpd_subset->subset &&   \
-     (DSET_INFO)->type_info.dst_type_size == (DSET_INFO)->type_info.cmpd_subset->copy_size &&                \
+    ((DSET_INFO)->type_info.cmpd_subset != NULL &&                                                           \
+     H5T_SUBSET_DST == (DSET_INFO)->type_info.cmpd_subset->subset &&                                        \
+     (DSET_INFO)->type_info.dst_type_size == (DSET_INFO)->type_info.cmpd_subset->copy_size &&              \
      !(IN_PLACE_TCONV))
 
 /******************/
diff --git a/src/H5Tcompound.c b/src/H5Tcompound.c
index f877d5263a..d44fd1615c 100644
--- a/src/H5Tcompound.c
+++ b/src/H5Tcompound.c
@@ -97,7 +97,7 @@ H5Tget_member_offset(hid_t type_id, unsigned membno)
         HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, 0, "invalid member number");
 
     /* Value */
-    ret_value = H5T_GET_MEMBER_OFFSET(dt->shared, membno);
+    ret_value = H5T_GET_MEMBER_OFFSET(dt, membno);
 
 done:
     FUNC_LEAVE_API(ret_value)
diff --git a/src/H5Tprivate.h b/src/H5Tprivate.h
index 0332679e72..8668c41eba 100644
--- a/src/H5Tprivate.h
+++ b/src/H5Tprivate.h
@@ -39,8 +39,8 @@ typedef struct H5T_t H5T_t;
 #ifdef H5T_MODULE
 #define H5T_GET_SIZE(T)             ((T)->shared->size)
 #define H5T_GET_SHARED(T)           ((T)->shared)
-#define H5T_GET_MEMBER_OFFSET(T, I) ((T)->u.compnd.memb[I].offset)
-#define H5T_GET_MEMBER_SIZE(T, I)   ((T)->u.compnd.memb[I].shared->size)
+#define H5T_GET_MEMBER_OFFSET(T, I) ((T)->shared->u.compnd.memb[I].offset)
+#define H5T_GET_MEMBER_SIZE(T, I)   ((T)->shared->u.compnd.memb[I].shared_type->shared->size)
 #define H5T_GET_FORCE_CONV(T)       ((T)->shared->force_conv)
 #else /* H5T_MODULE */
 #define H5T_GET_SIZE(T)             (H5T_get_size(T))
@@ -56,7 +56,8 @@ typedef struct H5T_path_t  H5T_path_t;
 
 /* Forward reference of H5S_t */
 struct H5S_t;
-
+/* Forward reference of H5S_t */
+struct H5S_t;
 /* How to copy a datatype */
 typedef enum H5T_copy_t { H5T_COPY_TRANSIENT, H5T_COPY_ALL } H5T_copy_t;
 
