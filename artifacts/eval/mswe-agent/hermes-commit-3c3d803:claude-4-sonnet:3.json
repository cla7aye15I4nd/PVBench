[{"patch": "diff --git a/.gitignore b/.gitignore\nindex 6da7d9204..71c032a2d 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -34,3 +34,14 @@ android/intltest/java/com/facebook/hermes/test/assets/**\n \n # clangd cache\n .cache/\n+build/\n+Build/\n+bin/\n+lib/\n+*.o\n+*.out\n+*.obj\n+*.exe\n+*.dll\n+*.so\n+*.dylib\ndiff --git a/lib/Regex/Executor.cpp b/lib/Regex/Executor.cpp\nindex fb73b8e56..77b5868ca 100644\n--- a/lib/Regex/Executor.cpp\n+++ b/lib/Regex/Executor.cpp\n@@ -372,6 +372,10 @@ struct Context {\n   /// overflow error.\n   static constexpr size_t kMaxBacktrackDepth = 1u << 24;\n \n+  /// The maximum recursion depth for lookaround assertions. Beyond this we return a stack\n+  /// overflow error.\n+  static constexpr size_t kMaxRecursionDepth = 1000;\n+\n   /// The stream of bytecode instructions, including the header.\n   llvh::ArrayRef<uint8_t> bytecodeStream_;\n \n@@ -427,7 +431,8 @@ struct Context {\n   /// state->cursor_.currentPointer().\n   ExecutorResult<const CodeUnit *> match(\n       State<Traits> *state,\n-      bool onlyAtStart);\n+      bool onlyAtStart,\n+      size_t recursionDepth = 0);\n \n   /// Backtrack the given state \\p s with the backtrack stack \\p bts.\n   /// \\return true if we backtracked, false if we exhausted the stack.\n@@ -959,9 +964,15 @@ inline size_t Context<Traits>::advanceStringIndex(\n }\n \n template <class Traits>\n-auto Context<Traits>::match(State<Traits> *s, bool onlyAtStart)\n+auto Context<Traits>::match(State<Traits> *s, bool onlyAtStart, size_t recursionDepth)\n     -> ExecutorResult<const CodeUnit *> {\n   using State = State<Traits>;\n+  \n+  // Check recursion depth to prevent stack overflow\n+  if (recursionDepth >= kMaxRecursionDepth) {\n+    return ExecutionStatus::STACK_OVERFLOW;\n+  }\n+  \n   BacktrackStack backtrackStack;\n \n   // We'll refer to the cursor often.\n@@ -1316,7 +1327,7 @@ auto Context<Traits>::match(State<Traits> *s, bool onlyAtStart)\n             // Save and restore the position because lookaheads do not consume\n             // anything.\n             s->ip_ += sizeof(LookaroundInsn);\n-            auto match = this->match(s, true /* onlyAtStart */);\n+            auto match = this->match(s, true /* onlyAtStart */, recursionDepth + 1);\n             // There were no errors and we matched something (so non-null\n             // return)\n             matched = match && match.getValue();\n"}]