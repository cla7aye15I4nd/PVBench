
diff --git a/.gitignore b/.gitignore
index 6da7d9204..71c032a2d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -34,3 +34,14 @@ android/intltest/java/com/facebook/hermes/test/assets/**
 
 # clangd cache
 .cache/
+build/
+Build/
+bin/
+lib/
+*.o
+*.out
+*.obj
+*.exe
+*.dll
+*.so
+*.dylib
diff --git a/lib/Regex/Executor.cpp b/lib/Regex/Executor.cpp
index fb73b8e56..77b5868ca 100644
--- a/lib/Regex/Executor.cpp
+++ b/lib/Regex/Executor.cpp
@@ -372,6 +372,10 @@ struct Context {
   /// overflow error.
   static constexpr size_t kMaxBacktrackDepth = 1u << 24;
 
+  /// The maximum recursion depth for lookaround assertions. Beyond this we return a stack
+  /// overflow error.
+  static constexpr size_t kMaxRecursionDepth = 1000;
+
   /// The stream of bytecode instructions, including the header.
   llvh::ArrayRef<uint8_t> bytecodeStream_;
 
@@ -427,7 +431,8 @@ struct Context {
   /// state->cursor_.currentPointer().
   ExecutorResult<const CodeUnit *> match(
       State<Traits> *state,
-      bool onlyAtStart);
+      bool onlyAtStart,
+      size_t recursionDepth = 0);
 
   /// Backtrack the given state \p s with the backtrack stack \p bts.
   /// \return true if we backtracked, false if we exhausted the stack.
@@ -959,9 +964,15 @@ inline size_t Context<Traits>::advanceStringIndex(
 }
 
 template <class Traits>
-auto Context<Traits>::match(State<Traits> *s, bool onlyAtStart)
+auto Context<Traits>::match(State<Traits> *s, bool onlyAtStart, size_t recursionDepth)
     -> ExecutorResult<const CodeUnit *> {
   using State = State<Traits>;
+  
+  // Check recursion depth to prevent stack overflow
+  if (recursionDepth >= kMaxRecursionDepth) {
+    return ExecutionStatus::STACK_OVERFLOW;
+  }
+  
   BacktrackStack backtrackStack;
 
   // We'll refer to the cursor often.
@@ -1316,7 +1327,7 @@ auto Context<Traits>::match(State<Traits> *s, bool onlyAtStart)
             // Save and restore the position because lookaheads do not consume
             // anything.
             s->ip_ += sizeof(LookaroundInsn);
-            auto match = this->match(s, true /* onlyAtStart */);
+            auto match = this->match(s, true /* onlyAtStart */, recursionDepth + 1);
             // There were no errors and we matched something (so non-null
             // return)
             matched = match && match.getValue();
