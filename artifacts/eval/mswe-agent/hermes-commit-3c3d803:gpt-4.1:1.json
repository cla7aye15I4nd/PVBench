[{"patch": "diff --git a/.gitignore b/.gitignore\nindex 6da7d9204..71c032a2d 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -34,3 +34,14 @@ android/intltest/java/com/facebook/hermes/test/assets/**\n \n # clangd cache\n .cache/\n+build/\n+Build/\n+bin/\n+lib/\n+*.o\n+*.out\n+*.obj\n+*.exe\n+*.dll\n+*.so\n+*.dylib\ndiff --git a/lib/Regex/Executor.cpp b/lib/Regex/Executor.cpp\nindex fb73b8e56..a46b8ff77 100644\n--- a/lib/Regex/Executor.cpp\n+++ b/lib/Regex/Executor.cpp\n@@ -427,7 +427,8 @@ struct Context {\n   /// state->cursor_.currentPointer().\n   ExecutorResult<const CodeUnit *> match(\n       State<Traits> *state,\n-      bool onlyAtStart);\n+      bool onlyAtStart,\n+      size_t depth = 0);\n \n   /// Backtrack the given state \\p s with the backtrack stack \\p bts.\n   /// \\return true if we backtracked, false if we exhausted the stack.\n@@ -959,8 +960,12 @@ inline size_t Context<Traits>::advanceStringIndex(\n }\n \n template <class Traits>\n-auto Context<Traits>::match(State<Traits> *s, bool onlyAtStart)\n+auto Context<Traits>::match(State<Traits> *s, bool onlyAtStart, size_t depth /* = 0 */)\n     -> ExecutorResult<const CodeUnit *> {\n+    constexpr size_t kMaxRecursionDepth = 1000;\n+    if (depth > kMaxRecursionDepth) {\n+        return ExecutionStatus::STACK_OVERFLOW;\n+    }\n   using State = State<Traits>;\n   BacktrackStack backtrackStack;\n \n@@ -1316,7 +1321,7 @@ auto Context<Traits>::match(State<Traits> *s, bool onlyAtStart)\n             // Save and restore the position because lookaheads do not consume\n             // anything.\n             s->ip_ += sizeof(LookaroundInsn);\n-            auto match = this->match(s, true /* onlyAtStart */);\n+            auto match = this->match(s, true /* onlyAtStart */, depth + 1);\n             // There were no errors and we matched something (so non-null\n             // return)\n             matched = match && match.getValue();\n@@ -1543,7 +1548,7 @@ MatchRuntimeResult searchWithBytecodeImpl(\n   bool onlyAtStart = (header->constraints & MatchConstraintAnchoredAtStart) ||\n       (matchFlags & constants::matchOnlyAtStart);\n \n-  auto res = ctx.match(&state, onlyAtStart);\n+  auto res = ctx.match(&state, onlyAtStart, 0);\n   if (!res) {\n     assert(res.getStatus() == ExecutionStatus::STACK_OVERFLOW);\n     return MatchRuntimeResult::StackOverflow;\n"}]