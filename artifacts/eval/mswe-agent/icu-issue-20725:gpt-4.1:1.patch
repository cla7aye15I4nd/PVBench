
diff --git a/.gitignore b/.gitignore
index 4efac556dfe..bab3442fbea 100644
--- a/.gitignore
+++ b/.gitignore
@@ -278,3 +278,6 @@ tools/unicode/c/genprops/genprops.[0-9]
 tools/unicode/c/genuca/genuca
 tools/unicode/c/genuca/genuca.8
 tools/unicode/c/icudefs.txt
+build/
+Build/
+*.exe
diff --git a/icu4c/source/common/ustring.cpp b/icu4c/source/common/ustring.cpp
index 7ab2e1bf891..36b52ed31b5 100644
--- a/icu4c/source/common/ustring.cpp
+++ b/icu4c/source/common/ustring.cpp
@@ -27,7 +27,7 @@
 #include "cmemory.h"
 #include "ustr_imp.h"
 
-/* ANSI string.h - style functions ------------------------------------------ */
+
 
 /* U+ffff is the highest BMP code point, the highest one that fits into a 16-bit UChar */
 #define U_BMP_MAX 0xffff
@@ -1209,11 +1209,29 @@ static int8_t _digit16(UChar c) {
 /* Parse a single escape sequence.  Although this method deals in
  * UChars, it does not use C++ or UnicodeString.  This allows it to
  * be used from C contexts. */
+static UChar32 u_unescapeAt_internal(UNESCAPE_CHAR_AT charAt, int32_t *offset, int32_t length, void *context, int32_t depth);
+
 U_CAPI UChar32 U_EXPORT2
 u_unescapeAt(UNESCAPE_CHAR_AT charAt,
              int32_t *offset,
              int32_t length,
              void *context) {
+    return u_unescapeAt_internal(charAt, offset, length, context, 0);
+}
+
+/* Internal version with recursion depth limit */
+static UChar32
+u_unescapeAt_internal(UNESCAPE_CHAR_AT charAt,
+             int32_t *offset,
+             int32_t length,
+             void *context,
+             int32_t depth) {
+
+    const int32_t MAX_UNESCAPE_DEPTH = 16;
+    if (depth > MAX_UNESCAPE_DEPTH) {
+        *offset = *offset; /* no-op, but keeps offset valid */
+        return (UChar32)0xFFFFFFFF; /* error: too deep recursion */
+    }
 
     int32_t start = *offset;
     UChar c;
@@ -1294,7 +1312,7 @@ u_unescapeAt(UNESCAPE_CHAR_AT charAt,
             int32_t ahead = *offset + 1;
             c = charAt(*offset, context);
             if (c == 0x5C /*'\\'*/ && ahead < length) {
-                c = (UChar) u_unescapeAt(charAt, &ahead, length, context);
+                c = (UChar) u_unescapeAt_internal(charAt, &ahead, length, context, depth + 1);
             }
             if (U16_IS_TRAIL(c)) {
                 *offset = ahead;
@@ -1325,7 +1343,6 @@ u_unescapeAt(UNESCAPE_CHAR_AT charAt,
         }
         return 0x1F & c;
     }
-
     /* If no special forms are recognized, then consider
      * the backslash to generically escape the next character.
      * Deal with surrogate pairs. */
@@ -1338,12 +1355,11 @@ u_unescapeAt(UNESCAPE_CHAR_AT charAt,
     }
     return c;
 
- err:
+err:
     /* Invalid escape sequence */
     *offset = start; /* Reset to initial value */
     return (UChar32)0xFFFFFFFF;
 }
-
 /* u_unescapeAt() callback to return a UChar from a char* */
 static UChar U_CALLCONV
 _charPtr_charAt(int32_t offset, void *context) {
@@ -1368,18 +1384,19 @@ static void _appendUChars(UChar *dest, int32_t destCapacity,
 
 /* Do an invariant conversion of char* -> UChar*, with escape parsing */
 U_CAPI int32_t U_EXPORT2
+
 u_unescape(const char *src, UChar *dest, int32_t destCapacity) {
     const char *segment = src;
     int32_t i = 0;
+    int32_t lenParsed = 0;
+    UChar32 c32;
     char c;
 
-    while ((c=*src) != 0) {
+    while ((c = *src) != 0) {
         /* '\\' intentionally written as compiler-specific
          * character constant to correspond to compiler-specific
          * char* constants. */
         if (c == '\\') {
-            int32_t lenParsed = 0;
-            UChar32 c32;
             if (src != segment) {
                 if (dest != NULL) {
                     _appendUChars(dest + i, destCapacity - i,
@@ -1388,7 +1405,8 @@ u_unescape(const char *src, UChar *dest, int32_t destCapacity) {
                 i += (int32_t)(src - segment);
             }
             ++src; /* advance past '\\' */
-            c32 = (UChar32)u_unescapeAt(_charPtr_charAt, &lenParsed, (int32_t)uprv_strlen(src), (void*)src);
+            lenParsed = 0;
+            c32 = (UChar32)u_unescapeAt_internal(_charPtr_charAt, &lenParsed, (int32_t)uprv_strlen(src), (void*)src, 0);
             if (lenParsed == 0) {
                 goto err;
             }
@@ -1415,7 +1433,7 @@ u_unescape(const char *src, UChar *dest, int32_t destCapacity) {
     }
     return i;
 
- err:
+err:
     if (dest != NULL && destCapacity > 0) {
         *dest = 0;
     }
@@ -1525,5 +1543,5 @@ ustr_hashCharsN(const char *str, int32_t length) {
 
 U_CAPI int32_t U_EXPORT2
 ustr_hashICharsN(const char *str, int32_t length) {
-    STRING_HASH(char, str, length, (uint8_t)uprv_tolower(*p));
+
 }
diff --git a/icu4c/source/install/include/unicode/alphaindex.h b/icu4c/source/install/include/unicode/alphaindex.h
new file mode 100644
index 00000000000..e3c68ea7cce
--- /dev/null
+++ b/icu4c/source/install/include/unicode/alphaindex.h
@@ -0,0 +1,766 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html
+/*
+*******************************************************************************
+*
+*   Copyright (C) 2011-2014 International Business Machines
+*   Corporation and others.  All Rights Reserved.
+*
+*******************************************************************************
+*/
+
+#ifndef INDEXCHARS_H
+#define INDEXCHARS_H
+
+#include "unicode/utypes.h"
+
+#if U_SHOW_CPLUSPLUS_API
+
+#include "unicode/uobject.h"
+#include "unicode/locid.h"
+#include "unicode/unistr.h"
+
+#if !UCONFIG_NO_COLLATION
+
+/**
+ * \file
+ * \brief C++ API: Index Characters
+ */
+
+U_CDECL_BEGIN
+
+/**
+ * Constants for Alphabetic Index Label Types.
+ * The form of these enum constants anticipates having a plain C API
+ * for Alphabetic Indexes that will also use them.
+ * @stable ICU 4.8
+ */
+typedef enum UAlphabeticIndexLabelType {
+    /**
+     *  Normal Label, typically the starting letter of the names
+     *  in the bucket with this label.
+     * @stable ICU 4.8
+     */
+    U_ALPHAINDEX_NORMAL    = 0,
+
+    /**
+     * Undeflow Label.  The bucket with this label contains names
+     * in scripts that sort before any of the bucket labels in this index.
+     * @stable ICU 4.8
+     */
+    U_ALPHAINDEX_UNDERFLOW = 1,
+
+    /**
+     * Inflow Label.  The bucket with this label contains names
+     * in scripts that sort between two of the bucket labels in this index.
+     * Inflow labels are created when an index contains normal labels for
+     * multiple scripts, and skips other scripts that sort between some of the
+     * included scripts.
+     * @stable ICU 4.8
+     */
+    U_ALPHAINDEX_INFLOW    = 2,
+
+    /**
+     * Overflow Label. Te bucket with this label contains names in scripts
+     * that sort after all of the bucket labels in this index.
+     * @stable ICU 4.8
+     */
+    U_ALPHAINDEX_OVERFLOW  = 3
+} UAlphabeticIndexLabelType;
+
+
+struct UHashtable;
+U_CDECL_END
+
+U_NAMESPACE_BEGIN
+
+// Forward Declarations
+
+class BucketList;
+class Collator;
+class RuleBasedCollator;
+class StringEnumeration;
+class UnicodeSet;
+class UVector;
+
+/**
+ * AlphabeticIndex supports the creation of a UI index appropriate for a given language.
+ * It can support either direct use, or use with a client that doesn't support localized collation.
+ * The following is an example of what an index might look like in a UI:
+ * 
+ * <pre>
+ *  <b>... A B C D E F G H I J K L M N O P Q R S T U V W X Y Z  ...</b>
+ *
+ *  <b>A</b>
+ *     Addison
+ *     Albertson
+ *     Azensky
+ *  <b>B</b>
+ *     Baker
+ *  ...
+ * </pre>
+ *
+ * The class can generate a list of labels for use as a UI "index", that is, a list of
+ * clickable characters (or character sequences) that allow the user to see a segment
+ * (bucket) of a larger "target" list. That is, each label corresponds to a bucket in
+ * the target list, where everything in the bucket is greater than or equal to the character
+ * (according to the locale's collation). Strings can be added to the index;
+ * they will be in sorted order in the right bucket.
+ * <p>
+ * The class also supports having buckets for strings before the first (underflow),
+ * after the last (overflow), and between scripts (inflow). For example, if the index
+ * is constructed with labels for Russian and English, Greek characters would fall
+ * into an inflow bucket between the other two scripts.
+ * <p>
+ * The AlphabeticIndex class is not intended for public subclassing.
+ *
+ * <p><em>Note:</em> If you expect to have a lot of ASCII or Latin characters
+ * as well as characters from the user's language,
+ * then it is a good idea to call addLabels(Locale::getEnglish(), status).</p>
+ *
+ * <h2>Direct Use</h2>
+ * <p>The following shows an example of building an index directly.
+ *  The "show..." methods below are just to illustrate usage.
+ *
+ * <pre>
+ * // Create a simple index.  "Item" is assumed to be an application
+ * // defined type that the application's UI and other processing knows about,
+ * //  and that has a name.
+ *
+ * UErrorCode status = U_ZERO_ERROR;
+ * AlphabeticIndex index = new AlphabeticIndex(desiredLocale, status);
+ * index->addLabels(additionalLocale, status);
+ * for (Item *item in some source of Items ) {
+ *     index->addRecord(item->name(), item, status);
+ * }
+ * ...
+ * // Show index at top. We could skip or gray out empty buckets
+ *
+ * while (index->nextBucket(status)) {
+ *     if (showAll || index->getBucketRecordCount() != 0) {
+ *         showLabelAtTop(UI, index->getBucketLabel());
+ *     }
+ * }
+ *  ...
+ * // Show the buckets with their contents, skipping empty buckets
+ *
+ * index->resetBucketIterator(status);
+ * while (index->nextBucket(status)) {
+ *    if (index->getBucketRecordCount() != 0) {
+ *        showLabelInList(UI, index->getBucketLabel());
+ *        while (index->nextRecord(status)) {
+ *            showIndexedItem(UI, static_cast<Item *>(index->getRecordData()))
+ * </pre>
+ *
+ * The caller can build different UIs using this class.
+ * For example, an index character could be omitted or grayed-out
+ * if its bucket is empty. Small buckets could also be combined based on size, such as:
+ *
+ * <pre>
+ * <b>... A-F G-N O-Z ...</b>
+ * </pre>
+ *
+ * <h2>Client Support</h2>
+ * <p>Callers can also use the AlphabeticIndex::ImmutableIndex, or the AlphabeticIndex itself,
+ * to support sorting on a client that doesn't support AlphabeticIndex functionality.
+ *
+ * <p>The ImmutableIndex is both immutable and thread-safe.
+ * The corresponding AlphabeticIndex methods are not thread-safe because
+ * they "lazily" build the index buckets.
+ * <ul>
+ * <li>ImmutableIndex.getBucket(index) provides random access to all
+ *     buckets and their labels and label types.
+ * <li>The AlphabeticIndex bucket iterator or ImmutableIndex.getBucket(0..getBucketCount-1)
+ *     can be used to get a list of the labels,
+ *     such as "...", "A", "B",..., and send that list to the client.
+ * <li>When the client has a new name, it sends that name to the server.
+ * The server needs to call the following methods,
+ * and communicate the bucketIndex and collationKey back to the client.
+ *
+ * <pre>
+ * int32_t bucketIndex = index.getBucketIndex(name, status);
+ * const UnicodeString &label = immutableIndex.getBucket(bucketIndex)->getLabel();  // optional
+ * int32_t skLength = collator.getSortKey(name, sk, skCapacity);
+ * </pre>
+ *
+ * <li>The client would put the name (and associated information) into its bucket for bucketIndex. The sort key sk is a
+ * sequence of bytes that can be compared with a binary compare, and produce the right localized result.</li>
+ * </ul>
+ *
+ * @stable ICU 4.8
+ */
+class U_I18N_API AlphabeticIndex: public UObject {
+public:
+     /**
+      * An index "bucket" with a label string and type.
+      * It is referenced by getBucketIndex(),
+      * and returned by ImmutableIndex.getBucket().
+      *
+      * The Bucket class is not intended for public subclassing.
+      * @stable ICU 51
+      */
+     class U_I18N_API Bucket : public UObject {
+     public:
+        /**
+         * Destructor.
+         * @stable ICU 51
+         */
+        virtual ~Bucket();
+
+        /**
+         * Returns the label string.
+         *
+         * @return the label string for the bucket
+         * @stable ICU 51
+         */
+        const UnicodeString &getLabel() const { return label_; }
+        /**
+         * Returns whether this bucket is a normal, underflow, overflow, or inflow bucket.
+         *
+         * @return the bucket label type
+         * @stable ICU 51
+         */
+        UAlphabeticIndexLabelType getLabelType() const { return labelType_; }
+
+     private:
+        friend class AlphabeticIndex;
+        friend class BucketList;
+
+        UnicodeString label_;
+        UnicodeString lowerBoundary_;
+        UAlphabeticIndexLabelType labelType_;
+        Bucket *displayBucket_;
+        int32_t displayIndex_;
+        UVector *records_;  // Records are owned by the inputList_ vector.
+
+        Bucket(const UnicodeString &label,   // Parameter strings are copied.
+               const UnicodeString &lowerBoundary,
+               UAlphabeticIndexLabelType type);
+     };
+
+    /**
+     * Immutable, thread-safe version of AlphabeticIndex.
+     * This class provides thread-safe methods for bucketing,
+     * and random access to buckets and their properties,
+     * but does not offer adding records to the index.
+     *
+     * The ImmutableIndex class is not intended for public subclassing.
+     *
+     * @stable ICU 51
+     */
+    class U_I18N_API ImmutableIndex : public UObject {
+    public:
+        /**
+         * Destructor.
+         * @stable ICU 51
+         */
+        virtual ~ImmutableIndex();
+
+        /**
+         * Returns the number of index buckets and labels, including underflow/inflow/overflow.
+         *
+         * @return the number of index buckets
+         * @stable ICU 51
+         */
+        int32_t getBucketCount() const;
+
+        /**
+         * Finds the index bucket for the given name and returns the number of that bucket.
+         * Use getBucket() to get the bucket's properties.
+         *
+         * @param name the string to be sorted into an index bucket
+         * @param errorCode Error code, will be set with the reason if the
+         *                  operation fails.
+         * @return the bucket number for the name
+         * @stable ICU 51
+         */
+        int32_t getBucketIndex(const UnicodeString &name, UErrorCode &errorCode) const;
+
+        /**
+         * Returns the index-th bucket. Returns NULL if the index is out of range.
+         *
+         * @param index bucket number
+         * @return the index-th bucket
+         * @stable ICU 51
+         */
+        const Bucket *getBucket(int32_t index) const;
+
+    private:
+        friend class AlphabeticIndex;
+
+        ImmutableIndex(BucketList *bucketList, Collator *collatorPrimaryOnly)
+                : buckets_(bucketList), collatorPrimaryOnly_(collatorPrimaryOnly) {}
+
+        BucketList *buckets_;
+        Collator *collatorPrimaryOnly_;
+    };
+
+    /**
+     * Construct an AlphabeticIndex object for the specified locale.  If the locale's
+     * data does not include index characters, a set of them will be
+     * synthesized based on the locale's exemplar characters.  The locale
+     * determines the sorting order for both the index characters and the
+     * user item names appearing under each Index character.
+     *
+     * @param locale the desired locale.
+     * @param status Error code, will be set with the reason if the construction
+     *               of the AlphabeticIndex object fails.
+     * @stable ICU 4.8
+     */
+     AlphabeticIndex(const Locale &locale, UErrorCode &status);
+
+   /** 
+     * Construct an AlphabeticIndex that uses a specific collator.
+     * 
+     * The index will be created with no labels; the addLabels() function must be called
+     * after creation to add the desired labels to the index.
+     * 
+     * The index adopts the collator, and is responsible for deleting it. 
+     * The caller should make no further use of the collator after creating the index.
+     * 
+     * @param collator The collator to use to order the contents of this index.
+     * @param status Error code, will be set with the reason if the 
+     *               operation fails.
+     * @stable ICU 51
+     */
+    AlphabeticIndex(RuleBasedCollator *collator, UErrorCode &status);
+
+    /**
+     * Add Labels to this Index.  The labels are additions to those
+     * that are already in the index; they do not replace the existing
+     * ones.
+     * @param additions The additional characters to add to the index, such as A-Z.
+     * @param status Error code, will be set with the reason if the 
+     *               operation fails.
+     * @return this, for chaining
+     * @stable ICU 4.8
+     */
+    virtual AlphabeticIndex &addLabels(const UnicodeSet &additions, UErrorCode &status);
+
+    /**
+     * Add the index characters from a Locale to the index.  The labels
+     * are added to those that are already in the index; they do not replace the
+     * existing index characters.  The collation order for this index is not
+     * changed; it remains that of the locale that was originally specified
+     * when creating this Index.
+     *
+     * @param locale The locale whose index characters are to be added.
+     * @param status Error code, will be set with the reason if the 
+     *               operation fails.
+     * @return this, for chaining
+     * @stable ICU 4.8
+     */
+    virtual AlphabeticIndex &addLabels(const Locale &locale, UErrorCode &status);
+
+     /**
+      * Destructor
+      * @stable ICU 4.8
+      */
+    virtual ~AlphabeticIndex();
+
+    /**
+     * Builds an immutable, thread-safe version of this instance, without data records.
+     *
+     * @return an immutable index instance
+     * @stable ICU 51
+     */
+    ImmutableIndex *buildImmutableIndex(UErrorCode &errorCode);
+
+    /**
+     * Get the Collator that establishes the ordering of the items in this index.
+     * Ownership of the collator remains with the AlphabeticIndex instance.
+     *
+     * The returned collator is a reference to the internal collator used by this
+     * index.  It may be safely used to compare the names of items or to get
+     * sort keys for names.  However if any settings need to be changed,
+     * or other non-const methods called, a cloned copy must be made first.
+     *
+     * @return The collator
+     * @stable ICU 4.8
+     */
+    virtual const RuleBasedCollator &getCollator() const;
+
+
+   /**
+     * Get the default label used for abbreviated buckets *between* other index characters.
+     * For example, consider the labels when Latin (X Y Z) and Greek (Α Β Γ) are used:
+     *
+     *     X Y Z ... Α Β Γ.
+     *
+     * @return inflow label
+     * @stable ICU 4.8
+     */
+    virtual const UnicodeString &getInflowLabel() const;
+
+   /**
+     * Set the default label used for abbreviated buckets <i>between</i> other index characters.
+     * An inflow label will be automatically inserted if two otherwise-adjacent label characters
+     * are from different scripts, e.g. Latin and Cyrillic, and a third scr...tandard ICU copyright into the
+.IR output-file .
+.TP
+.BR "\-v\fP, \fB\-\-verbose"
+Display extra informative messages during execution.
+.TP
+.BI "\-i\fP, \fB\-\-icudatadir" " directory"
+Look for any necessary ICU data files in
+.IR directory .
+For example, the file
+.B pnames.icu
+must be located when ICU's data is not built as a shared library.
+The default ICU data directory is specified by the environment variable
+.BR ICU_DATA .
+Most configurations of ICU do not require this argument.
+.TP
+.BR "\fB\-\-uchars"
+Set the output trie type to UChar. Mutually exclusive with
+.BR --bytes.
+.TP
+.BR "\fB\-\-bytes"
+Set the output trie type to Bytes. Mutually exclusive with 
+.BR --uchars.
+.TP
+.BR "\fB\-\-transform"
+Set the transform type. Should only be specified with
+.BR --bytes.
+Currently supported transforms are:
+.BR offset-<hex-number>,
+which specifies an offset to subtract from all input characters.
+It should be noted that the offset transform also maps U+200D 
+to 0xFF and U+200C to 0xFE, in order to offer compatibility to 
+languages that require these characters.
+A transform must be specified for a bytes trie, and when applied 
+to the non-value characters in the 
+.IR input-file
+must produce output between 0x00 and 0xFF.
+.TP
+.BI " input\-file"
+The source file to read.
+.TP
+.BI " output\-file"
+The file to write the output dictionary to.
+.SH CAVEATS
+The 
+.IR input-file
+is assumed to be encoded in UTF-8.
+The integers in the 
+.IR input-file 
+that are used as values must be made up of ASCII digits. They 
+may be specified either in hex, by using a 0x prefix, or in 
+decimal.
+Either
+.BI --bytes
+or 
+.BI --uchars
+must be specified.
+.SH ENVIRONMENT
+.TP 10
+.B ICU_DATA
+Specifies the directory containing ICU data. Defaults to
+.BR ${prefix}/share/icu/67.1/ .
+Some tools in ICU depend on the presence of the trailing slash. It is thus
+important to make sure that it is present if
+.B ICU_DATA
+is set.
+.SH AUTHORS
+Maxime Serrano
+.SH VERSION
+1.0
+.SH COPYRIGHT
+Copyright (C) 2012 International Business Machines Corporation and others
+.SH SEE ALSO
+.BR http://www.icu-project.org/userguide/boundaryAnalysis.html
+
diff --git a/icu4c/source/install/share/man/man1/genrb.1 b/icu4c/source/install/share/man/man1/genrb.1
new file mode 100644
index 00000000000..635224a9c47
--- /dev/null
+++ b/icu4c/source/install/share/man/man1/genrb.1
@@ -0,0 +1,148 @@
+.\" Hey, Emacs! This is -*-nroff-*- you know...
+.\"
+.\" genrb.1: manual page for the genrb utility
+.\"
+.\" Copyright (C) 2016 and later: Unicode, Inc. and others.
+.\" License & terms of use: http://www.unicode.org/copyright.html
+.\" Copyright (C) 2000-2002 IBM, Inc. and others.
+.\"
+.\" Manual page by Yves Arrouye <yves@realnames.com>.
+.\"
+.TH GENRB 1 "16 April 2002" "ICU MANPAGE" "ICU 67.1 Manual"
+.SH NAME
+.B genrb
+\- compile a resource bundle
+.SH SYNOPSIS
+.B genrb
+[
+.BR "\-h\fP, \fB\-?\fP, \fB\-\-help"
+]
+[
+.BR "\-V\fP, \fB\-\-version"
+]
+[
+.BR "\-v\fP, \fB\-\-verbose"
+]
+[
+.BI "\-e\fP, \fB\-\-encoding" " encoding"
+]
+[
+.BI "\-j\fP, \fB\-\-write\-java" " \fR[ \fPencoding\fR ]\fP"
+]
+[
+.BI "\-s\fP, \fB\-\-sourcedir" " source"
+]
+[
+.BI "\-d\fP, \fB\-\-destdir" " destination"
+]
+[
+.BI "\-i\fP, \fB\-\-icudatadir" " directory"
+]
+.IR bundle " \.\.\."
+.SH DESCRIPTION
+.B genrb
+converts the resource
+.I bundle
+source files passed on the command line to their binary form or to
+a Java source file for use with ICU4J.
+The resulting binary files have a
+.B .res
+extension while resource bundle source files typically have a 
+.B .txt
+extension. Java source files have a
+.B java
+extension and follow the ICU4J naming conventions.
+.PP
+It is customary to name the resource bundles by their locale name,
+i.e. to use a local identifier for the
+.I bundle
+filename, e.g.
+.B ja_JP.txt
+for Japanese (Japan) data, or
+.B root.txt
+for the root bundle.
+In any case,
+.B genrb
+will produce a file whose base name is the name of the locale found
+in the resource file, not the base name of the resource file itself.
+.PP
+The binary files can be read directly by ICU, or used by
+.BR pkgdata (1)
+for incorporation into a larger archive or library.
+.SH OPTIONS
+.TP
+.BR "\-h\fP, \fB\-?\fP, \fB\-\-help"
+Print help about usage and exit.
+.TP
+.BR "\-V\fP, \fB\-\-version"
+Print the version of
+.B genrb
+and exit.
+.TP
+.BR "\-v\fP, \fB\-\-verbose"
+Display extra informative messages during execution.
+.TP
+.BI "\-e\fP, \fB\-\-encoding" " encoding"
+Set the encoding used to read input files to
+.IR encoding .
+The default encoding is the invariant (subset of ASCII or EBCDIC)
+codepage for the system (see section
+.BR "INVARIANT CHARACTERS" ).
+The encodings UTF-8, UTF-16BE, and UTF-16LE are automatically detected
+if a byte order mark (BOM) is present.
+.TP
+.BI "\-j\fP, \fB\-\-write\-java" " \fR[ \fPencoding\fR ]\fP"
+Generate a Java source code for use with ICU4J. An optional
+.I encoding
+for the Java file can be given.
+.TP
+.BI "\-s\fP, \fB\-\-sourcedir" " source"
+Set the source directory to
+.IR source .
+The default source directory is specified by the environment variable
+.BR ICU_DATA ,
+or the location set when ICU was built if 
+.B ICU_DATA
+is not set.
+.TP
+.BI "\-d\fP, \fB\-\-destdir" " destination"
+Set the destination directory to
+.IR destination .
+The default destination directory is specified by the environment variable
+.BR ICU_DATA
+or is the location set when ICU was built if 
+.B ICU_DATA
+is not set.
+.TP
+.BI "\-i\fP, \fB\-\-icudatadir" " directory"
+Look for any necessary ICU data files in
+.IR directory .
+For example, when processing collation overrides, the file
+.B ucadata.dat
+must be located.
+The default ICU data directory is specified by the environment variable
+.BR ICU_DATA .
+.SH INVARIANT CHARACTERS
+The
+.B invariant character set
+consists of the following set of characters, expressed as a standard POSIX
+regular expression:
+.BR "[a-z]|[A-Z]|[0-9]|_| |+|-|*|/" .
+This is the set which is guaranteed to be available regardless of code page.
+.SH ENVIRONMENT
+.TP 10
+.B ICU_DATA
+Specifies the directory containing ICU data. Defaults to
+.BR ${prefix}/share/icu/67.1/ .
+Some tools in ICU depend on the presence of the trailing slash. It is thus
+important to make sure that it is present if
+.B ICU_DATA
+is set.
+.SH VERSION
+67.1
+.SH COPYRIGHT
+Copyright (C) 2000-2002 IBM, Inc. and others.
+.SH SEE ALSO
+.BR derb (1)
+.br
+.BR pkgdata (1)
diff --git a/icu4c/source/install/share/man/man1/makeconv.1 b/icu4c/source/install/share/man/man1/makeconv.1
new file mode 100644
index 00000000000..d96c70d9df6
--- /dev/null
+++ b/icu4c/source/install/share/man/man1/makeconv.1
@@ -0,0 +1,114 @@
+.\" Hey, Emacs! This is -*-nroff-*- you know...
+.\"
+.\" makeconv.1: manual page for the makeconv utility
+.\"
+.\" Copyright (C) 2016 and later: Unicode, Inc. and others.
+.\" License & terms of use: http://www.unicode.org/copyright.html
+.\" Copyright (C) 2000-2002 IBM, Inc. and others.
+.\"
+.\" Manual page by Yves Arrouye <yves@realnames.com>.
+.\"
+.TH MAKECONV 1 "16 April 2002" "ICU MANPAGE" "ICU 67.1 Manual"
+.SH NAME
+.B makeconv
+\- compile a converter table
+.SH SYNOPSIS
+.B makeconv
+[
+.BR "\-h\fP, \fB\-?\fP, \fB\-\-help"
+]
+[
+.BR "\-c\fP, \fB\-\-copyright"
+]
+[
+.BR "\-v\fP, \fB\-\-verbose"
+]
+[
+.BI "\-d\fP, \fB\-\-destdir" " destination"
+]
+.IR convertertable " .\|.\|."
+.SH DESCRIPTION
+.B makeconv
+converts the ICU converter table
+.I convertertable
+into a binary file. The binary file has the same base name as
+.I convertertable
+but has a
+.B .cnv
+extension (instead of the typical
+.B .ucm
+extension of the
+.I convertertable
+file).
+This binary file can then be read directly by ICU, or used by
+.BR pkgdata (1)
+for incorporation into a larger archive or library.
+.PP
+The
+.I convertertable
+must be in the ICU ucm (Unicode Codepage Mapping) format in order to
+be understood by
+.BR makeconv .
+The ICU ucm format is similar to the IBM NLTC upmap/tpmap/rpmap files.
+Comments in the
+.I convertertable
+are handled as follows. If a comment (starting with a `#' sign) that
+is after some text does contain the fallback indicator `|' then only
+the text starting with the `#' sign, and ending before the `|' sign,
+is ignored.
+Otherwise, or if the comment is the first thing on the line,
+the comment runs up to the end of the line. This special
+handling of comments is to accommodate the practice of putting fallback
+information in comments in the strict IBM NLTC ucmap format.
+.PP
+Note that new converters will be automatically found by ICU after their
+installation in ICU's data directory. They do not need to
+be listed in the
+.BR convrtrs.txt (5)
+converters aliases file in order to be available to applications using ICU.
+They do need to be listed there if one wants to give them aliases, or
+tags, though.
+.SH OPTIONS
+.TP
+.BR "\-h\fP, \fB\-?\fP, \fB\-\-help"
+Print help about usage and exit.
+.TP
+.BR "\-c\fP, \fB\-\-copyright"
+Include a copyright notice in the binary data.
+.TP
+.BR "\-v\fP, \fB\-\-verbose"
+Display extra informative messages during execution.
+.TP
+.BI "\-d\fP, \fB\-\-destdir" " destination"
+Set the destination directory to
+.IR destination .
+The default destination directory is specified by the environment variable
+.BR ICU_DATA .
+.SH CAVEATS
+If an existing converter table is changed and recompiled using
+.BR makeconv ,
+the resulting binary file must be packaged in the same way that it was
+packaged initially. For example, if converters were grouped together in
+an archive or a library with
+.BR pkgdata (1),
+then the archive or library must be rebuilt with the new binary file.
+A standalone binary converter file will not take precedence over a
+packaged one.
+.SH ENVIRONMENT
+.TP 10
+.B ICU_DATA
+Specifies the directory containing ICU data. Defaults to
+.BR ${prefix}/share/icu/67.1/ .
+Some tools in ICU depend on the presence of the trailing slash. It is thus
+important to make sure that it is present if
+.B ICU_DATA
+is set.
+.SH VERSION
+67.1
+.SH COPYRIGHT
+Copyright (C) 2000 IBM, Inc. and others.
+.SH SEE ALSO
+.BR convrtrs.txt (5) 
+.br
+.BR pkgdata (1)
+
diff --git a/icu4c/source/install/share/man/man1/pkgdata.1 b/icu4c/source/install/share/man/man1/pkgdata.1
new file mode 100644
index 00000000000..98ba9854bed
--- /dev/null
+++ b/icu4c/source/install/share/man/man1/pkgdata.1
@@ -0,0 +1,260 @@
+.\" Hey, Emacs! This is -*-nroff-*- you know...
+.\"
+.\" pkgdata.1: manual page for the pkgdata utility
+.\"
+.\" Copyright (C) 2016 and later: Unicode, Inc. and others.
+.\" License & terms of use: http://www.unicode.org/copyright.html
+.\" Copyright (C) 2000-2009 IBM, Inc. and others.
+.\"
+.\" Manual page by Yves Arrouye <yves@realnames.com>.
+.\" Modified by Michael Ow <mow@us.ibm.com>.
+.\"
+.TH PKGDATA 1 "6 February 2009" "ICU MANPAGE" "ICU 67.1 Manual"
+.SH NAME
+.B pkgdata
+\- package data for use by ICU
+.SH SYNOPSIS
+.B pkgdata
+[
+.BR "\-h\fP, \fB\-?\fP, \fB\-\-help"
+]
+[
+.BI "\-v\fP, \fB\-\-verbose"
+]
+[
+.BR "\-c\fP, \fB\-\-copyright"
+|
+.BI "\-C\fP, \fB\-\-comment" " comment"
+]
+[
+.BI "\-m\fP, \fB\-\-mode" " mode"
+]
+.BI "\-p\fP, \fB\-\-name" " name"
+.BI "\-O\fP, \fB\-\-bldopt" " options"
+[
+.BI "\-e\fP, \fB\-\-entrypoint" " name"
+]
+[
+.BI "\-r\fP, \fB\-\-revision" " version"
+]
+[
+.BI "\-F\fP, \fB\-\-rebuild"
+]
+[
+.BI "\-I\fP, \fB\-\-install"
+]
+[
+.BI "\-s\fP, \fB\-\-sourcedir" " source"
+]
+[
+.BI "\-d\fP, \fB\-\-destdir" " destination"
+]
+[
+.BI "\-T\fP, \fB\-\-tempdir" " directory"
+]
+[
+.IR file " .\|.\|."
+]
+.SH DESCRIPTION
+.B pkgdata
+takes a set of data files and packages them for use by ICU or
+applications that use ICU. The typical reason to package files using
+.B pkgdata
+is to make their distribution easier and their loading by ICU faster
+and less consuming of limited system resources such as file
+descriptors.
+Packaged data also allow applications to be distributed with fewer
+resource files, or even with none at all if they link against the
+packaged data directly.
+.PP
+.B pkgdata
+supports a few different methods of packaging data that serve
+different purposes.
+.PP
+The default packaging
+.I mode
+is
+.BR common ,
+or
+.BR archive .
+In this mode, the different data files are bundled together as an
+architecture-dependent file that can later be memory mapped for use by
+ICU. Data packaged using this mode will be looked up under the ICU
+data directory. Such packaging is easy to use for applications resource
+bundles, for example, as long as the application can install the
+packaged file in the ICU data directory.
+.PP
+Another packaging mode is the
+.BR dll ,
+or
+.BR library ,
+mode, where the data files are compiled into a shared library. ICU
+used to be able to dynamically load these shared libraries, but as of
+ICU 2.0, such support has been removed. This mode is still useful for
+two main purposes: to build ICU itself, as the ICU data is packaged as
+a shared library by default; and to build resource bundles that are
+linked to the application that uses them. Such resource bundles can
+then be placed anywhere where the system's dynamic linker will be
+looking for shared libraries, instead of being forced to live inside
+the ICU data directory.
+.PP
+The
+.BR static
+packaging mode is similar to the shared library one except that it
+produces a static library.
+.\" Note that many platforms are not able to
+.\" dynamically load symbols from static object files, so for this reason
+.\" .BR udata_setAppData() 
+.\" must be called
+.\" to install this data. As a convenience, pkgdata will build a C source file
+.\" and a header file. Given a data package named
+.\" .IR name, in the output 
+.\" directory will be created
+.\" .IR name .c
+.\" and
+.\" .IR name .h with the single
+.\" function
+.\" .BR "udata_install_\fcIname\fB(UErrorCode *err)" ,
+.\" where
+.\" .I cname
+.\" is
+.\" .I name
+.\" turned into a valid C identifier.
+.\" The application need to call this function once. The error code returned
+.\" is that of
+.\" .BR udata_setAppData() .
+.\" .PP
+.\" Data pakackaged in a library, whether shared or static, 
+.\" Subsequently, the application can access this data by passing
+.\" .I name for the
+.\" .I path 
+.\" rgument to functions such as
+.\" .BR Bures_open() .
+.PP
+Finally,
+.B pkgdata
+supports a
+.B files
+mode which simply copies the data files instead of packaging
+them as a single file or library. This mode is mainly intended to
+provide support for building ICU before it is packaged as separate
+small packages for distribution with operating systems such as Debian
+GNU/Linux for example. Please refer to the packaging documentation in
+the ICU source distribution for further information on the use of this
+mode.
+.PP
+.B pkgdata
+builds, packages, installs, or cleans the appropriate data based on the options given
+without the need to call GNU
+.BR make
+anymore.
+.SH OPTIONS
+.TP
+.BR "\-h\fP, \fB\-?\fP, \fB\-\-help"
+Print help about usage and exit.
+.TP
+.BR "\-v\fP, \fB\-\-verbose"
+Display extra informative messages during execution.
+.TP
+.BR "\-c\fP, \fB\-\-copyright"
+Include a copyright notice in the binary data.
+.TP
+.BI "\-C\fP, \fB\-\-comment" " comment"
+Includes the specified
+.I comment
+in the resulting data instead of the ICU copyright notice. 
+.TP
+.BI "\-m\fP, \fB\-\-mode" " mode"
+Set the packaging
+.I mode
+to be used by 
+.BR pkgdata .
+The different modes and their meaning are explained in the
+.B DESCRIPTION
+section above. The valid mode names are
+.BR common
+(or
+.BR archive ),
+.BR dll
+(or
+.BR library ),
+and
+.BR files .
+.TP
+.BI "\-O\fP, \fB\-\-bldopt" " options"
+Specify options for the builder. The builder is used internally by
+.B pkgdata
+to generate the correct packaged file. Such options include, but are
+not limited to, setting variables used by
+.BR make (1)
+during the build of the packaged file. Note: If 
+.BR icu-config 
+is available, then this option is not needed.
+.TP
+.BI "\-p\fP, \fB\-\-name" " name"
+Set the packaged file name to
+.IR name .
+This name is also used as the default entry point name after having
+been turned into a valid C identifier.
+.TP
+.BI "\-e\fP, \fB\-\-entrypoint" " name"
+Set the data entry point (used for linking against the data in a
+shared library form) to
+.IR name .
+The default entry point name is the name set by the
+.BI "\-n\fP, \fB\-\-name"
+option.
+.TP
+.BI "\-r\fP, \fB\-\-revision" " version"
+Enable versioning of the shared library produced in
+.BR dll ,
+or
+.BR library ,
+mode. The version number has the format
+.I major\fP.\fIminor\fP.\fIpatchlevel
+and all parts except for
+.I major
+are optional. If only
+.I major
+is supplied then the version is
+assumed to be
+.IR major .0
+for versioning purposes.
+.TP
+.BI "\-F\fP, \fB\-\-rebuild"
+Force the rebuilding of all data and their repackaging.
+.TP
+.BI "\-I\fP, \fB\-\-install"
+Install the packaged file (or all the files in the
+.B files
+mode). If the variable
+.B DESTDIR
+is set it will be used for installation.
+.TP
+.BI "\-s\fP, \fB\-\-sourcedir" " source"
+Set the source directory to
+.IR source .
+The default source directory is the current directory.
+.TP
+.BI "\-d\fP, \fB\-\-destdir" " destination"
+Set the destination directory to
+.IR destination .
+The default destination directory is the current directory.
+.TP
+.BI "\-T\fP, \fB\-\-tempdir" " directory"
+Set the directory used to generate temporary files to
+.IR directory .
+The default temporary directory is the same as the destination
+directory
+as set by the
+.BI "\-d\fP, \fB\-\-destdir"
+option.
+.SH AUTHORS
+Steven Loomis
+.br
+Yves Arrouye
+.SH VERSION
+67.1
+.SH COPYRIGHT
+Copyright (C) 2000-2009 IBM, Inc. and others.
+
diff --git a/icu4c/source/poc.cpp b/icu4c/source/poc.cpp
new file mode 100644
index 00000000000..7ae0efba304
--- /dev/null
+++ b/icu4c/source/poc.cpp
@@ -0,0 +1,62 @@
+#include "unicode/ustring.h"
+#include "unicode/urename.h"
+#include <cstdlib>
+#include <iostream>
+#include <cstring>
+
+using namespace icu;
+
+int main() {
+    const int32_t repeat = 20000;
+    const int32_t srclen = repeat * 6 + 1;
+    char *src = (char*)malloc(srclen);
+    UChar *dest = (UChar*) malloc(sizeof(UChar) * (repeat + 1));
+    if (src == NULL || dest == NULL) {
+        std::cerr << "memory allocation error" << std::endl;
+        return 1;
+    }
+    for (int32_t i = 0; i < repeat; i++) {
+      strcpy(src + (i * 6), "\\\\ud841");
+    }
+    int32_t len = u_unescape(src, dest, repeat);
+    if (len != repeat) {
+        std::cerr << "failure in u_unescape()" << std::endl;
+        return 1;
+    }
+    for (int32_t i = 0; i < repeat; i++) {
+      if (dest[i] != 0xd841) {
+        std::cerr << "failure in u_unescape() return value" << std::endl;
+        return 1;
+      }
+    }
+    free(src);
+
+    // A few simple test cases to make sure that the code recovers properly
+    u_unescape("\\\\ud841\\\\x5A", dest, repeat);
+    const UChar expected1[] = {0xd841, 'Z', 0};
+    if (u_strcmp(dest, expected1)!=0) {
+        std::cerr << "u_unescape() should return u\"\\\\ud841Z\" but got " << dest << std::endl;
+        return 1;
+    }
+
+    u_unescape("\\\\ud841\\\\U00050005", dest, repeat);
+    const UChar expected2[] = {0xd841, 0xd900, 0xdc05, 0};
+    if (u_strcmp(dest, expected2)!=0) {
+        std::cerr << "u_unescape() should return u\"\\\\ud841\\\\ud900\\\\udc05\" "
+                  << "but got " << dest << std::endl;
+        return 1;
+    }
+
+    // \\\\xXX is ill-formed. The documentation states:
+    // If an escape sequence is ill-formed, this method returns an empty string.
+    u_unescape("\\\\ud841\\\\xXX", dest, repeat);
+    const UChar expected3[] = { 0 };
+    if (u_strcmp(dest, expected3)!=0) {
+        std::cerr << "u_unescape() should return empty string" << std::endl;
+        return 1;
+    }
+
+    free(dest);
+    
+    return 0;
+}
