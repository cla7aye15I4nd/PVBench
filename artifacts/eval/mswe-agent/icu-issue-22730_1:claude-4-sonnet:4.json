[{"patch": "diff --git a/.gitignore b/.gitignore\nindex 2663b13e874..fdfd1f9bf45 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -292,3 +292,6 @@ icu4c/build_qnx/nto-x86_64-o/*\n icu4c/build_qnx/linux-x86_64-o/Makefile\n icu4c/build_qnx/nto-aarch64-le/Makefile\n icu4c/build_qnx/nto-x86_64-o/Makefile\n+build/\n+Build/\n+*.exe\ndiff --git a/icu4c/source/common/putil.cpp b/icu4c/source/common/putil.cpp\nindex 92c7940827a..6f29597030c 100644\n--- a/icu4c/source/common/putil.cpp\n+++ b/icu4c/source/common/putil.cpp\n@@ -546,6 +546,16 @@ uprv_mul32_overflow(int32_t a, int32_t b, int32_t* res) {\n     *res = static_cast<int32_t>(res64);\n     return res64 != *res;\n }\n+U_CAPI UBool U_EXPORT2\n+uprv_sub32_overflow(int32_t a, int32_t b, int32_t* res) {\n+    // NOTE: Some compilers (GCC, Clang) have primitives available, like __builtin_sub_overflow.\n+    // This function could be optimized by calling one of those primitives.\n+    auto a64 = static_cast<int64_t>(a);\n+    auto b64 = static_cast<int64_t>(b);\n+    int64_t res64 = a64 - b64;\n+    *res = static_cast<int32_t>(res64);\n+    return res64 != *res;\n+}\n \n /**\n  * Truncates the given double.\ndiff --git a/icu4c/source/common/putilimp.h b/icu4c/source/common/putilimp.h\nindex 5b95a68418c..3fd0b20a4d3 100644\n--- a/icu4c/source/common/putilimp.h\n+++ b/icu4c/source/common/putilimp.h\n@@ -350,6 +350,18 @@ U_CAPI UBool U_EXPORT2 uprv_add32_overflow(int32_t a, int32_t b, int32_t* res);\n  * @internal\n  */\n U_CAPI UBool U_EXPORT2 uprv_mul32_overflow(int32_t a, int32_t b, int32_t* res);\n+/**\n+ * Subtracts the signed integer b from a, storing the result in res.\n+ * Checks for signed integer overflow.\n+ * Similar to the GCC/Clang extension __builtin_sub_overflow\n+ *\n+ * @param a The minuend.\n+ * @param b The subtrahend.\n+ * @param res a - b\n+ * @return true if overflow occurred; false if no overflow occurred.\n+ * @internal\n+ */\n+U_CAPI UBool U_EXPORT2 uprv_sub32_overflow(int32_t a, int32_t b, int32_t* res);\n \n #if 0\n /**\ndiff --git a/icu4c/source/i18n/japancal.cpp b/icu4c/source/i18n/japancal.cpp\nindex 7e69b97a3af..502728ad410 100644\n--- a/icu4c/source/i18n/japancal.cpp\n+++ b/icu4c/source/i18n/japancal.cpp\n@@ -37,6 +37,7 @@\n #include \"uassert.h\"\n #include \"ucln_in.h\"\n #include \"cstring.h\"\n+#include \"putilimp.h\"\n \n static icu::EraRules * gJapaneseEraRules = nullptr;\n static icu::UInitOnce gJapaneseEraRulesInitOnce {};\n@@ -228,7 +229,19 @@ void JapaneseCalendar::handleComputeFields(int32_t julianDay, UErrorCode& status\n     int32_t eraIdx = gJapaneseEraRules->getEraIndex(year, internalGetMonth(status) + 1, internalGet(UCAL_DAY_OF_MONTH), status);\n \n     internalSet(UCAL_ERA, eraIdx);\n-    internalSet(UCAL_YEAR, year - gJapaneseEraRules->getStartYear(eraIdx, status) + 1);\n+    // Use overflow-safe arithmetic to compute year - eraStartYear + 1\n+    int32_t eraStartYear = gJapaneseEraRules->getStartYear(eraIdx, status);\n+    int32_t tempYear;\n+    if (uprv_sub32_overflow(year, eraStartYear, &tempYear)) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return;\n+    }\n+    int32_t finalYear;\n+    if (uprv_add32_overflow(tempYear, 1, &finalYear)) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return;\n+    }\n+    internalSet(UCAL_YEAR, finalYear);\n }\n \n /*\n@@ -271,7 +284,11 @@ int32_t JapaneseCalendar::handleGetLimit(UCalendarDateFields field, ELimitType l\n                 UErrorCode status = U_ZERO_ERROR;\n                 int32_t eraStartYear = gJapaneseEraRules->getStartYear(gCurrentEra, status);\n                 U_ASSERT(U_SUCCESS(status));\n-                return GregorianCalendar::handleGetLimit(UCAL_YEAR, UCAL_LIMIT_MAXIMUM) - eraStartYear;\n+                int32_t maxYear;\n+                if (uprv_sub32_overflow(GregorianCalendar::handleGetLimit(UCAL_YEAR, UCAL_LIMIT_MAXIMUM), eraStartYear, &maxYear)) {\n+                    return 1; // Return minimum valid year on overflow\n+                }\n+                return maxYear;\n             }\n             default:\n                 return 1;    // Error condition, invalid limitType\n@@ -301,7 +318,17 @@ int32_t JapaneseCalendar::getActualMaximum(UCalendarDateFields field, UErrorCode\n     int32_t nextEraDate = nextEraStart[2];\n \n     int32_t eraStartYear = gJapaneseEraRules->getStartYear(era, status);\n-    int32_t maxYear = nextEraYear - eraStartYear + 1;   // 1-base\n+    // Use overflow-safe arithmetic to compute nextEraYear - eraStartYear + 1\n+    int32_t tempMaxYear;\n+    if (uprv_sub32_overflow(nextEraYear, eraStartYear, &tempMaxYear)) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return 1; // Return minimum valid year on overflow\n+    }\n+    int32_t maxYear;\n+    if (uprv_add32_overflow(tempMaxYear, 1, &maxYear)) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return 1; // Return minimum valid year on overflow\n+    }\n     if (nextEraMonth == 1 && nextEraDate == 1) {\n         // Subtract 1, because the next era starts at Jan 1\n         maxYear--;\n"}]