[{"patch": "diff --git a/.gitignore b/.gitignore\nindex a84268a7f686..ff15b5180e1f 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -73,3 +73,14 @@ pythonenv*\n /clang/utils/analyzer/projects/*/RefScanBuildResults\n # automodapi puts generated documentation files here.\n /lldb/docs/python_api/\n+build/\n+Build/\n+bin/\n+lib/\n+*.o\n+*.out\n+*.obj\n+*.exe\n+*.dll\n+*.so\n+*.dylib\ndiff --git a/llvm/lib/Target/X86/X86ISelLowering.cpp b/llvm/lib/Target/X86/X86ISelLowering.cpp\nindex f04603867a58..c4ad7b5d2b47 100644\n--- a/llvm/lib/Target/X86/X86ISelLowering.cpp\n+++ b/llvm/lib/Target/X86/X86ISelLowering.cpp\n@@ -54729,9 +54729,17 @@ SDValue X86TargetLowering::getNegatedExpression(SDValue Op, SelectionDAG &DAG,\n     // This is always negatible for free but we might be able to remove some\n     // extra operand negations as well.\n     SmallVector<SDValue, 4> NewOps(Op.getNumOperands(), SDValue());\n-    for (int i = 0; i != 3; ++i)\n+    \n+    // Try to get cheaper negated expressions for the first 3 operands\n+    // If any of them fail, we'll bail out completely\n+    for (int i = 0; i != 3; ++i) {\n+      SDValue Operand = Op.getOperand(i);\n+      if (!Operand.getNode() || Operand.getOpcode() == ISD::DELETED_NODE)\n+        return SDValue();\n+      \n       NewOps[i] = getCheaperNegatedExpression(\n-          Op.getOperand(i), DAG, LegalOperations, ForCodeSize, Depth + 1);\n+          Operand, DAG, LegalOperations, ForCodeSize, Depth + 1);\n+    }\n \n     bool NegA = !!NewOps[0];\n     bool NegB = !!NewOps[1];\n@@ -54742,9 +54750,22 @@ SDValue X86TargetLowering::getNegatedExpression(SDValue Op, SelectionDAG &DAG,\n                                   : NegatibleCost::Neutral;\n \n     // Fill in the non-negated ops with the original values.\n-    for (int i = 0, e = Op.getNumOperands(); i != e; ++i)\n-      if (!NewOps[i])\n-        NewOps[i] = Op.getOperand(i);\n+    // But first, validate that all original operands are still valid\n+    for (int i = 0, e = Op.getNumOperands(); i != e; ++i) {\n+      if (!NewOps[i]) {\n+        SDValue OrigOp = Op.getOperand(i);\n+        if (!OrigOp.getNode() || OrigOp.getOpcode() == ISD::DELETED_NODE)\n+          return SDValue(); // Bail out if any operand is deleted\n+        NewOps[i] = OrigOp;\n+      }\n+    }\n+    \n+    // Final validation: ensure all operands in NewOps are valid before creating the node\n+    for (const SDValue &NewOp : NewOps) {\n+      if (!NewOp.getNode() || NewOp.getOpcode() == ISD::DELETED_NODE)\n+        return SDValue();\n+    }\n+    \n     return DAG.getNode(NewOpc, SDLoc(Op), VT, NewOps);\n   }\n   case X86ISD::FRCP:\n"}]