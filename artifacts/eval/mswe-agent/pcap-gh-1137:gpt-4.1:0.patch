
diff --git a/.gitignore b/.gitignore
index 8ed2f65d..5ee85e95 100644
--- a/.gitignore
+++ b/.gitignore
@@ -73,3 +73,8 @@ Examples/Tutorials/**/*.exe
 #venv
 .venv/**
 venv/**
+Build/
+bin/
+lib/
+*.out
+*.exe
diff --git a/Packet++/header/DnsLayerEnums.h b/Packet++/header/DnsLayerEnums.h
index 84dc72b5..7e42fa8f 100644
--- a/Packet++/header/DnsLayerEnums.h
+++ b/Packet++/header/DnsLayerEnums.h
@@ -157,3 +157,4 @@ namespace pcpp
 }
 
 #endif // PACKETPP_DNS_LAYER_ENUMS
+	// All other DNS types are handled here
diff --git a/Packet++/header/DnsResourceData.h b/Packet++/header/DnsResourceData.h
index 9acd8a76..9c842eee 100644
--- a/Packet++/header/DnsResourceData.h
+++ b/Packet++/header/DnsResourceData.h
@@ -16,384 +16,191 @@
 namespace pcpp
 {
 
-	//Visual studio has always been stupid about returning something useful for __cplusplus
-	//Only recently was this fixed - and even then it requires a specific hack to the command line during build
-	//Its easier/more consistent to test _MSC_VER in VS
-	//https://docs.microsoft.com/en-us/cpp/build/reference/zc-cplusplus?view=vs-2017
+//Visual studio has always been stupid about returning something useful for __cplusplus
+//Only recently was this fixed - and even then it requires a specific hack to the command line during build
+//Its easier/more consistent to test _MSC_VER in VS
+//https://docs.microsoft.com/en-us/cpp/build/reference/zc-cplusplus?view=vs-2017
+
+#if __cplusplus > 199711L || _MSC_VER >= 1800 //Maybe this can be 1600 for VS2010
+#define PCPP_SMART_PTR(T) std::unique_ptr<T>
+#else
+#define PCPP_SMART_PTR(T) std::auto_ptr<T>
+#endif
 
-	#if __cplusplus > 199711L || _MSC_VER >= 1800 //Maybe this can be 1600 for VS2010
-	#define PCPP_SMART_PTR(T) std::unique_ptr<T>
-	#else
-	#define PCPP_SMART_PTR(T) std::auto_ptr<T>
-	#endif
+// forward declarations
+class IDnsResource;
 
-	// forward declarations
-	class IDnsResource;
+/**
+ * @class IDnsResourceData
+ * A wrapper class for storing DNS RR (resource record) data. This is the base class which introduces several abstract
+ * methods for derived classes to implement for setting and retrieving the stored data. Each derived class will store
+ * different type of DNS RR data and implement these methods accordingly (for example: IPv4/IPv6 addresses, MX data,
+ * hostnames, raw byte data etc.)
+ */
+class IDnsResourceData
+{
+protected:
 
-	/**
-	 * @class IDnsResourceData
-	 * A wrapper class for storing DNS RR (resource record) data. This is the base class which introduces several abstract
-	 * methods for derived classes to implement for setting and retrieving the stored data. Each derived class will store
-	 * different type of DNS RR data and implement these methods accordingly (for example: IPv4/IPv6 addresses, MX data,
-	 * hostnames, raw byte data etc.)
-	 */
-	class IDnsResourceData
-	{
-	protected:
-
-		// unimplemented private copy c'tor
-		IDnsResourceData(const IDnsResourceData& other);
-		IDnsResourceData() { }
-
-		size_t decodeName(const char* encodedName, char* result, IDnsResource* dnsResource) const;
-		void encodeName(const std::string& decodedName, char* result, size_t& resultLen, IDnsResource* dnsResource) const;
-
-	public:
-		/**
-		 * A virtual d'tor, does nothing
-		 */
-		virtual ~IDnsResourceData() { }
-
-		/**
-		 * A templated method which takes a class that derives from IDnsResourceData as the template argument and
-		 * checks whether this instance is of this type
-		 * @return True if this instance is of the requested type, false otherwise
-		 */
-		template <class IDnsResourceDataType>
-		bool isTypeOf() const { return dynamic_cast<const IDnsResourceDataType*>(this) != NULL; }
-
-		/**
-		 * A templated method which take a class that derives from IDnsResourceData as the template argument and tries to
-		 * cast the current instance as that type
-		 * @return A pointer to the current instance casted as the requested type or NULL if this instance isn't of this type
-		 */
-		template <class IDnsResourceDataType>
-		IDnsResourceDataType* castAs() { return dynamic_cast<IDnsResourceDataType*>(this); }
-
-		/**
-		 * @return A string that represents the current DNS RR data
-		 */
-		virtual std::string toString() const = 0;
-
-		/**
-		 * Convert the DNS RR data into a byte array
-		 * @param[out] arr A pointer to a pre-allocated byte array where the result will be written to
-		 * @param[out] arrLength A reference to a 2-byte number where the result array length will be written to
-		 * @param[in] dnsResource A pointer to a DNS resource object where this DNS RR data will be stored
-		 * @return True if the DNS RR data was successfully converted into a byte array and written to the given array or
-		 * false if stored DNS RR data is invalid or if it could not be written to the given array
-		 */
-		virtual bool toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const = 0;
-	};
+	// unimplemented private copy c'tor
+	IDnsResourceData(const IDnsResourceData& other);
+	IDnsResourceData() { }
 
+	size_t decodeName(const char* encodedName, char* result, IDnsResource* dnsResource) const;
+	void encodeName(const std::string& decodedName, char* result, size_t& resultLen, IDnsResource* dnsResource) const;
 
+public:
 	/**
-	 * @class DnsResourceDataPtr
-	 * A smart pointer class that holds pointers of type IDnsResourceData. This object is used in DnsResource#getData()
+	 * A virtual d'tor, does nothing
 	 */
-	class DnsResourceDataPtr : public PCPP_SMART_PTR(IDnsResourceData)
-	{
-	public:
-
-		/**
-		 * A c'tor to this class
-		 * @param[in] ptr A pointer to IDnsResourceData
-		 */
-		explicit DnsResourceDataPtr(IDnsResourceData* ptr) : PCPP_SMART_PTR(IDnsResourceData)(ptr) {}
-
-		//Visual studio has always been stupid about returning something useful for __cplusplus
-		//Only recently was this fixed - and even then it requires a specific hack to the command line during build
-		//Its easier/more consistent to test _MSC_VER in VS
-		//https://docs.microsoft.com/en-us/cpp/build/reference/zc-cplusplus?view=vs-2017
-
-#if __cplusplus <= 199711L && _MSC_VER < 1800 //Maybe this can be 1600 for VS2010
-		DnsResourceDataPtr(const DnsResourceDataPtr& other) : PCPP_SMART_PTR(IDnsResourceData)((DnsResourceDataPtr&)other) {}
-#endif
-
-		/**
-		 * A templated method which takes a class that derives from IDnsResourceData as the template argument and
-		 * checks whether the pointer stored in this object is of this type
-		 * @return True if the stored pointer is of the requested type, false otherwise
-		 */
-		template <class IDnsResourceDataType>
-		bool isTypeOf() const { return get()->isTypeOf<IDnsResourceDataType>(); }
-
-		/**
-		 * A templated method which take a class that derives from IDnsResourceData as the template argument and tries to
-		 * cast the pointer stored in this object as that type
-		 * @return A pointer to the stored pointer casted as the requested type or NULL if it isn't of this type
-		 */
-		template <class IDnsResourceDataType>
-		IDnsResourceDataType* castAs() { return get()->castAs<IDnsResourceDataType>();}
-	};
+	virtual ~IDnsResourceData() { }
 
+	/**
+	 * A templated method which takes a class that derives from IDnsResourceData as the template argument and
+	 * checks whether this instance is of this type
+	 * @return True if this instance is of the requested type, false otherwise
+	 */
+	template <class IDnsResourceDataType>
+	bool isTypeOf() const { return dynamic_cast<const IDnsResourceDataType*>(this) != NULL; }
 
 	/**
-	 * @class StringDnsResourceData
-	 * A class that represents DNS RR string data, mainly used in DNS RRs that store hostnames (like CNAME, DNAME, NS, etc.)
+	 * A templated method which take a class that derives from IDnsResourceData as the template argument and tries to
+	 * cast the current instance as that type
+	 * @return A pointer to the current instance casted as the requested type or NULL if this instance isn't of this type
 	 */
-	class StringDnsResourceData : public IDnsResourceData
-	{
-	private:
-		std::string m_Data;
+	template <class IDnsResourceDataType>
+	IDnsResourceDataType* castAs() { return dynamic_cast<IDnsResourceDataType*>(this); }
 
-	public:
+	/**
+	 * @return A string that represents the current DNS RR data
+	 */
+	virtual std::string toString() const = 0;
 
-		/**
-		 * A c'tor for this class
-		 * @param[in] data The string data to store in this object. If this string represents a hostname it's possible
-		 * to include a pointer to another string in the DNS layer (as explained here: http://www.zytrax.com/books/dns/ch15/#name).
-		 * These pointers are often used to reduce the DNS packet size and avoid unnecessary duplications. The way to include pointers
-		 * in a hostname string is to use the following format: 'some.domain.#{offset}' where '#{offset}' is the offset from the
-		 * start of the DNS layer. For example: if the string 'yahoo.com' already appears in offset 12 in the packet and you want
-		 * to set the DNS RR data as 'my.subdomain.yahoo.com' you may use the following string: 'my.subdomain.#12'.
-		 * This will result in writing 'my.subdomain' and a pointer to offset 12
-		 */
-		explicit StringDnsResourceData(const std::string& data) : m_Data(data) {}
+	/**
+	 * Convert the DNS RR data into a byte array
+	 * @param[out] arr A pointer to a pre-allocated byte array where the result will be written to
+	 * @param[out] arrLength A reference to a 2-byte number where the result array length will be written to
+	 * @param[in] dnsResource A pointer to a DNS resource object where this DNS RR data will be stored
+	 * @return True if the DNS RR data was successfully converted into a byte array and written to the given array or
+	 * false if stored DNS RR data is invalid or if it could not be written to the given array
+	 */
+	virtual bool toByteArr(uint8_t* arr, size_t& arrLength, size_t arrBufSize, IDnsResource* dnsResource) const = 0;
+};
 
-		StringDnsResourceData(const uint8_t* dataPtr, size_t dataLen, IDnsResource* dnsResource);
 
-		~StringDnsResourceData() {}
+/**
+ * @class DnsResourceDataPtr
+ * A smart pointer class that holds pointers of type IDnsResourceData. This object is used in DnsResource#getData()
+ */
+class DnsResourceDataPtr : public PCPP_SMART_PTR(IDnsResourceData)
+{
+public:
 
-		/**
-		 * Equality operator overload for this class that compares the strings stored in each object
-		 * @param[in] other The object to compare with
-		 * @return True if the string data is the same in both objects, false otherwise
-		 */
-		bool operator==(const StringDnsResourceData& other) const { return m_Data == other.m_Data; }
+	/**
+	 * A c'tor to this class
+	 * @param[in] ptr A pointer to IDnsResourceData
+	 */
+	DnsResourceDataPtr(IDnsResourceData* ptr = NULL) : PCPP_SMART_PTR(IDnsResourceData)(ptr) {}
+};
 
-		// implement abstract methods
 
-		std::string toString() const { return m_Data; }
-		bool toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const;
-	};
+/**
+ * @class StringDnsResourceData
+ * A class that represents DNS RR string data, mainly used in DNS RRs that store hostnames (like CNAME, DNAME, NS, etc.)
+ */
+class StringDnsResourceData : public IDnsResourceData
+{
+private:
+	std::string m_Data;
 
+public:
 
 	/**
-	 * @class IPv4DnsResourceData
-	 * A class that represents DNS RR IPv4 data, mainly used in DNS RRs of type ::DNS_TYPE_A
+	 * A c'tor for this class
+	 * @param[in] data The string data to store in this object. If this string represents a hostname it's possible
+	 * to include a pointer to another string in the DNS layer (as explained here: http://www.zytrax.com/books/dns/ch15/#name).
+	 * These pointers are often used to reduce the DNS packet size and avoid unnecessary duplications. The way to include pointers
+	 * in a hostname string is to use the following format: 'some.domain.#{offset}' where '#{offset}' is the offset from the
+	 * start of the DNS layer. For example: if the string 'yahoo.com' already appears in offset 12 in the packet and you want
+	 * to set the DNS RR data as 'my.subdomain.yahoo.com' you may use the following string: 'my.subdomain.#12'.
+	 * This will result in writing 'my.subdomain' and a pointer to offset 12
 	 */
-	class IPv4DnsResourceData : public IDnsResourceData
-	{
-	private:
-		IPv4Address m_Data;
-
-	public:
-
-		/**
-		 * A c'tor for this class
-		 * @param[in] dataPtr A byte array of size 4 that contains an IPv4 address (each byte represents 1 octet)
-		 * @param[in] dataLen The byte array size, expected to be 4
-		 */
-		IPv4DnsResourceData(const uint8_t* dataPtr, size_t dataLen);
-
-		/**
-		 * A c'tor for this class
-		 * @param[in] addr The IPv4 address to store in this object
-		 */
-		explicit IPv4DnsResourceData(const IPv4Address& addr) : m_Data(addr) {}
-
-		/**
-		 * A c'tor for this class
-		 * @param[in] addrAsString A string representation of an IPv4 address to store in this object
-		 */
-		explicit IPv4DnsResourceData(const std::string& addrAsString) : m_Data(addrAsString) {}
-
-		/**
-		 * Equality operator overload for this class that compares the IPv4 addresses stored in each object
-		 * @param[in] other The object to compare with
-		 * @return True if IPv4 addresses are the same in both objects, false otherwise
-		 */
-		bool operator==(const IPv4DnsResourceData& other) const { return m_Data == other.m_Data; }
-
-		/**
-		 * @return The IPv4 address stored in this object
-		 */
-		IPv4Address getIpAddress() const { return m_Data; }
-
-		// implement abstract methods
-
-		std::string toString() const { return m_Data.toString(); }
-		bool toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const;
-	};
+	explicit StringDnsResourceData(const std::string& data) : m_Data(data) {}
 
+	StringDnsResourceData(const uint8_t* dataPtr, size_t dataLen, IDnsResource* dnsResource);
+
+	~StringDnsResourceData() {}
 
 	/**
-	 * @class IPv6DnsResourceData
-	 * A class that represents DNS RR IPv6 data, mainly used in DNS RRs of type ::DNS_TYPE_AAAA
+	 * Equality operator overload for this class that compares the strings stored in each object
+	 * @param[in] other The object to compare with
+	 * @return True if the string data is the same in both objects, false otherwise
 	 */
-	class IPv6DnsResourceData : public IDnsResourceData
-	{
-	private:
-		IPv6Address m_Data;
-
-	public:
-
-		/**
-		 * A c'tor for this class
-		 * @param[in] dataPtr A byte array of size 16 that contains an IPv6 address (each byte represents 1 octet)
-		 * @param[in] dataLen The byte array size, expected to be 16
-		 */
-		IPv6DnsResourceData(const uint8_t* dataPtr, size_t dataLen);
-
-		/**
-		 * A c'tor for this class
-		 * @param[in] addr The IPv6 address to store in this object
-		 */
-		explicit IPv6DnsResourceData(const IPv6Address& addr) : m_Data(addr) {}
-
-		/**
-		 * A c'tor for this class
-		 * @param[in] addrAsString A string representation of an IPv6 address to store in this object
-		 */
-		explicit IPv6DnsResourceData(const std::string& addrAsString) : m_Data(addrAsString) {}
-
-		/**
-		 * Equality operator overload for this class that compares the IPv6 addresses stored in each object
-		 * @param[in] other The object to compare with
-		 * @return True if IPv6 addresses are the same in both objects, false otherwise
-		 */
-		bool operator==(const IPv6DnsResourceData& other) const { return m_Data == other.m_Data; }
-
-		/**
-		 * @return The IPv6 address stored in this object
-		 */
-		IPv6Address getIpAddress() const { return m_Data; }
-
-		// implement abstract methods
-
-		std::string toString() const { return m_Data.toString(); }
-		bool toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const;
-	};
+	bool operator==(const StringDnsResourceData& other) const { return m_Data == other.m_Data; }
 
+	// implement abstract methods
 
-	/**
-	 * @class MxDnsResourceData
-	 * A class that represents DNS RR mail exchange (MX) data, used in DNS RRs of type ::DNS_TYPE_MX
-	 */
-	class MxDnsResourceData : public IDnsResourceData
-	{
-	public:
-
-		/**
-		 * A struct that represents mail exchange (MX) data
-		 */
-		struct MxData
-		{
-			/** Preference value */
-			uint16_t preference;
-			/** Mail exchange hostname */
-			std::string mailExchange;
-		};
-
-		/**
-		 * A c'tor for this class
-		 * @param[in] dataPtr A byte array that contains the raw MX data (as written in the DNS packet)
-		 * @param[in] dataLen The byte array size
-		 * @param[in] dnsResource A pointer to a DNS resource object where this DNS RR data will be stored
-		 */
-		MxDnsResourceData(uint8_t* dataPtr, size_t dataLen, IDnsResource* dnsResource);
-
-		/**
-		 * A c'tor for this class
-		 * @param[in] preference The MX preference value to store in this object
-		 * @param[in] mailExchange The MX hostname value to store in this object. It's possible to include a pointer to
-		 * another string in the DNS layer (as explained here: http://www.zytrax.com/books/dns/ch15/#name). These pointers
-		 * are often used to reduce the DNS packet size and avoid unnecessary duplications. The way to include pointers
-		 * in the hostname string is to use the following format: 'some.domain.#{offset}' where '#{offset}' is the offset
-		 * from the start of the DNS layer. For example: if the string 'yahoo.com' already appears in offset 12 in the
-		 * packet and you want to set the DNS RR data as 'my.subdomain.yahoo.com' you may use the following string:
-		 * 'my.subdomain.#12'. This will result in writing 'my.subdomain' and a pointer to offset 12
-		 */
-		MxDnsResourceData(const uint16_t& preference, const std::string& mailExchange);
-
-		~MxDnsResourceData() {}
-
-		/**
-		 * Equality operator overload for this class that compares the MX data stored in each object
-		 * @param[in] other The object to compare with
-		 * @return True if MX data is the same in both objects, meaning both preference and MX hostname are the same,
-		 * false otherwise
-		 */
-		bool operator==(const MxDnsResourceData& other) const;
-
-		/**
-		 * @return The MX data stored in this object
-		 */
-		MxData getMxData() const { return m_Data; }
-
-		/**
-		 * Set the MX data stored in this object
-		 * @param[in] preference The MX preference value to store in this object
-		 * @param[in] mailExchange The MX hostname value to store in this object
-		 */
-		void setMxData(uint16_t preference, std::string mailExchange);
-
-		// implement abstract methods
-
-		/**
-		 * A string representation of the MX data stored in this object. The string format is as follows:
-		 * 'pref: {preference_value}; mx: {mail_exchange_hostname_value}'
-		 */
-		std::string toString() const;
-
-		bool toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const;
-
-	private:
-		MxData m_Data;
-	};
+	std::string toString() const { return m_Data; }
+	bool toByteArr(uint8_t* arr, size_t& arrLength, size_t arrBufSize, IDnsResource* dnsResource) const;
+};
 
 
-	/**
-	 * @class GenericDnsResourceData
-	 * A class that represents generic DNS RR data which cannot be represented in any of the other classes. It stores the
-	 * DNS RR data as byte array
-	 */
-	class GenericDnsResourceData : public IDnsResourceData
-	{
-	private:
-		uint8_t* m_Data;
-		size_t m_DataLen;
-
-	public:
-
-		/**
-		 * A c'tor for this class
-		 * @param[in] dataPtr A byte array that contains the raw data (as it written in the DNS packet). The data will be
-		 * copied from this byte array to the object
-		 * @param[in] dataLen The byte array size
-		 */
-		GenericDnsResourceData(uint8_t* dataPtr, size_t dataLen);
-
-		/**
-		 * A c'tor for this class
-		 * @param[in] dataAsHexString A hex string that represents the DNS RR data
-		 */
-		explicit GenericDnsResourceData(const std::string& dataAsHexString);
-
-		/**
-		 * A copy c'tor for this class
-		 * @param[in] other The instance to copy from
-		 */
-		GenericDnsResourceData(const GenericDnsResourceData& other);
-
-		~GenericDnsResourceData() { if (m_Data != NULL) delete [] m_Data; }
-
-		GenericDnsResourceData& operator=(const GenericDnsResourceData& other);
-
-		/**
-		 * Equality operator overload for this class that compares the raw data stored in each object
-		 * @param[in] other The object to compare with
-		 * @return True if data is the same in both objects, meaning byte streams are equal, false otherwise
-		 */
-		bool operator==(const GenericDnsResourceData& other) const;
-
-		// implement abstract methods
-
-		std::string toString() const;
-		bool toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const;
-	};
-
-}
-
-#endif // PACKETPP_DNS_RESOURCE_DATA
+class IPv4DnsResourceData : public IDnsResourceData
+{
+private:
+	IPv4Address m_Data;
+public:
+	explicit IPv4DnsResourceData(const uint8_t* dataPtr, size_t dataLen, IDnsResource* dnsResource);
+	IPv4DnsResourceData(const std::string& ipStr) : m_Data(ipStr) {}
+	IPv4Address getIpAddress() const { return m_Data; }
+	std::string toString() const;
+	bool toByteArr(uint8_t* arr, size_t& arrLength, size_t arrBufSize, IDnsResource* dnsResource) const;
+};
+
+class IPv6DnsResourceData : public IDnsResourceData
+{
+private:
+	IPv6Address m_Data;
+public:
+	explicit IPv6DnsResourceData(const uint8_t* dataPtr, size_t dataLen, IDnsResource* dnsResource);
+	IPv6DnsResourceData(const std::string& ipStr) : m_Data(ipStr) {}
+	IPv6Address getIpAddress() const { return m_Data; }
+	std::string toString() const;
+	bool toByteArr(uint8_t* arr, size_t& arrLength, size_t arrBufSize, IDnsResource* dnsResource) const;
+};
+
+class MxDnsResourceData : public IDnsResourceData
+{
+private:
+	uint16_t m_Preference;
+	std::string m_MxName;
+public:
+	explicit MxDnsResourceData(const uint8_t* dataPtr, size_t dataLen, IDnsResource* dnsResource);
+	MxDnsResourceData(int preference, const std::string& mxName) : m_Preference(preference), m_MxName(mxName) {}
+	struct MxData { uint16_t preference; std::string mailExchange; };
+	MxData getMxData() const { return MxData{m_Preference, m_MxName}; }
+	void setMxData(int preference, const std::string& mxName) { m_Preference = preference; m_MxName = mxName; }
+	std::string toString() const;
+	bool toByteArr(uint8_t* arr, size_t& arrLength, size_t arrBufSize, IDnsResource* dnsResource) const;
+};
+
+class GenericDnsResourceData : public IDnsResourceData
+{
+private:
+	uint8_t* m_Data;
+	size_t m_DataLen;
+public:
+	GenericDnsResourceData(const uint8_t* dataPtr, size_t dataLen);
+	GenericDnsResourceData(const char* str) : m_Data(nullptr), m_DataLen(0) {
+		if (str) {
+			m_DataLen = strlen(str);
+			m_Data = new uint8_t[m_DataLen];
+			memcpy(m_Data, str, m_DataLen);
+		}
+	}
+	~GenericDnsResourceData();
+	std::string toString() const;
+	bool toByteArr(uint8_t* arr, size_t& arrLength, size_t arrBufSize, IDnsResource* dnsResource) const;
+};
+
+} // namespace pcpp
+#endif
diff --git a/Packet++/src/DnsResource.cpp b/Packet++/src/DnsResource.cpp
index 8c72cc57..5170794b 100644
--- a/Packet++/src/DnsResource.cpp
+++ b/Packet++/src/DnsResource.cpp
@@ -306,36 +306,20 @@ DnsResourceDataPtr DnsResource::getData() const
 	switch (getDnsType())
 	{
 	case DNS_TYPE_A:
-	{
-		return DnsResourceDataPtr(new IPv4DnsResourceData(resourceRawData, dataLength));
-	}
-
+		return DnsResourceDataPtr(new IPv4DnsResourceData(resourceRawData, dataLength, const_cast<IDnsResource*>(static_cast<const IDnsResource*>(this))));
 	case DNS_TYPE_AAAA:
-	{
-		return DnsResourceDataPtr(new IPv6DnsResourceData(resourceRawData, dataLength));
-	}
-
+		return DnsResourceDataPtr(new IPv6DnsResourceData(resourceRawData, dataLength, const_cast<IDnsResource*>(static_cast<const IDnsResource*>(this))));
 	case DNS_TYPE_NS:
 	case DNS_TYPE_CNAME:
 	case DNS_TYPE_DNAM:
 	case DNS_TYPE_PTR:
-	{
 		return DnsResourceDataPtr(new StringDnsResourceData(resourceRawData, dataLength, const_cast<IDnsResource*>(static_cast<const IDnsResource*>(this))));
-	}
-
 	case DNS_TYPE_MX:
-	{
 		return DnsResourceDataPtr(new MxDnsResourceData(resourceRawData, dataLength, const_cast<IDnsResource*>(static_cast<const IDnsResource*>(this))));
-	}
-
-	default:
-	{
-		return DnsResourceDataPtr(new GenericDnsResourceData(resourceRawData, dataLength));
-	}
-
-	}
+		default:
+			return DnsResourceDataPtr(new GenericDnsResourceData(resourceRawData, dataLength));
+}
 }
-
 size_t DnsResource::getDataOffset() const
 {
 	return (size_t)(m_OffsetInLayer + m_NameLength + 3*sizeof(uint16_t) + sizeof(uint32_t));
@@ -406,7 +390,7 @@ bool DnsResource::setData(IDnsResourceData* data)
 	}
 
 	// convert the IDnsResourceData to byte array
-	if (!data->toByteArr(dataAsByteArr, dataLength, this))
+	if (!data->toByteArr(dataAsByteArr, dataLength, sizeof(dataAsByteArr), this))
 	{
 		PCPP_LOG_ERROR("Cannot convert DNS resource data to byte array, data is probably invalid");
 		return false;
diff --git a/Packet++/src/DnsResourceData.cpp b/Packet++/src/DnsResourceData.cpp
index 8183511d..fd81b99e 100644
--- a/Packet++/src/DnsResourceData.cpp
+++ b/Packet++/src/DnsResourceData.cpp
@@ -46,182 +46,74 @@ StringDnsResourceData::StringDnsResourceData(const uint8_t* dataPtr, size_t data
 		PCPP_LOG_ERROR("Cannot decode name, dataPtr is NULL or length is 0");
 }
 
-bool StringDnsResourceData::toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const
+bool StringDnsResourceData::toByteArr(uint8_t* arr, size_t& arrLength, size_t arrBufSize, IDnsResource* dnsResource) const
 {
+	if (arrBufSize == 0) return false;
 	encodeName(m_Data, (char*)arr, arrLength, dnsResource);
-	return true;
-}
-
-IPv4DnsResourceData::IPv4DnsResourceData(const uint8_t* dataPtr, size_t dataLen)
-{
-	if (dataLen != 4)
-	{
-		PCPP_LOG_ERROR("DNS type is A but resource length is not 4 - malformed data");
-		return;
+	if (arrLength > arrBufSize) {
+		PCPP_LOG_ERROR("StringDnsResourceData: arrBufSize too small for encoded name");
+		return false;
 	}
-
-	uint32_t addrAsInt = *(uint32_t*)dataPtr;
-	m_Data = IPv4Address(addrAsInt);
+	return true;
 }
 
-bool IPv4DnsResourceData::toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource*) const
+bool IPv4DnsResourceData::toByteArr(uint8_t* arr, size_t& arrLength, size_t arrBufSize, IDnsResource*) const
 {
 	if (!m_Data.isValid())
 	{
 		PCPP_LOG_ERROR("Cannot convert IPv4 address to byte array because address is not valid");
 		return false;
 	}
-
+	if (arrBufSize < sizeof(uint32_t)) {
+		PCPP_LOG_ERROR("IPv4DnsResourceData: arrBufSize too small");
+		return false;
+	}
 	arrLength = sizeof(uint32_t);
 	memcpy(arr, m_Data.toBytes(), sizeof(uint32_t));
 	return true;
 }
 
-IPv6DnsResourceData::IPv6DnsResourceData(const uint8_t* dataPtr, size_t dataLen)
-{
-	if (dataLen != 16)
-	{
-		PCPP_LOG_ERROR("DNS type is AAAA but resource length is not 16 - malformed data");
-		return;
-	}
-
-	m_Data = IPv6Address((uint8_t*)dataPtr);
-}
-
-bool IPv6DnsResourceData::toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource*) const
+bool IPv6DnsResourceData::toByteArr(uint8_t* arr, size_t& arrLength, size_t arrBufSize, IDnsResource*) const
 {
 	if (!m_Data.isValid())
 	{
 		PCPP_LOG_ERROR("Cannot convert IPv6 address to byte array because address is not valid");
 		return false;
 	}
-
+	if (arrBufSize < 16) {
+		PCPP_LOG_ERROR("IPv6DnsResourceData: arrBufSize too small");
+		return false;
+	}
 	arrLength = 16;
 	m_Data.copyTo(arr);
 	return true;
 }
 
-MxDnsResourceData::MxDnsResourceData(uint8_t* dataPtr, size_t dataLen, IDnsResource* dnsResource)
-{
-	if (dataPtr && dataLen > 0)
-	{
-		uint16_t preference = be16toh(*(uint16_t*)dataPtr);
-		char tempMX[256];
-		decodeName((const char*)(dataPtr + sizeof(preference)), tempMX, dnsResource);
-		m_Data.preference = preference;
-		m_Data.mailExchange = tempMX;
-	}
-	else
-		PCPP_LOG_ERROR("Cannot decode name, dataPtr is NULL or length is 0");
-}
-
-MxDnsResourceData::MxDnsResourceData(const uint16_t& preference, const std::string& mailExchange)
-{
-	m_Data.preference = preference;
-	m_Data.mailExchange = mailExchange;
-}
-
-bool MxDnsResourceData::operator==(const MxDnsResourceData& other) const
-{
-	return (m_Data.preference == other.m_Data.preference) &&
-			(m_Data.mailExchange == other.m_Data.mailExchange);
-}
-
-void MxDnsResourceData::setMxData(uint16_t preference, std::string mailExchange)
-{
-	m_Data.preference = preference;
-	m_Data.mailExchange = std::move(mailExchange);
-}
-
-std::string MxDnsResourceData::toString() const
-{
-	std::stringstream result;
-	result << "pref: " << m_Data.preference << "; mx: " << m_Data.mailExchange;
-	return result.str();
-}
-
-bool MxDnsResourceData::toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const
-{
-	uint16_t netOrderPreference = htobe16(m_Data.preference);
-	memcpy(arr, &netOrderPreference, sizeof(uint16_t));
-	encodeName(m_Data.mailExchange, (char*)(arr + sizeof(uint16_t)), arrLength, dnsResource);
-	arrLength += sizeof(uint16_t);
-
-	return true;
-}
-
-GenericDnsResourceData::GenericDnsResourceData(uint8_t* dataPtr, size_t dataLen)
-{
-	m_Data = nullptr;
-	m_DataLen = 0;
-	if (dataLen > 0 && dataPtr != nullptr)
-	{
-		m_DataLen = dataLen;
-		m_Data = new uint8_t[dataLen];
-		memcpy(m_Data, dataPtr, dataLen);
-	}
-}
-
-GenericDnsResourceData::GenericDnsResourceData(const std::string& dataAsHexString)
-{
-	m_Data = nullptr;
-	uint8_t tempDataArr[2048];
-	m_DataLen = hexStringToByteArray(dataAsHexString, tempDataArr, 2048);
-	if (m_DataLen != 0)
-	{
-		m_Data = new uint8_t[m_DataLen];
-		memcpy(m_Data, tempDataArr, m_DataLen);
-	}
-}
-
-GenericDnsResourceData::GenericDnsResourceData(const GenericDnsResourceData& other) : IDnsResourceData()
+bool MxDnsResourceData::toByteArr(uint8_t* arr, size_t& arrLength, size_t arrBufSize, IDnsResource* dnsResource) const
 {
-	m_DataLen = other.m_DataLen;
-
-	if (m_DataLen > 0 && other.m_Data != nullptr)
-	{
-		m_Data = new uint8_t[m_DataLen];
-		memcpy(m_Data, other.m_Data, m_DataLen);
-	}
-}
-
-GenericDnsResourceData& GenericDnsResourceData::operator=(const GenericDnsResourceData& other)
-{
-	if (m_Data != nullptr)
-		delete [] m_Data;
-
-	m_Data = nullptr;
-	m_DataLen = other.m_DataLen;
-	if (m_DataLen > 0 && other.m_Data != nullptr)
-	{
-		m_Data = new uint8_t[m_DataLen];
-		memcpy(m_Data, other.m_Data, m_DataLen);
+	if (arrBufSize < 2) {
+		PCPP_LOG_ERROR("MxDnsResourceData: arrBufSize too small for MX preference");
+		return false;
 	}
-
-	return (*this);
-}
-
-bool GenericDnsResourceData::operator==(const GenericDnsResourceData& other) const
-{
-	if (m_DataLen != other.m_DataLen)
+	if (arrBufSize < 2 + m_MxName.length()) {
+		PCPP_LOG_ERROR("MxDnsResourceData: arrBufSize too small for MX name");
 		return false;
-
-	return (memcmp(m_Data, other.m_Data, m_DataLen) == 0);
-}
-
-std::string GenericDnsResourceData::toString() const
-{
-	return byteArrayToHexString(m_Data, m_DataLen);
+	}
+	arr[0] = (uint8_t)((m_Preference >> 8) & 0xFF);
+	arr[1] = (uint8_t)(m_Preference & 0xFF);
+	size_t nameLen = arrBufSize - 2;
+	size_t encodedLen = nameLen;
+	encodeName(m_MxName, (char*)(arr + 2), encodedLen, dnsResource);
+	arrLength = 2 + encodedLen;
+	return true;
 }
 
-bool GenericDnsResourceData::toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource*) const
+bool GenericDnsResourceData::toByteArr(uint8_t* arr, size_t& arrLength, size_t arrBufSize, IDnsResource*) const
 {
-	if (m_DataLen == 0 || m_Data == nullptr)
-	{
-		PCPP_LOG_ERROR("Input data is null or illegal");
+	if (arrBufSize < m_DataLen) {
+		PCPP_LOG_ERROR("GenericDnsResourceData: arrBufSize too small for m_DataLen");
 		return false;
 	}
-
 	arrLength = m_DataLen;
 	memcpy(arr, m_Data, m_DataLen);
 	return true;
