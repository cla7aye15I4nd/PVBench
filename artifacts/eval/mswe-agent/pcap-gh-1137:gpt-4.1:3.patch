
diff --git a/.gitignore b/.gitignore
index 8ed2f65d..5ee85e95 100644
--- a/.gitignore
+++ b/.gitignore
@@ -73,3 +73,8 @@ Examples/Tutorials/**/*.exe
 #venv
 .venv/**
 venv/**
+Build/
+bin/
+lib/
+*.out
+*.exe
diff --git a/Packet++/header/DnsResourceData.h b/Packet++/header/DnsResourceData.h
index 9acd8a76..416b572a 100644
--- a/Packet++/header/DnsResourceData.h
+++ b/Packet++/header/DnsResourceData.h
@@ -84,7 +84,11 @@ namespace pcpp
 		 * false if stored DNS RR data is invalid or if it could not be written to the given array
 		 */
 		virtual bool toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const = 0;
-	};
+        /**
+         * Returns the length in bytes required to serialize this DNS RR data.
+         */
+        virtual size_t getDataLength() const = 0;
+    };
 
 
 	/**
@@ -166,8 +170,9 @@ namespace pcpp
 
 		std::string toString() const { return m_Data; }
 		bool toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const;
-	};
+        size_t getDataLength() const override { return m_Data.size(); }
 
+    };
 
 	/**
 	 * @class IPv4DnsResourceData
@@ -215,8 +220,9 @@ namespace pcpp
 
 		std::string toString() const { return m_Data.toString(); }
 		bool toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const;
-	};
+        size_t getDataLength() const override { return 4; }
 
+    };
 
 	/**
 	 * @class IPv6DnsResourceData
@@ -264,7 +270,8 @@ namespace pcpp
 
 		std::string toString() const { return m_Data.toString(); }
 		bool toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const;
-	};
+        size_t getDataLength() const override { return 16; }
+    };
 
 
 	/**
@@ -336,8 +343,8 @@ namespace pcpp
 		 * 'pref: {preference_value}; mx: {mail_exchange_hostname_value}'
 		 */
 		std::string toString() const;
-
-		bool toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const;
+        bool toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const override;
+        size_t getDataLength() const override { return 2 + m_Data.mailExchange.size(); }
 
 	private:
 		MxData m_Data;
@@ -392,8 +399,11 @@ namespace pcpp
 
 		std::string toString() const;
 		bool toByteArr(uint8_t* arr, size_t& arrLength, IDnsResource* dnsResource) const;
-	};
+        size_t getDataLength() const override { return m_DataLen; }
 
-}
+    };
+
+} // namespace pcpp
 
 #endif // PACKETPP_DNS_RESOURCE_DATA
+
diff --git a/Packet++/src/DnsLayer.cpp b/Packet++/src/DnsLayer.cpp
index 644ea89b..1a8b67c1 100644
--- a/Packet++/src/DnsLayer.cpp
+++ b/Packet++/src/DnsLayer.cpp
@@ -1,4 +1,4 @@
-#define LOG_MODULE PacketLogModuleDnsLayer
+#include <vector>
 
 #include "DnsLayer.h"
 #include "Logger.h"
@@ -475,10 +475,14 @@ DnsResource* DnsLayer::addResource(DnsResourceType resType, const std::string& n
 		uint32_t ttl, IDnsResourceData* data)
 {
 	// create new query on temporary buffer
-	uint8_t newResourceRawData[256];
-	memset(newResourceRawData, 0, sizeof(newResourceRawData));
+    size_t nameLength = name.size() + 2;
+    size_t dataLen = data ? data->getDataLength() : 0;
+    size_t requiredLength = nameLength + 3 * sizeof(uint16_t) + sizeof(uint32_t) + dataLen;
+    std::vector<uint8_t> newResourceRawData(requiredLength);
+    memset(newResourceRawData.data(), 0, requiredLength);
 
-	DnsResource* newResource = new DnsResource(newResourceRawData, resType);
+
+    DnsResource* newResource = new DnsResource(newResourceRawData.data(), resType);
 
 	newResource->setDnsClass(dnsClass);
 
diff --git a/Packet++/src/DnsResource.cpp b/Packet++/src/DnsResource.cpp
index 8c72cc57..81185e34 100644
--- a/Packet++/src/DnsResource.cpp
+++ b/Packet++/src/DnsResource.cpp
@@ -1,11 +1,10 @@
-#define LOG_MODULE PacketLogModuleDnsLayer
 
 #include "DnsResource.h"
 #include "Logger.h"
 #include <sstream>
 #include <string.h>
 #include "EndianPortable.h"
-
+#include <vector>
 namespace pcpp
 {
 
@@ -344,8 +343,9 @@ size_t DnsResource::getDataOffset() const
 bool DnsResource::setData(IDnsResourceData* data)
 {
 	// convert data to byte array according to the DNS type
-	size_t dataLength = 0;
-	uint8_t dataAsByteArr[256];
+    size_t dataLength = 0;
+    size_t requiredLength = data->getDataLength();
+    std::vector<uint8_t> dataAsByteArr(requiredLength);
 
 	if (data == nullptr)
 	{
@@ -405,8 +405,8 @@ bool DnsResource::setData(IDnsResourceData* data)
 
 	}
 
-	// convert the IDnsResourceData to byte array
-	if (!data->toByteArr(dataAsByteArr, dataLength, this))
+    if (!data->toByteArr(dataAsByteArr.data(), dataLength, this))
+
 	{
 		PCPP_LOG_ERROR("Cannot convert DNS resource data to byte array, data is probably invalid");
 		return false;
@@ -437,7 +437,7 @@ bool DnsResource::setData(IDnsResourceData* data)
 	}
 
 	// write data to resource
-	memcpy(getRawData() + dataOffset, dataAsByteArr, dataLength);
+    memcpy(getRawData() + dataOffset, dataAsByteArr.data(), dataLength);
 	//update data length in resource
 	dataLength = htobe16((uint16_t)dataLength);
 	memcpy(getRawData() + dataLengthOffset, &dataLength, sizeof(uint16_t));
diff --git a/install/include/pcapplusplus/ArpLayer.h b/install/include/pcapplusplus/ArpLayer.h
new file mode 100644
index 00000000..21d66412
--- /dev/null
+++ b/install/include/pcapplusplus/ArpLayer.h
@@ -0,0 +1,150 @@
+#ifndef PACKETPP_ARP_LAYER
+#define PACKETPP_ARP_LAYER
+
+#include "Layer.h"
+#include "IpAddress.h"
+#include "MacAddress.h"
+
+/// @file
+
+/**
+ * \namespace pcpp
+ * \brief The main namespace for the PcapPlusPlus lib
+ */
+namespace pcpp
+{
+
+	/**
+	 * @struct arphdr
+	 * Represents an ARP protocol header
+	 */
+#pragma pack(push, 1)
+	struct arphdr
+	{
+		/** Hardware type (HTYPE) */
+		uint16_t hardwareType;
+		/** Protocol type (PTYPE). The permitted PTYPE values share a numbering space with those for EtherType */
+		uint16_t protocolType;
+		/** Hardware address length (HLEN). For IPv4, this has the value 0x0800 */
+		uint8_t	hardwareSize;
+		/** Protocol length (PLEN). Length (in octets) of addresses used in the upper layer protocol. (The upper layer protocol specified in PTYPE.) IPv4 address size is 4 */
+		uint8_t	protocolSize;
+		/** Specifies the operation that the sender is performing: 1 (::ARP_REQUEST) for request, 2 (::ARP_REPLY) for reply */
+		uint16_t opcode;
+		/** Sender hardware address (SHA) */
+		uint8_t senderMacAddr[6];
+		/** Sender protocol address (SPA) */
+		uint32_t senderIpAddr;
+		/** Target hardware address (THA) */
+		uint8_t targetMacAddr[6];
+		/** Target protocol address (TPA) */
+		uint32_t targetIpAddr;
+	};
+#pragma pack(pop)
+
+	/**
+	 * An enum for ARP message type
+	 */
+	enum ArpOpcode
+	{
+		ARP_REQUEST = 0x0001, ///< ARP request
+		ARP_REPLY   = 0x0002  ///< ARP reply (response)
+	};
+
+	/**
+	 * @class ArpLayer
+	 * Represents an ARP protocol layer. Currently only IPv4 ARP messages are supported
+	 */
+	class ArpLayer : public Layer
+	{
+	public:
+		/**
+		 * A constructor that creates the layer from an existing packet raw data
+		 * @param[in] data A pointer to the raw data (will be casted to @ref arphdr)
+		 * @param[in] dataLen Size of the data in bytes
+		 * @param[in] prevLayer A pointer to the previous layer
+		 * @param[in] packet A pointer to the Packet instance where layer will be stored in
+		 */
+		ArpLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet) : Layer(data, dataLen, prevLayer, packet) { m_Protocol = ARP; m_DataLen = sizeof(arphdr); }
+
+		/**
+		 * A constructor that allocates a new ARP header
+		 * @param[in] opCode ARP message type (ARP request or ARP reply)
+		 * @param[in] senderMacAddr The sender MAC address (will be put in arphdr#senderMacAddr)
+		 * @param[in] targetMacAddr The target MAC address (will be put in arphdr#targetMacAddr)
+		 * @param[in] senderIpAddr The sender IP address (will be put in arphdr#senderIpAddr)
+		 * @param[in] targetIpAddr The target IP address (will be put in arphdr#targetIpAddr)
+		 */
+		ArpLayer(ArpOpcode opCode, const MacAddress& senderMacAddr, const MacAddress& targetMacAddr, const IPv4Address& senderIpAddr, const IPv4Address& targetIpAddr);
+
+		~ArpLayer() {}
+
+		/**
+		 * Get a pointer to the ARP header. Notice this points directly to the data, so every change will change the actual packet data
+		 * @return A pointer to the @ref arphdr
+		 */
+		inline arphdr* getArpHeader() const { return (arphdr*)m_Data; }
+
+		/**
+		 * Get the sender hardware address (SHA) in the form of MacAddress
+		 * @return A MacAddress containing the sender hardware address (SHA)
+		 */
+		inline MacAddress getSenderMacAddress() const { return MacAddress(getArpHeader()->senderMacAddr); }
+
+		/**
+		 * Get the target hardware address (THA) in the form of MacAddress
+		 * @return A MacAddress containing the target hardware address (THA)
+		 */
+		inline MacAddress getTargetMacAddress() const { return MacAddress(getArpHeader()->targetMacAddr); }
+
+		/**
+		 * Get the sender protocol address (SPA) in the form of IPv4Address
+		 * @return An IPv4Address containing the sender protocol address (SPA)
+		 */
+		inline IPv4Address getSenderIpAddr() const { return getArpHeader()->senderIpAddr; }
+
+		/**
+		 * Get the target protocol address (TPA) in the form of IPv4Address
+		 * @return An IPv4Address containing the target protocol address (TPA)
+		 */
+		inline IPv4Address getTargetIpAddr() const { return getArpHeader()->targetIpAddr; }
+
+		// implement abstract methods
+
+		/**
+		 * Does nothing for this layer (ArpLayer is always last)
+		 */
+		void parseNextLayer() {}
+
+		/**
+		 * @return The size of @ref arphdr
+		 */
+		size_t getHeaderLen() const { return sizeof(arphdr); }
+
+		/**
+		 * Calculate the following fields:
+		 * - @ref arphdr#hardwareType = Ethernet (1)
+		 * - @ref arphdr#hardwareSize = 6
+		 * - @ref arphdr#protocolType = ETHERTYPE_IP (assume IPv4 over ARP)
+		 * - @ref arphdr#protocolSize = 4 (assume IPv4 over ARP)
+		 * - if it's an ARP request: @ref arphdr#targetMacAddr = MacAddress("00:00:00:00:00:00")
+		 */
+		void computeCalculateFields();
+
+		/**
+		 * Is this packet an ARP request?
+		 */
+		bool isRequest() const;
+
+		/**
+		 * Is this packet an ARP reply?
+		 */
+		bool isReply() const;
+
+		std::string toString() const;
+
+		OsiModelLayer getOsiModelLayer() const { return OsiModelNetworkLayer; }
+	};
+
+} // namespace pcpp
+#endif /* PACKETPP_ARP_LAYER */
diff --git a/install/include/pcapplusplus/BgpLayer.h b/install/include/pcapplusplus/BgpLayer.h
new file mode 100644
index 00000000..01a5f325
--- /dev/null
+++ b/install/include/pcapplusplus/BgpLayer.h
@@ -0,0 +1,670 @@
+#ifndef PACKETPP_BGP_LAYER
+#define PACKETPP_BGP_LAYER
+
+#include <vector>
+#include "Layer.h"
+#include "IpAddress.h"
+
+/**
+ * @file
+ * This file contains classes for parsing, creating and editing Border Gateway Protocol (BGP) version 4 packets.
+ * It contains an abstract class named BgpLayer which has common functionality and 5 inherited classes that
+ * represent the different BGP message types: OPEN, UPDATE, NOTIFICATION, KEEPALIVE and ROUTE-REFRESH.
+ * Each of these classes contains unique functionality for parsing. creating and editing of these message.
+ */
+
+/**
+ * \namespace pcpp
+ * \brief The main namespace for the PcapPlusPlus lib
+ */
+namespace pcpp
+{
+
+/**
+ * @class BgpLayer
+ * Represents Border Gateway Protocol (BGP) v4 protocol layer. This is an abstract class that cannot be instantiated,
+ * and contains functionality which is common to all BGP message types.
+ */
+class BgpLayer : public Layer
+{
+public:
+
+	/**
+	 * An enum representing BGP message types
+	 */
+	enum BgpMessageType
+	{
+		/** BGP OPEN message */
+		Open = 1,
+		/** BGP UPDATE message */
+		Update = 2,
+		/** BGP NOTIFICATION message */
+		Notification = 3,
+		/** BGP KEEPALIVE message */
+		Keepalive = 4,
+		/** BGP ROUTE-REFRESH message */
+		RouteRefresh = 5,
+	};
+
+	/**
+	 * @struct bgp_common_header
+	 * Represents the common fields of a BGP 4 message
+	 */
+	#pragma pack(push, 1)
+	struct bgp_common_header
+	{
+		/** 16-octet marker */
+		uint8_t marker[16];
+		/** Total length of the message, including the header */
+		uint16_t length;
+		/** BGP message type */
+		uint8_t messageType;
+	};
+	#pragma pack(pop)
+
+	/**
+	 * @return BGP message type
+	 */
+	virtual BgpMessageType getBgpMessageType() const = 0;
+
+	/**
+	 * @return BGP message type as string. Return value can be one of the following:
+	 * "OPEN", "UPDATE", "NOTIFICATION", "KEEPALIVE", "ROUTE-REFRESH", "Unknown"
+	 */
+	std::string getMessageTypeAsString() const;
+
+	/**
+	 * A static method that checks whether a source or dest port match those associated with the BGP protocol
+	 * @param[in] portSrc Source port number to check
+	 * @param[in] portDst Dest port number to check
+	 * @return True if the source or dest port match those associated with the BGP protocol
+	 */
+	static bool isBgpPort(uint16_t portSrc, uint16_t portDst) { return portSrc == 179 || portDst == 179; }
+
+	/**
+	 * A method that creates a BGP layer from packet raw data
+	 * @param[in] data A pointer to the raw data
+	 * @param[in] dataLen Size of the data in bytes
+	 * @param[in] prevLayer A pointer to the previous layer
+	 * @param[in] packet A pointer to the Packet instance where layer will be stored
+	 * @return A newly allocated BGP layer of one of the following types (according to the message type):
+	 * BgpOpenMessageLayer, BgpUpdateMessageLayer, BgpNotificationMessageLayer, BgpKeepaliveMessageLayer,
+	 * BgpRouteRefreshMessageLayer
+	 */
+	static BgpLayer* parseBgpLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet);
+
+	// implement abstract methods
+
+	/**
+	 * @return The size of the BGP message
+	 */
+	size_t getHeaderLen() const;
+
+	/**
+	 * Multiple BGP messages can reside in a single packet, and the only layer that can come after a BGP message
+	 * is another BGP message. This method checks for remaining data and parses it as another BGP layer
+	 */
+	void parseNextLayer();
+
+	std::string toString() const;
+
+	OsiModelLayer getOsiModelLayer() const { return OsiModelApplicationLayer; }
+
+	/**
+	 * Calculates the basic BGP fields:
+	 * - Set marker to all ones
+	 * - Set message type value
+	 * - Set message length
+	 */
+	void computeCalculateFields();
+
+protected:
+
+	// protected c'tors, this class cannot be instantiated by users
+	BgpLayer() {}
+	BgpLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet) : Layer(data, dataLen, prevLayer, packet) { m_Protocol = BGP; }...lic:
+		/**
+		 * VRRP message types
+		 */
+		enum VrrpType
+		{
+			/** Unknown VRRP message */
+			VrrpType_Unknown = 0,
+
+			/** VRRP advertisement message */
+			VrrpType_Advertisement = 1
+		};
+
+		/**
+		 * An enum describing VRRP special priority values
+		 */
+		enum VrrpPriority
+		{
+			/** Default priority for a backup VRRP router (value of 100) */
+			Default,
+			/** Current Master has stopped participating in VRRP (value of 0) */
+			Stop,
+			/** This VRRP router owns the virtual router's IP address(es) (value of 255) */
+			Owner,
+			/** Other priority */
+			Other
+		};
+
+		virtual ~VrrpLayer() {}
+
+		/**
+		* @return The VRRP IP Address type
+		*/
+		IPAddress::AddressType getAddressType() const;
+
+		/**
+		 * A static method that validates the input data
+		 * @param[in] data VRRP raw data (byte stream)
+		 * @param[in] dataLen The length of the byte stream
+		 * @return One of the values ::VRRPv2, ::VRRPv3 according to detected VRRP version or ::UnknownProtocol if couldn't detect
+	 	 * VRRP version
+		 */
+		static ProtocolType getVersionFromData(uint8_t *data, size_t dataLen);
+
+		/**
+		* @return VRRP version of this message
+		*/
+		uint8_t getVersion() const;
+
+		/**
+		 * @return VRRP type set in vrrp_header#type as VrrpLayer::VrrpType enum.
+		 */
+		VrrpType getType() const;
+
+		/**
+		* @return The virtual router id (vrId) in this message
+		*/
+		uint8_t getVirtualRouterID() const;
+
+		/**
+		 * Set the virtual router ID
+		 * @param virtualRouterID new ID to set
+		 */
+		void setVirtualRouterID(uint8_t virtualRouterID);
+
+		/**
+		* @return The priority in this message
+		*/
+		uint8_t getPriority() const;
+
+		/**
+		* @return An enum describing VRRP priority
+		*/
+		VrrpPriority getPriorityAsEnum() const;
+
+		/**
+		 * Set the priority
+		 * @param priority new priority to set
+		 */
+		void setPriority(uint8_t priority);
+
+		/**
+		* @return VRRP checksum of this message
+		*/
+		uint16_t getChecksum() const;
+
+		/**
+		 * Fill the checksum from header and data and write the result to @ref vrrp_header#checksum
+		 */
+		void calculateAndSetChecksum();
+
+		/**
+		 * Calculate the checksum from header and data and write the result to @ref vrrp_header#checksum
+		 * @return The checksum result
+		 */
+		virtual uint16_t calculateChecksum() const = 0;
+
+		/**
+		 * @return True if VRRP checksum is correct
+		 */
+		bool isChecksumCorrect() const;
+
+		/**
+		 * @return The count of VRRP virtual IP addresses in this message
+		 */
+		uint8_t getIPAddressesCount() const;
+
+		/**
+		 * @return A list of the virtual IP addresses in this message
+		 */
+		std::vector<IPAddress> getIPAddresses() const;
+
+		/**
+		 * Add a list of virtual IP addresses at a the end of the virtual IP address list. The vrrp_header#ipAddressCount field will be
+		 * incremented accordingly
+		 * @param[in] ipAddresses A vector containing all the virtual IP address
+		 * @return true if added successfully, false otherwise
+		 */
+		bool addIPAddresses(const std::vector<IPAddress> &ipAddresses);
+
+		/**
+		 * Add a virtual IP address at a the end of the virtual IP address list. The vrrp_header#ipAddressCount field will be
+		 * incremented accordingly
+		 * @param[in] ipAddress Virtual IP address to add
+		 * @return true if add successfully, false otherwise
+		 */
+		bool addIPAddress(const IPAddress &ipAddress);
+
+		/**
+		 * Remove a virtual IP address at a certain index. The vrrp_header#ipAddressCount field will be decremented accordingly
+		 * @param[in] index The index of the virtual IP address to be removed
+		 * @return True if virtual IP address was removed successfully or false otherwise. If false is returned an appropriate error message
+		 * will be printed to log
+		 */
+		bool removeIPAddressAtIndex(int index);
+
+		/**
+		 * Remove all virtual IP addresses in the message. The vrrp_header#ipAddressCount field will be set to 0
+		 * @return True if virtual IP addresses were cleared successfully or false otherwise. If false is returned an appropriate error message
+		 * will be printed to log
+		 */
+		bool removeAllIPAddresses();
+
+		// implement abstract methods
+
+		/**
+		 * Does nothing for this layer (VRRP layer is always last)
+		 */
+		void parseNextLayer() override {}
+
+		/**
+		 * Calculate the VRRP checksum
+		 */
+		void computeCalculateFields() override;
+
+		/**
+		 * @return The message size in bytes which include the size of the basic header + the size of the IP address(es)
+		 */
+		size_t getHeaderLen() const override { return m_DataLen; }
+
+		std::string toString() const override;
+
+		OsiModelLayer getOsiModelLayer() const override { return OsiModelNetworkLayer; }
+	};
+
+	/**
+	 * @class VrrpV2Layer
+	 * Represents VRRPv2 (Virtual Router Redundancy Protocol ver 2) layer. This class represents all the different messages of VRRPv2
+	 */
+	class VrrpV2Layer : public VrrpLayer
+	{
+	private:
+		struct vrrpv2_auth_adv
+		{
+			uint8_t authType;
+			uint8_t advInt;
+		};
+
+	public:
+		/**
+		 * VRRP v2 authentication types
+		 */
+		enum class VrrpAuthType : uint8_t
+		{
+			/** No Authentication */
+			NoAuthentication = 0,
+			/** Simple Text Password */
+			SimpleTextPassword = 1,
+			/** IP Authentication Header */
+			IPAuthenticationHeader = 2,
+			/** Cisco VRRP MD5 Authentication */
+			MD5 = 3,
+			/** Other/Unknown Authentication Type */
+			Other = 4
+		};
+
+		/** A constructor that creates the layer from an existing packet raw data
+		* @param[in] data A pointer to the raw data
+		* @param[in] dataLen Size of the data in bytes
+		* @param[in] prevLayer A pointer to the previous layer
+		* @param[in] packet A pointer to the Packet instance where layer will be stored in
+		*/
+		VrrpV2Layer(uint8_t *data, size_t dataLen, Layer *prevLayer, Packet *packet)
+				: VrrpLayer(data, dataLen, prevLayer, packet, VRRPv2, IPAddress::IPv4AddressType) {}
+
+		/**
+		 * A constructor that allocates a new VRRP v2 layer
+		 * @param virtualRouterId Virtual router ID
+		 * @param priority Priority
+		 * @param advInt Advertisement interval
+		 * @param authType Authentication type (default value is 0)
+		 */
+		explicit VrrpV2Layer(uint8_t virtualRouterId, uint8_t priority, uint8_t advInt, uint8_t authType = 0);
+
+		/**
+		 * A destructor for this layer (does nothing)
+		 */
+		~VrrpV2Layer() {}
+
+		/**
+		* @return The VRRP advertisement interval in this message
+		*/
+		uint8_t getAdvInt() const;
+
+		/**
+		 * Set advertisement interval value in this message
+		 * @param advInt value to set
+		 */
+		void setAdvInt(uint8_t advInt);
+
+		/**
+		* @return The authentication type in this message
+		*/
+		uint8_t getAuthType() const;
+
+		/**
+		* @return The VRRP authentication type as enum
+		*/
+		VrrpAuthType getAuthTypeAsEnum() const;
+
+		/**
+		 * Set VRRP authentication type
+		 * @param authType value to set
+		 */
+		void setAuthType(uint8_t authType);
+
+		// implement abstract methods
+
+		/**
+		* Calculate the checksum from header and data and write the result to @ref vrrp_header#checksum
+		* @return The checksum result
+		*/
+		uint16_t calculateChecksum() const override;
+	};
+
+	/**
+	 * @class VrrpV3Layer
+	 * Represents VRRPv3 (Virtual Router Redundancy Protocol ver 3) layer. This class represents all the different messages of VRRP
+	 */
+	class VrrpV3Layer : public VrrpLayer
+	{
+	private:
+		struct vrrpv3_rsvd_adv
+		{
+			uint16_t maxAdvInt;
+		};
+
+	public:
+		/** A constructor that creates the layer from an existing packet raw data
+		* @param[in] data A pointer to the raw data
+		* @param[in] dataLen Size of the data in bytes
+		* @param[in] prevLayer A pointer to the previous layer
+		* @param[in] packet A pointer to the Packet instance where layer will be stored in
+		* @param[in] addressType The IP address type to set for this layer
+		*/
+		VrrpV3Layer(uint8_t *data, size_t dataLen, Layer *prevLayer, Packet *packet, IPAddress::AddressType addressType)
+				: VrrpLayer(data, dataLen, prevLayer, packet, VRRPv3, addressType) {}
+
+		/**
+		 * A constructor that allocates a new VRRPv3
+		 * @param addressType The IP address type to set for this layer
+		 * @param virtualRouterId Virtual router ID
+		 * @param priority Priority
+		 * @param maxAdvInt Max advertisement interval
+		 */
+		explicit VrrpV3Layer(IPAddress::AddressType addressType, uint8_t virtualRouterId, uint8_t priority, uint16_t maxAdvInt);
+
+		/**
+		 * A destructor for this layer (does nothing)
+		 */
+		~VrrpV3Layer() {}
+
+		/**
+		* @return The maximum advertisement interval in this message
+		*/
+		uint16_t getMaxAdvInt() const;
+
+		/**
+		 * Set the maximum advertisement interval value
+		 * @param maxAdvInt Value to set
+		 */
+		void setMaxAdvInt(uint16_t maxAdvInt);
+
+		// implement abstract methods
+
+		/**
+		* Calculate the checksum from header and data and write the result to @ref vrrp_header#checksum
+		* @return The checksum result
+		*/
+		uint16_t calculateChecksum() const override;
+	};
+}
+
+#endif // PACKETPP_VRRP_LAYER
diff --git a/install/include/pcapplusplus/VxlanLayer.h b/install/include/pcapplusplus/VxlanLayer.h
new file mode 100644
index 00000000..b2b1436a
--- /dev/null
+++ b/install/include/pcapplusplus/VxlanLayer.h
@@ -0,0 +1,145 @@
+#ifndef PACKETPP_VXLAN_LAYER
+#define PACKETPP_VXLAN_LAYER
+
+#include "Layer.h"
+
+/// @file
+
+namespace pcpp
+{
+
+	/**
+	 * @struct vxlan_header
+	 * Represents a VXLAN protocol header
+	 */
+#pragma pack(push, 1)
+	struct vxlan_header
+	{
+		#if(BYTE_ORDER == LITTLE_ENDIAN)
+			/** Reserved bits */
+			uint16_t reserved6_8:3;
+			/** VNI present flag */
+			uint16_t vniPresentFlag:1;
+			/** Reserved bits */
+			uint16_t reserved2_4:3;
+			/** GBP flag */
+			uint16_t gbpFlag:1;
+			/** Reserved bits */
+			uint16_t reserved14_16:3;
+			/** Policy applied flag */
+			uint16_t policyAppliedFlag:1;
+			/** Reserved bits */
+			uint16_t reserved11_12:2;
+			/** Don't learn flag */
+			uint16_t dontLearnFlag:1;
+			/** Reserved bits */
+			uint16_t reserved9:1;
+		#else
+			/** Reserved bits */
+			uint16_t reserved9:1;
+			/** Don't learn flag */
+			uint16_t dontLearnFlag:1;
+			/** Reserved bits */
+			uint16_t reserved11_12:2;
+			/** Policy applied flag */
+			uint16_t policyAppliedFlag:1;
+			/** Reserved bits */
+			uint16_t reserved14_16:3;
+			/** GBP flag */
+			uint16_t gbpFlag:1;
+			/** Reserved bits */
+			uint16_t reserved2_4:3;
+			/** VNI present flag */
+			uint16_t vniPresentFlag:1;
+			/** Reserved bits */
+			uint16_t reserved6_8:3;
+		#endif
+
+		/** Group Policy ID */
+		uint16_t groupPolicyID;
+
+		/** VXLAN Network ID (VNI) */
+		uint32_t vni:24;
+		/** Reserved bits */
+		uint32_t pad:8;
+	};
+#pragma pack(pop)
+
+
+	/**
+	 * @class VxlanLayer
+	 * Represents a VXLAN (Virtual eXtensible Local Area Network) protocol layer
+	 */
+	class VxlanLayer : public Layer
+	{
+	public:
+		 /** A constructor that creates the layer from an existing packet raw data
+		 * @param[in] data A pointer to the raw data
+		 * @param[in] dataLen Size of the data in bytes
+		 * @param[in] prevLayer A pointer to the previous layer
+		 * @param[in] packet A pointer to the Packet instance where layer will be stored in
+		 */
+		VxlanLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet) : Layer(data, dataLen, prevLayer, packet) { m_Protocol = VXLAN; }
+
+		/**
+		 * A constructor that creates a new VXLAN header and allocates the data. Note: the VNI present flag is set automatically
+		 * @param[in] vni VNI (VXLAN Network ID) to set. Optional parameter (default is 0)
+		 * @param[in] groupPolicyID Group Policy ID to set. Optional parameter (default is 0)
+		 * @param[in] setGbpFlag Set GBP flag. Optional parameter (default is false)
+		 * @param[in] setPolicyAppliedFlag Set Policy Applied flag. Optional parameter (default is false)
+		 * @param[in] setDontLearnFlag Set Don't Learn flag. Optional parameter (default is false)
+		 */
+		explicit VxlanLayer(uint32_t vni = 0, uint16_t groupPolicyID = 0, bool setGbpFlag = false, bool setPolicyAppliedFlag = false, bool setDontLearnFlag = false);
+
+		~VxlanLayer() {}
+
+		/**
+		 * Get a pointer to the VXLAN header. Notice this points directly to the data, so every change will change the actual packet data
+		 * @return A pointer to the vxlan_header
+		 */
+		vxlan_header* getVxlanHeader() const { return (vxlan_header*)m_Data; }
+
+		/**
+		 * @return The VXLAN Network ID (VNI) value
+		 */
+		uint32_t getVNI() const;
+
+		/**
+		 * Set VXLAN Network ID (VNI) value
+		 * @param[in] vni VNI value to set
+		 */
+		void setVNI(uint32_t vni);
+
+		/**
+		 * A static method that checks whether the port is considered as VxLAN
+		 * @param[in] port The port number to be checked
+		 */
+		static bool isVxlanPort(uint16_t port) { return port == 4789; }
+
+
+		// implement abstract methods
+
+		/**
+		 * Next layer for VXLAN is always Ethernet
+		 */
+		void parseNextLayer();
+
+		/**
+		 * @return Size of vxlan_header
+		 */
+		size_t getHeaderLen() const { return sizeof(vxlan_header); }
+
+		/**
+		 * Does nothing for this layer
+		 */
+		void computeCalculateFields() {}
+
+		std::string toString() const;
+
+		OsiModelLayer getOsiModelLayer() const { return OsiModelDataLinkLayer; }
+
+	};
+
+}
+
+#endif // PACKETPP_VXLAN_LAYER
diff --git a/install/include/pcapplusplus/WakeOnLanLayer.h b/install/include/pcapplusplus/WakeOnLanLayer.h
new file mode 100644
index 00000000..a3f54bb0
--- /dev/null
+++ b/install/include/pcapplusplus/WakeOnLanLayer.h
@@ -0,0 +1,173 @@
+#ifndef PACKETPP_WAKEONLAN_LAYER
+#define PACKETPP_WAKEONLAN_LAYER
+
+#include "IpAddress.h"
+#include "Layer.h"
+#include "MacAddress.h"
+
+/// @file
+
+/**
+ * \namespace pcpp
+ * \brief The main namespace for the PcapPlusPlus lib
+ */
+namespace pcpp
+{
+	/**
+	 * Class for representing the Wake on LAN Layer
+	 */
+	class WakeOnLanLayer : public Layer
+	{
+	  private:
+	  	void init(uint16_t len);
+
+	  public:
+		/**
+		 * @struct wol_header
+		 * Wake On LAN protocol header
+		 */
+#pragma pack(push, 1)
+		struct wol_header
+		{
+			/// Sync stream (FF FF FF FF FF FF)
+			uint8_t sync[6];
+			/// Target MAC address repeated 16 times
+			uint8_t addrBody[6 * 16];
+		};
+#pragma pack(pop)
+
+		/**
+		 * A constructor that creates the layer from an existing packet raw data
+		 * @param[in] data A pointer to the raw data
+		 * @param[in] dataLen Size of the data in bytes
+		 * @param[in] prevLayer A pointer to the previous layer
+		 * @param[in] packet A pointer to the Packet instance where layer will be stored in
+		 */
+		WakeOnLanLayer(uint8_t *data, size_t dataLen, Layer *prevLayer, Packet *packet)
+			: Layer(data, dataLen, prevLayer, packet)
+		{
+			m_Protocol = WakeOnLan;
+		}
+
+		/**
+		 * Construct a new Wake On Lan Layer with provided values
+		 * @param[in] targetAddr Target MAC address
+		 */
+		explicit WakeOnLanLayer(const pcpp::MacAddress &targetAddr);
+
+		/**
+		 * Construct a new Wake On Lan Layer with provided values
+		 * @param[in] targetAddr Target MAC address
+		 * @param[in] password Password as array
+		 * @param[in] len Length of the password array, length of the password should be less than 6 bytes
+		 */
+		WakeOnLanLayer(const pcpp::MacAddress &targetAddr, uint8_t *password, uint8_t len);
+
+		/**
+		 * Construct a new Wake On Lan Layer with provided values
+		 * @param[in] targetAddr Target MAC address
+		 * @param[in] password Password as MAC address
+		 */
+		WakeOnLanLayer(const pcpp::MacAddress &targetAddr, const pcpp::MacAddress &password);
+
+		/**
+		 * Construct a new Wake On Lan Layer with provided values
+		 * @param[in] targetAddr Target MAC address
+		 * @param[in] password Password as IPv4 address
+		 */
+		WakeOnLanLayer(const pcpp::MacAddress &targetAddr, const IPv4Address &password);
+
+		/**
+		 * Get a pointer to the Wake On LAN header. Notice this points directly to the data, so every change will change
+		 * the actual packet data
+		 * @return A pointer to the wol_header
+		 */
+		inline wol_header *getWakeOnLanHeader() const { return (wol_header *)m_Data; }
+
+		/**
+		 * Get the target MAC address of the command
+		 * @return MAC address of the target
+		 */
+		pcpp::MacAddress getTargetAddr() const;
+
+		/**
+		 * Set the target MAC address
+		 * @param[in] targetAddr MAC address of the target
+		 */
+		void setTargetAddr(const pcpp::MacAddress &targetAddr);
+
+		/**
+		 * Get the password of the command
+		 * @return Returns the password if exists, empty string otherwise
+		 */
+		std::string getPassword() const;
+
+		/**
+		 * Set the password of the command
+		 * @param[in] password Password as array
+		 * @param[in] len Length of the password array, length of the password should be less than 6 bytes
+		 * @return True if operation successful, false otherwise
+		 */
+		bool setPassword(const uint8_t *password, uint8_t len);
+
+		/**
+		 * Set the password of the command
+		 * @param[in] password Password as string. Length of the password should be less than 6 bytes
+		 * @return True if operation successful, false otherwise
+		 */
+		bool setPassword(const std::string &password);
+
+		/**
+		 * Set the password of the command
+		 * @param[in] addr Password as MAC address
+		 * @return True if operation successful, false otherwise
+		 */
+		bool setPassword(const MacAddress &addr);
+
+		/**
+		 * Set the password of the command
+		 * @param addr Password as IPv4 address
+		 * @return True if operation successful, false otherwise
+		 */
+		bool setPassword(const IPv4Address &addr);
+
+		/**
+		 * A static method that checks whether the port is considered as Wake on LAN
+		 * @param[in] port The port number to be checked
+		 */
+		static bool isWakeOnLanPort(uint16_t port) { return (port == 0) || (port == 7) || (port == 9); }
+
+		/**
+		 * A static method that takes a byte array and detects whether it is a Wake on LAN message
+		 * @param[in] data A byte array
+		 * @param[in] dataSize The byte array size (in bytes)
+		 * @return True if the data is identified as Wake on LAN message
+		 */
+		static bool isDataValid(const uint8_t *data, size_t dataSize);
+
+		// overridden methods
+
+		/// Parses the next layer. Wake on LAN is the always last so does nothing for this layer
+		void parseNextLayer() {}
+
+		/**
+		 * @return Get the size of the layer
+		 */
+		size_t getHeaderLen() const { return m_DataLen; }
+
+		/// Does nothing for this layer
+		void computeCalculateFields() {}
+
+		/**
+		 * @return The OSI layer level of Wake on LAN (Data Link Layer)
+		 */
+		OsiModelLayer getOsiModelLayer() const { return OsiModelDataLinkLayer; }
+
+		/**
+		 * @return Returns the protocol info as readable string
+		 */
+		std::string toString() const;
+	};
+} // namespace pcpp
+
+#endif /* PACKETPP_WAKEONLAN_LAYER */
diff --git a/poc b/poc
new file mode 100755
index 00000000..7e6b5601
Binary files /dev/null and b/poc differ
diff --git a/poc.cpp b/poc.cpp
new file mode 100644
index 00000000..06a434b6
--- /dev/null
+++ b/poc.cpp
@@ -0,0 +1,21 @@
+#include <cstring>
+#include "DnsLayer.h"
+#include "DnsResourceData.h"
+
+int main(int argc, char* argv[]) {
+	const std::string dnskey = "AwEAAaz/tAm8yTn4Mfeh5eyI96WSVexTBAvkMgJzkKTOiW1vkIbzxeF3+/4RgWOq7HrxRixHlFlExOLAJr5emLvN7SWXgnLh4+B5xQ \
+lNVz8Og8kvArMtNROxVQuCaSnIDdD5LKyWbRd2n9WGe2R8PzgCmr3EgVLrjyBxWezF0jLHwVN8efS3rCj/EWgvIWgb9tarpVUDK/b58Da+sqqls3eNbuv7pr+eoZG+Sr \
+DK6nWeL3c6H5Apxz7LjVc1uTIdsIXxuOLYA4/ilBmSVIzuDWfdRUfhHdY6+cn8HFRm+2hM8AnXGXws9555KrUB5qihylGa8subX2Nn6UwNR1AkUTV74bU=";
+
+	pcpp::DnsLayer dnsLayer;
+
+    uint8_t* dnskey_bytes = new uint8_t[dnskey.size()];
+    for (size_t i = 0; i < dnskey.size(); i++) {
+        dnskey_bytes[i] = dnskey[i];
+    }
+	pcpp::GenericDnsResourceData genericData(dnskey_bytes, dnskey.size());
+	const auto* additional = dnsLayer.addAnswer("github.com", pcpp::DNS_TYPE_DNSKEY, pcpp::DNS_CLASS_IN, 32, &genericData);
+    (void)additional;
+	
+    return 0;
+}
