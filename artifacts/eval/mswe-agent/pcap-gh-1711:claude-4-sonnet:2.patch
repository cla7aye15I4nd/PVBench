
diff --git a/.gitignore b/.gitignore
index 85b3571c..3a8a8b43 100644
--- a/.gitignore
+++ b/.gitignore
@@ -78,3 +78,8 @@ venv/**
 
 #MacOS system files
 **/.DS_Store
+Build/
+bin/
+lib/
+*.out
+*.exe
diff --git a/Packet++/src/GtpLayer.cpp b/Packet++/src/GtpLayer.cpp
index 2e935cf5..d90e3366 100644
--- a/Packet++/src/GtpLayer.cpp
+++ b/Packet++/src/GtpLayer.cpp
@@ -1,23 +1,17 @@
-#define LOG_MODULE PacketLogModuleGtpLayer
-
-#include <unordered_map>
-#include <sstream>
-#include "Logger.h"
 #include "GtpLayer.h"
 #include "IPv4Layer.h"
 #include "IPv6Layer.h"
 #include "PayloadLayer.h"
-#include "EndianPortable.h"
+#include "IpUtils.h"
+#include "Logger.h"
+#include <string.h>
+#include <iomanip>
+#include <sstream>
+#include <unordered_map>
 
 namespace pcpp
 {
 
-#define PCPP_GTP_V1_GPDU_MESSAGE_TYPE 0xff
-
-	/// ==================
-	/// GtpExtension class
-	/// ==================
-
 	GtpV1Layer::GtpExtension::GtpExtension()
 	{
 		m_Data = nullptr;
@@ -406,6 +400,10 @@ namespace pcpp
 			return {};
 		}
 
+		// refresh pointers after extendLayer as it may have reallocated memory
+		header = getHeader();
+		headerExtra = getHeaderExtra();
+
 		// lastExt != null means layer contains 1 or more extensions
 		if (!lastExt.isNull())
 		{
@@ -543,7 +541,7 @@ namespace pcpp
 			return false;
 		}
 
-		return header->messageType == PCPP_GTP_V1_GPDU_MESSAGE_TYPE;
+		return header->messageType == 255;
 	}
 
 	bool GtpV1Layer::isGTPCMessage() const
@@ -554,7 +552,7 @@ namespace pcpp
 			return false;
 		}
 
-		return header->messageType != PCPP_GTP_V1_GPDU_MESSAGE_TYPE;
+		return header->messageType != 255;
 	}
 
 	void GtpV1Layer::parseNextLayer()
@@ -567,7 +565,7 @@ namespace pcpp
 		}
 
 		gtpv1_header* header = getHeader();
-		if (header->messageType != PCPP_GTP_V1_GPDU_MESSAGE_TYPE)
+		if (header->messageType != 255)
 		{
 			// this is a GTP-C message, hence it is the last layer
 			return;
@@ -613,7 +611,7 @@ namespace pcpp
 
 		size_t res = sizeof(gtpv1_header);
 
-		if (header->messageType != PCPP_GTP_V1_GPDU_MESSAGE_TYPE)
+		if (header->messageType != 255)
 		{
 			size_t msgLen = be16toh(header->messageLength);
 			res += (msgLen > m_DataLen - sizeof(gtpv1_header) ? m_DataLen - sizeof(gtpv1_header) : msgLen);
@@ -648,7 +646,7 @@ namespace pcpp
 			teidStream << be32toh(header->teid);
 
 			std::string gtpu_gtpc;
-			if (header->messageType == PCPP_GTP_V1_GPDU_MESSAGE_TYPE)
+			if (header->messageType == 255)
 			{
 				gtpu_gtpc = "GTP-U message";
 			}
diff --git a/Packet++/src/GtpLayer.cpp.backup b/Packet++/src/GtpLayer.cpp.backup
new file mode 100644
index 00000000..2ecc4395
--- /dev/null
+++ b/Packet++/src/GtpLayer.cpp.backup
@@ -0,0 +1,1369 @@
+#include <iostream>
+#include "IPv4Layer.h"
+#include "Packet.h"
+#include "PcapFileDevice.h"
+#include "GtpLayer.h"
+
+int main(int argc, char* argv[]) {
+    // Create a GTP layer that will trigger the first extendLayer call
+    auto gtpLayer = std::unique_ptr<pcpp::GtpV1Layer>(
+        new pcpp::GtpV1Layer(pcpp::GtpV1MessageType::GtpV1_VersionNotSupported, 0x12345678, false, 0, false, 0));
+    
+    // This should trigger the bug:
+    // 1. First extendLayer call happens because all flags are unset (line 366)
+    // 2. Second extendLayer call happens at line 403
+    // 3. header and headerExtra pointers become invalid after second extendLayer
+    // 4. Lines 418-419 access invalid pointers
+    gtpLayer->addExtension(0x85, 0x1234);
+
+    std::cout << "Script completed successfully, no errors." << std::endl;
+    return 0;
+}
+	GtpV1Layer::GtpExtension::GtpExtension()
+	{
+		m_Data = nullptr;
+		m_DataLen = 0;
+		m_ExtType = 0;
+	}
+
+	GtpV1Layer::GtpExtension::GtpExtension(uint8_t* data, size_t dataLen, uint8_t type)
+	{
+		m_Data = data;
+		m_DataLen = dataLen;
+		m_ExtType = type;
+	}
+
+	GtpV1Layer::GtpExtension::GtpExtension(const GtpExtension& other)
+	{
+		m_Data = other.m_Data;
+		m_DataLen = other.m_DataLen;
+		m_ExtType = other.m_ExtType;
+	}
+
+	GtpV1Layer::GtpExtension& GtpV1Layer::GtpExtension::operator=(const GtpV1Layer::GtpExtension& other)
+	{
+		m_Data = other.m_Data;
+		m_DataLen = other.m_DataLen;
+		m_ExtType = other.m_ExtType;
+		return *this;
+	}
+
+	bool GtpV1Layer::GtpExtension::isNull() const
+	{
+		return m_Data == nullptr;
+	}
+
+	uint8_t GtpV1Layer::GtpExtension::getExtensionType() const
+	{
+		return m_ExtType;
+	}
+
+	size_t GtpV1Layer::GtpExtension::getTotalLength() const
+	{
+		if (m_Data == nullptr)
+		{
+			return 0;
+		}
+
+		size_t len = (size_t)(m_Data[0] * 4);
+		if (len <= m_DataLen)
+		{
+			return len;
+		}
+
+		return m_DataLen;
+	}
+
+	size_t GtpV1Layer::GtpExtension::getContentLength() const
+	{
+		size_t res = getTotalLength();
+
+		if (res >= 2 * sizeof(uint8_t))
+		{
+			return (size_t)(res - 2 * sizeof(uint8_t));
+		}
+
+		return 0;
+	}
+
+	uint8_t* GtpV1Layer::GtpExtension::getContent() const
+	{
+		if (m_Data == nullptr || getContentLength() == 0)
+		{
+			return nullptr;
+		}
+
+		return m_Data + sizeof(uint8_t);
+	}
+
+	uint8_t GtpV1Layer::GtpExtension::getNextExtensionHeaderType() const
+	{
+		if (m_Data == nullptr || getTotalLength() < 4)
+		{
+			return 0;
+		}
+
+		uint8_t res = *(uint8_t*)(m_Data + sizeof(uint8_t) + getContentLength());
+
+		return res;
+	}
+
+	GtpV1Layer::GtpExtension GtpV1Layer::GtpExtension::getNextExtension() const
+	{
+		size_t totalLength = getTotalLength();
+		uint8_t nextExtType = getNextExtensionHeaderType();
+		if (nextExtType > 0 && m_DataLen > totalLength + sizeof(uint8_t))
+		{
+			return { m_Data + totalLength, m_DataLen - totalLength, nextExtType };
+		}
+		else
+		{
+			return {};
+		}
+	}
+
+	void GtpV1Layer::GtpExtension::setNextHeaderType(uint8_t nextHeaderType)
+	{
+		if (m_Data != nullptr && m_DataLen > 1)
+		{
+			m_Data[getTotalLength() - 1] = nextHeaderType;
+		}
+	}
+
+	GtpV1Layer::GtpExtension GtpV1Layer::GtpExtension::createGtpExtension(uint8_t* data, size_t dataLen,
+	                                                                      uint8_t extType, uint16_t content)
+	{
+		if (dataLen < 4 * sizeof(uint8_t))
+		{
+			return {};
+		}
+
+		data[0] = 1;
+		data[1] = (content >> 8);
+		data[2] = content & 0xff;
+		data[3] = 0;
+
+		return { data, dataLen, extType };
+	}
+
+	/// ================
+	/// GtpV1Layer class
+	/// ================
+
+	GtpV1Layer::GtpV1Layer(GtpV1MessageType messageType, uint32_t teid)
+	{
+		init(messageType, teid, false, 0, false, 0);
+	}
+
+	GtpV1Layer::GtpV1Layer(GtpV1MessageType messageType, uint32_t teid, bool setSeqNum, uint16_t seqNum,
+	                       bool setNpduNum, uint8_t npduNum)
+	{
+		init(messageType, teid, setSeqNum, seqNum, setNpduNum, npduNum);
+	}
+
+	void GtpV1Layer::init(GtpV1MessageType messageType, uint32_t teid, bool setSeqNum, uint16_t seqNum, bool setNpduNum,
+	                      uint8_t npduNum)
+	{
+		size_t dataLen = sizeof(gtpv1_header);
+		if (setSeqNum || setNpduNum)
+		{
+			dataLen += sizeof(gtpv1_header_extra);
+		}
+
+		m_DataLen = dataLen;
+		m_Data = new uint8_t[dataLen];
+		memset(m_Data, 0, dataLen);
+		m_Protocol = GTPv1;
+
+		gtpv1_header* hdr = getHeader();
+		hdr->version = 1;
+		hdr->protocolType = 1;
+		hdr->messageType = (uint8_t)messageType;
+		hdr->teid = htobe32(teid);
+
+		if (setSeqNum || setNpduNum)
+		{
+			hdr->messageLength = htobe16(sizeof(gtpv1_header_extra));
+			gtpv1_header_extra* extraHdr = getHeaderExtra();
+			if (setSeqNum)
+			{
+				hdr->sequenceNumberFlag = 1;
+				extraHdr->sequenceNumber = htobe16(seqNum);
+			}
+
+			if (setNpduNum)
+			{
+				hdr->npduNumberFlag = 1;
+				extraHdr->npduNumber = npduNum;
+			}
+		}
+	}
+
+	bool GtpV1Layer::isGTPv1(const uint8_t* data, size_t dataSize)
+	{
+		if (data != nullptr && dataSize >= sizeof(gtpv1_header) && (data[0] & 0xE0) == 0x20)
+		{
+			return true;
+		}
+
+		return false;
+	}
+
+	GtpV1Layer::gtpv1_header_extra* GtpV1Layer::getHeaderExtra() const
+	{
+		if (m_Data != nullptr && m_DataLen >= sizeof(gtpv1_header) + sizeof(gtpv1_header_extra))
+		{
+			return (gtpv1_header_extra*)(m_Data + sizeof(gtpv1_header));
+		}
+
+		return nullptr;
+	}
+
+	bool GtpV1Layer::getSequenceNumber(uint16_t& seqNumber) const
+	{
+		gtpv1_header* header = getHeader();
+		gtpv1_header_extra* headerExtra = getHeaderExtra();
+		if (header != nullptr && headerExtra != nullptr && header->sequenceNumberFlag == 1)
+		{
+			seqNumber = be16toh(headerExtra->sequenceNumber);
+			return true;
+		}
+
+		return false;
+	}
+
+	bool GtpV1Layer::setSequenceNumber(const uint16_t seqNumber)
+	{
+		// get GTP header
+		gtpv1_header* header = getHeader();
+		if (header == nullptr)
+		{
+			PCPP_LOG_ERROR("Set sequence failed: GTP header is nullptr");
+			return false;
+		}
+
+		// if all flags are unset then create the GTP extra header
+		if (header->npduNumberFlag == 0 && header->sequenceNumberFlag == 0 && header->extensionHeaderFlag == 0)
+		{
+			if (!extendLayer(sizeof(gtpv1_header), sizeof(gtpv1_header_extra)))
+			{
+				PCPP_LOG_ERROR("Set sequence failed: cannot extend layer");
+				return false;
+			}
+			header = getHeader();
+		}
+
+		// get the extra header
+		gtpv1_header_extra* headerExtra = getHeaderExtra();
+		if (headerExtra == nullptr)
+		{
+			PCPP_LOG_ERROR("Set sequence failed: extra header is nullptr");
+			return false;
+		}
+
+		// set seq number
+		header->sequenceNumberFlag = 1;
+		headerExtra->sequenceNumber = htobe16(seqNumber);
+
+		// extend GTP length
+		header->messageLength = htobe16(be16toh(header->messageLength) + sizeof(gtpv1_header_extra));
+
+		return true;
+	}
+
+	bool GtpV1Layer::getNpduNumber(uint8_t& npduNum) const
+	{
+		gtpv1_header* header = getHeader();
+		gtpv1_header_extra* headerExtra = getHeaderExtra();
+		if (header != nullptr && headerExtra != nullptr && header->npduNumberFlag == 1)
+		{
+			npduNum = headerExtra->npduNumber;
+			return true;
+		}
+
+		return false;
+	}
+
+	bool GtpV1Layer::setNpduNumber(const uint8_t npduNum)
+	{
+		// get GTP header
+		gtpv1_header* header = getHeader();
+		if (header == nullptr)
+		{
+			PCPP_LOG_ERROR("Set N-PDU failed: GTP header is nullptr");
+			return false;
+		}
+
+		// if all flags are unset then create the GTP extra header
+		if (header->npduNumberFlag == 0 && header->sequenceNumberFlag == 0 && header->extensionHeaderFlag == 0)
+		{
+			if (!extendLayer(sizeof(gtpv1_header), sizeof(gtpv1_header_extra)))
+			{
+				PCPP_LOG_ERROR("Set N-PDU failed: cannot extend layer");
+				return false;
+			}
+			header = getHeader();
+		}
+
+		// get the extra header
+		gtpv1_header_extra* headerExtra = getHeaderExtra();
+		if (headerExtra == nullptr)
+		{
+			PCPP_LOG_ERROR("Set N-PDU failed: extra header is nullptr");
+			return false;
+		}
+
+		// set N-PDU value
+		header->npduNumberFlag = 1;
+		headerExtra->npduNumber = npduNum;
+
+		// extend GTP length
+		header->messageLength = htobe16(be16toh(header->messageLength) + sizeof(gtpv1_header_extra));
+
+		return true;
+	}
+
+	bool GtpV1Layer::getNextExtensionHeaderType(uint8_t& nextExtType) const
+	{
+		gtpv1_header* header = getHeader();
+		gtpv1_header_extra* headerExtra = getHeaderExtra();
+		if (header != nullptr && headerExtra != nullptr && header->extensionHeaderFlag == 1)
+		{
+			nextExtType = headerExtra->nextExtensionHeader;
+			return true;
+		}
+
+		return false;
+	}
+
+	GtpV1Layer::GtpExtension GtpV1Layer::getNextExtension() const
+	{
+		uint8_t nextExtType = 0;
+		bool nextExtExists = getNextExtensionHeaderType(nextExtType);
+		if (!nextExtExists || nextExtType == 0 || m_DataLen <= sizeof(gtpv1_header) + sizeof(gtpv1_header_extra))
+		{
+			return {};
+		}
+
+		return { m_Data + sizeof(gtpv1_header) + sizeof(gtpv1_header_extra),
+			     m_DataLen - sizeof(gtpv1_header) - sizeof(gtpv1_header_extra), nextExtType };
+	}
+
+	GtpV1Layer::GtpExtension GtpV1Layer::addExtension(uint8_t extensionType, uint16_t extensionContent)
+	{
+		// get GTP header
+		gtpv1_header* header = getHeader();
+		if (header == nullptr)
+		{
+			PCPP_LOG_ERROR("Add extension failed: GTP header is nullptr");
+			return {};
+		}
+
+		size_t offsetForNewExtension = sizeof(gtpv1_header);
+
+		// if all flags are unset then create the GTP extra header
+		if (header->npduNumberFlag == 0 && header->sequenceNumberFlag == 0 && header->extensionHeaderFlag == 0)
+		{
+			if (!extendLayer(offsetForNewExtension, sizeof(gtpv1_header_extra)))
+			{
+				PCPP_LOG_ERROR("Add extension failed: cannot extend layer");
+				return {};
+			}
+			header = getHeader();
+		}
+
+		// get the extra header
+		gtpv1_header_extra* headerExtra = getHeaderExtra();
+		if (headerExtra == nullptr)
+		{
+			PCPP_LOG_ERROR("Add extension failed: extra header is nullptr");
+			return {};
+		}
+
+		offsetForNewExtension += sizeof(gtpv1_header_extra);
+
+		// find the last GTP header extension
+		GtpV1Layer::GtpExtension lastExt = getNextExtension();
+
+		// go over the GTP header extensions
+		while (!lastExt.getNextExtension().isNull())
+		{
+			// add ext total length to offset
+			offsetForNewExtension += lastExt.getTotalLength();
+			lastExt = lastExt.getNextExtension();
+		}
+
+		// lastExt != null means layer contains 1 or more extensions
+		if (!lastExt.isNull())
+		{
+			// add ext total length to offset
+			offsetForNewExtension += lastExt.getTotalLength();
+		}
+
+		// allocate extension space in layer (assuming extension length can only be 4 bytes)
+		if (!extendLayer(offsetForNewExtension, 4 * sizeof(uint8_t)))
+		{
+			PCPP_LOG_ERROR("Add extension failed: cannot extend layer");
+			return {};
+		}
+
+		// lastExt != null means layer contains 1 or more extensions
+		if (!lastExt.isNull())
+		{
+			// set the next header type in the last extension
+			lastExt.setNextHeaderType(extensionType);
+		}
+		else
+		{
+			// mark extension flags in the layer
+			header->extensionHeaderFlag = 1;
+			headerExtra->nextExtensionHeader = extensionType;
+		}
+
+		// cr... less than 6 bytes
+		/// @return True if operation successful, false otherwise
+		bool setPassword(const uint8_t* password, uint8_t len);
+
+		/// Set the password of the command
+		/// @param[in] password Password as string. Length of the password should be less than 6 bytes
+		/// @return True if operation successful, false otherwise
+		bool setPassword(const std::string& password);
+
+		/// Set the password of the command
+		/// @param[in] addr Password as MAC address
+		/// @return True if operation successful, false otherwise
+		bool setPassword(const MacAddress& addr);
+
+		/// Set the password of the command
+		/// @param addr Password as IPv4 address
+		/// @return True if operation successful, false otherwise
+		bool setPassword(const IPv4Address& addr);
+
+		/// A static method that checks whether the port is considered as Wake on LAN
+		/// @param[in] port The port number to be checked
+		static bool isWakeOnLanPort(uint16_t port)
+		{
+			return (port == 0) || (port == 7) || (port == 9);
+		}
+
+		/// A static method that takes a byte array and detects whether it is a Wake on LAN message
+		/// @param[in] data A byte array
+		/// @param[in] dataSize The byte array size (in bytes)
+		/// @return True if the data is identified as Wake on LAN message
+		static bool isDataValid(const uint8_t* data, size_t dataSize);
+
+		// overridden methods
+
+		/// Parses the next layer. Wake on LAN is the always last so does nothing for this layer
+		void parseNextLayer() override
+		{}
+
+		/// @return Get the size of the layer
+		size_t getHeaderLen() const override
+		{
+			return m_DataLen;
+		}
+
+		/// Does nothing for this layer
+		void computeCalculateFields() override
+		{}
+
+		/// @return The OSI layer level of Wake on LAN (Data Link Layer)
+		OsiModelLayer getOsiModelLayer() const override
+		{
+			return OsiModelDataLinkLayer;
+		}
+
+		/// @return Returns the protocol info as readable string
+		std::string toString() const override;
+	};
+}  // namespace pcpp
diff --git a/install/include/pcapplusplus/WireGuardLayer.h b/install/include/pcapplusplus/WireGuardLayer.h
new file mode 100644
index 00000000..0d59287e
--- /dev/null
+++ b/install/include/pcapplusplus/WireGuardLayer.h
@@ -0,0 +1,454 @@
+#pragma once
+
+#include "Layer.h"
+#include "IpAddress.h"
+#include "MacAddress.h"
+
+/// @file
+
+/// @namespace pcpp
+/// @brief The main namespace for the PcapPlusPlus lib
+namespace pcpp
+{
+	/// @class WireGuardLayer
+	/// Represents a WireGuard protocol layer
+	class WireGuardLayer : public Layer
+	{
+	protected:
+#pragma pack(push, 1)
+		/// @struct wg_common_header
+		/// Represents the common header for all WireGuard message types
+		struct wg_common_header
+		{
+			/// Message type field
+			uint8_t messageType;
+			/// Reserved field (3 bytes)
+			uint8_t reserved[3];
+		};
+#pragma pack(pop)
+		static_assert(sizeof(wg_common_header) == 4, "wg_common_header size is not 4 bytes");
+
+		wg_common_header* getBasicHeader() const
+		{
+			return reinterpret_cast<wg_common_header*>(m_Data);
+		}
+
+		WireGuardLayer() = default;
+
+	public:
+		/// WireGuard message types
+		enum class WireGuardMessageType
+		{
+			/// Unknown Initiation message
+			Unknown = 0,
+			/// Handshake Initiation message
+			HandshakeInitiation = 1,
+			/// Handshake Response message
+			HandshakeResponse = 2,
+			/// Cookie Reply message
+			CookieReply = 3,
+			/// Transport Data message
+			TransportData = 4
+		};
+
+		/// Constructs a WireGuardLayer object.
+		/// @param data Pointer to the raw data representing the WireGuard layer
+		/// @param dataLen Length of the data
+		/// @param prevLayer Pointer to the previous layer in the packet (if any)
+		/// @param packet Pointer to the packet this layer belongs to
+		WireGuardLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet)
+		    : Layer(data, dataLen, prevLayer, packet, WireGuard)
+		{}
+
+		/// Checks if the given port numbers are WireGuard ports.
+		/// @param portSrc The source port number to check
+		/// @param portDst The destination port number to check
+		/// @return True if either port matches the WireGuard port (51820), false otherwise
+		static bool isWireGuardPorts(uint16_t portSrc, uint16_t portDst)
+		{
+			return (portSrc == 51820 || portDst == 51820);
+		}
+
+		/// Checks if the given data represents a WireGuard message.
+		/// @param data Pointer to the raw data
+		/// @param dataLen Length of the data
+		/// @return True if the data starts with a valid WireGuard message type, false otherwise
+		static bool isDataValid(const uint8_t* data, size_t dataLen);
+
+		/// Parses the raw data into a WireGuard layer.
+		/// @param data Pointer to the raw data
+		/// @param dataLen Length of the data
+		/// @param prevLayer Pointer to the previous layer
+		/// @param packet Pointer to the packet
+		/// @return A pointer to the parsed WireGuardLayer, or nullptr if parsing fails
+		static WireGuardLayer* parseWireGuardLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet);
+
+		/// @return String representation of the message type.
+		std::string getMessageTypeAsString() const;
+
+		/// @return The message type as an unsigned 32-bit integer.
+		uint8_t getMessageType() const;
+
+		/// @return The reserved field as a 32-bit integer.
+		uint32_t getReserved() const;
+
+		/// @param reserved The reserved field to set as a An array containing the 3-byte.
+		void setReserved(const std::array<uint8_t, 3>& reserved);
+
+		/// Does nothing for this layer (WireGuard layer is always last)
+		void parseNextLayer() override
+		{}
+
+		/// @return Size of the header in bytes.
+		size_t getHeaderLen() const override;
+
+		/// No fields to compute or update, so this method is left empty.
+		void computeCalculateFields() override
+		{}
+
+		/// Converts the WireGuard layer to a string representation.
+		/// @return String representation of the WireGuard layer
+		std::string toString() const override;
+
+		/// @return OSI model layer corresponding to the Network layer
+		OsiModelLayer getOsiModelLayer() const override
+		{
+			return OsiModelNetworkLayer;
+		}
+
+		/// @return The message type as a WireGuardMessageType enum value.
+		virtual WireGuardMessageType getWireGuardMessageType() const
+		{
+			return WireGuardMessageType::Unknown;
+		}
+	};
+
+	/// @class WireGuardHandshakeInitiationLayer
+	/// Represents the Handshake Initiation message layer
+	class WireGuardHandshakeInitiationLayer : public WireGuardLayer
+	{
+	private:
+#pragma pack(push, 1)
+		/// @struct wg_handshake_initiation
+		/// Represents the Handshake Initiation message structure
+		typedef struct wg_handshake_initiation : wg_common_header
+		{
+			/// Sender index
+			uint32_t senderIndex;
+			/// Initiator's ephemeral public key
+			uint8_t initiatorEphemeral[32];
+			/// Encrypted initiator's static key
+			uint8_t encryptedInitiatorStatic[48];
+			/// Encrypted timestamp
+			uint8_t encryptedTimestamp[28];
+			/// MAC1 field
+			uint8_t mac1[16];
+			/// MAC2 field
+			uint8_t mac2[16];
+		} wg_handshake_initiation;
+#pragma pack(pop)
+		wg_handshake_initiation* getHandshakeInitiationHeader() const
+		{
+			return reinterpret_cast<wg_handshake_initiation*>(getBasicHeader());
+		}
+
+	public:
+		/// A constructor that creates the layer from an existing packet raw data
+		/// @param[in] data A pointer to the raw data
+		/// @param[in] dataLen Size of the data in bytes
+		/// @param[in] prevLayer A pointer to the previous layer
+		/// @param[in] packet A pointer to the Packet instance where layer will be stored in
+		WireGuardHandshakeInitiationLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet)
+		    : WireGuardLayer(data, dataLen, prevLayer, packet)
+		{}
+
+		/// A constructor that creates a new Handshake Initiation message
+		/// @param[in] senderIndex The sender's index
+		/// @param[in] initiatorEphemeral The initiator's ephemeral public key
+		/// @param[in] encryptedInitiatorStatic The encrypted initiator's static key
+		/// @param[in] encryptedTimestamp The encrypted timestamp
+		/// @param[in] mac1 The MAC1 field
+		/// @param[in] mac2 The MAC2 field
+		WireGuardHandshakeInitiationLayer(uint32_t senderIndex, const uint8_t initiatorEphemeral[32],
+		                                  const uint8_t encryptedInitiatorStatic[48],
+		                                  const uint8_t encryptedTimestamp[28], const uint8_t mac1[16],
+		                                  const uint8_t mac2[16]);
+
+		/// @return The sender index as a 32-bit integer.
+		uint32_t getSenderIndex() const;
+
+		/// @return An array containing the initiator's ephemeral public key.
+		std::array<uint8_t, 32> getInitiatorEphemeral() const;
+
+		/// @return An array containing the encrypted initiator's static key.
+		std::array<uint8_t, 48> getEncryptedInitiatorStatic() const;
+
+		/// @return An array containing the encrypted timestamp.
+		std::array<uint8_t, 28> getEncryptedTimestamp() const;
+
+		/// @return An array containing the MAC1 field.
+		std::array<uint8_t, 16> getMac1() const;
+
+		/// @return An array containing the MAC2 field.
+		std::array<uint8_t, 16> getMac2() const;
+
+		/// @param senderIndex A 32-bit integer representing the sender index.
+		void setSenderIndex(uint32_t senderIndex);
+
+		/// @param initiatorEphemeral An array containing the 32-byte initiator ephemeral public key.
+		void setInitiatorEphemeral(const std::array<uint8_t, 32>& initiatorEphemeral);
+
+		/// @param encryptedInitiatorStatic An array containing the 48-byte encrypted initiator's static key.
+		void setEncryptedInitiatorStatic(const std::array<uint8_t, 48>& encryptedInitiatorStatic);
+
+		/// @param encryptedTimestamp An array containing the 28-byte encrypted timestamp.
+		void setEncryptedTimestamp(const std::array<uint8_t, 28>& encryptedTimestamp);
+
+		/// @param mac1 An array containing the 16-byte MAC1 field.
+		void setMac1(const std::array<uint8_t, 16>& mac1);
+
+		/// @param mac2 An array containing the 16-byte MAC2 field.
+		void setMac2(const std::array<uint8_t, 16>& mac2);
+
+		// implement abstract methods
+
+		/// @return WireGuardMessageType enum value indicating HandshakeInitiation.
+		WireGuardMessageType getWireGuardMessageType() const override
+		{
+			return WireGuardMessageType::HandshakeInitiation;
+		}
+	};
+
+	/// @class WireGuardHandshakeResponseLayer
+	/// Represents a Handshake Response message
+	class WireGuardHandshakeResponseLayer : public WireGuardLayer
+	{
+	private:
+#pragma pack(push, 1)
+		/// @struct wg_handshake_response
+		/// Represents the Handshake Response message structure
+		typedef struct wg_handshake_response : wg_common_header
+		{
+			/// Sender index
+			uint32_t senderIndex;
+			/// Receiver index
+			uint32_t receiverIndex;
+			/// Responder's ephemeral public key
+			uint8_t responderEphemeral[32];
+			/// Encrypted empty field
+			uint8_t encryptedEmpty[16];
+			/// MAC1 field
+			uint8_t mac1[16];
+			/// MAC2 field
+			uint8_t mac2[16];
+		} wg_handshake_response;
+#pragma pack(pop)
+
+		wg_handshake_response* getHandshakeResponseHeader() const
+		{
+			return reinterpret_cast<wg_handshake_response*>(getBasicHeader());
+		}
+
+	public:
+		/// A constructor that creates the layer from an existing packet raw data
+		/// @param[in] data A pointer to the raw data
+		/// @param[in] dataLen Size of the data in bytes
+		/// @param[in] prevLayer A pointer to the previous layer
+		/// @param[in] packet A pointer to the Packet instance where layer will be stored in
+		WireGuardHandshakeResponseLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet)
+		    : WireGuardLayer(data, dataLen, prevLayer, packet)
+		{}
+
+		/// A constructor that creates a new Handshake Response message
+		/// @param[in] senderIndex The sender index
+		/// @param[in] receiverIndex The receiver index
+		/// @param[in] responderEphemeral The responder's ephemeral public key
+		/// @param[in] encryptedEmpty The encrypted empty field
+		/// @param[in] mac1 The MAC1 field
+		/// @param[in] mac2 The MAC2 field
+		WireGuardHandshakeResponseLayer(uint32_t senderIndex, uint32_t receiverIndex,
+		                                const uint8_t responderEphemeral[32], const uint8_t encryptedEmpty[16],
+		                                const uint8_t mac1[16], const uint8_t mac2[16]);
+
+		/// @return The sender index as a 32-bit unsigned integer.
+		uint32_t getSenderIndex() const;
+
+		/// @return The receiver index as a 32-bit unsigned integer.
+		uint32_t getReceiverIndex() const;
+
+		/// @return The responder's ephemeral public key as an array of 32 bytes.
+		std::array<uint8_t, 32> getResponderEphemeral() const;
+
+		/// @return The encrypted empty field as an array of 16 bytes.
+		std::array<uint8_t, 16> getEncryptedEmpty() const;
+
+		/// @return The MAC1 field as an array of 16 bytes.
+		std::array<uint8_t, 16> getMac1() const;
+
+		/// @return The MAC2 field as an array of 16 bytes.
+		std::array<uint8_t, 16> getMac2() const;
+
+		/// @param senderIndex A 32-bit unsigned integer representing the sender index.
+		void setSenderIndex(uint32_t senderIndex);
+
+		/// @param receiverIndex A 32-bit unsigned integer representing the receiver index.
+		void setReceiverIndex(uint32_t receiverIndex);
+
+		/// @param responderEphemeral An array containing the 32-byte responder ephemeral public key.
+		void setResponderEphemeral(const std::array<uint8_t, 32>& responderEphemeral);
+
+		/// @param encryptedEmpty An array containing the 16-byte encrypted empty field.
+		void setEncryptedEmpty(const std::array<uint8_t, 16>& encryptedEmpty);
+
+		/// @param mac1 An array containing the 16-byte MAC1 field.
+		void setMac1(const std::array<uint8_t, 16>& mac1);
+
+		/// @param mac2 An array containing the 16-byte MAC2 field.
+		void setMac2(const std::array<uint8_t, 16>& mac2);
+
+		// implement abstract methods
+
+		/// @return The message type as a WireGuardMessageType enum value.
+		WireGuardMessageType getWireGuardMessageType() const override
+		{
+			return WireGuardMessageType::HandshakeResponse;
+		}
+	};
+
+	/// @class WireGuardCookieReplyLayer
+	/// Represents a Cookie Reply message
+	class WireGuardCookieReplyLayer : public WireGuardLayer
+	{
+	private:
+#pragma pack(push, 1)
+		/// @struct wg_cookie_reply
+		/// Represents the Cookie Reply message structure
+		typedef struct wg_cookie_reply : wg_common_header
+		{
+			/// Receiver index
+			uint32_t receiverIndex;
+			/// Nonce field
+			uint8_t nonce[24];
+			/// Encrypted cookie
+			uint8_t encryptedCookie[32];
+		} wg_cookie_reply;
+#pragma pack(pop)
+
+		wg_cookie_reply* getCookieReplyHeader() const
+		{
+			return reinterpret_cast<wg_cookie_reply*>(getBasicHeader());
+		}
+
+	public:
+		/// A constructor that creates the layer from an existing packet raw data
+		/// @param[in] data A pointer to the raw data
+		/// @param[in] dataLen Size of the data in bytes
+		/// @param[in] prevLayer A pointer to the previous layer
+		/// @param[in] packet A pointer to the Packet instance where layer will be stored in
+		WireGuardCookieReplyLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet)
+		    : WireGuardLayer(data, dataLen, prevLayer, packet)
+		{}
+
+		/// A constructor that creates a new Cookie Reply message
+		/// @param[in] receiverIndex The receiver index
+		/// @param[in] nonce The nonce field
+		/// @param[in] encryptedCookie The encrypted cookie
+		WireGuardCookieReplyLayer(uint32_t receiverIndex, const uint8_t nonce[24], const uint8_t encryptedCookie[32]);
+
+		/// @return The receiver index as a 32-bit unsigned integer.
+		uint32_t getReceiverIndex() const;
+
+		/// @return The nonce field as an array of 24 bytes.
+		std::array<uint8_t, 24> getNonce() const;
+
+		/// @return The encrypted cookie as an array of 32 bytes.
+		std::array<uint8_t, 32> getEncryptedCookie() const;
+
+		/// @param receiverIndex A 32-bit unsigned integer representing the receiver index.
+		void setReceiverIndex(uint32_t receiverIndex);
+
+		/// @param nonce An array containing the 24-byte nonce field.
+		void setNonce(const std::array<uint8_t, 24>& nonce);
+
+		/// @param encryptedCookie An array containing the 32-byte encrypted cookie.
+		void setEncryptedCookie(const std::array<uint8_t, 32>& encryptedCookie);
+
+		// implement abstract methods
+
+		/// @return The message type as a WireGuardMessageType enum value.
+		WireGuardMessageType getWireGuardMessageType() const override
+		{
+			return WireGuardMessageType::CookieReply;
+		}
+	};
+
+	/// @class WireGuardTransportDataLayer
+	/// Represents a Transport Data message
+	class WireGuardTransportDataLayer : public WireGuardLayer
+	{
+	private:
+#pragma pack(push, 1)
+		/// @struct wg_transport_data
+		/// Represents the Transport Data message structure
+		typedef struct wg_transport_data : wg_common_header
+		{
+			/// Receiver index
+			uint32_t receiverIndex;
+			/// Counter field
+			uint64_t counter;
+			/// Flexible array member for encrypted data
+			uint8_t encryptedData[0];
+		} wg_transport_data;
+#pragma pack(pop)
+
+		wg_transport_data* getTransportHeader() const
+		{
+			return reinterpret_cast<wg_transport_data*>(getBasicHeader());
+		}
+
+	public:
+		/// A constructor that creates the layer from an existing packet raw data
+		/// @param[in] data A pointer to the raw data
+		/// @param[in] dataLen Size of the data in bytes
+		/// @param[in] prevLayer A pointer to the previous layer
+		/// @param[in] packet A pointer to the Packet instance where layer will be stored in
+		WireGuardTransportDataLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet)
+		    : WireGuardLayer(data, dataLen, prevLayer, packet)
+		{}
+
+		/// A constructor that creates a new Transport Data message
+		/// @param[in] receiverIndex The receiver index
+		/// @param[in] counter The counter field
+		/// @param[in] encryptedData The encrypted data
+		/// @param[in] encryptedDataLen The length of the encrypted data
+		WireGuardTransportDataLayer(uint32_t receiverIndex, uint64_t counter, const uint8_t* encryptedData,
+		                            size_t encryptedDataLen);
+
+		/// @return The receiver index as a 32-bit unsigned integer.
+		uint32_t getReceiverIndex() const;
+
+		/// @return The counter field as a 64-bit unsigned integer.
+		uint64_t getCounter() const;
+
+		/// @return A pointer to the encrypted data field.
+		const uint8_t* getEncryptedData() const;
+
+		/// @param receiverIndex A 32-bit unsigned integer representing the receiver index.
+		void setReceiverIndex(uint32_t receiverIndex);
+
+		/// @param counter A 64-bit unsigned integer representing the counter field.
+		void setCounter(uint64_t counter);
+
+		/// @param encryptedData A pointer to the encrypted data.
+		/// @param encryptedDataLen The length of the encrypted data.
+		void setEncryptedData(const uint8_t* encryptedData, size_t encryptedDataLen);
+
+		// implement abstract methods
+
+		/// @return The message type as a WireGuardMessageType enum value.
+		WireGuardMessageType getWireGuardMessageType() const override
+		{
+			return WireGuardMessageType::TransportData;
+		}
+	};
+}  // namespace pcpp
diff --git a/reproduce_bug b/reproduce_bug
new file mode 100755
index 00000000..f92363cb
Binary files /dev/null and b/reproduce_bug differ
diff --git a/reproduce_bug.cpp b/reproduce_bug.cpp
new file mode 100644
index 00000000..971429b2
--- /dev/null
+++ b/reproduce_bug.cpp
@@ -0,0 +1,15 @@
+#include <iostream>
+#include "IPv4Layer.h"
+#include "Packet.h"
+#include "PcapFileDevice.h"
+#include "GtpLayer.h"
+
+int main(int argc, char* argv[]) {
+    auto gtpLayer = std::unique_ptr<pcpp::GtpV1Layer>(
+    new pcpp::GtpV1Layer(pcpp::GtpV1MessageType::GtpV1_VersionNotSupported, 0x12345678, true, 1, false, 0));
+    gtpLayer->getHeader()->messageType = 0xFF;
+    gtpLayer->addExtension(0x85, 0x1234);
+
+    std::cout << "Script completed successfully, no errors." << std::endl;
+    return 0;
+}
