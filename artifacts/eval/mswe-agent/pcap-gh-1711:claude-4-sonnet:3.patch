
diff --git a/.gitignore b/.gitignore
index 85b3571c..3a8a8b43 100644
--- a/.gitignore
+++ b/.gitignore
@@ -78,3 +78,8 @@ venv/**
 
 #MacOS system files
 **/.DS_Store
+Build/
+bin/
+lib/
+*.out
+*.exe
diff --git a/Packet++/src/GtpLayer.cpp b/Packet++/src/GtpLayer.cpp
index 2e935cf5..24c41c81 100644
--- a/Packet++/src/GtpLayer.cpp
+++ b/Packet++/src/GtpLayer.cpp
@@ -406,6 +406,16 @@ namespace pcpp
 			return {};
 		}
 
+		// refresh header and headerExtra pointers after extendLayer() call
+		// because extendLayer() may reallocate memory, invalidating previous pointers
+		header = getHeader();
+		headerExtra = getHeaderExtra();
+		if (header == nullptr || headerExtra == nullptr)
+		{
+			PCPP_LOG_ERROR("Add extension failed: header or headerExtra is nullptr after extendLayer");
+			return {};
+		}
+
 		// lastExt != null means layer contains 1 or more extensions
 		if (!lastExt.isNull())
 		{
diff --git a/install/include/pcapplusplus/ArpLayer.h b/install/include/pcapplusplus/ArpLayer.h
new file mode 100644
index 00000000..02251c42
--- /dev/null
+++ b/install/include/pcapplusplus/ArpLayer.h
@@ -0,0 +1,276 @@
+#pragma once
+
+#include "Layer.h"
+#include "IpAddress.h"
+#include "MacAddress.h"
+#include "DeprecationUtils.h"
+
+/// @file
+
+/// @namespace pcpp
+/// @brief The main namespace for the PcapPlusPlus lib
+namespace pcpp
+{
+	/// @struct arphdr
+	/// Represents an ARP protocol header
+#pragma pack(push, 1)
+	struct arphdr
+	{
+		/// Hardware type (HTYPE)
+		uint16_t hardwareType;
+		/// Protocol type (PTYPE). The permitted PTYPE values share a numbering space with those for EtherType
+		uint16_t protocolType;
+		/// Hardware address length (HLEN). For IPv4, this has the value 0x0800
+		uint8_t hardwareSize;
+		/// Protocol length (PLEN). Length (in octets) of addresses used in the upper layer protocol. (The upper layer
+		/// protocol specified in PTYPE.) IPv4 address size is 4
+		uint8_t protocolSize;
+		/// Specifies the operation that the sender is performing: 1 (::ARP_REQUEST) for request, 2 (::ARP_REPLY) for
+		/// reply
+		uint16_t opcode;
+		/// Sender hardware address (SHA)
+		uint8_t senderMacAddr[6];
+		/// Sender protocol address (SPA)
+		uint32_t senderIpAddr;
+		/// Target hardware address (THA)
+		uint8_t targetMacAddr[6];
+		/// Target protocol address (TPA)
+		uint32_t targetIpAddr;
+	};
+#pragma pack(pop)
+	static_assert(sizeof(arphdr) == 28, "arphdr size is not 28 bytes");
+
+	/// An enum for ARP message type
+	enum ArpOpcode
+	{
+		ARP_REQUEST = 0x0001,  ///< ARP request
+		ARP_REPLY = 0x0002     ///< ARP reply (response)
+	};
+
+	/// @brief An enum representing the ARP message type
+	enum class ArpMessageType
+	{
+		Unknown,            ///< Unknown ARP message type
+		Request,            ///< ARP request
+		Reply,              ///< ARP reply
+		GratuitousRequest,  ///< Gratuitous ARP request
+		GratuitousReply,    ///< Gratuitous ARP reply
+	};
+
+	/// @brief A struct representing the build data for an ARP request
+	///
+	/// An ARP request is a message sent by a machine to request the MAC address of another machine on the network.
+	struct ArpRequest
+	{
+		MacAddress senderMacAddr;
+		IPv4Address senderIpAddr;
+		IPv4Address targetIpAddr;
+
+		/// @brief Construct a new Arp Request object
+		/// @param senderMacAddress The MAC address of the machine sending the query.
+		/// @param senderIPAddress The IP address of the machine sending the query.
+		/// @param targetIPAddress The IP address of the target machine being queried.
+		ArpRequest(MacAddress const& senderMacAddress, IPv4Address const& senderIPAddress,
+		           IPv4Address const& targetIPAddress)
+		    : senderMacAddr(senderMacAddress), senderIpAddr(senderIPAddress), targetIpAddr(targetIPAddress) {};
+	};
+
+	/// @brief A struct representing the build data for an ARP reply
+	///
+	/// An ARP reply is a message sent by a machine in response to an ARP request. It contains the MAC address of the
+	/// answering machine, and is sent to the IP/MAC address of the machine that sent the original ARP request.
+	struct ArpReply
+	{
+		MacAddress senderMacAddr;
+		IPv4Address senderIpAddr;
+		MacAddress targetMacAddr;
+		IPv4Address targetIpAddr;
+
+		/// @brief Construct a new Arp Reply object
+		/// @param senderMacAddress The MAC address of the machine sending the reply.
+		/// @param senderIPAddress The IP address of the machine sending the reply.
+		/// @param targetMacAddress The MAC address of the target machine being replied to.
+		/// @param targetIPAddress The IP address of the target machine being replied to.
+		/// @remarks The target machine is considered the machine that sent the original ARP request.
+		ArpReply(MacAddress const& senderMacAddress, IPv4Address const& senderIPAddress,
+		         MacAddress const& targetMacAddress, IPv4Address const& targetIPAddress)
+		    : senderMacAddr(senderMacAddress), senderIpAddr(senderIPAddress), targetMacAddr(targetMacAddress),
+		      targetIpAddr(targetIPAddress) {};
+	};
+
+	/// @brief A struct representing the build data for a gratuitous ARP request
+	///
+	/// A gratuitous ARP request is an ARP request that is sent by a machine to announce its presence on the network.
+	/// It is an ARP request that has both the sender and target IP addresses set to the IP address of the machine
+	/// and the target MAC address set to the broadcast address. Normally such a request will not receive a reply.
+	///
+	/// These requests can be used to update ARP caches on other machines on the network, or to help in detecting IP
+	/// address conflicts.
+	struct GratuitousArpRequest
+	{
+		MacAddress senderMacAddr;
+		IPv4Address senderIpAddr;
+
+		/// @brief Construct a new Gratuitous Arp Request object
+		/// @param senderMacAddress The MAC address of the machine sending the gratuitous ARP request.
+		/// @param senderIPAddress The IP address of the machine sending the gratuitous ARP request.
+		/// @remarks The target MAC address is set to the broadcast address and the target IP address is set to the
+		/// sender's.
+		GratuitousArpRequest(MacAddress const& senderMacAddress, IPv4Address const& senderIPAddress)
+		    : senderMacAddr(senderMacAddress), senderIpAddr(senderIPAddress) {};
+	};
+
+	/// @brief A struct representing the build data a gratuitous ARP reply
+	///
+	/// A gratuitous ARP reply is an ARP reply that is sent by a machine to announce its presence on the network.
+	/// It is gratuitous in the sense that it is not in response to an ARP request, but sent unsolicited to the network.
+	struct GratuitousArpReply
+	{
+		MacAddress senderMacAddr;
+		IPv4Address senderIpAddr;
+
+		/// @brief Construct a new Gratuitous Arp Reply object
+		/// @param senderMacAddress The MAC address of the machine sending the gratuitous ARP reply.
+		/// @param senderIPAddress The IP address of the machine sending the gratuitous ARP reply.
+		/// @remarks The target MAC address is set to the broadcast address and the target IP address is set to the
+		/// sender's.
+		GratuitousArpReply(MacAddress const& senderMacAddress, IPv4Address const& senderIPAddress)
+		    : senderMacAddr(senderMacAddress), senderIpAddr(senderIPAddress) {};
+	};
+
+	/// @class ArpLayer
+	/// Represents an ARP protocol layer. Currently only IPv4 ARP messages are supported
+	class ArpLayer : public Layer
+	{
+	public:
+		/// A constructor that creates the layer from an existing packet raw data
+		/// @param[in] data A pointer to the raw data (will be casted to @ref arphdr)
+		/// @param[in] dataLen Size of the data in bytes
+		/// @param[in] prevLayer A pointer to the previous layer
+		/// @param[in] packet A pointer to the Packet instance where layer will be stored in
+		ArpLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet)
+		    : Layer(data, dataLen, prevLayer, packet, ARP)
+		{
+			m_DataLen = sizeof(arphdr);
+		}
+
+		/// @brief A constructor that creates an ARP header
+		/// @param[in] opCode ARP message type (ARP request or ARP reply)
+		/// @param[in] senderMacAddr The sender MAC address (will be put in arphdr#senderMacAddr)
+		/// @param[in] senderIpAddr The sender IP address (will be put in arphdr#senderIpAddr)
+		/// @param[in] targetMacAddr The target MAC address (will be put in arphdr#targetMacAddr)
+		/// @param[in] targetIpAddr The target IP address (will be put in arphdr#targetIpAddr)
+		/// @remarks No validation is done on the input parameters. The caller must ensure that the input creates a
+		/// valid header.
+		ArpLayer(ArpOpcode opCode, const MacAddress& senderMacAddr, const IPv4Address& senderIpAddr,
+		         const MacAddress& targetMacAddr, const IPv4Address& targetIpAddr);
+
+		/// A constructor that allocates a new ARP header
+		/// @param[in] opCode ARP message type (ARP request or ARP reply)
+		/// @param[in] senderMacAddr The sender MAC address (will be put in arphdr#senderMacAddr)
+		/// @param[in] targetMacAddr The target MAC address (will be put in arphdr#targetMacAddr)
+		/// @param[in] senderIpAddr The sender IP address (will be put in arphdr#senderIpAddr)
+		/// @param[in] targetIpAddr The target IP address (will be put in arphdr#targetIpAddr)
+		/// @deprecated This constructor has been deprecated. Please use one of the other overloads.
+		/// @remarks This constructor zeroes the target MAC address for ARP requests to keep backward compatibility.
+		PCPP_DEPRECATED("This constructor has been deprecated. Please use one of the other overloads.")
+		ArpLayer(ArpOpcode opCode, const MacAddress& senderMacAddr, const MacAddress& targetMacAddr,
+		         const IPv4Address& senderIpAddr, const IPv4Address& targetIpAddr);
+
+		/// @brief A constructor that creates an ARP request header.
+		/// @param arpRequest The ARP request data
+		explicit ArpLayer(ArpRequest const& arpRequest);
+
+		/// @brief A constructor that creates an ARP reply header.
+		/// @param arpReply The ARP reply data
+		explicit ArpLayer(ArpReply const& arpReply);
+
+		/// @brief A constructor that creates a gratuitous ARP request header.
+		/// @param gratuitousArpRequest The gratuitous ARP request data
+		explicit ArpLayer(GratuitousArpRequest const& gratuitousArpRequest);
+
+		/// @brief A constructor that creates a gratuitous ARP reply header.
+		/// @param gratuitousArpReply The gratuitous ARP reply data
+		explicit ArpLayer(GratuitousArpReply const& gratuitousArpReply);
+
+		~ArpLayer() override = default;
+
+		/// Get a pointer to the ARP header. Notice this points directly to the data, so every change will change the
+		/// actual packet data
+		/// @return A pointer to the @ref arphdr
+		inline arphdr* getArpHeader() const
+		{
+			return reinterpret_cast<arphdr*>(m_Data);
+		}
+
+		/// Get the ARP opcode
+		/// @return The ARP opcode
+		/// @remarks The opcode may not be one of the values in @ref ArpOpcode
+		ArpOpcode getOpcode() const;
+
+		/// Get the sender hardware address (SHA) in the form of MacAddress
+		/// @return A MacAddress containing the sender hardware address (SHA)
+		inline MacAddress getSenderMacAddress() const
+		{
+			return MacAddress(getArpHeader()->senderMacAddr);
+		}
+
+		/// Get the target hardware address (THA) in the form of MacAddress
+		/// @return A MacAddress containing the target hardware address (THA)
+		inline MacAddress getTargetMacAddress() const
+		{
+			return MacAddress(getArpHeader()->targetMacAddr);
+		}
+
+		/// Get the sender protocol address (SPA) in the form of IPv4Address
+		/// @return An IPv4Address containing the sender protocol address (SPA)
+		inline IPv4Address getSenderIpAddr() const
+		{
+			return getArpHeader()->senderIpAddr;
+		}
+
+		/// Get the target protocol address (TPA) in the form of IPv4Address
+		/// @return An IPv4Address containing the target protocol address (TPA)
+		inline IPv4Address getTargetIpAddr() const
+		{
+			return getArpHeader()->targetIpAddr;
+		}
+
+		// implement abstract methods
+
+		/// Does nothing for this layer (ArpLayer is always last)
+		void parseNextLayer() override
+		{}
+
+		/// @return The size of @ref arphdr
+		size_t getHeaderLen() const override
+		{
+			return sizeof(arphdr);
+		}
+
+		/// Calculate the following fields:
+		/// - @ref arphdr#hardwareType = Ethernet (1)
+		/// - @ref arphdr#hardwareSize = 6
+		/// - @ref arphdr#protocolType = ETHERTYPE_IP (assume IPv4 over ARP)
+		/// - @ref arphdr#protocolSize = 4 (assume IPv4 over ARP)
+		void computeCalculateFields() override;
+
+		/// @brief Attempts to determine the ARP message type based on the header signature.
+		/// @return An @ref ArpMessageType representing the ARP message type.
+		ArpMessageType getMessageType() const;
+
+		/// Is this packet an ARP request?
+		bool isRequest() const;
+
+		/// Is this packet an ARP reply?
+		bool isReply() const;
+
+		std::string toString() const override;
+
+		OsiModelLayer getOsiModelLayer() const override
+		{
+			return OsiModelNetworkLayer;
+		}
+	};
+
+}  // namespace pcpp
diff --git a/install/include/pcapplusplus/Asn1Codec.h b/install/include/pcapplusplus/Asn1Codec.h
new file mode 100644
index 00000000..1d0f74da
--- /dev/null
+++ b/install/include/pcapplusplus/Asn1Codec.h
@@ -0,0 +1,495 @@
+#pragma once
+
+#include <string>
+#include <memory>
+#include <typeinfo>
+#include <stdexcept>
+#include "PointerVector.h"
+
+/// @file
+
+/// @namespace pcpp
+/// @brief The main namespace for the PcapPlusPlus lib
+namespace pcpp
+{
+	/// An enum for representing ASN.1 tag class
+	enum class Asn1TagClass : uint8_t
+	{
+		/// The Universal tag class
+		Universal = 0,
+		/// The Application tag class
+		Application = 1,
+		/// The Context-Specific tag class
+		ContextSpecific = 2,
+		/// The Private tag class
+		Private = 3,
+	};
+
+	/// An enum for representing ASN.1 Universal tag types
+	enum class Asn1UniversalTagType : uint8_t
+	{
+		/// The reserved identifier for the End-of-Contents marker in an indefinite length encoding
+		EndOfContent = 0,
+		/// The universal tag type for Boolean
+		Boolean = 1,
+		/// The universal tag type for Integer
+		Integer = 2,
+		/// The universal tag type for Bit String
+		BitString = 3,
+		/// The universal tag type for Octet String
+		OctetString = 4,
+		/// The universal tag type for Null
+		Null = 5,
+		/// The universal tag type for...nge will
+		/// change the actual packet data
+		/// @return A pointer to the wol_header
+		inline wol_header* getWakeOnLanHeader() const
+		{
+			return reinterpret_cast<wol_header*>(m_Data);
+		}
+
+		/// Get the target MAC address of the command
+		/// @return MAC address of the target
+		pcpp::MacAddress getTargetAddr() const;
+
+		/// Set the target MAC address
+		/// @param[in] targetAddr MAC address of the target
+		void setTargetAddr(const pcpp::MacAddress& targetAddr);
+
+		/// Get the password of the command
+		/// @return Returns the password if exists, empty string otherwise
+		std::string getPassword() const;
+
+		/// Set the password of the command
+		/// @param[in] password Password as array
+		/// @param[in] len Length of the password array, length of the password should be less than 6 bytes
+		/// @return True if operation successful, false otherwise
+		bool setPassword(const uint8_t* password, uint8_t len);
+
+		/// Set the password of the command
+		/// @param[in] password Password as string. Length of the password should be less than 6 bytes
+		/// @return True if operation successful, false otherwise
+		bool setPassword(const std::string& password);
+
+		/// Set the password of the command
+		/// @param[in] addr Password as MAC address
+		/// @return True if operation successful, false otherwise
+		bool setPassword(const MacAddress& addr);
+
+		/// Set the password of the command
+		/// @param addr Password as IPv4 address
+		/// @return True if operation successful, false otherwise
+		bool setPassword(const IPv4Address& addr);
+
+		/// A static method that checks whether the port is considered as Wake on LAN
+		/// @param[in] port The port number to be checked
+		static bool isWakeOnLanPort(uint16_t port)
+		{
+			return (port == 0) || (port == 7) || (port == 9);
+		}
+
+		/// A static method that takes a byte array and detects whether it is a Wake on LAN message
+		/// @param[in] data A byte array
+		/// @param[in] dataSize The byte array size (in bytes)
+		/// @return True if the data is identified as Wake on LAN message
+		static bool isDataValid(const uint8_t* data, size_t dataSize);
+
+		// overridden methods
+
+		/// Parses the next layer. Wake on LAN is the always last so does nothing for this layer
+		void parseNextLayer() override
+		{}
+
+		/// @return Get the size of the layer
+		size_t getHeaderLen() const override
+		{
+			return m_DataLen;
+		}
+
+		/// Does nothing for this layer
+		void computeCalculateFields() override
+		{}
+
+		/// @return The OSI layer level of Wake on LAN (Data Link Layer)
+		OsiModelLayer getOsiModelLayer() const override
+		{
+			return OsiModelDataLinkLayer;
+		}
+
+		/// @return Returns the protocol info as readable string
+		std::string toString() const override;
+	};
+}  // namespace pcpp
diff --git a/install/include/pcapplusplus/WireGuardLayer.h b/install/include/pcapplusplus/WireGuardLayer.h
new file mode 100644
index 00000000..0d59287e
--- /dev/null
+++ b/install/include/pcapplusplus/WireGuardLayer.h
@@ -0,0 +1,454 @@
+#pragma once
+
+#include "Layer.h"
+#include "IpAddress.h"
+#include "MacAddress.h"
+
+/// @file
+
+/// @namespace pcpp
+/// @brief The main namespace for the PcapPlusPlus lib
+namespace pcpp
+{
+	/// @class WireGuardLayer
+	/// Represents a WireGuard protocol layer
+	class WireGuardLayer : public Layer
+	{
+	protected:
+#pragma pack(push, 1)
+		/// @struct wg_common_header
+		/// Represents the common header for all WireGuard message types
+		struct wg_common_header
+		{
+			/// Message type field
+			uint8_t messageType;
+			/// Reserved field (3 bytes)
+			uint8_t reserved[3];
+		};
+#pragma pack(pop)
+		static_assert(sizeof(wg_common_header) == 4, "wg_common_header size is not 4 bytes");
+
+		wg_common_header* getBasicHeader() const
+		{
+			return reinterpret_cast<wg_common_header*>(m_Data);
+		}
+
+		WireGuardLayer() = default;
+
+	public:
+		/// WireGuard message types
+		enum class WireGuardMessageType
+		{
+			/// Unknown Initiation message
+			Unknown = 0,
+			/// Handshake Initiation message
+			HandshakeInitiation = 1,
+			/// Handshake Response message
+			HandshakeResponse = 2,
+			/// Cookie Reply message
+			CookieReply = 3,
+			/// Transport Data message
+			TransportData = 4
+		};
+
+		/// Constructs a WireGuardLayer object.
+		/// @param data Pointer to the raw data representing the WireGuard layer
+		/// @param dataLen Length of the data
+		/// @param prevLayer Pointer to the previous layer in the packet (if any)
+		/// @param packet Pointer to the packet this layer belongs to
+		WireGuardLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet)
+		    : Layer(data, dataLen, prevLayer, packet, WireGuard)
+		{}
+
+		/// Checks if the given port numbers are WireGuard ports.
+		/// @param portSrc The source port number to check
+		/// @param portDst The destination port number to check
+		/// @return True if either port matches the WireGuard port (51820), false otherwise
+		static bool isWireGuardPorts(uint16_t portSrc, uint16_t portDst)
+		{
+			return (portSrc == 51820 || portDst == 51820);
+		}
+
+		/// Checks if the given data represents a WireGuard message.
+		/// @param data Pointer to the raw data
+		/// @param dataLen Length of the data
+		/// @return True if the data starts with a valid WireGuard message type, false otherwise
+		static bool isDataValid(const uint8_t* data, size_t dataLen);
+
+		/// Parses the raw data into a WireGuard layer.
+		/// @param data Pointer to the raw data
+		/// @param dataLen Length of the data
+		/// @param prevLayer Pointer to the previous layer
+		/// @param packet Pointer to the packet
+		/// @return A pointer to the parsed WireGuardLayer, or nullptr if parsing fails
+		static WireGuardLayer* parseWireGuardLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet);
+
+		/// @return String representation of the message type.
+		std::string getMessageTypeAsString() const;
+
+		/// @return The message type as an unsigned 32-bit integer.
+		uint8_t getMessageType() const;
+
+		/// @return The reserved field as a 32-bit integer.
+		uint32_t getReserved() const;
+
+		/// @param reserved The reserved field to set as a An array containing the 3-byte.
+		void setReserved(const std::array<uint8_t, 3>& reserved);
+
+		/// Does nothing for this layer (WireGuard layer is always last)
+		void parseNextLayer() override
+		{}
+
+		/// @return Size of the header in bytes.
+		size_t getHeaderLen() const override;
+
+		/// No fields to compute or update, so this method is left empty.
+		void computeCalculateFields() override
+		{}
+
+		/// Converts the WireGuard layer to a string representation.
+		/// @return String representation of the WireGuard layer
+		std::string toString() const override;
+
+		/// @return OSI model layer corresponding to the Network layer
+		OsiModelLayer getOsiModelLayer() const override
+		{
+			return OsiModelNetworkLayer;
+		}
+
+		/// @return The message type as a WireGuardMessageType enum value.
+		virtual WireGuardMessageType getWireGuardMessageType() const
+		{
+			return WireGuardMessageType::Unknown;
+		}
+	};
+
+	/// @class WireGuardHandshakeInitiationLayer
+	/// Represents the Handshake Initiation message layer
+	class WireGuardHandshakeInitiationLayer : public WireGuardLayer
+	{
+	private:
+#pragma pack(push, 1)
+		/// @struct wg_handshake_initiation
+		/// Represents the Handshake Initiation message structure
+		typedef struct wg_handshake_initiation : wg_common_header
+		{
+			/// Sender index
+			uint32_t senderIndex;
+			/// Initiator's ephemeral public key
+			uint8_t initiatorEphemeral[32];
+			/// Encrypted initiator's static key
+			uint8_t encryptedInitiatorStatic[48];
+			/// Encrypted timestamp
+			uint8_t encryptedTimestamp[28];
+			/// MAC1 field
+			uint8_t mac1[16];
+			/// MAC2 field
+			uint8_t mac2[16];
+		} wg_handshake_initiation;
+#pragma pack(pop)
+		wg_handshake_initiation* getHandshakeInitiationHeader() const
+		{
+			return reinterpret_cast<wg_handshake_initiation*>(getBasicHeader());
+		}
+
+	public:
+		/// A constructor that creates the layer from an existing packet raw data
+		/// @param[in] data A pointer to the raw data
+		/// @param[in] dataLen Size of the data in bytes
+		/// @param[in] prevLayer A pointer to the previous layer
+		/// @param[in] packet A pointer to the Packet instance where layer will be stored in
+		WireGuardHandshakeInitiationLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet)
+		    : WireGuardLayer(data, dataLen, prevLayer, packet)
+		{}
+
+		/// A constructor that creates a new Handshake Initiation message
+		/// @param[in] senderIndex The sender's index
+		/// @param[in] initiatorEphemeral The initiator's ephemeral public key
+		/// @param[in] encryptedInitiatorStatic The encrypted initiator's static key
+		/// @param[in] encryptedTimestamp The encrypted timestamp
+		/// @param[in] mac1 The MAC1 field
+		/// @param[in] mac2 The MAC2 field
+		WireGuardHandshakeInitiationLayer(uint32_t senderIndex, const uint8_t initiatorEphemeral[32],
+		                                  const uint8_t encryptedInitiatorStatic[48],
+		                                  const uint8_t encryptedTimestamp[28], const uint8_t mac1[16],
+		                                  const uint8_t mac2[16]);
+
+		/// @return The sender index as a 32-bit integer.
+		uint32_t getSenderIndex() const;
+
+		/// @return An array containing the initiator's ephemeral public key.
+		std::array<uint8_t, 32> getInitiatorEphemeral() const;
+
+		/// @return An array containing the encrypted initiator's static key.
+		std::array<uint8_t, 48> getEncryptedInitiatorStatic() const;
+
+		/// @return An array containing the encrypted timestamp.
+		std::array<uint8_t, 28> getEncryptedTimestamp() const;
+
+		/// @return An array containing the MAC1 field.
+		std::array<uint8_t, 16> getMac1() const;
+
+		/// @return An array containing the MAC2 field.
+		std::array<uint8_t, 16> getMac2() const;
+
+		/// @param senderIndex A 32-bit integer representing the sender index.
+		void setSenderIndex(uint32_t senderIndex);
+
+		/// @param initiatorEphemeral An array containing the 32-byte initiator ephemeral public key.
+		void setInitiatorEphemeral(const std::array<uint8_t, 32>& initiatorEphemeral);
+
+		/// @param encryptedInitiatorStatic An array containing the 48-byte encrypted initiator's static key.
+		void setEncryptedInitiatorStatic(const std::array<uint8_t, 48>& encryptedInitiatorStatic);
+
+		/// @param encryptedTimestamp An array containing the 28-byte encrypted timestamp.
+		void setEncryptedTimestamp(const std::array<uint8_t, 28>& encryptedTimestamp);
+
+		/// @param mac1 An array containing the 16-byte MAC1 field.
+		void setMac1(const std::array<uint8_t, 16>& mac1);
+
+		/// @param mac2 An array containing the 16-byte MAC2 field.
+		void setMac2(const std::array<uint8_t, 16>& mac2);
+
+		// implement abstract methods
+
+		/// @return WireGuardMessageType enum value indicating HandshakeInitiation.
+		WireGuardMessageType getWireGuardMessageType() const override
+		{
+			return WireGuardMessageType::HandshakeInitiation;
+		}
+	};
+
+	/// @class WireGuardHandshakeResponseLayer
+	/// Represents a Handshake Response message
+	class WireGuardHandshakeResponseLayer : public WireGuardLayer
+	{
+	private:
+#pragma pack(push, 1)
+		/// @struct wg_handshake_response
+		/// Represents the Handshake Response message structure
+		typedef struct wg_handshake_response : wg_common_header
+		{
+			/// Sender index
+			uint32_t senderIndex;
+			/// Receiver index
+			uint32_t receiverIndex;
+			/// Responder's ephemeral public key
+			uint8_t responderEphemeral[32];
+			/// Encrypted empty field
+			uint8_t encryptedEmpty[16];
+			/// MAC1 field
+			uint8_t mac1[16];
+			/// MAC2 field
+			uint8_t mac2[16];
+		} wg_handshake_response;
+#pragma pack(pop)
+
+		wg_handshake_response* getHandshakeResponseHeader() const
+		{
+			return reinterpret_cast<wg_handshake_response*>(getBasicHeader());
+		}
+
+	public:
+		/// A constructor that creates the layer from an existing packet raw data
+		/// @param[in] data A pointer to the raw data
+		/// @param[in] dataLen Size of the data in bytes
+		/// @param[in] prevLayer A pointer to the previous layer
+		/// @param[in] packet A pointer to the Packet instance where layer will be stored in
+		WireGuardHandshakeResponseLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet)
+		    : WireGuardLayer(data, dataLen, prevLayer, packet)
+		{}
+
+		/// A constructor that creates a new Handshake Response message
+		/// @param[in] senderIndex The sender index
+		/// @param[in] receiverIndex The receiver index
+		/// @param[in] responderEphemeral The responder's ephemeral public key
+		/// @param[in] encryptedEmpty The encrypted empty field
+		/// @param[in] mac1 The MAC1 field
+		/// @param[in] mac2 The MAC2 field
+		WireGuardHandshakeResponseLayer(uint32_t senderIndex, uint32_t receiverIndex,
+		                                const uint8_t responderEphemeral[32], const uint8_t encryptedEmpty[16],
+		                                const uint8_t mac1[16], const uint8_t mac2[16]);
+
+		/// @return The sender index as a 32-bit unsigned integer.
+		uint32_t getSenderIndex() const;
+
+		/// @return The receiver index as a 32-bit unsigned integer.
+		uint32_t getReceiverIndex() const;
+
+		/// @return The responder's ephemeral public key as an array of 32 bytes.
+		std::array<uint8_t, 32> getResponderEphemeral() const;
+
+		/// @return The encrypted empty field as an array of 16 bytes.
+		std::array<uint8_t, 16> getEncryptedEmpty() const;
+
+		/// @return The MAC1 field as an array of 16 bytes.
+		std::array<uint8_t, 16> getMac1() const;
+
+		/// @return The MAC2 field as an array of 16 bytes.
+		std::array<uint8_t, 16> getMac2() const;
+
+		/// @param senderIndex A 32-bit unsigned integer representing the sender index.
+		void setSenderIndex(uint32_t senderIndex);
+
+		/// @param receiverIndex A 32-bit unsigned integer representing the receiver index.
+		void setReceiverIndex(uint32_t receiverIndex);
+
+		/// @param responderEphemeral An array containing the 32-byte responder ephemeral public key.
+		void setResponderEphemeral(const std::array<uint8_t, 32>& responderEphemeral);
+
+		/// @param encryptedEmpty An array containing the 16-byte encrypted empty field.
+		void setEncryptedEmpty(const std::array<uint8_t, 16>& encryptedEmpty);
+
+		/// @param mac1 An array containing the 16-byte MAC1 field.
+		void setMac1(const std::array<uint8_t, 16>& mac1);
+
+		/// @param mac2 An array containing the 16-byte MAC2 field.
+		void setMac2(const std::array<uint8_t, 16>& mac2);
+
+		// implement abstract methods
+
+		/// @return The message type as a WireGuardMessageType enum value.
+		WireGuardMessageType getWireGuardMessageType() const override
+		{
+			return WireGuardMessageType::HandshakeResponse;
+		}
+	};
+
+	/// @class WireGuardCookieReplyLayer
+	/// Represents a Cookie Reply message
+	class WireGuardCookieReplyLayer : public WireGuardLayer
+	{
+	private:
+#pragma pack(push, 1)
+		/// @struct wg_cookie_reply
+		/// Represents the Cookie Reply message structure
+		typedef struct wg_cookie_reply : wg_common_header
+		{
+			/// Receiver index
+			uint32_t receiverIndex;
+			/// Nonce field
+			uint8_t nonce[24];
+			/// Encrypted cookie
+			uint8_t encryptedCookie[32];
+		} wg_cookie_reply;
+#pragma pack(pop)
+
+		wg_cookie_reply* getCookieReplyHeader() const
+		{
+			return reinterpret_cast<wg_cookie_reply*>(getBasicHeader());
+		}
+
+	public:
+		/// A constructor that creates the layer from an existing packet raw data
+		/// @param[in] data A pointer to the raw data
+		/// @param[in] dataLen Size of the data in bytes
+		/// @param[in] prevLayer A pointer to the previous layer
+		/// @param[in] packet A pointer to the Packet instance where layer will be stored in
+		WireGuardCookieReplyLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet)
+		    : WireGuardLayer(data, dataLen, prevLayer, packet)
+		{}
+
+		/// A constructor that creates a new Cookie Reply message
+		/// @param[in] receiverIndex The receiver index
+		/// @param[in] nonce The nonce field
+		/// @param[in] encryptedCookie The encrypted cookie
+		WireGuardCookieReplyLayer(uint32_t receiverIndex, const uint8_t nonce[24], const uint8_t encryptedCookie[32]);
+
+		/// @return The receiver index as a 32-bit unsigned integer.
+		uint32_t getReceiverIndex() const;
+
+		/// @return The nonce field as an array of 24 bytes.
+		std::array<uint8_t, 24> getNonce() const;
+
+		/// @return The encrypted cookie as an array of 32 bytes.
+		std::array<uint8_t, 32> getEncryptedCookie() const;
+
+		/// @param receiverIndex A 32-bit unsigned integer representing the receiver index.
+		void setReceiverIndex(uint32_t receiverIndex);
+
+		/// @param nonce An array containing the 24-byte nonce field.
+		void setNonce(const std::array<uint8_t, 24>& nonce);
+
+		/// @param encryptedCookie An array containing the 32-byte encrypted cookie.
+		void setEncryptedCookie(const std::array<uint8_t, 32>& encryptedCookie);
+
+		// implement abstract methods
+
+		/// @return The message type as a WireGuardMessageType enum value.
+		WireGuardMessageType getWireGuardMessageType() const override
+		{
+			return WireGuardMessageType::CookieReply;
+		}
+	};
+
+	/// @class WireGuardTransportDataLayer
+	/// Represents a Transport Data message
+	class WireGuardTransportDataLayer : public WireGuardLayer
+	{
+	private:
+#pragma pack(push, 1)
+		/// @struct wg_transport_data
+		/// Represents the Transport Data message structure
+		typedef struct wg_transport_data : wg_common_header
+		{
+			/// Receiver index
+			uint32_t receiverIndex;
+			/// Counter field
+			uint64_t counter;
+			/// Flexible array member for encrypted data
+			uint8_t encryptedData[0];
+		} wg_transport_data;
+#pragma pack(pop)
+
+		wg_transport_data* getTransportHeader() const
+		{
+			return reinterpret_cast<wg_transport_data*>(getBasicHeader());
+		}
+
+	public:
+		/// A constructor that creates the layer from an existing packet raw data
+		/// @param[in] data A pointer to the raw data
+		/// @param[in] dataLen Size of the data in bytes
+		/// @param[in] prevLayer A pointer to the previous layer
+		/// @param[in] packet A pointer to the Packet instance where layer will be stored in
+		WireGuardTransportDataLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet)
+		    : WireGuardLayer(data, dataLen, prevLayer, packet)
+		{}
+
+		/// A constructor that creates a new Transport Data message
+		/// @param[in] receiverIndex The receiver index
+		/// @param[in] counter The counter field
+		/// @param[in] encryptedData The encrypted data
+		/// @param[in] encryptedDataLen The length of the encrypted data
+		WireGuardTransportDataLayer(uint32_t receiverIndex, uint64_t counter, const uint8_t* encryptedData,
+		                            size_t encryptedDataLen);
+
+		/// @return The receiver index as a 32-bit unsigned integer.
+		uint32_t getReceiverIndex() const;
+
+		/// @return The counter field as a 64-bit unsigned integer.
+		uint64_t getCounter() const;
+
+		/// @return A pointer to the encrypted data field.
+		const uint8_t* getEncryptedData() const;
+
+		/// @param receiverIndex A 32-bit unsigned integer representing the receiver index.
+		void setReceiverIndex(uint32_t receiverIndex);
+
+		/// @param counter A 64-bit unsigned integer representing the counter field.
+		void setCounter(uint64_t counter);
+
+		/// @param encryptedData A pointer to the encrypted data.
+		/// @param encryptedDataLen The length of the encrypted data.
+		void setEncryptedData(const uint8_t* encryptedData, size_t encryptedDataLen);
+
+		// implement abstract methods
+
+		/// @return The message type as a WireGuardMessageType enum value.
+		WireGuardMessageType getWireGuardMessageType() const override
+		{
+			return WireGuardMessageType::TransportData;
+		}
+	};
+}  // namespace pcpp
