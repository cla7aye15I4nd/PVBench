[{"patch": "diff --git a/.gitignore b/.gitignore\nindex 85b3571c..3a8a8b43 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -78,3 +78,8 @@ venv/**\n \n #MacOS system files\n **/.DS_Store\n+Build/\n+bin/\n+lib/\n+*.out\n+*.exe\ndiff --git a/Examples/CMakeLists.txt b/Examples/CMakeLists.txt\nindex 00e371ea..0b25f302 100644\n--- a/Examples/CMakeLists.txt\n+++ b/Examples/CMakeLists.txt\n@@ -28,7 +28,7 @@ add_subdirectory(HttpAnalyzer)\n add_subdirectory(IcmpFileTransfer)\n add_subdirectory(IPDefragUtil)\n add_subdirectory(IPFragUtil)\n-add_subdirectory(PcapPlusPlus-benchmark)\n+# add_subdirectory(PcapPlusPlus-benchmark)\n add_subdirectory(PcapPrinter)\n add_subdirectory(PcapSearch)\n add_subdirectory(PcapSplitter)\ndiff --git a/Examples/PcapPlusPlus-benchmark/CMakeLists.txt b/Examples/PcapPlusPlus-benchmark/CMakeLists.txt\ndeleted file mode 100644\nindex 81955134..00000000\n--- a/Examples/PcapPlusPlus-benchmark/CMakeLists.txt\n+++ /dev/null\n@@ -1,41 +0,0 @@\n-add_executable(BenchmarkExample benchmark.cpp)\n-\n-target_link_libraries(BenchmarkExample PUBLIC PcapPlusPlus::Pcap++)\n-\n-set_target_properties(BenchmarkExample PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${PCAPPP_BINARY_EXAMPLES_DIR}\")\n-\n-if(\"cxx_std_14\" IN_LIST CMAKE_CXX_COMPILE_FEATURES)\n-  if(\n-    (CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL CMAKE_SYSTEM_PROCESSOR)\n-    AND (NOT MINGW)\n-    AND (NOT CMAKE_OSX_ARCHITECTURES OR (CMAKE_HOST_SYSTEM_PROCESSOR STREQUAL CMAKE_OSX_ARCHITECTURES))\n-  )\n-    include(FetchContent)\n-\n-    # Fetch Google Benchmark\n-    FetchContent_Declare(benchmark GIT_REPOSITORY https://github.com/google/benchmark.git GIT_TAG v1.9.0)\n-\n-    # Disable testing and installation for Google Benchmark\n-    set(BENCHMARK_ENABLE_TESTING OFF)\n-    set(BENCHMARK_ENABLE_INSTALL OFF)\n-    FetchContent_MakeAvailable(benchmark)\n-\n-    add_executable(BenchmarkExampleGoogle benchmark-google.cpp)\n-\n-    target_link_libraries(BenchmarkExampleGoogle PUBLIC PcapPlusPlus::Pcap++ benchmark::benchmark)\n-\n-    set_target_properties(BenchmarkExampleGoogle PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${PCAPPP_BINARY_EXAMPLES_DIR}\")\n-  else()\n-    message(WARNING \"Google Benchmark backend is not supported for cross-compilation\")\n-  endif()\n-else()\n-  message(WARNING \"Google Benchmark backend requires C++14 support\")\n-endif()\n-\n-if(PCAPPP_INSTALL)\n-  install(TARGETS BenchmarkExample EXPORT PcapPlusPlusTargets RUNTIME DESTINATION ${PCAPPP_INSTALL_BINDIR})\n-\n-  if(TARGET BenchmarkExampleGoogle)\n-    install(TARGETS BenchmarkExampleGoogle EXPORT PcapPlusPlusTargets RUNTIME DESTINATION ${PCAPPP_INSTALL_BINDIR})\n-  endif()\n-endif()\ndiff --git a/Examples/PcapPlusPlus-benchmark/README.md b/Examples/PcapPlusPlus-benchmark/README.md\ndeleted file mode 100644\nindex dc481dcd..00000000\n--- a/Examples/PcapPlusPlus-benchmark/README.md\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-PcapPlusPlus Benchmark\n-======================\n-\n-This folder contains benchmark applications for measuring the performance of PcapPlusPlus. Currently, there are two benchmark applications.\n-\n-## Compare with other libraries\n-\n-A benchmark application used for measuring PcapPlusPlus performance can be found in `benchmark.cpp`. It is based on Matias Fontanini's packet-capture-benchmarks project (https://github.com/mfontanini/packet-capture-benchmarks) and allows us to compare PcapPlusPlus with other packet libraries. See this page for more details and result comparisons: https://pcapplusplus.github.io/docs/benchmark\n-\n-## Directly benchmark PcapPlusPlus\n-\n-Another application integrates with the Google Benchmark library and can be found in `benchmark-google.cpp`. This application currently consists of four different benchmarks, and each benchmark can be influenced by various factors. These benchmarks aim to utilize different influence factors to provide accurate results for different scenarios. You can check the table below for more information. For performance-critical applications using PcapPlusPlus, it is recommended to run benchmarks in your specific environment for more accurate results. Using larger pcap files and those with diverse protocols and sessions can provide better insights into PcapPlusPlus performance in your setup.\n-\n-|     Benchmark     |   Operation   |  Influencing factors |\n-|:-----------------:|:-------------:|:--------------------:|\n-| BM_PcapFileRead   |     Read      |  CPU + Disk (Read)   |\n-| BM_PcapFileWrite  |     Write     |  CPU + Disk (Write)  |\n-| BM_PacketParsing  | Read + Parse  |  CPU + Disk (Read)   |\n-| BM_PacketCrafting |     Craft     |        CPU           |\ndiff --git a/Examples/PcapPlusPlus-benchmark/benchmark-google.cpp b/Examples/PcapPlusPlus-benchmark/benchmark-google.cpp\ndeleted file mode 100644\nindex e12ccc30..00000000\n--- a/Examples/PcapPlusPlus-benchmark/benchmark-google.cpp\n+++ /dev/null\n@@ -1,236 +0,0 @@\n-#include <Packet.h>\n-#include <PcapFileDevice.h>\n-#include <PcapPlusPlusVersion.h>\n-\n-#include <EthLayer.h>\n-#include <IPv4Layer.h>\n-#include <IPv6Layer.h>\n-#include <TcpLayer.h>\n-#include <UdpLayer.h>\n-\n-#include <benchmark/benchmark.h>\n-\n-#include <iostream>\n-\n-static std::string pcapFileName = \"\";\n-\n-static void BM_PcapFileRead(benchmark::State& state)\n-{\n-\t// Open the pcap file for reading\n-\tpcpp::PcapFileReaderDevice reader(pcapFileName);\n-\tif (!reader.open())\n-\t{\n-\t\tstate.SkipWithError(\"Cannot open pcap file for reading\");\n-\t\treturn;\n-\t}\n-\n-\tsize_t totalBytes = 0;\n-\tsize_t totalPackets = 0;\n-\tpcpp::RawPacket rawPacket;\n-\tfor (auto _ : state)\n-\t{\n-\t\tif (!reader.getNextPacket(rawPacket))\n-\t\t{\n-\t\t\t// If the rawPacket is empty there should be an error\n-\t\t\tif (totalBytes == 0)\n-\t\t\t{\n-\t\t\t\tstate.SkipWithError(\"Cannot read packet\");\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// Rewind the file if it reached the end\n-\t\t\tstate.PauseTiming();\n-\t\t\treader.close();\n-\t\t\treader.open();\n-\t\t\tstate.ResumeTiming();\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\t++totalPackets;\n-\t\ttotalBytes += rawPacket.getRawDataLen();\n-\t}\n-\n-\tstate.SetBytesProcessed(totalBytes);\n-\tstate.SetItemsProcessed(totalPackets);\n-}\n-BENCHMARK(BM_PcapFileRead);\n-\n-static void BM_PcapFileWrite(benchmark::State& state)\n-{\n-\t// Open the pcap file for writing\n-\tpcpp::PcapFileWriterDevice writer(\"benchmark-output.pcap\");\n-\tif (!writer.open())\n-\t{\n-\t\tstate.SkipWithError(\"Cannot open pcap file for writing\");\n-\t\treturn;\n-\t}\n-\n-\tpcpp::Packet packet;\n-\tpcpp::EthLayer ethLayer(pcpp::MacAddress(\"00:00:00:00:00:00\"), pcpp::MacAddress(\"00:00:00:00:00:00\"));\n-\tpcpp::IPv4Layer ip4Layer(pcpp::IPv4Address(\"192.168.0.1\"), pcpp::IPv4Address(\"192.168.0.2\"));\n-\tpcpp::TcpLayer tcpLayer(12345, 80);\n-\n-\tpacket.addLayer(&ethLayer);\n-\tpacket.addLayer(&ip4Layer);\n-\tpacket.addLayer(&tcpLayer);\n-\tpacket.computeCalculateFields();\n-\n-\tsize_t totalBytes = 0;\n-\tsize_t totalPackets = 0;\n-\tfor (auto _ : state)\n-\t{\n-\t\t// Write packet to file\n-\t\twriter.writePacket(*(packet.getRawPacket()));\n-\n-\t\t// Count total bytes and packets\n-\t\t++totalPackets;\n-\t\ttotalBytes += packet.getRawPacket()->getRawDataLen();\n-\t}\n-\n-\t// Set statistics to the benchmark state\n-\tstate.SetBytesProcessed(totalBytes);\n-\tstate.SetItemsProcessed(totalPackets);\n-}\n-BENCHMARK(BM_PcapFileWrite);\n-\n-static void BM_PacketParsing(benchmark::State& state)\n-{\n-\t// Open the pcap file for reading\n-\tsize_t totalBytes = 0;\n-\tsize_t totalPackets = 0;\n-\tpcpp::PcapFileReaderDevice reader(pcapFileName);\n-\tif (!reader.open())\n-\t{\n-\t\tstate.SkipWithError(\"Cannot open pcap file for reading\");\n-\t\treturn;\n-\t}\n-\n-\tpcpp::RawPacket rawPacket;\n-\tfor (auto _ : state)\n-\t{\n-\t\tif (!reader.getNextPacket(rawPacket))\n-\t\t{\n-\t\t\t// If the rawPacket is empty there should be an error\n-\t\t\tif (totalBytes == 0)\n-\t\t\t{\n-\t\t\t\tstate.SkipWithError(\"Cannot read packet\");\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// Rewind the file if it reached the end\n-\t\t\tstate.PauseTiming();\n-\t\t\treader.close();\n-\t\t\treader.open();\n-\t\t\tstate.ResumeTiming();\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\t// Parse packet\n-\t\tpcpp::Packet parsedPacket(&rawPacket);\n-\n-\t\t// Use parsedPacket to prevent compiler optimizations\n-\t\tassert(parsedPacket.getFirstLayer());\n-\n-\t\t// Count total bytes and packets\n-\t\t++totalPackets;\n-\t\ttotalBytes += rawPacket.getRawDataLen();\n-\t}\n-\n-\t// Set statistics to the benchmark state\n-\tstate.SetBytesProcessed(totalBytes);\n-\tstate.SetItemsProcessed(totalPackets);\n-}\n-BENCHMARK(BM_PacketParsing);\n-\n-static void BM_PacketCrafting(benchmark::State& state)\n-{\n-\tsize_t totalBytes = 0;\n-\tsize_t totalPackets = 0;\n-\n-\tfor (auto _ : state)\n-\t{\n-\t\tuint8_t randNum = static_cast<uint8_t>(rand() % 256);\n-\n-\t\tpcpp::Packet packet;\n-\n-\t\t// Generate random MAC addresses\n-\t\tpcpp::MacAddress srcMac(randNum, randNum, randNum, randNum, randNum, randNum);\n-\t\tpcpp::MacAddress dstMac(randNum, randNum, randNum, randNum, randNum, randNum);\n-\t\tpacket.addLayer(new pcpp::EthLayer(srcMac, dstMac), true);\n-\n-\t\t// Randomly choose between IPv4 and IPv6\n-\t\tif (randNum % 2)\n-\t\t{\n-\t\t\tpacket.addLayer(new pcpp::IPv4Layer(randNum, randNum), true);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tstd::array<uint8_t, 16> srcIP = { randNum, randNum, randNum, randNum, randNum, randNum, randNum, randNum,\n-\t\t\t\t                              randNum, randNum, randNum, randNum, randNum, randNum, randNum, randNum };\n-\t\t\tstd::array<uint8_t, 16> dstIP = { randNum, randNum, randNum, randNum, randNum, randNum, randNum, randNum,\n-\t\t\t\t                              randNum, randNum, randNum, randNum, randNum, randNum, randNum, randNum };\n-\n-\t\t\tpacket.addLayer(new pcpp::IPv6Layer(srcIP, dstIP), true);\n-\t\t}\n-\n-\t\t// Randomly choose between TCP and UDP\n-\t\tif (randNum % 2)\n-\t\t{\n-\t\t\tpacket.addLayer(new pcpp::TcpLayer(randNum % 65536, randNum % 65536), true);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tpacket.addLayer(new pcpp::UdpLayer(randNum % 65536, randNum % 65536), true);\n-\t\t}\n-\n-\t\t// Calculate all fields to update the packet\n-\t\tpacket.computeCalculateFields();\n-\n-\t\t// Count total bytes and packets\n-\t\t++totalPackets;\n-\t\ttotalBytes += packet.getRawPacket()->getRawDataLen();\n-\t}\n-\n-\t// Set statistics to the benchmark state\n-\tstate.SetBytesProcessed(totalBytes);\n-\tstate.SetItemsProcessed(totalPackets);\n-}\n-BENCHMARK(BM_PacketCrafting);\n-\n-int main(int argc, char** argv)\n-{\n-\t// Initialize the benchmark\n-\tbenchmark::Initialize(&argc, argv);\n-\n-\t// Parse command line arguments to find the pcap file name\n-\tfor (int idx = 1; idx < argc; ++idx)\n-\t{\n-\t\tif (strcmp(argv[idx], \"--pcap-file\") == 0)\n-\t\t{\n-\t\t\tif (idx == argc - 1)\n-\t\t\t{\n-\t\t\t\tstd::cerr << \"Please provide a pcap file name after --pcap-file\" << std::endl;\n-\t\t\t\treturn 1;\n-\t\t\t}\n-\n-\t\t\tpcapFileName = argv[idx + 1];\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\n-\tif (pcapFileName.empty())\n-\t{\n-\t\tstd::cerr << \"Please provide a pcap file name using --pcap-file\" << std::endl;\n-\t\treturn 1;\n-\t}\n-\n-\tbenchmark::AddCustomContext(\"PcapPlusPlus version\", pcpp::getPcapPlusPlusVersionFull());\n-\tbenchmark::AddCustomContext(\"Build info\", pcpp::getBuildDateTime());\n-\tbenchmark::AddCustomContext(\"Git info\", pcpp::getGitInfo());\n-\tbenchmark::AddCustomContext(\"Pcap file\", pcapFileName);\n-\n-\t// Run the benchmarks\n-\tbenchmark::RunSpecifiedBenchmarks();\n-\n-\treturn 0;\n-}\ndiff --git a/Examples/PcapPlusPlus-benchmark/benchmark.cpp b/Examples/PcapPlusPlus-benchmark/benchmark.cpp\ndeleted file mode 100644\nindex 96c77ca6..00000000\n--- a/Examples/PcapPlusPlus-benchmark/benchmark.cpp\n+++ /dev/null\n@@ -1,109 +0,0 @@\n-/**\n- * PcapPlusPlus benchmark application\n- * ==================================\n- * This application is meant to run a benchmark for PcapPlusPlus as part of the \"packet-capture-benchmarks\" project\n- * created by Matias Fontanini: https://github.com/mfontanini/packet-capture-benchmarks The application follows the\n- * project's convention so the benchmark code is very similar to other existing benchmarks in this project with minor\n- * changes necessary to test and run PcapPlusPlus. This application currently compiles and runs on Linux only, I didn't\n- * manage to compile it on Windows with MinGW (issues related to to compiling a C++11 application together with WinPcap.\n- * There's probably a solution but I didn't find it yet) In order to run this benchmark please download\n- * packet-capture-benchmarks and compile the existing benchmarks . Then build PcapPlusPlus which will also build the\n- * benchmark in `<cmake_build_dir>/examples_bin/benchmark`. Copy this executable to\n- * `packet-capture-benchmarks/pcapplusplus` Then run the `benchmark.sh` script provided in `packet-capture-benchmarks`\n- * with all benchmarks you want to run. For example:\n- * `./benchmark.sh libpcap PcapPlusPlus libtins libcrafter`\n- */\n-\n-#include <Packet.h>\n-#include <DnsLayer.h>\n-#include <PcapFileDevice.h>\n-#include <iostream>\n-#include <chrono>\n-#include <string>\n-#include <vector>\n-#include <numeric>\n-\n-using namespace pcpp;\n-\n-size_t count = 0;\n-\n-bool handle_dns(Packet& packet)\n-{\n-\tif (!packet.isPacketOfType(DNS))\n-\t\treturn true;\n-\n-\tDnsLayer* dnsLayer = packet.getLayerOfType<DnsLayer>();\n-\n-\tDnsQuery* query = dnsLayer->getFirstQuery();\n-\twhile (query != nullptr)\n-\t{\n-\t\tcount++;\n-\t\tquery = dnsLayer->getNextQuery(query);\n-\t}\n-\n-\tDnsResource* answer = dnsLayer->getFirstAnswer();\n-\twhile (answer != nullptr)\n-\t{\n-\t\tcount++;\n-\t\tanswer = dnsLayer->getNextAnswer(answer);\n-\t}\n-\n-\treturn true;\n-}\n-\n-bool handle_packet(Packet& packet)\n-{\n-\tcount++;\n-\treturn true;\n-}\n-\n-int main(int argc, char* argv[])\n-{\n-\tif (argc != 4)\n-\t{\n-\t\tstd::cout << \"Usage: \" << *argv << \" <input-file> <dns|packet> <repetitions>\\n\";\n-\t\treturn 1;\n-\t}\n-\tstd::string input_type(argv[2]);\n-\tint total_runs = std::stoi(argv[3]);\n-\tsize_t total_packets = 0;\n-\tstd::vector<std::chrono::high_resolution_clock::duration> durations;\n-\tfor (int i = 0; i < total_runs; ++i)\n-\t{\n-\t\tcount = 0;\n-\t\tPcapFileReaderDevice reader(argv[1]);\n-\t\treader.open();\n-\t\tstd::chrono::high_resolution_clock::time_point start;\n-\t\tif (input_type == \"dns\")\n-\t\t{\n-\t\t\tstart = std::chrono::high_resolution_clock::now();\n-\t\t\tRawPacket rawPacket;\n-\t\t\twhile (reader.getNextPacket(rawPacket))\n-\t\t\t{\n-\t\t\t\tPacket packet(&rawPacket);\n-\t\t\t\thandle_dns(packet);\n-\t\t\t}\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tstart = std::chrono::high_resolution_clock::now();\n-\t\t\tRawPacket rawPacket;\n-\t\t\twhile (reader.getNextPacket(rawPacket))\n-\t\t\t{\n-\t\t\t\tPacket packet(&rawPacket, pcpp::TCP);\n-\t\t\t\thandle_packet(packet);\n-\t\t\t}\n-\t\t}\n-\t\tauto end = std::chrono::high_resolution_clock::now();\n-\t\tdurations.push_back(end - start);\n-\t\ttotal_packets += count;\n-\t\treader.close();\n-\t}\n-\tauto total_time =\n-\t    std::accumulate(durations.begin(), durations.end(), std::chrono::high_resolution_clock::duration(0));\n-\n-\tusing std::chrono::duration_cast;\n-\tusing std::chrono::milliseconds;\n-\tauto total_time_in_ms = duration_cast<milliseconds>(total_time).count();\n-\tstd::cout << (total_packets / total_runs) << \" \" << (total_time_in_ms / durations.size()) << std::endl;\n-}\ndiff --git a/Packet++/src/GtpLayer.cpp b/Packet++/src/GtpLayer.cpp\nindex 2e935cf5..808efef9 100644\n--- a/Packet++/src/GtpLayer.cpp\n+++ b/Packet++/src/GtpLayer.cpp\n@@ -405,19 +405,22 @@ namespace pcpp\n \t\t\tPCPP_LOG_ERROR(\"Add extension failed: cannot extend layer\");\n \t\t\treturn {};\n \t\t}\n-\n-\t\t// lastExt != null means layer contains 1 or more extensions\n-\t\tif (!lastExt.isNull())\n-\t\t{\n-\t\t\t// set the next header type in the last extension\n-\t\t\tlastExt.setNextHeaderType(extensionType);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\t// mark extension flags in the layer\n-\t\t\theader->extensionHeaderFlag = 1;\n-\t\t\theaderExtra->nextExtensionHeader = extensionType;\n-\t\t}\n+        // lastExt != null means layer contains 1 or more extensions\n+        // Re-acquire header pointers after extendLayer, as m_Data may have changed\n+        header = getHeader();\n+        headerExtra = getHeaderExtra();\n+\n+        if (!lastExt.isNull())\n+        {\n+            // set the next header type in the last extension\n+            lastExt.setNextHeaderType(extensionType);\n+        }\n+        else\n+        {\n+            // mark extension flags in the layer\n+            header->extensionHeaderFlag = 1;\n+            headerExtra->nextExtensionHeader = extensionType;\n+        }\n \n \t\t// create the extension data and return the extension object to the user\n \t\treturn GtpV1Layer::GtpExtension::createGtpExtension(\n"}]