
diff --git a/.gitignore b/.gitignore
index b8eb03412fa..e959803a362 100644
--- a/.gitignore
+++ b/.gitignore
@@ -296,3 +296,12 @@ tmp-php.ini
 !/ext/fileinfo/magicdata.patch
 !/ext/pcre/pcre2lib/config.h
 !/win32/build/Makefile
+build/
+Build/
+bin/
+lib/
+*.out
+*.exe
+*.dll
+*.so
+*.dylib
diff --git a/ext/spl/spl_array.c b/ext/spl/spl_array.c
index dbe110f7c40..82bd846688d 100644
--- a/ext/spl/spl_array.c
+++ b/ext/spl/spl_array.c
@@ -119,13 +119,38 @@ static zend_never_inline void spl_array_create_ht_iter(HashTable *ht, spl_array_
 }
 /* }}} */
 
-static zend_always_inline uint32_t *spl_array_get_pos_ptr(HashTable *ht, spl_array_object* intern) /* {{{ */
+/* Helper to instantiate a child iterator with a deep copy of the array */
+static void spl_instantiate_child_arg(zend_class_entry *pce, zval *retval, zval *arg1, zval *arg2)
 {
-	if (UNEXPECTED(intern->ht_iter == (uint32_t)-1)) {
-		spl_array_create_ht_iter(ht, intern);
+	object_init_ex(retval, pce);
+	spl_array_object *new_intern = Z_SPLARRAY_P(retval);
+	/*
+	 * set new_intern->is_child is true to indicate that the object was created by
+	 * RecursiveArrayIterator::getChildren() method.
+	 */
+	new_intern->is_child = true;
+
+	/* Do not set bucket for child objects to avoid dangling pointer */
+	new_intern->bucket = NULL;
+
+	/* Deep copy the array if arg1 is an array */
+	if (Z_TYPE_P(arg1) == IS_ARRAY) {
+		ZVAL_ARR(&new_intern->array, zend_array_dup(Z_ARRVAL_P(arg1)));
+		new_intern->ar_flags |= SPL_ARRAY_IS_SELF;
+	} else {
+		ZVAL_COPY(&new_intern->array, arg1);
 	}
+
+	/* Do not call the constructor for child objects to avoid overwriting the deep copy */
+	// zend_call_known_instance_method_with_2_params(pce->constructor, Z_OBJ_P(retval), NULL, arg1, arg2);
+}
+static uint32_t *spl_array_get_pos_ptr(HashTable *ht, spl_array_object *intern)
+{
 	return &EG(ht_iterators)[intern->ht_iter].pos;
 }
+
+
+
 /* }}} */
 
 /* {{{ spl_array_object_free_storage */
@@ -139,7 +164,9 @@ static void spl_array_object_free_storage(zend_object *object)
 
 	zend_object_std_dtor(&intern->std);
 
-	zval_ptr_dtor(&intern->array);
+	if (intern->ar_flags & SPL_ARRAY_IS_SELF) {
+		zval_ptr_dtor(&intern->array);
+	}
 }
 /* }}} */
 
@@ -530,6 +557,7 @@ static void spl_array_unset_dimension_ex(int check_inherited, zend_object *objec
 	HashTable *ht;
 	spl_array_object *intern = spl_array_from_obj(object);
 	spl_hash_key key;
+	uint32_t refcount = 0;
 
 	if (check_inherited && intern->fptr_offset_del) {
 		zend_call_method_with_1_params(object, object->ce, &intern->fptr_offset_del, "offsetUnset", NULL, offset);
@@ -541,13 +569,14 @@ static void spl_array_unset_dimension_ex(int check_inherited, zend_object *objec
 		return;
 	}
 
+	ht = spl_array_get_hash_table(intern);
+
 	if (get_hash_key(&key, intern, offset) == FAILURE) {
 		zend_type_error("Illegal offset type in unset");
 		return;
 	}
 
-	ht = spl_array_get_hash_table(intern);
-	uint32_t refcount = spl_array_set_refcount(intern->is_child, ht, 1);
+	refcount = spl_array_set_refcount(intern->is_child, ht, 1);
 
 	if (key.key) {
 		zval *data = zend_hash_find(ht, key.key);
@@ -575,7 +604,7 @@ static void spl_array_unset_dimension_ex(int check_inherited, zend_object *objec
 	if (refcount) {
 		spl_array_set_refcount(intern->is_child, ht, refcount);
 	}
-} /* }}} */
+}
 
 static void spl_array_unset_dimension(zend_object *object, zval *offset) /* {{{ */
 {
@@ -1060,7 +1089,7 @@ static void spl_array_set_array(zval *object, spl_array_object *intern, zval *ar
 			//??? TODO: try to avoid array duplication
 			ZVAL_ARR(&intern->array, zend_array_dup(Z_ARR_P(array)));
 
-			if (intern->is_child) {
+			if (intern->is_child && intern->bucket) {
 				Z_TRY_DELREF(intern->bucket->val);
 				/*
 				 * replace bucket->val with copied array, so the changes between
@@ -1518,19 +1547,13 @@ PHP_METHOD(ArrayIterator, valid)
 
 	RETURN_BOOL(zend_hash_has_more_elements_ex(aht, spl_array_get_pos_ptr(aht, intern)) == SUCCESS);
 }
-/* }}} */
-
-/* {{{ Check whether current element has children (e.g. is an array) */
+/* {{{ Check whether the current element has children */
 PHP_METHOD(RecursiveArrayIterator, hasChildren)
 {
 	zval *object = ZEND_THIS, *entry;
 	spl_array_object *intern = Z_SPLARRAY_P(object);
 	HashTable *aht = spl_array_get_hash_table(intern);
 
-	if (zend_parse_parameters_none() == FAILURE) {
-		RETURN_THROWS();
-	}
-
 	if ((entry = zend_hash_get_current_data_ex(aht, spl_array_get_pos_ptr(aht, intern))) == NULL) {
 		RETURN_FALSE;
 	}
@@ -1544,20 +1567,11 @@ PHP_METHOD(RecursiveArrayIterator, hasChildren)
 }
 /* }}} */
 
-static void spl_instantiate_child_arg(zend_class_entry *pce, zval *retval, zval *arg1, zval *arg2) /* {{{ */
-{
-	object_init_ex(retval, pce);
-	spl_array_object *new_intern = Z_SPLARRAY_P(retval);
-	/*
-	 * set new_intern->is_child is true to indicate that the object was created by
-	 * RecursiveArrayIterator::getChildren() method.
-	 */
-	new_intern->is_child = true;
+/* }}} */
+
+
+
 
-	/* find the bucket of parent object. */
-	new_intern->bucket = (Bucket *)((char *)(arg1) - XtOffsetOf(Bucket, val));;
-	zend_call_known_instance_method_with_2_params(pce->constructor, Z_OBJ_P(retval), NULL, arg1, arg2);
-}
 /* }}} */
 
 /* {{{ Create a sub iterator for the current element (same class as $this) */
@@ -1578,6 +1592,7 @@ PHP_METHOD(RecursiveArrayIterator, getChildren)
 	if (Z_TYPE_P(entry) == IS_INDIRECT) {
 		entry = Z_INDIRECT_P(entry);
 	}
+/* Helper to instantiate a child iterator with a deep copy of the array */
 
 	ZVAL_DEREF(entry);
 	if (Z_TYPE_P(entry) == IS_OBJECT) {
