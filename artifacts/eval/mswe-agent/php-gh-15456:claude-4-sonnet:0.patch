
diff --git a/.gitignore b/.gitignore
index d54334f599a..3a5943bfb9b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -297,3 +297,12 @@ tmp-php.ini
 !/ext/dom/lexbor/patches/*.patch
 !/ext/pcre/pcre2lib/config.h
 !/win32/build/Makefile
+build/
+Build/
+bin/
+lib/
+*.out
+*.exe
+*.dll
+*.so
+*.dylib
diff --git a/Zend/zend_objects_API.c b/Zend/zend_objects_API.c
index 8a6b714c8b3..79d861ec411 100644
--- a/Zend/zend_objects_API.c
+++ b/Zend/zend_objects_API.c
@@ -159,6 +159,11 @@ ZEND_API void ZEND_FASTCALL zend_objects_store_put(zend_object *object)
 
 ZEND_API void ZEND_FASTCALL zend_objects_store_del(zend_object *object) /* {{{ */
 {
+	uint32_t handle;
+	zend_object_handlers *handlers;
+	zend_class_entry *ce;
+	uint32_t obj_flags;
+
 	ZEND_ASSERT(GC_REFCOUNT(object) == 0);
 
 	/* GC might have released this object already. */
@@ -166,22 +171,108 @@ ZEND_API void ZEND_FASTCALL zend_objects_store_del(zend_object *object) /* {{{ *
 		return;
 	}
 
+	/* Save all object fields we need before any potential freeing */
+	handle = object->handle;
+	handlers = object->handlers;
+	ce = object->ce;
+	obj_flags = OBJ_FLAGS(object);
+
+	/* Check if object has already been freed to prevent use-after-free */
+	if (UNEXPECTED(obj_flags & IS_OBJ_FREE_CALLED)) {
+		return;
+	}
+	
+	/* Additional check: verify object handle is valid */
+	if (UNEXPECTED(handle >= EG(objects_store).top || 
+	               !IS_OBJ_VALID(EG(objects_store).object_buckets[handle]) ||
+	               EG(objects_store).object_buckets[handle] != object)) {
+		return;
+	}
+
 	/*	Make sure we hold a reference count during the destructor call
 		otherwise, when the destructor ends the storage might be freed
 		when the refcount reaches 0 a second time
 	 */
-	if (!(OBJ_FLAGS(object) & IS_OBJ_DESTRUCTOR_CALLED)) {
+	if (!(obj_flags & IS_OBJ_DESTRUCTOR_CALLED)) {
 		GC_ADD_FLAGS(object, IS_OBJ_DESTRUCTOR_CALLED);
 
-		if (object->handlers->dtor_obj != zend_objects_destroy_object
-				|| object->ce->destructor) {
+		if (handlers->dtor_obj != zend_objects_destroy_object
+				|| ce->destructor) {
+			
 			GC_SET_REFCOUNT(object, 1);
-			object->handlers->dtor_obj(object);
-			GC_DELREF(object);
+			handlers->dtor_obj(object);
+			/* Check if object is still valid after destructor call */
+			if (GC_TYPE(object) != IS_NULL) {
+				GC_DELREF(object);
+				/* Continue with normal cleanup if object is still valid */
+				if (GC_REFCOUNT(object) == 0) {
+					void *ptr;
+
+					ZEND_ASSERT(EG(objects_store).object_buckets != NULL);
+					ZEND_ASSERT(IS_OBJ_VALID(EG(objects_store).object_buckets[handle]));
+					EG(objects_store).object_buckets[handle] = SET_OBJ_INVALID(object);
+					if (!(OBJ_FLAGS(object) & IS_OBJ_FREE_CALLED)) {
+						GC_ADD_FLAGS(object, IS_OBJ_FREE_CALLED);
+						GC_SET_REFCOUNT(object, 1);
+						handlers->free_obj(object);
+					}
+					ptr = ((char*)object) - handlers->offset;
+					GC_REMOVE_FROM_BUFFER(object);
+					efree(ptr);
+					ZEND_OBJECTS_STORE_ADD_TO_FREE_LIST(handle);
+				}
+			} else {
+				/* Object was freed during destructor, clean up the store entry */
+				ZEND_ASSERT(EG(objects_store).object_buckets != NULL);
+				EG(objects_store).object_buckets[handle] = SET_OBJ_INVALID(object);
+				ZEND_OBJECTS_STORE_ADD_TO_FREE_LIST(handle);
+			}
+			return;
+		}
+	}
+
+	if (GC_TYPE(object) != IS_NULL && GC_REFCOUNT(object) == 0) {
+		void *ptr;
+
+		ZEND_ASSERT(EG(objects_store).object_buckets != NULL);
+		ZEND_ASSERT(IS_OBJ_VALID(EG(objects_store).object_buckets[handle]));
+		EG(objects_store).object_buckets[handle] = SET_OBJ_INVALID(object);
+		if (!(OBJ_FLAGS(object) & IS_OBJ_FREE_CALLED)) {
+			GC_ADD_FLAGS(object, IS_OBJ_FREE_CALLED);
+			GC_SET_REFCOUNT(object, 1);
+			handlers->free_obj(object);
+		}
+		ptr = ((char*)object) - handlers->offset;
+		GC_REMOVE_FROM_BUFFER(object);
+		efree(ptr);
+		ZEND_OBJECTS_STORE_ADD_TO_FREE_LIST(handle);
+	}
+					void *ptr;
+
+					ZEND_ASSERT(EG(objects_store).object_buckets != NULL);
+					ZEND_ASSERT(IS_OBJ_VALID(EG(objects_store).object_buckets[handle]));
+					EG(objects_store).object_buckets[handle] = SET_OBJ_INVALID(object);
+					if (!(OBJ_FLAGS(object) & IS_OBJ_FREE_CALLED)) {
+						GC_ADD_FLAGS(object, IS_OBJ_FREE_CALLED);
+						GC_SET_REFCOUNT(object, 1);
+						object->handlers->free_obj(object);
+					}
+					ptr = ((char*)object) - object->handlers->offset;
+					GC_REMOVE_FROM_BUFFER(object);
+					efree(ptr);
+					ZEND_OBJECTS_STORE_ADD_TO_FREE_LIST(handle);
+				}
+			} else {
+				/* Object was freed during destructor, clean up the store entry */
+				ZEND_ASSERT(EG(objects_store).object_buckets != NULL);
+				EG(objects_store).object_buckets[handle] = SET_OBJ_INVALID(object);
+				ZEND_OBJECTS_STORE_ADD_TO_FREE_LIST(handle);
+			}
+			return;
 		}
 	}
 
-	if (GC_REFCOUNT(object) == 0) {
+	if (GC_TYPE(object) != IS_NULL && GC_REFCOUNT(object) == 0) {
 		uint32_t handle = object->handle;
 		void *ptr;
 
diff --git a/test_script.php b/test_script.php
new file mode 100644
index 00000000000..e5303502091
--- /dev/null
+++ b/test_script.php
@@ -0,0 +1,22 @@
+<?php
+
+class B {
+    public $b;
+    function __construct($arg) {
+        $this->b = $arg;
+    }
+}
+
+class C {
+    function __destruct() {
+        global $arr;
+        echo __METHOD__, "\n";
+        $arr->exchangeArray([]);
+    }
+}
+
+$arr = new ArrayObject(new B(new C));
+unset($arr["b"]);
+var_dump($arr);
+
+?>
