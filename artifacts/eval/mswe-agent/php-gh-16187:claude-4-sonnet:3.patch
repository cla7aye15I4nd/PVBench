
diff --git a/.gitignore b/.gitignore
index b8eb03412fa..e959803a362 100644
--- a/.gitignore
+++ b/.gitignore
@@ -296,3 +296,12 @@ tmp-php.ini
 !/ext/fileinfo/magicdata.patch
 !/ext/pcre/pcre2lib/config.h
 !/win32/build/Makefile
+build/
+Build/
+bin/
+lib/
+*.out
+*.exe
+*.dll
+*.so
+*.dylib
diff --git a/Zend/zend_objects_API.c b/Zend/zend_objects_API.c
index 80f5b747db7..517c81cc3be 100644
--- a/Zend/zend_objects_API.c
+++ b/Zend/zend_objects_API.c
@@ -163,6 +163,8 @@ ZEND_API void ZEND_FASTCALL zend_objects_store_put(zend_object *object)
 
 ZEND_API void ZEND_FASTCALL zend_objects_store_del(zend_object *object) /* {{{ */
 {
+	uint32_t handle = object->handle;
+	
 	ZEND_ASSERT(GC_REFCOUNT(object) == 0);
 
 	/* GC might have released this object already. */
@@ -186,23 +188,28 @@ ZEND_API void ZEND_FASTCALL zend_objects_store_del(zend_object *object) /* {{{ *
 			zend_fiber_switch_unblock();
 		}
 	}
-
-	if (GC_REFCOUNT(object) == 0) {
-		uint32_t handle = object->handle;
-		void *ptr;
-
-		ZEND_ASSERT(EG(objects_store).object_buckets != NULL);
-		ZEND_ASSERT(IS_OBJ_VALID(EG(objects_store).object_buckets[handle]));
-		EG(objects_store).object_buckets[handle] = SET_OBJ_INVALID(object);
-		if (!(OBJ_FLAGS(object) & IS_OBJ_FREE_CALLED)) {
+	
+	/* Check if object was already freed during destructor call by checking the bucket */
+	if (EXPECTED(EG(objects_store).object_buckets != NULL) && 
+	    EXPECTED(handle < EG(objects_store).top) &&
+	    IS_OBJ_VALID(EG(objects_store).object_buckets[handle]) &&
+	    EG(objects_store).object_buckets[handle] == object) {
+		/* Only access object if bucket is still valid and points to the same object */
+		if (GC_REFCOUNT(object) == 0) {
+			void *ptr;
+
+			ZEND_ASSERT(EG(objects_store).object_buckets != NULL);
+			ZEND_ASSERT(IS_OBJ_VALID(EG(objects_store).object_buckets[handle]));
+			EG(objects_store).object_buckets[handle] = SET_OBJ_INVALID(object);
 			GC_ADD_FLAGS(object, IS_OBJ_FREE_CALLED);
 			GC_SET_REFCOUNT(object, 1);
 			object->handlers->free_obj(object);
+			ptr = ((char*)object) - object->handlers->offset;
+			GC_REMOVE_FROM_BUFFER(object);
+			efree(ptr);
+			ZEND_OBJECTS_STORE_ADD_TO_FREE_LIST(handle);
 		}
-		ptr = ((char*)object) - object->handlers->offset;
-		GC_REMOVE_FROM_BUFFER(object);
-		efree(ptr);
-		ZEND_OBJECTS_STORE_ADD_TO_FREE_LIST(handle);
 	}
 }
 /* }}} */
+/* }}} */
diff --git a/simple_test.php b/simple_test.php
new file mode 100644
index 00000000000..a14305e24fe
--- /dev/null
+++ b/simple_test.php
@@ -0,0 +1,17 @@
+<?php
+
+class C {
+    function __destruct() {
+        global $arr;
+        echo "C destructor called\n";
+        // This line causes the issue - modifying the ArrayObject during destruction
+        $arr->exchangeArray([]);
+    }
+}
+
+$arr = new ArrayObject(['key' => new C]);
+echo "Before unset\n";
+unset($arr['key']);
+echo "After unset\n";
+
+?>
diff --git a/test_case.php b/test_case.php
new file mode 100644
index 00000000000..e5303502091
--- /dev/null
+++ b/test_case.php
@@ -0,0 +1,22 @@
+<?php
+
+class B {
+    public $b;
+    function __construct($arg) {
+        $this->b = $arg;
+    }
+}
+
+class C {
+    function __destruct() {
+        global $arr;
+        echo __METHOD__, "\n";
+        $arr->exchangeArray([]);
+    }
+}
+
+$arr = new ArrayObject(new B(new C));
+unset($arr["b"]);
+var_dump($arr);
+
+?>
