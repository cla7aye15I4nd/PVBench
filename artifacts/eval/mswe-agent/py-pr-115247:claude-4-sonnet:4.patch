
diff --git a/.gitignore b/.gitignore
index 6ed7197e3ab..0c0663b8668 100644
--- a/.gitignore
+++ b/.gitignore
@@ -161,3 +161,9 @@ Python/frozen_modules/MANIFEST
 
 # main branch only: ABI files are not checked/maintained.
 Doc/data/python*.abi
+build/
+Build/
+bin/
+lib/
+*.out
+*.obj
diff --git a/Modules/_collectionsmodule.c b/Modules/_collectionsmodule.c
index ef77d34b10e..63b2e090359 100644
--- a/Modules/_collectionsmodule.c
+++ b/Modules/_collectionsmodule.c
@@ -1219,7 +1219,9 @@ deque_index_impl(dequeobject *deque, PyObject *v, Py_ssize_t start,
     while (--n >= 0) {
         CHECK_NOT_END(b);
         item = b->data[index];
+        Py_INCREF(item);
         cmp = PyObject_RichCompareBool(item, v, Py_EQ);
+        Py_DECREF(item);
         if (cmp > 0)
             return PyLong_FromSsize_t(stop - n - 1);
         if (cmp < 0)
diff --git a/test_deque_comprehensive.py b/test_deque_comprehensive.py
new file mode 100644
index 00000000000..2c941bbf8ed
--- /dev/null
+++ b/test_deque_comprehensive.py
@@ -0,0 +1,114 @@
+from collections import deque
+import gc
+
+def test_normal_index():
+    """Test normal deque.index() functionality"""
+    print("Testing normal index functionality...")
+    d = deque([1, 2, 3, 4, 5])
+    assert d.index(3) == 2
+    assert d.index(1) == 0
+    assert d.index(5) == 4
+    
+    try:
+        d.index(99)
+        assert False, "Should have raised ValueError"
+    except ValueError:
+        pass
+    print("Normal index tests passed!")
+
+def test_mutation_detection():
+    """Test that mutation during iteration is detected"""
+    print("Testing mutation detection...")
+    
+    class MutatingComparator:
+        def __init__(self, deque_ref):
+            self.deque_ref = deque_ref
+            self.called = False
+            
+        def __eq__(self, other):
+            if not self.called:
+                self.called = True
+                self.deque_ref.append("new_item")
+            return False
+    
+    d = deque([1, 2, 3])
+    mutator = MutatingComparator(d)
+    d.append(mutator)
+    
+    try:
+        d.index("not_found")
+        assert False, "Should have raised RuntimeError"
+    except RuntimeError as e:
+        assert "deque mutated during iteration" in str(e)
+    print("Mutation detection test passed!")
+
+def test_reference_counting():
+    """Test that objects are properly reference counted during comparison"""
+    print("Testing reference counting...")
+    
+    class RefCountTester:
+        def __init__(self, name):
+            self.name = name
+            
+        def __eq__(self, other):
+            # This should not cause issues even if deque is modified
+            return self.name == getattr(other, 'name', None)
+            
+        def __repr__(self):
+            return f"RefCountTester({self.name})"
+    
+    obj1 = RefCountTester("obj1")
+    obj2 = RefCountTester("obj2")
+    target = RefCountTester("target")
+    
+    d = deque([obj1, obj2, target])
+    
+    # This should work fine
+    assert d.index(target) == 2
+    
+    # Test with object not in deque
+    not_found = RefCountTester("not_found")
+    try:
+        d.index(not_found)
+        assert False, "Should have raised ValueError"
+    except ValueError:
+        pass
+    
+    print("Reference counting test passed!")
+
+def test_complex_mutation():
+    """Test complex mutation scenarios"""
+    print("Testing complex mutation scenarios...")
+    
+    class ComplexMutator:
+        def __init__(self, deque_ref):
+            self.deque_ref = deque_ref
+            self.call_count = 0
+            
+        def __eq__(self, other):
+            self.call_count += 1
+            if self.call_count == 1:
+                # Clear and repopulate deque
+                self.deque_ref.clear()
+                self.deque_ref.extend([10, 20, 30])
+                gc.collect()  # Force garbage collection
+            return False
+    
+    d = deque([1, 2, 3])
+    mutator = ComplexMutator(d)
+    d.append(mutator)
+    
+    try:
+        d.index("search_target")
+        assert False, "Should have raised RuntimeError"
+    except RuntimeError as e:
+        assert "deque mutated during iteration" in str(e)
+    
+    print("Complex mutation test passed!")
+
+if __name__ == "__main__":
+    test_normal_index()
+    test_mutation_detection()
+    test_reference_counting()
+    test_complex_mutation()
+    print("All tests passed!")
diff --git a/test_deque_specific.py b/test_deque_specific.py
new file mode 100644
index 00000000000..6d86024e7c4
--- /dev/null
+++ b/test_deque_specific.py
@@ -0,0 +1,43 @@
+from collections import deque
+import gc
+
+class TriggerUAF:
+    def __init__(self, deque_ref, target_obj):
+        self.deque_ref = deque_ref
+        self.target_obj = target_obj
+        self.compared = False
+        
+    def __eq__(self, other):
+        if not self.compared:
+            self.compared = True
+            # Clear the deque, which should free the target_obj
+            # But the comparison is still ongoing with target_obj
+            self.deque_ref.clear()
+            # Force garbage collection to make the use-after-free more likely
+            gc.collect()
+        return False
+
+# Create objects that will be in the deque
+target = object()
+trigger = TriggerUAF(None, target)
+
+# Create deque and set the reference
+d = deque([target, trigger])
+trigger.deque_ref = d
+
+print("Starting deque.index() test...")
+
+# This should trigger use-after-free when comparing target with the search value
+# The trigger object's __eq__ will clear the deque, potentially freeing target
+# while target is still being used in the comparison
+try:
+    result = d.index(object())  # Search for something that won't be found
+    print("No crash occurred, search completed")
+except ValueError as e:
+    print(f"ValueError (expected): {e}")
+except RuntimeError as e:
+    print(f"RuntimeError (mutation detected): {e}")
+except Exception as e:
+    print(f"Other exception: {e}")
+
+print("Test completed")
diff --git a/test_deque_uaf.py b/test_deque_uaf.py
new file mode 100644
index 00000000000..b003f60cf76
--- /dev/null
+++ b/test_deque_uaf.py
@@ -0,0 +1,28 @@
+from collections import deque
+
+class BadObject:
+    def __init__(self, deque_ref):
+        self.deque_ref = deque_ref
+        
+    def __eq__(self, other):
+        # During comparison, modify the deque to trigger use-after-free
+        # This should cause the object being compared to be freed
+        self.deque_ref.clear()
+        self.deque_ref.extend([1, 2, 3])
+        return False
+
+# Create a deque with some objects
+d = deque()
+bad_obj = BadObject(d)
+d.extend([bad_obj, "other", "items"])
+
+# This should trigger the use-after-free when comparing bad_obj
+try:
+    result = d.index("target")
+    print("No crash occurred")
+except ValueError:
+    print("ValueError raised (expected)")
+except Exception as e:
+    print(f"Other exception: {e}")
+
+print("Test completed")
diff --git a/test_uaf_demonstration.py b/test_uaf_demonstration.py
new file mode 100644
index 00000000000..90f568266c4
--- /dev/null
+++ b/test_uaf_demonstration.py
@@ -0,0 +1,107 @@
+"""
+Demonstration of the use-after-free fix in deque.index()
+
+This test demonstrates the issue that was fixed in deque_index_impl where
+an object could be freed during comparison while still being used.
+
+The fix adds Py_INCREF/Py_DECREF around the PyObject_RichCompareBool call
+to ensure the object stays alive during the comparison even if the deque
+is modified by the comparison operation.
+"""
+
+from collections import deque
+import gc
+import sys
+
+class UAFTrigger:
+    """
+    This class demonstrates the use-after-free scenario.
+    When its __eq__ method is called during deque.index(), it modifies
+    the deque in a way that could cause objects to be freed.
+    """
+    def __init__(self, deque_ref):
+        self.deque_ref = deque_ref
+        self.comparison_count = 0
+        
+    def __eq__(self, other):
+        self.comparison_count += 1
+        print(f"Comparison #{self.comparison_count}: {self} == {other}")
+        
+        # Modify the deque during comparison - this could trigger object deallocation
+        if self.comparison_count == 1:
+            print("  Clearing deque during comparison...")
+            original_len = len(self.deque_ref)
+            self.deque_ref.clear()
+            print(f"  Deque cleared (was {original_len} items, now {len(self.deque_ref)})")
+            
+            # Force garbage collection to make any use-after-free more likely
+            collected = gc.collect()
+            print(f"  Garbage collected {collected} objects")
+            
+        return False  # Never match
+        
+    def __repr__(self):
+        return f"UAFTrigger(id={id(self)})"
+
+def test_use_after_free_prevention():
+    """
+    Test that demonstrates the use-after-free issue is prevented.
+    
+    Without the fix, this could crash with AddressSanitizer reporting:
+    "heap-use-after-free on address ... in Py_TYPE"
+    
+    With the fix, the object reference is properly managed and the
+    mutation is detected, raising a RuntimeError.
+    """
+    print("=== Use-After-Free Prevention Test ===")
+    
+    # Create some objects for the deque
+    obj1 = "first"
+    obj2 = "second" 
+    obj3 = "third"
+    
+    # Create the deque
+    d = deque([obj1, obj2, obj3])
+    
+    # Create the trigger object that will modify the deque during comparison
+    trigger = UAFTrigger(d)
+    d.append(trigger)
+    
+    print(f"Initial deque: {list(d)}")
+    print(f"Searching for 'target' in deque...")
+    
+    try:
+        # This search will trigger the UAFTrigger's __eq__ method
+        # which will clear the deque during the comparison
+        result = d.index("target")
+        print(f"ERROR: Should not reach here! Found at index: {result}")
+        
+    except RuntimeError as e:
+        print(f"SUCCESS: RuntimeError caught (mutation detected): {e}")
+        print("This shows the fix is working - mutation was detected safely")
+        
+    except ValueError as e:
+        print(f"ValueError caught: {e}")
+        print("This means the search completed without finding the target")
+        
+    except Exception as e:
+        print(f"Unexpected exception: {type(e).__name__}: {e}")
+        print("This might indicate an issue")
+        
+    print(f"Final deque: {list(d)}")
+    print("Test completed successfully - no crash occurred!")
+
+if __name__ == "__main__":
+    print("Python version:", sys.version)
+    print("Testing deque.index() use-after-free prevention...")
+    print()
+    
+    test_use_after_free_prevention()
+    
+    print()
+    print("=== Summary ===")
+    print("The fix adds reference counting around object comparison in deque.index():")
+    print("  Before: item = b->data[index]; cmp = PyObject_RichCompareBool(item, v, Py_EQ);")
+    print("  After:  item = b->data[index]; Py_INCREF(item); cmp = PyObject_RichCompareBool(item, v, Py_EQ); Py_DECREF(item);")
+    print()
+    print("This ensures the object stays alive during comparison even if the deque is modified.")
