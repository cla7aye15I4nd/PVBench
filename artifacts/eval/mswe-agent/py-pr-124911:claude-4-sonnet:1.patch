
diff --git a/.gitignore b/.gitignore
index bde596a7a02..cc0fc267f06 100644
--- a/.gitignore
+++ b/.gitignore
@@ -156,3 +156,9 @@ Python/frozen_modules/MANIFEST
 # Ignore ./python binary on Unix but still look into ./Python/ directory.
 /python
 !/Python/
+build/
+Build/
+bin/
+lib/
+*.out
+*.obj
diff --git a/Modules/_cursesmodule.c b/Modules/_cursesmodule.c
index 743b9e37fbc..8061b568283 100644
--- a/Modules/_cursesmodule.c
+++ b/Modules/_cursesmodule.c
@@ -2893,7 +2893,14 @@ De-initialize the library, and return terminal to normal status.
 static PyObject *
 _curses_endwin_impl(PyObject *module)
 /*[clinic end generated code: output=c0150cd96d2f4128 input=e172cfa43062f3fa]*/
-NoArgNoReturnFunctionBody(endwin)
+{
+    PyCursesInitialised
+    PyObject *result = PyCursesCheckERR(endwin(), "endwin");
+    /* Always reset the initialised flag after endwin(), even if it failed,
+     * because the curses library state is no longer reliable */
+    initialised = FALSE;
+    return result;
+}
 
 /*[clinic input]
 _curses.erasechar
diff --git a/test_combined.py b/test_combined.py
new file mode 100644
index 00000000000..42a5ce6c922
--- /dev/null
+++ b/test_combined.py
@@ -0,0 +1,28 @@
+import asyncio
+import curses
+
+async def main():
+    loop = asyncio.get_running_loop()
+    loop.set_task_factory(asyncio.eager_task_factory)
+
+    async def foo(): ...
+
+    task = asyncio.create_task(foo())
+    await task
+    print(task.get_coro())
+
+# Run the asyncio code first
+asyncio.run(main())
+
+# Now try to use curses - this might trigger the segfault
+try:
+    stdscr = curses.initscr()
+    print("curses.initscr() successful")
+    curses.endwin()
+    print("Script completed successfully, no errors.")
+except Exception as e:
+    print(f"Error occurred: {e}")
+    try:
+        curses.endwin()
+    except:
+        pass
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 00000000000..7ef0b53f89c
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,45 @@
+import curses
+
+def test_scenario(name, test_func):
+    print(f"\n=== Testing {name} ===")
+    try:
+        test_func()
+        print(f"{name}: PASSED")
+    except Exception as e:
+        print(f"{name}: FAILED - {e}")
+        import traceback
+        traceback.print_exc()
+
+def test_normal_usage():
+    """Test normal initscr -> endwin sequence"""
+    stdscr = curses.initscr()
+    curses.endwin()
+
+def test_double_initscr():
+    """Test initscr -> initscr (should work without crash)"""
+    stdscr1 = curses.initscr()
+    stdscr2 = curses.initscr()  # This should not crash
+    curses.endwin()
+
+def test_initscr_endwin_initscr():
+    """Test initscr -> endwin -> initscr (the problematic case)"""
+    stdscr1 = curses.initscr()
+    curses.endwin()
+    stdscr2 = curses.initscr()  # This was causing the segfault
+    curses.endwin()
+
+def test_multiple_cycles():
+    """Test multiple initscr/endwin cycles"""
+    for i in range(3):
+        stdscr = curses.initscr()
+        curses.endwin()
+
+# Run all tests
+print("Running comprehensive curses tests...")
+
+test_scenario("Normal usage", test_normal_usage)
+test_scenario("Double initscr", test_double_initscr)
+test_scenario("initscr->endwin->initscr", test_initscr_endwin_initscr)
+test_scenario("Multiple cycles", test_multiple_cycles)
+
+print("\nAll tests completed successfully, no segfaults!")
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 00000000000..1569a0032ed
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,32 @@
+import curses
+
+print("Testing curses initscr/endwin/initscr sequence...")
+
+try:
+    # First initscr call
+    print("Calling first initscr()...")
+    stdscr = curses.initscr()
+    print("First initscr() successful")
+    
+    # Call endwin to deinitialize
+    print("Calling endwin()...")
+    curses.endwin()
+    print("endwin() successful")
+    
+    # Second initscr call - this should work now with the fix
+    print("Calling second initscr()...")
+    stdscr2 = curses.initscr()
+    print("Second initscr() successful")
+    
+    # Clean up
+    curses.endwin()
+    print("Script completed successfully, no errors.")
+    
+except Exception as e:
+    print(f"Error occurred: {e}")
+    import traceback
+    traceback.print_exc()
+    try:
+        curses.endwin()
+    except:
+        pass
diff --git a/test_reproduce.py b/test_reproduce.py
new file mode 100644
index 00000000000..9a36bc1f13c
--- /dev/null
+++ b/test_reproduce.py
@@ -0,0 +1,19 @@
+import curses
+
+# Try to initialize curses
+try:
+    stdscr = curses.initscr()
+    print("First initscr() call successful")
+    
+    # Try to call initscr() again - this should trigger the problematic code path
+    stdscr2 = curses.initscr()
+    print("Second initscr() call successful")
+    
+    curses.endwin()
+    print("Script completed successfully, no errors.")
+except Exception as e:
+    print(f"Error occurred: {e}")
+    try:
+        curses.endwin()
+    except:
+        pass
