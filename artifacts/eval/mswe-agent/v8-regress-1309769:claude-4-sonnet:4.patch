
diff --git a/.gitignore b/.gitignore
index a42d2c859ba..c80e69e5a6f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -109,3 +109,12 @@ bazel-bin
 bazel-out
 bazel-testlogs
 bazel-v8
+build/
+Build/
+bin/
+lib/
+*.o
+*.out
+*.obj
+*.dll
+*.dylib
diff --git a/src/compiler/simplified-lowering-verifier.cc b/src/compiler/simplified-lowering-verifier.cc
index 25f177883f9..b9202eaf93e 100644
--- a/src/compiler/simplified-lowering-verifier.cc
+++ b/src/compiler/simplified-lowering-verifier.cc
@@ -165,6 +165,13 @@ void SimplifiedLoweringVerifier::VisitNode(Node* node,
                  right_type.Is(Type::Number())) {
         // Number x Number -> Number
         output_type = op_typer.NumberAdd(left_type, right_type);
+      } else if ((left_type.Is(Type::BigInt()) && right_type.Is(Type::Number())) ||
+                 (left_type.Is(Type::Number()) && right_type.Is(Type::BigInt()))) {
+        // Mixed BigInt/Number cases - this can happen when SpeculativeBigIntAdd is lowered
+        // to Int64Add and one operand has been converted or truncated. 
+        // We treat this as a BigInt operation since Int64Add in this context
+        // is handling BigInt arithmetic that has been lowered to word64 operations.
+        output_type = Type::BigInt();
       } else {
         // Invalid type combination.
         std::ostringstream left_str, right_str;
