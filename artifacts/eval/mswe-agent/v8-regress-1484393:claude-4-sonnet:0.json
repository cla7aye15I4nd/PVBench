[{"patch": "diff --git a/.gitignore b/.gitignore\nindex d35b588ef65..29d98592a37 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -116,3 +116,12 @@ bazel-bin\n bazel-out\n bazel-testlogs\n bazel-v8\n+build/\n+Build/\n+bin/\n+lib/\n+*.o\n+*.out\n+*.obj\n+*.dll\n+*.dylib\ndiff --git a/src/compiler/backend/instruction-selector-adapter.h b/src/compiler/backend/instruction-selector-adapter.h\nindex d36bacbf158..7295b5914be 100644\n--- a/src/compiler/backend/instruction-selector-adapter.h\n+++ b/src/compiler/backend/instruction-selector-adapter.h\n@@ -185,8 +185,47 @@ struct TurbofanAdapter {\n     explicit LoadView(node_t node) : node_(node) {}\n \n     LoadRepresentation loaded_rep() const {\n-      return LoadRepresentationOf(node_->op());\n+      switch (node_->opcode()) {\n+        case IrOpcode::kLoad:\n+        case IrOpcode::kProtectedLoad:\n+        case IrOpcode::kLoadTrapOnNull:\n+        case IrOpcode::kUnalignedLoad:\n+        case IrOpcode::kLoadImmutable:\n+          return LoadRepresentationOf(node_->op());\n+        case IrOpcode::kWord32AtomicLoad:\n+        case IrOpcode::kWord64AtomicLoad:\n+          return AtomicLoadParametersOf(node_->op()).representation();\n+        case IrOpcode::kLoadTransform: {\n+          LoadTransformParameters params = LoadTransformParametersOf(node_->op());\n+          // LoadTransform operations load data and transform it, so we need to\n+          // determine the load representation from the transformation type\n+          switch (params.transformation) {\n+            case LoadTransformation::kS128Load8Splat:\n+            case LoadTransformation::kS128Load8x8S:\n+            case LoadTransformation::kS128Load8x8U:\n+              return LoadRepresentation::Int8();\n+            case LoadTransformation::kS128Load16Splat:\n+            case LoadTransformation::kS128Load16x4S:\n+            case LoadTransformation::kS128Load16x4U:\n+              return LoadRepresentation::Int16();\n+            case LoadTransformation::kS128Load32Splat:\n+            case LoadTransformation::kS128Load32x2S:\n+            case LoadTransformation::kS128Load32x2U:\n+            case LoadTransformation::kS128Load32Zero:\n+              return LoadRepresentation::Int32();\n+            case LoadTransformation::kS128Load64Splat:\n+            case LoadTransformation::kS128Load64Zero:\n+              return LoadRepresentation::Int64();\n+            default:\n+              // For other transformations, assume 128-bit SIMD load\n+              return LoadRepresentation::Simd128();\n+          }\n+        }\n+        default:\n+          UNREACHABLE();\n+      }\n     }\n+\n     bool is_protected(bool* traps_on_null) const {\n       if (node_->opcode() == IrOpcode::kLoadTrapOnNull) {\n         *traps_on_null = true;\n@@ -388,8 +427,7 @@ struct TurbofanAdapter {\n            node->opcode() == IrOpcode::kLoadTrapOnNull ||\n            node->opcode() == IrOpcode::kWord32AtomicLoad ||\n            node->opcode() == IrOpcode::kWord64AtomicLoad ||\n-           node->opcode() == IrOpcode::kLoadTransform ||\n-           node->opcode() == IrOpcode::kF64x2PromoteLowF32x4;\n+           node->opcode() == IrOpcode::kLoadTransform;\n   }\n   ConstantView constant_view(node_t node) const { return ConstantView{node}; }\n   CallView call_view(node_t node) { return CallView{node}; }\n"}]