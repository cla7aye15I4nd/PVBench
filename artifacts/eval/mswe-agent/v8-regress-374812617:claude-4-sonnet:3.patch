
diff --git a/.gitignore b/.gitignore
index 9142623efa8..926f616c81e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -124,3 +124,12 @@ bazel-bin
 bazel-out
 bazel-testlogs
 bazel-v8
+build/
+Build/
+bin/
+lib/
+*.o
+*.out
+*.obj
+*.dll
+*.dylib
diff --git a/src/heap/object-stats.cc b/src/heap/object-stats.cc
index 37ecfc79099..8c1027a2cff 100644
--- a/src/heap/object-stats.cc
+++ b/src/heap/object-stats.cc
@@ -490,10 +490,11 @@ template <typename Dictionary>
 void ObjectStatsCollectorImpl::RecordHashTableVirtualObjectStats(
     Tagged<HeapObject> parent, Tagged<Dictionary> hash_table,
     ObjectStats::VirtualInstanceType type) {
-  size_t over_allocated =
-      (hash_table->Capacity() - (hash_table->NumberOfElements() +
-                                 hash_table->NumberOfDeletedElements())) *
-      Dictionary::kEntrySize * kTaggedSize;
+  size_t used_slots = hash_table->NumberOfElements() + hash_table->NumberOfDeletedElements();
+  size_t over_allocated = 0;
+  if (hash_table->Capacity() > used_slots) {
+    over_allocated = (hash_table->Capacity() - used_slots) * Dictionary::kEntrySize * kTaggedSize;
+  }
   RecordVirtualObjectStats(parent, hash_table, type, hash_table->Size(),
                            over_allocated);
 }
diff --git a/test/unittests/heap/object-stats-unittest.cc b/test/unittests/heap/object-stats-unittest.cc
index 912bcafcb52..d4e4dd73c64 100644
--- a/test/unittests/heap/object-stats-unittest.cc
+++ b/test/unittests/heap/object-stats-unittest.cc
@@ -33,6 +33,47 @@ TEST(ObjectStats, NoClashWithInstanceTypes) {
 #undef CHECK_REGULARINSTANCE_TYPE
 }
 
+TEST(ObjectStats, HashTableVirtualObjectStatsNoUnderflow) {
+  // Test that RecordHashTableVirtualObjectStats doesn't underflow
+  // when NumberOfElements + NumberOfDeletedElements > Capacity
+  
+  // This is a simplified test to verify the fix for the underflow issue
+  // We can't easily create a real hash table with this condition in a unit test,
+  // but we can verify that the calculation logic is sound by testing the
+  // core arithmetic that was fixed.
+  
+  // Simulate the problematic scenario:
+  // capacity = 10, elements = 8, deleted = 5
+  // elements + deleted = 13 > capacity = 10
+  
+  size_t capacity = 10;
+  size_t elements = 8;
+  size_t deleted = 5;
+  size_t entry_size = 3;  // Typical Dictionary::kEntrySize
+  size_t tagged_size = 8; // Typical kTaggedSize
+  
+  // This is the fixed calculation logic from RecordHashTableVirtualObjectStats
+  size_t used_slots = elements + deleted;
+  size_t over_allocated = 0;
+  if (capacity > used_slots) {
+    over_allocated = (capacity - used_slots) * entry_size * tagged_size;
+  }
+  
+  // In the bug scenario, over_allocated should be 0 (not underflowed)
+  EXPECT_EQ(over_allocated, 0u);
+  
+  // Test normal case where capacity > used_slots
+  capacity = 20;
+  used_slots = elements + deleted; // still 13
+  over_allocated = 0;
+  if (capacity > used_slots) {
+    over_allocated = (capacity - used_slots) * entry_size * tagged_size;
+  }
+  
+  // Should be (20 - 13) * 3 * 8 = 7 * 3 * 8 = 168
+  EXPECT_EQ(over_allocated, 168u);
+}
+
 }  // namespace heap
 }  // namespace internal
 }  // namespace v8
