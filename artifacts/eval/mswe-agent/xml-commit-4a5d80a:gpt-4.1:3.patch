
diff --git a/.gitignore b/.gitignore
index 995094da..294f2ca2 100644
--- a/.gitignore
+++ b/.gitignore
@@ -119,3 +119,13 @@ xstc/Makefile
 xstc/Makefile.in
 xstc/Tests
 xstc/xsts-*.tar.gz
+build/
+Build/
+bin/
+lib/
+*.out
+*.obj
+*.exe
+*.dll
+*.so
+*.dylib
diff --git a/libxml2-config.cmake b/libxml2-config.cmake
new file mode 100644
index 00000000..31a19aa7
--- /dev/null
+++ b/libxml2-config.cmake
@@ -0,0 +1,50 @@
+# libxml2-config.cmake
+# --------------------
+#
+# Libxml2 cmake module.
+# THis module sets the following variables:
+#
+# ::
+#
+#   LIBXML2_INCLUDE_DIRS      - Directory where libxml2 headers are located.
+#   LIBXML2_LIBRARIES         - xml2 libraries to link against.
+#   LIBXML2_VERSION_MAJOR     - The major version of libxml2.
+#   LIBXML2_VERSION_MINOR     - The minor version of libxml2.
+#   LIBXML2_VERSION_PATCH     - The patch version of libxml2.
+#   LIBXML2_VERSION_STRING    - version number as a string (ex: "2.3.4")
+#   LIBXML2_MODULES           - whether libxml2 as dso support
+
+get_filename_component(_libxml2_rootdir ${CMAKE_CURRENT_LIST_DIR}/../../../ ABSOLUTE)
+
+set(LIBXML2_VERSION_MAJOR  2)
+set(LIBXML2_VERSION_MINOR  9)
+set(LIBXML2_VERSION_MICRO  2)
+set(LIBXML2_VERSION_STRING "2.9.2")
+set(LIBXML2_INSTALL_PREFIX ${_libxml2_rootdir})
+set(LIBXML2_INCLUDE_DIRS   ${_libxml2_rootdir}/include ${_libxml2_rootdir}/include/libxml2)
+set(LIBXML2_LIBRARY_DIR    ${_libxml2_rootdir}/lib)
+set(LIBXML2_LIBRARIES      -L${LIBXML2_LIBRARY_DIR} -lxml2)
+
+if(1)
+  find_package(Threads REQUIRED)
+  list(APPEND LIBXML2_LIBRARIES ${CMAKE_THREAD_LIBS_INIT})
+endif()
+
+if(1)
+  find_package(LibLZMA REQUIRED)
+  list(APPEND LIBXML2_LIBRARIES    ${LIBLZMA_LIBRARIES})
+  list(APPEND LIBXML2_INCLUDE_DIRS ${LIBLZMA_INCLUDE_DIRS})
+endif()
+
+if(1)
+  find_package(ZLIB REQUIRED)
+  list(APPEND LIBXML2_LIBRARIES    ${ZLIB_LIBRARIES})
+  list(APPEND LIBXML2_INCLUDE_DIRS ${ZLIB_INCLUDE_DIRS})
+endif()
+
+list(APPEND LIBXML2_LIBRARIES   -lm  )
+
+# whether libxml2 has dso support
+set(LIBXML2_MODULES 1)
+
+mark_as_advanced( LIBXML2_INCLUDE_DIRS LIBXML2_LIBRARIES )
diff --git a/parser.c b/parser.c
index fd29a395..23b8ff3a 100644
--- a/parser.c
+++ b/parser.c
@@ -12224,3484 +12224,15 @@ encoding_error:
     {
         char buffer[150];
 
-	snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
-			ctxt->input->cur[0], ctxt->input->cur[1],
-			ctxt->input->cur[2], ctxt->input->cur[3]);
-	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
-		     "Input is not proper UTF-8, indicate encoding !\n%s",
-		     BAD_CAST buffer, NULL);
-    }
-    return(0);
-}
-
-/**
- * xmlParseCheckTransition:
- * @ctxt:  an XML parser context
- * @chunk:  a char array
- * @size:  the size in byte of the chunk
- *
- * Check depending on the current parser state if the chunk given must be
- * processed immediately or one need more data to advance on parsing.
- *
- * Returns -1 in case of error, 0 if the push is not needed and 1 if needed
- */
-static int
-xmlParseCheckTransition(xmlParserCtxtPtr ctxt, const char *chunk, int size) {
-    if ((ctxt == NULL) || (chunk == NULL) || (size < 0))
-        return(-1);
-    if (ctxt->instate == XML_PARSER_START_TAG) {
-        if (memchr(chunk, '>', size) != NULL)
-            return(1);
-        return(0);
-    }
-    if (ctxt->progressive == XML_PARSER_COMMENT) {
-        if (memchr(chunk, '>', size) != NULL)
-            return(1);
-        return(0);
-    }
-    if (ctxt->instate == XML_PARSER_CDATA_SECTION) {
-        if (memchr(chunk, '>', size) != NULL)
-            return(1);
-        return(0);
-    }
-    if (ctxt->progressive == XML_PARSER_PI) {
-        if (memchr(chunk, '>', size) != NULL)
-            return(1);
-        return(0);
-    }
-    if (ctxt->instate == XML_PARSER_END_TAG) {
-        if (memchr(chunk, '>', size) != NULL)
-            return(1);
-        return(0);
-    }
-    if ((ctxt->progressive == XML_PARSER_DTD) ||
-        (ctxt->instate == XML_PARSER_DTD)) {
-        if (memchr(chunk, '>', size) != NULL)
-            return(1);
-        return(0);
-    }
-    return(1);
-}
-
-/**
- * xmlParseChunk:
- * @ctxt:  an XML parser context
- * @chunk:  an char array
- * @size:  the size in byte of the chunk
- * @terminate:  last chunk indicator
- *
- * Parse a Chunk of memory
- *
- * Returns zero if no error, the xmlParserErrors otherwise.
- */
-int
-xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,
-              int terminate) {
-    int end_in_lf = 0;
-    int remain = 0;
-    size_t old_avail = 0;
-    size_t avail = 0;
-
-    if (ctxt == NULL)
-        return(XML_ERR_INTERNAL_ERROR);
-    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
-        return(ctxt->errNo);
-    if (ctxt->instate == XML_PARSER_EOF)
-        return(-1);
-    if (ctxt->instate == XML_PARSER_START)
-        xmlDetectSAX2(ctxt);
-    if ((size > 0) && (chunk != NULL) && (!terminate) &&
-        (chunk[size - 1] == '\r')) {
-	end_in_lf = 1;
-	size--;
-    }
-
-xmldecl_done:
-
-    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&
-        (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF))  {
-	size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);
-	size_t cur = ctxt->input->cur - ctxt->input->base;
-	int res;
-
-        old_avail = xmlBufUse(ctxt->input->buf->buffer);
-        /*
-         * Specific handling if we autodetected an encoding, we should not
-         * push more than the first line ... which depend on the encoding
-         * And only push the rest once the final encoding was detected
-         */
-        if ((ctxt->instate == XML_PARSER_START) && (ctxt->input != NULL) &&
-            (ctxt->input->buf != NULL) && (ctxt->input->buf->encoder != NULL)) {
-            unsigned int len = 45;
-
-            if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,
-                               BAD_CAST "UTF-16")) ||
-                (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,
-                               BAD_CAST "UTF16")))
-                len = 90;
-            else if ((xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,
-                                    BAD_CAST "UCS-4")) ||
-                     (xmlStrcasestr(BAD_CAST ctxt->input->buf->encoder->name,
-                                    BAD_CAST "UCS4")))
-                len = 180;
-
-            if (ctxt->input->buf->rawconsumed < len)
-                len -= ctxt->input->buf->rawconsumed;
-
-            /*
-             * Change size for reading the initial declaration only
-             * if size is greater than len. Otherwise, memmove in xmlBufferAdd
-             * will blindly copy extra bytes from memory.
-             */
-            if ((unsigned int) size > len) {
-                remain = size - len;
-                size = len;
-            } else {
-                remain = 0;
-            }
-        }
-	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
-	if (res < 0) {
-	    ctxt->errNo = XML_PARSER_EOF;
-	    ctxt->disableSAX = 1;
-	    return (XML_PARSER_EOF);
-	}
-        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);
-#ifdef DEBUG_PUSH
-	xmlGenericError(xmlGenericErrorContext, "PP: pushed %d\n", size);
-#endif
-
-    } else if (ctxt->instate != XML_PARSER_EOF) {
-	if ((ctxt->input != NULL) && ctxt->input->buf != NULL) {
-	    xmlParserInputBufferPtr in = ctxt->input->buf;
-	    if ((in->encoder != NULL) && (in->buffer != NULL) &&
-		    (in->raw != NULL)) {
-		int nbchars;
-		size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);
-		size_t current = ctxt->input->cur - ctxt->input->base;
-
-		nbchars = xmlCharEncInput(in, terminate);
-		if (nbchars < 0) {
-		    /* TODO 2.6.0 */
-		    xmlGenericError(xmlGenericErrorContext,
-				    "xmlParseChunk: encoder error\n");
-		    return(XML_ERR_INVALID_ENCODING);
-		}
-		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);
-	    }
-	}
-    }
-    if (remain != 0) {
-        xmlParseTryOrFinish(ctxt, 0);
-    } else {
-        if ((ctxt->input != NULL) && (ctxt->input->buf != NULL))
-            avail = xmlBufUse(ctxt->input->buf->buffer);
-        /*
-         * Depending on the current state it may not be such
-         * a good idea to try parsing if there is nothing in the chunk
-         * which would be worth doing a parser state transition and we
-         * need to wait for more data
-         */
-        if ((terminate) || (avail > XML_MAX_TEXT_LENGTH) ||
-            (old_avail == 0) || (avail == 0) ||
-            (xmlParseCheckTransition(ctxt,
-                       (const char *)&ctxt->input->base[old_avail],
-                                     avail - old_avail)))
-            xmlParseTryOrFinish(ctxt, terminate);
-    }
-    if (ctxt->instate == XML_PARSER_EOF)
-        return(ctxt->errNo);
-
-    if ((ctxt->input != NULL) &&
-         (((ctxt->input->end - ctxt->input->cur) > XML_MAX_LOOKUP_LIMIT) ||
-         ((ctxt->input->cur - ctxt->input->base) > XML_MAX_LOOKUP_LIMIT)) &&
-        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
-        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "Huge input lookup");
-        ctxt->instate = XML_PARSER_EOF;
-    }
-    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
-        return(ctxt->errNo);
-
-    if (remain != 0) {
-        chunk += size;
-        size = remain;
-        remain = 0;
-        goto xmldecl_done;
-    }
-    if ((end_in_lf == 1) && (ctxt->input != NULL) &&
-        (ctxt->input->buf != NULL)) {
-	size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer,
-					 ctxt->input);
-	size_t current = ctxt->input->cur - ctxt->input->base;
-
-	xmlParserInputBufferPush(ctxt->input->buf, 1, "\r");
-
-	xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input,
-			      base, current);
-    }
-    if (terminate) {
-	/*
-	 * Check for termination
-	 */
-	int cur_avail = 0;
-
-	if (ctxt->input != NULL) {
-	    if (ctxt->input->buf == NULL)
-		cur_avail = ctxt->input->length -
-			    (ctxt->input->cur - ctxt->input->base);
-	    else
-		cur_avail = xmlBufUse(ctxt->input->buf->buffer) -
-			              (ctxt->input->cur - ctxt->input->base);
-	}
-
-	if ((ctxt->instate != XML_PARSER_EOF) &&
-	    (ctxt->instate != XML_PARSER_EPILOG)) {
-	    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
-	}
-	if ((ctxt->instate == XML_PARSER_EPILOG) && (cur_avail > 0)) {
-	    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
-	}
-	if (ctxt->instate != XML_PARSER_EOF) {
-	    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
-		ctxt->sax->endDocument(ctxt->userData);
-	}
-	ctxt->instate = XML_PARSER_EOF;
-    }
-    if (ctxt->wellFormed == 0)
-	return((xmlParserErrors) ctxt->errNo);
-    else
-        return(0);
-}
-
-/************************************************************************
- *									*
- *		I/O front end functions to the parser			*
- *									*
- ************************************************************************/
-
-/**
- * xmlCreatePushParserCtxt:
- * @sax:  a SAX handler
- * @user_data:  The user data returned on SAX callbacks
- * @chunk:  a pointer to an array of chars
- * @size:  number of chars in the array
- * @filename:  an optional file name or URI
- *
- * Create a parser context for using the XML parser in push mode.
- * If @buffer and @size are non-NULL, the data is used to detect
- * the encoding.  The remaining characters will be parsed so they
- * don't need to be fed in again through xmlParseChunk.
- * To allow content encoding detection, @size should be >= 4
- * The value of @filename is used for fetching external entities
- * and error/warning reports.
- *
- * Returns the new parser context or NULL
- */
-
-xmlParserCtxtPtr
-xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax, void *user_data,
-                        const char *chunk, int size, const char *filename) {
-    xmlParserCtxtPtr ctxt;
-    xmlParserInputPtr inputStream;
-    xmlParserInputBufferPtr buf;
-    xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
-
-    /*
-     * plug some encoding conversion routines
-     */
-    if ((chunk != NULL) && (size >= 4))
-	enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);
-
-    buf = xmlAllocParserInputBuffer(enc);
-    if (buf == NULL) return(NULL);
-
-    ctxt = xmlNewParserCtxt();
-    if (ctxt == NULL) {
-        xmlErrMemory(NULL, "creating parser: out of memory\n");
-	xmlFreeParserInputBuffer(buf);
-	return(NULL);
-    }
-    ctxt->dictNames = 1;
-    ctxt->pushTab = (void **) xmlMalloc(ctxt->nameMax * 3 * sizeof(xmlChar *));
-    if (ctxt->pushTab == NULL) {
-        xmlErrMemory(ctxt, NULL);
-	xmlFreeParserInputBuffer(buf);
-	xmlFreeParserCtxt(ctxt);
-	return(NULL);
-    }
-    if (sax != NULL) {
-#ifdef LIBXML_SAX1_ENABLED
-	if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)
-#endif /* LIBXML_SAX1_ENABLED */
-	    xmlFree(ctxt->sax);
-	ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));
-	if (ctxt->sax == NULL) {
-	    xmlErrMemory(ctxt, NULL);
-	    xmlFreeParserInputBuffer(buf);
-	    xmlFreeParserCtxt(ctxt);
-	    return(NULL);
-	}
-	memset(ctxt->sax, 0, sizeof(xmlSAXHandler));
-	if (sax->initialized == XML_SAX2_MAGIC)
-	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));
-	else
-	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));
-	if (user_data != NULL)
-	    ctxt->userData = user_data;
-    }
-    if (filename == NULL) {
-	ctxt->directory = NULL;
-    } else {
-        ctxt->directory = xmlParserGetDirectory(filename);
-    }
-
-    inputStream = xmlNewInputStream(ctxt);
-    if (inputStream == NULL) {
-	xmlFreeParserCtxt(ctxt);
-	xmlFreeParserInputBuffer(buf);
-	return(NULL);
-    }
-
-    if (filename == NULL)
-	inputStream->filename = NULL;
-    else {
-	inputStream->filename = (char *)
-	    xmlCanonicPath((const xmlChar *) filename);
-	if (inputStream->filename == NULL) {
-	    xmlFreeParserCtxt(ctxt);
-	    xmlFreeParserInputBuffer(buf);
-	    return(NULL);
-	}
-    }
-    inputStream->buf = buf;
-    xmlBufResetInput(inputStream->buf->buffer, inputStream);
-    inputPush(ctxt, inputStream);
-
-    /*
-     * If the caller didn't provide an initial 'chunk' for determining
-     * the encoding, we set the context to XML_CHAR_ENCODING_NONE so
-     * that it can be automatically determined later
-     */
-    if ((size == 0) || (chunk == NULL)) {
-	ctxt->charset = XML_CHAR_ENCODING_NONE;
-    } else if ((ctxt->input != NULL) && (ctxt->input->buf != NULL)) {
-	size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);
-	size_t cur = ctxt->input->cur - ctxt->input->base;
-
-	xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
-
-        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);
-#ifdef DEBUG_PUSH
-	xmlGenericError(xmlGenericErrorContext, "PP: pushed %d\n", size);
-#endif
-    }
-
-    if (enc != XML_CHAR_ENCODING_NONE) {
-        xmlSwitchEncoding(ctxt, enc);
-    }
-
-    return(ctxt);
-}
-#endif /* LIBXML_PUSH_ENABLED */
-
-/**
- * xmlStopParser:
- * @ctxt:  an XML parser context
- *
- * Blocks further parser processing
- */
-void
-xmlStopParser(xmlParserCtxtPtr ctxt) {
-    if (ctxt == NULL)
-        return;
-    ctxt->instate = XML_PARSER_EOF;
-    ctxt->errNo = XML_ERR_USER_STOP;
-    ctxt->disableSAX = 1;
-    if (ctxt->input != NULL) {
-	ctxt->input->cur = BAD_CAST"";
-	ctxt->input->base = ctxt->input->cur;
-    }
-}
-
-/**
- * xmlCreateIOParserCtxt:
- * @sax:  a SAX handler
- * @user_data:  The user data returned on SAX callbacks
- * @ioread:  an I/O read function
- * @ioclose:  an I/O close function
- * @ioctx:  an I/O handler
- * @enc:  the charset encoding if known
- *
- * Create a parser context for using the XML parser with an existing
- * I/O stream
- *
- * Returns the new parser context or NULL
- */
-xmlParserCtxtPtr
-xmlCreateIOParserCtxt(xmlSAXHandlerPtr sax, void *user_data,
-	xmlInputReadCallback   ioread, xmlInputCloseCallback  ioclose,
-	void *ioctx, xmlCharEncoding enc) {
-    xmlParserCtxtPtr ctxt;
-    xmlParserInputPtr inputStream;
-    xmlParserInputBufferPtr buf;
-
-    if (ioread == NULL) return(NULL);
-
-    buf = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, enc);
-    if (buf == NULL) {
-        if (ioclose != NULL)
-            ioclose(ioctx);
-        return (NULL);
-    }
-
-    ctxt = xmlNewParserCtxt();
-    if (ctxt == NULL) {
-	xmlFreeParserInputBuffer(buf);
-	return(NULL);
-    }
-    if (sax != NULL) {
-#ifdef LIBXML_SAX1_ENABLED
-	if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)
-#endif /* LIBXML_SAX1_ENABLED */
-	    xmlFree(ctxt->sax);
-	ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));
-	if (ctxt->sax == NULL) {
-	    xmlErrMemory(ctxt, NULL);
-	    xmlFreeParserCtxt(ctxt);
-	    return(NULL);
-	}
-	memset(ctxt->sax, 0, sizeof(xmlSAXHandler));
-	if (sax->initialized == XML_SAX2_MAGIC)
-	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));
-	else
-	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));
-	if (user_data != NULL)
-	    ctxt->userData = user_data;
-    }
-
-    inputStream = xmlNewIOInputStream(ctxt, buf, enc);
-    if (inputStream == NULL) {
-	xmlFreeParserCtxt(ctxt);
-	return(NULL);
-    }
-    inputPush(ctxt, inputStream);
-
-    return(ctxt);
-}
-
-#ifdef LIBXML_VALID_ENABLED
-/************************************************************************
- *									*
- *		Front ends when parsing a DTD				*
- *									*
- ************************************************************************/
-
-/**
- * xmlIOParseDTD:
- * @sax:  the SAX handler block or NULL
- * @input:  an Input Buffer
- * @enc:  the charset encoding if known
- *
- * Load and parse a DTD
- *
- * Returns the resulting xmlDtdPtr or NULL in case of error.
- * @input will be freed by the function in any case.
- */
-
-xmlDtdPtr
-xmlIOParseDTD(xmlSAXHandlerPtr sax, xmlParserInputBufferPtr input,
-	      xmlCharEncoding enc) {
-    xmlDtdPtr ret = NULL;
-    xmlParserCtxtPtr ctxt;
-    xmlParserInputPtr pinput = NULL;
-    xmlChar start[4];
-
-    if (input == NULL)
-	return(NULL);
-
-    ctxt = xmlNewParserCtxt();
-    if (ctxt == NULL) {
-        xmlFreeParserInputBuffer(input);
-	return(NULL);
-    }
-
-    /* We are loading a DTD */
-    ctxt->options |= XML_PARSE_DTDLOAD;
-
-    /*
-     * Set-up the SAX context
-     */
-    if (sax != NULL) {
-	if (ctxt->sax != NULL)
-	    xmlFree(ctxt->sax);
-        ctxt->sax = sax;
-        ctxt->userData = ctxt;
-    }
-    xmlDetectSAX2(ctxt);
-
-    /*
-     * generate a parser input from the I/O handler
-     */
-
-    pinput = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
-    if (pinput == NULL) {
-        if (sax != NULL) ctxt->sax = NULL;
-        xmlFreeParserInputBuffer(input);
-	xmlFreeParserCtxt(ctxt);
-	return(NULL);
-    }
-
-    /*
-     * plug some encoding conversion routines here.
-     */
-    if (xmlPushInput(ctxt, pinput) < 0) {
-        if (sax != NULL) ctxt->sax = NULL;
-	xmlFreeParserCtxt(ctxt);
-	return(NULL);
-    }
-    if (enc != XML_CHAR_ENCODING_NONE) {
-        xmlSwitchEncoding(ctxt, enc);
-    }
-
-    pinput->filename = NULL;
-    pinput->line = 1;
-    pinput->col = 1;
-    pinput->base = ctxt->input->cur;
-    pinput->cur = ctxt->input->cur;
-    pinput->free = NULL;
-
-    /*
-     * let's parse that entity knowing it's an external subset.
-     */
-    ctxt->inSubset = 2;
-    ctxt->myDoc = xmlNewDoc(BAD_CAST "1.0");
-    if (ctxt->myDoc == NULL) {
-	xmlErrMemory(ctxt, "New Doc failed");
-	return(NULL);
-    }
-    ctxt->myDoc->properties = XML_DOC_INTERNAL;
-    ctxt->myDoc->extSubset = xmlNewDtd(ctxt->myDoc, BAD_CAST "none",
-	                               BAD_CAST "none", BAD_CAST "none");
-
-    if ((enc == XML_CHAR_ENCODING_NONE) &&
-        ((ctxt->input->end - ctxt->input->cur) >= 4)) {
-	/*
-	 * Get the 4 first bytes and decode the charset
-	 * if enc != XML_CHAR_ENCODING_NONE
-	 * plug s...-    if (options & XML_PARSE_NOBASEFIX) {
-	ctxt->options |= XML_PARSE_NOBASEFIX;
-        options -= XML_PARSE_NOBASEFIX;
-    }
-    if (options & XML_PARSE_HUGE) {
-	ctxt->options |= XML_PARSE_HUGE;
-        options -= XML_PARSE_HUGE;
-        if (ctxt->dict != NULL)
-            xmlDictSetLimit(ctxt->dict, 0);
-    }
-    if (options & XML_PARSE_OLDSAX) {
-	ctxt->options |= XML_PARSE_OLDSAX;
-        options -= XML_PARSE_OLDSAX;
-    }
-    if (options & XML_PARSE_IGNORE_ENC) {
-	ctxt->options |= XML_PARSE_IGNORE_ENC;
-        options -= XML_PARSE_IGNORE_ENC;
-    }
-    if (options & XML_PARSE_BIG_LINES) {
-	ctxt->options |= XML_PARSE_BIG_LINES;
-        options -= XML_PARSE_BIG_LINES;
-    }
-    ctxt->linenumbers = 1;
-    return (options);
-}
-
-/**
- * xmlCtxtUseOptions:
- * @ctxt: an XML parser context
- * @options:  a combination of xmlParserOption
- *
- * Applies the options to the parser context
- *
- * Returns 0 in case of success, the set of unknown or unimplemented options
- *         in case of error.
- */
-int
-xmlCtxtUseOptions(xmlParserCtxtPtr ctxt, int options)
-{
-   return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));
-}
-
-/**
- * xmlDoRead:
- * @ctxt:  an XML parser context
- * @URL:  the base URL to use for the document
- * @encoding:  the document encoding, or NULL
- * @options:  a combination of xmlParserOption
- * @reuse:  keep the context for reuse
- *
- * Common front-end for the xmlRead functions
- *
- * Returns the resulting document tree or NULL
- */
-static xmlDocPtr
-xmlDoRead(xmlParserCtxtPtr ctxt, const char *URL, const char *encoding,
-          int options, int reuse)
-{
-    xmlDocPtr ret;
-
-    xmlCtxtUseOptionsInternal(ctxt, options, encoding);
-    if (encoding != NULL) {
-        xmlCharEncodingHandlerPtr hdlr;
-
-	hdlr = xmlFindCharEncodingHandler(encoding);
-	if (hdlr != NULL)
-	    xmlSwitchToEncoding(ctxt, hdlr);
-    }
-    if ((URL != NULL) && (ctxt->input != NULL) &&
-        (ctxt->input->filename == NULL))
-        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);
-    xmlParseDocument(ctxt);
-    if ((ctxt->wellFormed) || ctxt->recovery)
-        ret = ctxt->myDoc;
-    else {
-        ret = NULL;
-	if (ctxt->myDoc != NULL) {
-	    xmlFreeDoc(ctxt->myDoc);
-	}
-    }
-    ctxt->myDoc = NULL;
-    if (!reuse) {
-	xmlFreeParserCtxt(ctxt);
-    }
-
-    return (ret);
-}
-
-/**
- * xmlReadDoc:
- * @cur:  a pointer to a zero terminated string
- * @URL:  the base URL to use for the document
- * @encoding:  the document encoding, or NULL
- * @options:  a combination of xmlParserOption
- *
- * parse an XML in-memory document and build a tree.
- *
- * Returns the resulting document tree
- */
-xmlDocPtr
-xmlReadDoc(const xmlChar * cur, const char *URL, const char *encoding, int options)
-{
-    xmlParserCtxtPtr ctxt;
-
-    if (cur == NULL)
-        return (NULL);
-    xmlInitParser();
-
-    ctxt = xmlCreateDocParserCtxt(cur);
-    if (ctxt == NULL)
-        return (NULL);
-    return (xmlDoRead(ctxt, URL, encoding, options, 0));
-}
-
-/**
- * xmlReadFile:
- * @filename:  a file or URL
- * @encoding:  the document encoding, or NULL
- * @options:  a combination of xmlParserOption
- *
- * parse an XML file from the filesystem or the network.
- *
- * Returns the resulting document tree
- */
-xmlDocPtr
-xmlReadFile(const char *filename, const char *encoding, int options)
-{
-    xmlParserCtxtPtr ctxt;
-
-    xmlInitParser();
-    ctxt = xmlCreateURLParserCtxt(filename, options);
-    if (ctxt == NULL)
-        return (NULL);
-    return (xmlDoRead(ctxt, NULL, encoding, options, 0));
-}
-
-/**
- * xmlReadMemory:
- * @buffer:  a pointer to a char array
- * @size:  the size of the array
- * @URL:  the base URL to use for the document
- * @encoding:  the document encoding, or NULL
- * @options:  a combination of xmlParserOption
- *
- * parse an XML in-memory document and build a tree.
- *
- * Returns the resulting document tree
- */
-xmlDocPtr
-xmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
-{
-    xmlParserCtxtPtr ctxt;
-
-    xmlInitParser();
-    ctxt = xmlCreateMemoryParserCtxt(buffer, size);
-    if (ctxt == NULL)
-        return (NULL);
-    return (xmlDoRead(ctxt, URL, encoding, options, 0));
-}
-
-/**
- * xmlReadFd:
- * @fd:  an open file descriptor
- * @URL:  the base URL to use for the document
- * @encoding:  the document encoding, or NULL
- * @options:  a combination of xmlParserOption
- *
- * parse an XML from a file descriptor and build a tree.
- * NOTE that the file descriptor will not be closed when the
- *      reader is closed or reset.
- *
- * Returns the resulting document tree
- */
-xmlDocPtr
-xmlReadFd(int fd, const char *URL, const char *encoding, int options)
-{
-    xmlParserCtxtPtr ctxt;
-    xmlParserInputBufferPtr input;
-    xmlParserInputPtr stream;
-
-    if (fd < 0)
-        return (NULL);
-    xmlInitParser();
-
-    input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
-    if (input == NULL)
-        return (NULL);
-    input->closecallback = NULL;
-    ctxt = xmlNewParserCtxt();
-    if (ctxt == NULL) {
-        xmlFreeParserInputBuffer(input);
-        return (NULL);
-    }
-    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
-    if (stream == NULL) {
-        xmlFreeParserInputBuffer(input);
-	xmlFreeParserCtxt(ctxt);
-        return (NULL);
-    }
-    inputPush(ctxt, stream);
-    return (xmlDoRead(ctxt, URL, encoding, options, 0));
-}
-
-/**
- * xmlReadIO:
- * @ioread:  an I/O read function
- * @ioclose:  an I/O close function
- * @ioctx:  an I/O handler
- * @URL:  the base URL to use for the document
- * @encoding:  the document encoding, or NULL
- * @options:  a combination of xmlParserOption
- *
- * parse an XML document from I/O functions and source and build a tree.
- *
- * Returns the resulting document tree
- */
-xmlDocPtr
-xmlReadIO(xmlInputReadCallback ioread, xmlInputCloseCallback ioclose,
-          void *ioctx, const char *URL, const char *encoding, int options)
-{
-    xmlParserCtxtPtr ctxt;
-    xmlParserInputBufferPtr input;
-    xmlParserInputPtr stream;
-
-    if (ioread == NULL)
-        return (NULL);
-    xmlInitParser();
-
-    input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
-                                         XML_CHAR_ENCODING_NONE);
-    if (input == NULL) {
-        if (ioclose != NULL)
-            ioclose(ioctx);
-        return (NULL);
-    }
-    ctxt = xmlNewParserCtxt();
-    if (ctxt == NULL) {
-        xmlFreeParserInputBuffer(input);
-        return (NULL);
-    }
-    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
-    if (stream == NULL) {
-        xmlFreeParserInputBuffer(input);
-	xmlFreeParserCtxt(ctxt);
-        return (NULL);
-    }
-    inputPush(ctxt, stream);
-    return (xmlDoRead(ctxt, URL, encoding, options, 0));
-}
-
-/**
- * xmlCtxtReadDoc:
- * @ctxt:  an XML parser context
- * @cur:  a pointer to a zero terminated string
- * @URL:  the base URL to use for the document
- * @encoding:  the document encoding, or NULL
- * @options:  a combination of xmlParserOption
- *
- * parse an XML in-memory document and build a tree.
- * This reuses the existing @ctxt parser context
- *
- * Returns the resulting document tree
- */
-xmlDocPtr
-xmlCtxtReadDoc(xmlParserCtxtPtr ctxt, const xmlChar * cur,
-               const char *URL, const char *encoding, int options)
-{
-    xmlParserInputPtr stream;
-
-    if (cur == NULL)
-        return (NULL);
-    if (ctxt == NULL)
-        return (NULL);
-    xmlInitParser();
-
-    xmlCtxtReset(ctxt);
-
-    stream = xmlNewStringInputStream(ctxt, cur);
-    if (stream == NULL) {
-        return (NULL);
-    }
-    inputPush(ctxt, stream);
-    return (xmlDoRead(ctxt, URL, encoding, options, 1));
-}
-
-/**
- * xmlCtxtReadFile:
- * @ctxt:  an XML parser context
- * @filename:  a file or URL
- * @encoding:  the document encoding, or NULL
- * @options:  a combination of xmlParserOption
- *
- * parse an XML file from the filesystem or the network.
- * This reuses the existing @ctxt parser context
- *
- * Returns the resulting document tree
- */
-xmlDocPtr
-xmlCtxtReadFile(xmlParserCtxtPtr ctxt, const char *filename,
-                const char *encoding, int options)
-{
-    xmlParserInputPtr stream;
-
-    if (filename == NULL)
-        return (NULL);
-    if (ctxt == NULL)
-        return (NULL);
-    xmlInitParser();
-
-    xmlCtxtReset(ctxt);
-
-    stream = xmlLoadExternalEntity(filename, NULL, ctxt);
-    if (stream == NULL) {
-        return (NULL);
-    }
-    inputPush(ctxt, stream);
-    return (xmlDoRead(ctxt, NULL, encoding, options, 1));
 }
-
-/**
- * xmlCtxtReadMemory:
- * @ctxt:  an XML parser context
- * @buffer:  a pointer to a char array
- * @size:  the size of the array
- * @URL:  the base URL to use for the document
- * @encoding:  the document encoding, or NULL
- * @options:  a combination of xmlParserOption
- *
- * parse an XML in-memory document and build a tree.
- * This reuses the existing @ctxt parser context
- *
- * Returns the resulting document tree
- */
-xmlDocPtr
-xmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size,
-                  const char *URL, const char *encoding, int options)
-{
-    xmlParserInputBufferPtr input;
-    xmlParserInputPtr stream;
-
-    if (ctxt == NULL)
-        return (NULL);
-    if (buffer == NULL)
-        return (NULL);
-    xmlInitParser();
-
-    xmlCtxtReset(ctxt);
-
-    input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
-    if (input == NULL) {
-	return(NULL);
-    }
-
-    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
-    if (stream == NULL) {
-	xmlFreeParserInputBuffer(input);
-	return(NULL);
-    }
-
-    inputPush(ctxt, stream);
-    return (xmlDoRead(ctxt, URL, encoding, options, 1));
-}
-
-/**
- * xmlCtxtReadFd:
- * @ctxt:  an XML parser context
- * @fd:  an open file descriptor
- * @URL:  the base URL to use for the document
- * @encoding:  the document encoding, or NULL
- * @options:  a combination of xmlParserOption
- *
- * parse an XML from a file descriptor and build a tree.
- * This reuses the existing @ctxt parser context
- * NOTE that the file descriptor will not be closed when the
- *      reader is closed or reset.
- *
- * Returns the resulting document tree
- */
-xmlDocPtr
-xmlCtxtReadFd(xmlParserCtxtPtr ctxt, int fd,
-              const char *URL, const char *encoding, int options)
-{
-    xmlParserInputBufferPtr input;
-    xmlParserInputPtr stream;
-
-    if (fd < 0)
-        return (NULL);
-    if (ctxt == NULL)
-        return (NULL);
-    xmlInitParser();
-
-    xmlCtxtReset(ctxt);
-
-
-    input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
-    if (input == NULL)
-        return (NULL);
-    input->closecallback = NULL;
-    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
-    if (stream == NULL) {
-        xmlFreeParserInputBuffer(input);
-        return (NULL);
-    }
-    inputPush(ctxt, stream);
-    return (xmlDoRead(ctxt, URL, encoding, options, 1));
-}
-
-/**
- * xmlCtxtReadIO:
- * @ctxt:  an XML parser context
- * @ioread:  an I/O read function
- * @ioclose:  an I/O close function
- * @ioctx:  an I/O handler
- * @URL:  the base URL to use for the document
- * @encoding:  the document encoding, or NULL
- * @options:  a combination of xmlParserOption
- *
- * parse an XML document from I/O functions and source and build a tree.
- * This reuses the existing @ctxt parser context
- *
- * Returns the resulting document tree
- */
-xmlDocPtr
-xmlCtxtReadIO(xmlParserCtxtPtr ctxt, xmlInputReadCallback ioread,
-              xmlInputCloseCallback ioclose, void *ioctx,
-	      const char *URL,
-              const char *encoding, int options)
-{
-    xmlParserInputBufferPtr input;
-    xmlParserInputPtr stream;
-
-    if (ioread == NULL)
-        return (NULL);
-    if (ctxt == NULL)
-        return (NULL);
-    xmlInitParser();
-
-    xmlCtxtReset(ctxt);
-
-    input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
-                                         XML_CHAR_ENCODING_NONE);
-    if (input == NULL) {
-        if (ioclose != NULL)
-            ioclose(ioctx);
-        return (NULL);
-    }
-    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
-    if (stream == NULL) {
-        xmlFreeParserInputBuffer(input);
-        return (NULL);
-    }
-    inputPush(ctxt, stream);
-    return (xmlDoRead(ctxt, URL, encoding, options, 1));
-}
-
-#define bottom_parser
-#include "elfgcchack.h"
+#endif
diff --git a/python/setup.py b/python/setup.py
deleted file mode 100755
index e5043237..00000000
--- a/python/setup.py
+++ /dev/null
@@ -1,242 +0,0 @@
-#!/usr/bin/python -u
-#
-# Setup script for libxml2 and libxslt if found
-#
-import sys, os
-from distutils.core import setup, Extension
-
-# Below ROOT, we expect to find include, include/libxml2, lib and bin.
-# On *nix, it is not needed (but should not harm),
-# on Windows, it is set by configure.js.
-ROOT = r'/usr'
-
-# Thread-enabled libxml2
-with_threads = 1
-
-# If this flag is set (windows only),
-# a private copy of the dlls are included in the package.
-# If this flag is not set, the libxml2 and libxslt
-# dlls must be found somewhere in the PATH at runtime.
-WITHDLLS = 1 and sys.platform.startswith('win')
-
-def missing(file):
-    if os.access(file, os.R_OK) == 0:
-        return 1
-    return 0
-
-try:
-    HOME = os.environ['HOME']
-except:
-    HOME="C:"
-
-if WITHDLLS:
-    # libxml dlls (expected in ROOT/bin)
-    dlls = [ 'iconv.dll','libxml2.dll','libxslt.dll','libexslt.dll' ]
-    dlls = [os.path.join(ROOT,'bin',dll) for dll in dlls]
-
-    # create __init__.py for the libxmlmods package
-    if not os.path.exists("libxmlmods"):
-        os.mkdir("libxmlmods")
-        open("libxmlmods/__init__.py","w").close()
-
-    def altImport(s):
-        s = s.replace("import libxml2mod","from libxmlmods import libxml2mod")
-        s = s.replace("import libxsltmod","from libxmlmods import libxsltmod")
-        return s
-
-if sys.platform.startswith('win'):
-    libraryPrefix = 'lib'
-    platformLibs = []
-else:
-    libraryPrefix = ''
-    platformLibs = ["m","z"]
-
-# those are examined to find
-# - libxml2/libxml/tree.h
-# - iconv.h
-# - libxslt/xsltconfig.h
-includes_dir = [
-"/usr/include",
-"/usr/local/include",
-"/opt/include",
-os.path.join(ROOT,'include'),
-HOME
-];
-
-xml_includes=""
-for dir in includes_dir:
-    if not missing(dir + "/libxml2/libxml/tree.h"):
-        xml_includes=dir + "/libxml2"
-        break;
-
-if xml_includes == "":
-    print("failed to find headers for libxml2: update includes_dir")
-    sys.exit(1)
-
-iconv_includes=""
-for dir in includes_dir:
-    if not missing(dir + "/iconv.h"):
-        iconv_includes=dir
-        break;
-
-if iconv_includes == "":
-    print("failed to find headers for libiconv: update includes_dir")
-    sys.exit(1)
-
-# those are added in the linker search path for libraries
-libdirs = [
-os.path.join(ROOT,'lib'),
-]
-
-xml_files = ["libxml2-api.xml", "libxml2-python-api.xml",
-             "libxml.c", "libxml.py", "libxml_wrap.h", "types.c",
-             "xmlgenerator.py", "README", "TODO", "drv_libxml2.py"]
-
-xslt_files = ["libxslt-api.xml", "libxslt-python-api.xml",
-             "libxslt.c", "libxsl.py", "libxslt_wrap.h",
-             "xsltgenerator.py"]
-
-if missing("libxml2-py.c") or missing("libxml2.py"):
-    try:
-        try:
-            import xmlgenerator
-        except:
-            import generator
-    except:
-        print("failed to find and generate stubs for libxml2, aborting ...")
-        print(sys.exc_info()[0], sys.exc_info()[1])
-        sys.exit(1)
-
-    head = open("libxml.py", "r")
-    generated = open("libxml2class.py", "r")
-    result = open("libxml2.py", "w")
-    for line in head.readlines():
-        if WITHDLLS:
-            result.write(altImport(line))
-        else:
-            result.write(line)
-    for line in generated.readlines():
-        result.write(line)
-    head.close()
-    generated.close()
-    result.close()
-
-with_xslt=0
-if missing("libxslt-py.c") or missing("libxslt.py"):
-    if missing("xsltgenerator.py") or missing("libxslt-api.xml"):
-        print("libxslt stub generator not found, libxslt not built")
-    else:
-        try:
-            import xsltgenerator
-        except:
-            print("failed to generate stubs for libxslt, aborting ...")
-            print(sys.exc_info()[0], sys.exc_info()[1])
-        else:
-            head = open("libxsl.py", "r")
-            generated = open("libxsltclass.py", "r")
-            result = open("libxslt.py", "w")
-            for line in head.readlines():
-                if WITHDLLS:
-                    result.write(altImport(line))
-                else:
-                    result.write(line)
-            for line in generated.readlines():
-                result.write(line)
-            head.close()
-            generated.close()
-            result.close()
-            with_xslt=1
-else:
-    with_xslt=1
-
-if with_xslt == 1:
-    xslt_includes=""
-    for dir in includes_dir:
-        if not missing(dir + "/libxslt/xsltconfig.h"):
-            xslt_includes=dir + "/libxslt"
-            break;
-
-    if xslt_includes == "":
-        print("failed to find headers for libxslt: update includes_dir")
-        with_xslt = 0
-
-
-descr = "libxml2 package"
-modules = [ 'libxml2', 'drv_libxml2' ]
-if WITHDLLS:
-    modules.append('libxmlmods.__init__')
-c_files = ['libxml2-py.c', 'libxml.c', 'types.c' ]
-includes= [xml_includes, iconv_includes]
-libs    = [libraryPrefix + "xml2"] + platformLibs
-macros  = []
-if with_threads:
-    macros.append(('_REENTRANT','1'))
-if with_xslt == 1:
-    descr = "libxml2 and libxslt package"
-    if not sys.platform.startswith('win'):
-        #
-        # We are gonna build 2 identical shared libs with merge initializing
-        # both libxml2mod and libxsltmod
-        #
-        c_files = c_files + ['libxslt-py.c', 'libxslt.c']
-        xslt_c_files = c_files
-        macros.append(('MERGED_MODULES', '1'))
-    else:
-        #
-        # On windows the MERGED_MODULE option is not needed
-        # (and does not work)
-        #
-        xslt_c_files = ['libxslt-py.c', 'libxslt.c', 'types.c']
-    libs.insert(0, libraryPrefix + 'exslt')
-    libs.insert(0, libraryPrefix + 'xslt')
-    includes.append(xslt_includes)
-    modules.append('libxslt')
-
-
-extens=[Extension('libxml2mod', c_files, include_dirs=includes,
-                  library_dirs=libdirs,
-                  libraries=libs, define_macros=macros)]
-if with_xslt == 1:
-    extens.append(Extension('libxsltmod', xslt_c_files, include_dirs=includes,
-                            library_dirs=libdirs,
-                            libraries=libs, define_macros=macros))
-
-if missing("MANIFEST"):
-
-    manifest = open("MANIFEST", "w")
-    manifest.write("setup.py\n")
-    for file in xml_files:
-        manifest.write(file + "\n")
-    if with_xslt == 1:
-        for file in xslt_files:
-            manifest.write(file + "\n")
-    manifest.close()
-
-if WITHDLLS:
-    ext_package = "libxmlmods"
-    if sys.version >= "2.2":
-        base = "lib/site-packages/"
-    else:
-        base = ""
-    data_files = [(base+"libxmlmods",dlls)]
-else:
-    ext_package = None
-    data_files = []
-
-setup (name = "libxml2-python",
-       # On *nix, the version number is created from setup.py.in
-       # On windows, it is set by configure.js
-       version = "2.9.2",
-       description = descr,
-       author = "Daniel Veillard",
-       author_email = "veillard@redhat.com",
-       url = "http://xmlsoft.org/python.html",
-       licence="MIT Licence",
-       py_modules=modules,
-       ext_modules=extens,
-       ext_package=ext_package,
-       data_files=data_files,
-       )
-
-sys.exit(0)
-
