{"patch": "--- a/lib/Parser/JSParserImpl.h\n+++ b/lib/Parser/JSParserImpl.h\n@@ -196,5 +196,9 @@\n   /// Track the parser recursion depth to avoid stack overflow.\n   /// We don't have to track it precisely as long as we increment it once in\n   /// every possible recursion cycle.\n   unsigned recursionDepth_{0};\n+\n+  // Maximum allowed parser recursion depth to prevent stack overflow.\n+  static constexpr unsigned MAX_PARSER_RECURSION_DEPTH = 1000;\n+\n \n--- a/lib/Parser/JSParserImpl.cpp\n+++ b/lib/Parser/JSParserImpl.cpp\n@@ -5523,8 +5523,14 @@\n Optional<ESTree::Node *> JSParserImpl::parseAssignmentExpression(\n     Param param,\n     AllowTypedArrowFunction allowTypedArrowFunction,\n     CoverTypedParameters coverTypedParameters,\n     ESTree::Node *typeParams) {\n+  llvh::SaveAndRestore<unsigned> depthGuard(recursionDepth_, recursionDepth_ + 1);\n+  if (recursionDepth_ > MAX_PARSER_RECURSION_DEPTH) {\n+    recursionDepthExceeded();\n+    return None;\n+  }\n+\n   struct State {\n     SMLoc leftStartLoc = {};\n     Optional<ESTree::Node *> optLeftExpr = llvh::None;\n@@ -4132,7 +4132,13 @@\n Optional<ESTree::Node *> JSParserImpl::parseConditionalExpression(\n     Param param,\n     CoverTypedParameters coverTypedParameters) {\n+  llvh::SaveAndRestore<unsigned> depthGuard(recursionDepth_, recursionDepth_ + 1);\n+  if (recursionDepth_ > MAX_PARSER_RECURSION_DEPTH) {\n+    recursionDepthExceeded();\n+    return None;\n+  }\n+\n   SMLoc startLoc = tok_->getStartLoc();\n   auto optTest = parseBinaryExpression(param);\n   if (!optTest)\n     return None;\n", "result": true}