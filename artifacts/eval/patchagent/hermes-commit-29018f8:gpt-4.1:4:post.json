{"patch": "--- a/lib/Parser/JSParserImpl.h\n+++ b/lib/Parser/JSParserImpl.h\n@@ -196,5 +196,5 @@\n   /// Track the parser recursion depth to avoid stack overflow.\n   /// We don't have to track it precisely as long as we increment it once in\n   /// every possible recursion cycle.\n-  unsigned recursionDepth_{0};\n+  unsigned recursionDepth_{0};\n \n--- a/lib/Parser/JSParserImpl.cpp\n+++ b/lib/Parser/JSParserImpl.cpp\n@@ -15,7 +15,16 @@\n using llvh::cast;\n using llvh::dyn_cast;\n using llvh::isa;\n+\n+// Helper for recursion depth management\n+namespace {\n+struct RecursionGuard {\n+  unsigned &depth;\n+  RecursionGuard(unsigned &d) : depth(d) {}\n+  ~RecursionGuard() { --depth; }\n+};\n+}\n \n namespace hermes {\n namespace parser {\n namespace detail {\n@@ -5523,8 +5523,16 @@\n Optional<ESTree::Node *> JSParserImpl::parseAssignmentExpression(\n     Param param,\n     AllowTypedArrowFunction allowTypedArrowFunction,\n     CoverTypedParameters coverTypedParameters,\n     ESTree::Node *typeParams) {\n+  constexpr unsigned MAX_RECURSION_DEPTH = 1000;\n+  if (++recursionDepth_ > MAX_RECURSION_DEPTH) {\n+    recursionDepthExceeded();\n+    --recursionDepth_;\n+    return None;\n+  }\n+  RecursionGuard _guard(recursionDepth_);\n+\n   struct State {\n     SMLoc leftStartLoc = {};\n     Optional<ESTree::Node *> optLeftExpr = llvh::None;\n@@ -4132,7 +4132,15 @@\n Optional<ESTree::Node *> JSParserImpl::parseConditionalExpression(\n     Param param,\n     CoverTypedParameters coverTypedParameters) {\n+  constexpr unsigned MAX_RECURSION_DEPTH = 1000;\n+  if (++recursionDepth_ > MAX_RECURSION_DEPTH) {\n+    recursionDepthExceeded();\n+    --recursionDepth_;\n+    return None;\n+  }\n+  RecursionGuard _guard(recursionDepth_);\n+\n   SMLoc startLoc = tok_->getStartLoc();\n   auto optTest = parseBinaryExpression(param);\n   if (!optTest)\n     return None;\n", "result": true}