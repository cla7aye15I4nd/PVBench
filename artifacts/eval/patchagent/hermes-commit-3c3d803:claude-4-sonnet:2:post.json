{"patch": "diff --git a/lib/Regex/Executor.cpp b/lib/Regex/Executor.cpp\nindex fb73b8e56..131dd3703 100644\n--- a/lib/Regex/Executor.cpp\n+++ b/lib/Regex/Executor.cpp\n@@ -400,6 +400,13 @@ struct Context {\n   /// This is effectively a timeout on the regexp execution.\n   uint32_t backtracksRemaining_ = kBacktrackLimit;\n \n+  /// The current recursion depth for match() calls.\n+  /// This prevents stack overflow from deeply nested lookaround assertions.\n+  uint32_t recursionDepth_ = 0;\n+\n+  /// Maximum allowed recursion depth for match() calls.\n+  static constexpr uint32_t kMaxRecursionDepth = 1000;\n+\n   Context(\n       llvh::ArrayRef<uint8_t> bytecodeStream,\n       constants::MatchFlagType flags,\n@@ -1315,8 +1322,15 @@ auto Context<Traits>::match(State<Traits> *s, bool onlyAtStart)\n             // Invoke match() recursively with our expression.\n             // Save and restore the position because lookaheads do not consume\n             // anything.\n+            if (LLVM_UNLIKELY(recursionDepth_ >= kMaxRecursionDepth)) {\n+              return ExecutionStatus::STACK_OVERFLOW;\n+            }\n+            recursionDepth_++;\n             s->ip_ += sizeof(LookaroundInsn);\n             auto match = this->match(s, true /* onlyAtStart */);\n+            recursionDepth_--;\n+            if (LLVM_UNLIKELY(match.getStatus() != ExecutionStatus::RETURNED))\n+              return match.getStatus();\n             // There were no errors and we matched something (so non-null\n             // return)\n             matched = match && match.getValue();\n", "result": true}