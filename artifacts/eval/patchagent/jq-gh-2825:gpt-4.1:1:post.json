{"patch": "--- a/src/decNumber/decNumber.c\n+++ b/src/decNumber/decNumber.c\n@@ -6169,46 +6169,54 @@\n static Int decCompare(const decNumber *lhs, const decNumber *rhs,\n                       Flag abs) {\n   Int   result;                    // result value\n   Int   sigr;                      // rhs signum\n   Int   compare;                   // work\n \n+  // Null and sanity checks\n+  if (lhs == NULL || rhs == NULL) {\n+    return BADINT;\n+  }\n+  if (lhs->digits <= 0 || rhs->digits <= 0) {\n+    return BADINT;\n+  }\n+\n   result=1;                                  // assume signum(lhs)\n   if (ISZERO(lhs)) result=0;\n   if (abs) {\n     if (ISZERO(rhs)) return result;          // LHS wins or both 0\n     // RHS is non-zero\n     if (result==0) return -1;                // LHS is 0; RHS wins\n     // [here, both non-zero, result=1]\n     }\n    else {                                    // signs matter\n     if (result && decNumberIsNegative(lhs)) result=-1;\n     sigr=1;                                  // compute signum(rhs)\n     if (ISZERO(rhs)) sigr=0;\n      else if (decNumberIsNegative(rhs)) sigr=-1;\n     if (result > sigr) return +1;            // L > R, return 1\n     if (result < sigr) return -1;            // L < R, return -1\n     if (result==0) return 0;                   // both 0\n     }\n \n   // signums are the same; both are non-zero\n   if ((lhs->bits | rhs->bits) & DECINF) {    // one or more infinities\n     if (decNumberIsInfinite(rhs)) {\n       if (decNumberIsInfinite(lhs)) result=0;// both infinite\n        else result=-result;                  // only rhs infinite\n       }\n     return result;\n     }\n   // must compare the coefficients, allowing for exponents\n   if (lhs->exponent>rhs->exponent) {         // LHS exponent larger\n     // swap sides, and sign\n     const decNumber *temp=lhs;\n     lhs=rhs;\n     rhs=temp;\n     result=-result;\n     }\n-  compare=decUnitCompare(lhs->lsu, D2U(lhs->digits),\n-                         rhs->lsu, D2U(rhs->digits),\n-                         rhs->exponent-lhs->exponent);\n+  compare=decUnitCompare(lhs->lsu, D2U(lhs->digits),\n+                        rhs->lsu, D2U(rhs->digits),\n+                        rhs->exponent-lhs->exponent);\n   if (compare!=BADINT) compare*=result;      // comparison succeeded\n   return compare;\n   } // decCompare\n@@ -6233,12 +6233,20 @@\n static Int decUnitCompare(const Unit *a, Int alength,\n                           const Unit *b, Int blength, Int exp) {\n   Unit  *acc;                      // accumulator for result\n   Unit  accbuff[SD2U(DECBUFFER*2+1)]; // local buffer\n   Unit  *allocacc=NULL;            // -> allocated acc buffer, iff allocated\n   Int   accunits, need;            // units in use or needed for acc\n   const Unit *l, *r, *u;           // work\n   Int   expunits, exprem, result;  // ..\n \n+  // Null and sanity checks\n+  if (a == NULL || b == NULL) {\n+    return BADINT;\n+  }\n+  if (alength < 0 || blength < 0 || exp < 0) {\n+    return BADINT;\n+  }\n+\n   if (exp==0) {                    // aligned; fastpath\n     if (alength>blength) return 1;\n     if (alength<blength) return -1;\n", "result": true}