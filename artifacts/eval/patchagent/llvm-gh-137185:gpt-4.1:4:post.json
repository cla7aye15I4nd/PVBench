{"patch": "diff --git a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\nindex 6027572f1e84..ff915beec8c8 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n@@ -2127,7 +2127,18 @@ void VPScalarIVStepsRecipe::execute(VPTransformState &State) {\n           Builder.CreateMul(StartIdx0, ConstantInt::get(StartIdx0->getType(),\n                                                         getUnrollPart(*this)));\n     }\n-    StartIdx0 = Builder.CreateTrunc(StartIdx0, IntStepTy);\n+    // Only perform truncation if it is valid.\n+    Type *SrcTy = nullptr;\n+    SrcTy = StartIdx0->getType();\n+    if (SrcTy->isIntegerTy() && IntStepTy->isIntegerTy() &&\n+        SrcTy->getScalarSizeInBits() > IntStepTy->getScalarSizeInBits()) {\n+      StartIdx0 = Builder.CreateTrunc(StartIdx0, IntStepTy);\n+    } else if (SrcTy == IntStepTy) {\n+      // No-op, types already match.\n+    } else {\n+      // Types are not compatible for truncation; skip or handle gracefully.\n+      // To avoid assertion failure, just leave StartIdx0 as is.\n+    }\n   }\n \n   if (!FirstLaneOnly && State.VF.isScalable()) {\n", "result": true}