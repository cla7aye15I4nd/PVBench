{"patch": "diff --git a/clang/lib/AST/ASTContext.cpp b/clang/lib/AST/ASTContext.cpp\nindex 92b246a83bce..0e2d290b3328 100644\n--- a/clang/lib/AST/ASTContext.cpp\n+++ b/clang/lib/AST/ASTContext.cpp\n@@ -2339,6 +2339,26 @@ TypeInfo ASTContext::getTypeInfoImpl(const Type *T) const {\n       Width = Target->getPointerWidth(LangAS::Default);\n       Align = Target->getPointerAlign(LangAS::Default);\n       break;\n+    // Placeholder types should not normally reach here, but if they do,\n+    // provide reasonable defaults to avoid crashes. These types are used\n+    // during parsing and type checking and should be resolved before\n+    // size/alignment queries.\n+    case BuiltinType::Dependent:\n+    case BuiltinType::Overload:\n+    case BuiltinType::BoundMember:\n+    case BuiltinType::UnresolvedTemplate:\n+    case BuiltinType::PseudoObject:\n+    case BuiltinType::UnknownAny:\n+    case BuiltinType::BuiltinFn:\n+    case BuiltinType::ARCUnbridgedCast:\n+    case BuiltinType::IncompleteMatrixIdx:\n+    case BuiltinType::ArraySection:\n+    case BuiltinType::OMPArrayShaping:\n+    case BuiltinType::OMPIterator:\n+      // Use int-sized defaults for placeholder types\n+      Width = Target->getIntWidth();\n+      Align = Target->getIntAlign();\n+      break;\n     }\n     break;\n   case Type::ObjCObjectPointer:\ndiff --git a/clang/lib/Sema/SemaOpenMP.cpp b/clang/lib/Sema/SemaOpenMP.cpp\nindex 835dba22a858..4ce1314f3101 100644\n--- a/clang/lib/Sema/SemaOpenMP.cpp\n+++ b/clang/lib/Sema/SemaOpenMP.cpp\n@@ -14344,10 +14344,14 @@ StmtResult SemaOpenMP::ActOnOpenMPTileDirective(ArrayRef<OMPClause *> Clauses,\n     // invariant that every loop iteration is executed exactly once and not\n     // cause an infinite loop, apply a minimum tile size of one.\n     // Build expr:\n-    // \\code{c}\n+    // If the type is a placeholder type, use int as a fallback to avoid crashes\n     //   (TS <= 0) ? 1 : TS\n     // \\endcode\n     QualType DimTy = DimTileSizeExpr->getType();\n+    // Double-check that we have a valid integer type\n+    if (!DimTy->isIntegerType()) {\n+      DimTy = Context.IntTy;\n+    }\n     uint64_t DimWidth = Context.getTypeSize(DimTy);\n     IntegerLiteral *Zero = IntegerLiteral::Create(\n         Context, llvm::APInt::getZero(DimWidth), DimTy, {});\n", "result": true}