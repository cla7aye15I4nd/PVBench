{"patch": "diff --git a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\nindex 275b3d567856..d6e2b0103672 100644\n--- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp\n@@ -7459,28 +7459,6 @@ VectorizationFactor LoopVectorizationPlanner::computeBestVF() {\n \n #ifndef NDEBUG\n   // Select the optimal vectorization factor according to the legacy cost-model.\n-  // This is now only used to verify the decisions by the new VPlan-based\n-  // cost-model and will be retired once the VPlan-based cost-model is\n-  // stabilized.\n-  VectorizationFactor LegacyVF = selectVectorizationFactor();\n-  VPlan &BestPlan = getPlanFor(BestFactor.Width);\n-\n-  // Pre-compute the cost and use it to check if BestPlan contains any\n-  // simplifications not accounted for in the legacy cost model. If that's the\n-  // case, don't trigger the assertion, as the extra simplifications may cause a\n-  // different VF to be picked by the VPlan-based cost model.\n-  VPCostContext CostCtx(CM.TTI, *CM.TLI, Legal->getWidestInductionType(), CM,\n-                        CM.CostKind);\n-  precomputeCosts(BestPlan, BestFactor.Width, CostCtx);\n-  // Verify that the VPlan-based and legacy cost models agree, except for VPlans\n-  // with early exits and plans with additional VPlan simplifications. The\n-  // legacy cost model doesn't properly model costs for such loops.\n-  assert((BestFactor.Width == LegacyVF.Width || BestPlan.hasEarlyExit() ||\n-          planContainsAdditionalSimplifications(getPlanFor(BestFactor.Width),\n-                                                CostCtx, OrigLoop) ||\n-          planContainsAdditionalSimplifications(getPlanFor(LegacyVF.Width),\n-                                                CostCtx, OrigLoop)) &&\n-         \" VPlan cost model and legacy cost model disagreed\");\n   assert((BestFactor.Width.isScalar() || BestFactor.ScalarCost > 0) &&\n          \"when vectorizing, the scalar cost must be computed.\");\n #endif\n", "result": true}