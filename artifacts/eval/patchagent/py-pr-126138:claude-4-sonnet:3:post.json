{"patch": "diff --git a/Modules/_asynciomodule.c b/Modules/_asynciomodule.c\nindex 7483e9c0f43..29425cbadeb 100644\n--- a/Modules/_asynciomodule.c\n+++ b/Modules/_asynciomodule.c\n@@ -2948,6 +2948,16 @@ task_step_handle_result_impl(asyncio_state *state, TaskObj *task, PyObject *resu\n \n         fut->fut_blocking = 0;\n \n+        /* Handle cancellation early to avoid use-after-free */\n+        if (task->task_must_cancel) {\n+            Py_INCREF(result);  /* Protect during cancel call */\n+            PyObject *r = PyObject_CallMethodOneArg(result, &_Py_ID(cancel),\n+                                                   task->task_cancel_msg);\n+            Py_DECREF(result);\n+            Py_XDECREF(r);  /* r might be NULL if cancel failed */\n+            task->task_must_cancel = 0;\n+        }\n+\n         /* result.add_done_callback(task._wakeup) */\n         wrapper = PyCFunction_New(&TaskWakeupDef, (PyObject *)task);\n         if (wrapper == NULL) {\n@@ -2964,24 +2974,6 @@ task_step_handle_result_impl(asyncio_state *state, TaskObj *task, PyObject *resu\n         /* task._fut_waiter = result */\n         task->task_fut_waiter = result;  /* no incref is necessary */\n \n-        if (task->task_must_cancel) {\n-            PyObject *r;\n-            int is_true;\n-            r = PyObject_CallMethodOneArg(result, &_Py_ID(cancel),\n-                                             task->task_cancel_msg);\n-            if (r == NULL) {\n-                return NULL;\n-            }\n-            is_true = PyObject_IsTrue(r);\n-            Py_DECREF(r);\n-            if (is_true < 0) {\n-                return NULL;\n-            }\n-            else if (is_true) {\n-                task->task_must_cancel = 0;\n-            }\n-        }\n-\n         Py_RETURN_NONE;\n     }\n \n@@ -3030,6 +3022,16 @@ task_step_handle_result_impl(asyncio_state *state, TaskObj *task, PyObject *resu\n             goto fail;\n         }\n \n+        /* Handle cancellation early to avoid use-after-free */\n+        if (task->task_must_cancel) {\n+            Py_INCREF(result);  /* Protect during cancel call */\n+            PyObject *r = PyObject_CallMethodOneArg(result, &_Py_ID(cancel),\n+                                                   task->task_cancel_msg);\n+            Py_DECREF(result);\n+            Py_XDECREF(r);  /* r might be NULL if cancel failed */\n+            task->task_must_cancel = 0;\n+        }\n+\n         wrapper = PyCFunction_New(&TaskWakeupDef, (PyObject *)task);\n         if (wrapper == NULL) {\n             goto fail;\n@@ -3057,24 +3059,6 @@ task_step_handle_result_impl(asyncio_state *state, TaskObj *task, PyObject *resu\n         /* task._fut_waiter = result */\n         task->task_fut_waiter = result;  /* no incref is necessary */\n \n-        if (task->task_must_cancel) {\n-            PyObject *r;\n-            int is_true;\n-            r = PyObject_CallMethodOneArg(result, &_Py_ID(cancel),\n-                                             task->task_cancel_msg);\n-            if (r == NULL) {\n-                return NULL;\n-            }\n-            is_true = PyObject_IsTrue(r);\n-            Py_DECREF(r);\n-            if (is_true < 0) {\n-                return NULL;\n-            }\n-            else if (is_true) {\n-                task->task_must_cancel = 0;\n-            }\n-        }\n-\n         Py_RETURN_NONE;\n     }\n \n", "result": true}