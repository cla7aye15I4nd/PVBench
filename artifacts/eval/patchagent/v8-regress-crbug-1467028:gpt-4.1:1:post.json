{"patch": "diff --git a/src/parsing/parser.cc b/src/parsing/parser.cc\nindex bb1c37968ce..24832b0b023 100644\n--- a/src/parsing/parser.cc\n+++ b/src/parsing/parser.cc\n@@ -901,14 +901,20 @@ void Parser::ParseFunction(Isolate* isolate, ParseInfo* info,\n   FunctionKind function_kind = flags().function_kind();\n   FunctionLiteral* result;\n   if (V8_UNLIKELY(IsClassMembersInitializerFunction(function_kind))) {\n-    DCHECK(!maybe_outer_scope_info.is_null());\n-    // Reparsing of class member initializer functions has to be handled\n-    // specially because they require reparsing of the whole class body,\n-    // function start/end positions correspond to the class literal body\n-    // positions.\n-    result = ParseClassForMemberInitialization(\n-        isolate, maybe_outer_scope_info, function_kind, start_position,\n-        function_literal_id, end_position, info->function_name());\n+    if (maybe_outer_scope_info.is_null()) {\n+      // Outer scope info is missing, cannot safely reparse as class member initializer.\n+      // Fallback to normal function parsing path.\n+      result = DoParseFunction(isolate, info, start_position, end_position,\n+                               function_literal_id, info->function_name());\n+    } else {\n+      // Reparsing of class member initializer functions has to be handled\n+      // specially because they require reparsing of the whole class body,\n+      // function start/end positions correspond to the class literal body\n+      // positions.\n+      result = ParseClassForMemberInitialization(\n+          isolate, maybe_outer_scope_info, function_kind, start_position,\n+          function_literal_id, end_position, info->function_name());\n+    }\n \n   } else if (V8_UNLIKELY(shared_info->private_name_lookup_skips_outer_class() &&\n                          original_scope_->is_class_scope())) {\n", "result": true}