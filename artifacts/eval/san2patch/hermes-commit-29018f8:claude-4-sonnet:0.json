[{"patch": "diff --git a/lib/Parser/JSParserImpl.cpp b/lib/Parser/JSParserImpl.cpp\nindex 0589efb3a..68ebb7611 100644\n--- a/lib/Parser/JSParserImpl.cpp\n+++ b/lib/Parser/JSParserImpl.cpp\n@@ -4150,7 +4150,7 @@ Optional<ESTree::Node *> JSParserImpl::parseConditionalExpression(\n       auto optCover = tryParseCoverTypedIdentifierNode(test, false);\n       if (!optCover)\n         return None;\n-      if (*optCover)\n+if (*optCover)\n         return *optCover;\n     }\n #endif\n@@ -4159,6 +4159,20 @@ Optional<ESTree::Node *> JSParserImpl::parseConditionalExpression(\n     return test;\n   }\n \n+  // Recursion depth tracking to prevent stack overflow\n+  static thread_local int recursionDepth = 0;\n+  if (recursionDepth > 1000) {\n+    error(tok_->getSourceRange().Start, \"Maximum recursion depth exceeded\");\n+    return nullptr;\n+  }\n+  \n+  // RAII-style recursion depth management\n+  struct RecursionGuard {\n+    RecursionGuard() { recursionDepth++; }\n+    ~RecursionGuard() { recursionDepth--; }\n+  };\n+  RecursionGuard guard;\n+  \n   ESTree::Node *consequent = nullptr;\n   SMRange questionRange = tok_->getSourceRange();\n \n@@ -4170,8 +4184,7 @@ Optional<ESTree::Node *> JSParserImpl::parseConditionalExpression(\n     JSLexer::SavePoint savePoint{&lexer_};\n     advance();\n \n-    // If CoverTypedParameters::Yes, we still need to account for this\n-    // being formal parameters, so try that,\n+    // If CoverTypedParameters::Yes, we still need to account for this    // being formal parameters, so try that,\n     // in which case the '?' was part of an optional parameter, not a\n     // conditional expression.\n     if (coverTypedParameters == CoverTypedParameters::Yes) {\n@@ -5927,7 +5940,11 @@ bool JSParserImpl::parseAssertClause(ESTree::NodeList &attributes) {\n           start))\n     return false;\n \n-  while (!check(TokenKind::r_brace)) {\n+  int loopCount = 0;\n+  const int MAX_LOOP_ITERATIONS = 1000;\n+  \n+  while (!check(TokenKind::r_brace) && loopCount < MAX_LOOP_ITERATIONS) {\n+    loopCount++;\n     // AssertionKey : StringLiteral\n     // ^\n     ESTree::Node *key = nullptr;\n"}]