{"patch": "diff --git a/lib/Parser/JSParserImpl.cpp b/lib/Parser/JSParserImpl.cpp\nindex 0589efb3a..559ff8daa 100644\n--- a/lib/Parser/JSParserImpl.cpp\n+++ b/lib/Parser/JSParserImpl.cpp\n@@ -5616,7 +5616,7 @@ Optional<ESTree::Node *> JSParserImpl::parseAssignmentExpression(\n                 \"type parameters must be used in an arrow function expression\");\n             return None;\n           }\n-        } else {\n+                } else {\n           // Invalid type params, and also invalid JSX. Bail.\n           savePoint.restore();\n         }\n@@ -5625,6 +5625,7 @@ Optional<ESTree::Node *> JSParserImpl::parseAssignmentExpression(\n #endif\n \n     state.leftStartLoc = tok_->getStartLoc();\n+    CHECK_RECURSION;\n     state.optLeftExpr = parseConditionalExpression(param, coverTypedParameters);\n     if (!state.optLeftExpr)\n       return None;\n@@ -5636,8 +5637,7 @@ Optional<ESTree::Node *> JSParserImpl::parseAssignmentExpression(\n       if (allowTypedArrowFunction == AllowTypedArrowFunction::Yes &&\n           ((*state.optLeftExpr)->getParens() != 0 ||\n            isa<ESTree::CoverEmptyArgsNode>(*state.optLeftExpr)) &&\n-          check(TokenKind::colon)) {\n-        JSLexer::SavePoint savePoint{&lexer_};\n+          check(TokenKind::colon)) {        JSLexer::SavePoint savePoint{&lexer_};\n         // Defer our decision on whether to show or suppress messages for this\n         // next section.\n         // If we are unsuccessful during the parse, it can mean that we need to\n", "result": true}