{"patch": "diff --git a/lib/Parser/JSParserImpl.cpp b/lib/Parser/JSParserImpl.cpp\nindex 0589efb3a..1d152cbac 100644\n--- a/lib/Parser/JSParserImpl.cpp\n+++ b/lib/Parser/JSParserImpl.cpp\n@@ -5617,7 +5617,8 @@ Optional<ESTree::Node *> JSParserImpl::parseAssignmentExpression(\n             return None;\n           }\n         } else {\n-          // Invalid type params, and also invalid JSX. Bail.\n+// FIXME: Crash CWE-674: Uncontrolled Recursion\n+           // Invalid type params, and also invalid JSX. Bail.\n           savePoint.restore();\n         }\n       }\n@@ -5625,12 +5626,18 @@ Optional<ESTree::Node *> JSParserImpl::parseAssignmentExpression(\n #endif\n \n     state.leftStartLoc = tok_->getStartLoc();\n+    // Add recursion depth check before parsing conditional expression\n+    if (recursionDepth_ >= MAX_RECURSION_DEPTH) {\n+      error(tok_->getStartLoc(), \"maximum recursion depth exceeded\");\n+      return None;\n+    }\n+    recursionDepth_++;\n     state.optLeftExpr = parseConditionalExpression(param, coverTypedParameters);\n+    recursionDepth_--;\n     if (!state.optLeftExpr)\n       return None;\n \n-    ESTree::Node *returnType = nullptr;\n-    ESTree::Node *predicate = nullptr;\n+    ESTree::Node *returnType = nullptr;    ESTree::Node *predicate = nullptr;\n #if HERMES_PARSE_FLOW\n     if (context_.getParseFlow()) {\n       if (allowTypedArrowFunction == AllowTypedArrowFunction::Yes &&\n", "result": true}