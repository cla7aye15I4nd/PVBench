[{"patch": "diff --git a/lib/Parser/JSParserImpl.cpp b/lib/Parser/JSParserImpl.cpp\nindex 0589efb3a..0c9e7b75c 100644\n--- a/lib/Parser/JSParserImpl.cpp\n+++ b/lib/Parser/JSParserImpl.cpp\n@@ -4242,10 +4242,19 @@ Optional<ESTree::Node *> JSParserImpl::parseConditionalExpression(\n           \"in conditional expression after '... ? ...'\",\n           \"location of '?'\",\n           questionRange.Start))\n-    return None;\n+     return None;\n \n+  // Check recursion depth to prevent stack overflow\n+  if (recursionDepth_ >= MAX_RECURSION_DEPTH) {\n+    error(\n+        questionRange.Start,\n+        \"maximum recursion depth exceeded in conditional expression\");\n+    return None;\n+  }\n+  recursionDepth_++;\n   auto optAlternate = parseAssignmentExpression(\n       param, AllowTypedArrowFunction::Yes, CoverTypedParameters::No);\n+  recursionDepth_--;\n   if (!optAlternate)\n     return None;\n   ESTree::Node *alternate = *optAlternate;\n@@ -5768,28 +5777,31 @@ Optional<ESTree::Node *> JSParserImpl::parseAssignmentExpression(\n       state.optLeftExpr = reparseAssignmentPattern(*state.optLeftExpr, false);\n       if (!state.optLeftExpr)\n         return None;\n-    }\n+  }\n \n-    state.op = getTokenIdent(tok_->getKind());\n-    state.debugLoc = advance().Start;\n-    return nullptr;\n-  };\n+  state.op = getTokenIdent(tok_->getKind());\n+  state.debugLoc = advance().Start;\n+  return nullptr;\n+};\n \n-  llvh::SmallVector<State, 2> stack;\n+llvh::SmallVector<State, 2> stack;\n+// FIXME: Crash CWE-674: Uncontrolled Recursion - Added recursion depth tracking\n \n-  stack.emplace_back();\n-  auto optRes = parseHelper(\n-      stack.back(),\n-      param,\n-      allowTypedArrowFunction,\n-      coverTypedParameters,\n-      typeParams);\n+const int MAX_RECURSION_DEPTH = 500;\n+int recursionDepth = 0;\n \n-  for (;;) {\n-    if (!optRes)\n-      return None;\n-    if (!stack.back().op) {\n-      stack.pop_back();\n+stack.emplace_back();\n+auto optRes = parseHelper(\n+    stack.back(),\n+    param,\n+    allowTypedArrowFunction,\n+    coverTypedParameters,\n+    typeParams);\n+\n+for (;;) {\n+  if (!optRes)\n+    return None;\n+  if (!stack.back().op) {      stack.pop_back();\n       break;\n     }\n     if (stack.size() > ESTree::MAX_NESTED_ASSIGNMENTS) {\n"}]