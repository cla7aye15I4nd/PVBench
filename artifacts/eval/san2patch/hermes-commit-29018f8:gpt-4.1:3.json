[{"patch": "diff --git a/lib/Parser/JSParserImpl.cpp b/lib/Parser/JSParserImpl.cpp\nindex 0589efb3a..f24f4fc3c 100644\n--- a/lib/Parser/JSParserImpl.cpp\n+++ b/lib/Parser/JSParserImpl.cpp\n@@ -4225,20 +4225,28 @@ Optional<ESTree::Node *> JSParserImpl::parseConditionalExpression(\n \n   // Only try with AllowTypedArrowFunction::No if we haven't already set\n   // up the consequent using AllowTypedArrowFunction::Yes.\n-  if (!consequent) {\n+// FIXME: Crash CWE-674: Uncontrolled Recursion\n+   if (!consequent) {\n     // Consume the '?' (either for the first time or after savePoint.restore()).\n     advance();\n+    static int parse_conditional_depth = 0;\n+    ++parse_conditional_depth;\n+    if (parse_conditional_depth > 256) {\n+      error(\"Exceeded maximum recursion depth in conditional expression\");\n+      --parse_conditional_depth;\n+      return None;\n+    }\n     CHECK_RECURSION;\n     auto optConsequent = parseAssignmentExpression(\n         ParamIn, AllowTypedArrowFunction::No, CoverTypedParameters::No);\n+    --parse_conditional_depth;\n     if (!optConsequent)\n       return None;\n     consequent = *optConsequent;\n   }\n \n   if (!eat(\n-          TokenKind::colon,\n-          JSLexer::AllowRegExp,\n+          TokenKind::colon,          JSLexer::AllowRegExp,\n           \"in conditional expression after '... ? ...'\",\n           \"location of '?'\",\n           questionRange.Start))\n@@ -5768,7 +5776,7 @@ Optional<ESTree::Node *> JSParserImpl::parseAssignmentExpression(\n       state.optLeftExpr = reparseAssignmentPattern(*state.optLeftExpr, false);\n       if (!state.optLeftExpr)\n         return None;\n-    }\n+}\n \n     state.op = getTokenIdent(tok_->getKind());\n     state.debugLoc = advance().Start;\n@@ -5776,7 +5784,13 @@ Optional<ESTree::Node *> JSParserImpl::parseAssignmentExpression(\n   };\n \n   llvh::SmallVector<State, 2> stack;\n-\n+// FIXME: Crash CWE-674: Uncontrolled Recursion\n+  constexpr int maxDepth = 1024;\n+  static int currentDepth = 0;\n+  if (currentDepth++ > maxDepth) {\n+    // Exceeded depth: avoid recursion\n+    return None;\n+  }\n   stack.emplace_back();\n   auto optRes = parseHelper(\n       stack.back(),\n@@ -5784,12 +5798,12 @@ Optional<ESTree::Node *> JSParserImpl::parseAssignmentExpression(\n       allowTypedArrowFunction,\n       coverTypedParameters,\n       typeParams);\n+  --currentDepth;\n \n   for (;;) {\n     if (!optRes)\n       return None;\n-    if (!stack.back().op) {\n-      stack.pop_back();\n+    if (!stack.back().op) {      stack.pop_back();\n       break;\n     }\n     if (stack.size() > ESTree::MAX_NESTED_ASSIGNMENTS) {\n"}]