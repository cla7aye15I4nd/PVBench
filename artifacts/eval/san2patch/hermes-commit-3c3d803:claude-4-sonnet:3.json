[{"patch": "diff --git a/lib/Regex/Executor.cpp b/lib/Regex/Executor.cpp\nindex fb73b8e56..6f4cc1ea9 100644\n--- a/lib/Regex/Executor.cpp\n+++ b/lib/Regex/Executor.cpp\n@@ -1304,22 +1304,36 @@ auto Context<Traits>::match(State<Traits> *s, bool onlyAtStart)\n         case Opcode::Lookaround: {\n           const LookaroundInsn *insn = llvh::cast<LookaroundInsn>(base);\n           bool matched = false;\n-          if (c.satisfiesConstraints(flags_, insn->constraints)) {\n-            // Copy the state. This is because if the match fails (or if we are\n+                  if (c.satisfiesConstraints(flags_, insn->constraints)) {\n+// FIXME: Crash CWE-674: Uncontrolled Recursion\n+             // Copy the state. This is because if the match fails (or if we are\n             // inverted) we need to restore its capture groups.\n             State savedState{*s};\n \n             // Set the direction of the cursor.\n             c.setForwards(insn->forwards);\n \n-            // Invoke match() recursively with our expression.\n+            // Invoke match() with recursion depth limit to prevent stack overflow\n             // Save and restore the position because lookaheads do not consume\n             // anything.\n             s->ip_ += sizeof(LookaroundInsn);\n-            auto match = this->match(s, true /* onlyAtStart */);\n-            // There were no errors and we matched something (so non-null\n-            // return)\n-            matched = match && match.getValue();\n+            \n+            // Add recursion depth tracking to prevent infinite recursion\n+            static const uint32_t MAX_RECURSION_DEPTH = 1000;\n+            static thread_local uint32_t recursionDepth = 0;\n+            \n+            if (recursionDepth < MAX_RECURSION_DEPTH) {\n+                recursionDepth++;\n+                auto match = this->match(s, true /* onlyAtStart */);\n+                recursionDepth--;\n+                \n+                // There were no errors and we matched something (so non-null return)\n+                matched = match && match.getValue();\n+            } else {\n+                // Recursion depth exceeded, treat as no match to prevent stack overflow\n+                matched = false;\n+            }\n+            \n             c.setCurrentPointer(savedState.cursor_.currentPointer());\n             c.setForwards(savedState.cursor_.forwards());\n \n"}]