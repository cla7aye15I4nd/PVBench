[{"patch": "diff --git a/lib/Regex/Executor.cpp b/lib/Regex/Executor.cpp\nindex fb73b8e56..c19ed4f8a 100644\n--- a/lib/Regex/Executor.cpp\n+++ b/lib/Regex/Executor.cpp\n@@ -1305,7 +1305,8 @@ auto Context<Traits>::match(State<Traits> *s, bool onlyAtStart)\n           const LookaroundInsn *insn = llvh::cast<LookaroundInsn>(base);\n           bool matched = false;\n           if (c.satisfiesConstraints(flags_, insn->constraints)) {\n-            // Copy the state. This is because if the match fails (or if we are\n+// FIXME: Crash CWE-674: Uncontrolled Recursion\n+             // Copy the state. This is because if the match fails (or if we are\n             // inverted) we need to restore its capture groups.\n             State savedState{*s};\n \n@@ -1316,10 +1317,20 @@ auto Context<Traits>::match(State<Traits> *s, bool onlyAtStart)\n             // Save and restore the position because lookaheads do not consume\n             // anything.\n             s->ip_ += sizeof(LookaroundInsn);\n-            auto match = this->match(s, true /* onlyAtStart */);\n-            // There were no errors and we matched something (so non-null\n-            // return)\n-            matched = match && match.getValue();\n+            \n+            // Limit recursion depth to prevent stack overflow\n+            static thread_local int recursionCount = 0;\n+            if (recursionCount >= 150) {\n+              matched = false;\n+            } else {\n+              recursionCount++;\n+              auto match = this->match(s, true /* onlyAtStart */);\n+              recursionCount--;\n+              // There were no errors and we matched something (so non-null\n+              // return)\n+              matched = match && match.getValue();\n+            }\n+            \n             c.setCurrentPointer(savedState.cursor_.currentPointer());\n             c.setForwards(savedState.cursor_.forwards());\n \n"}]