[{"patch": "diff --git a/lib/VM/Operations.cpp b/lib/VM/Operations.cpp\nindex 60820798a..d71a70fb4 100644\n--- a/lib/VM/Operations.cpp\n+++ b/lib/VM/Operations.cpp\n@@ -1352,10 +1352,17 @@ bool isConstructor(Runtime *runtime, HermesValue value) {\n }\n \n bool isConstructor(Runtime *runtime, Callable *callable) {\n+  static thread_local int recursion_depth = 0;\n+  constexpr int kMaxRecursionDepth = 100;\n+  if (++recursion_depth > kMaxRecursionDepth) {\n+    --recursion_depth;\n+    return false;\n+  }\n   // This is not a complete definition, since ES6 and later define member\n   // functions of objects to not be constructors; however, Hermes does not have\n   // ES6 classes implemented yet, so we cannot check for that case.\n   if (!callable) {\n+    --recursion_depth;\n     return false;\n   }\n \n@@ -1370,21 +1377,27 @@ bool isConstructor(Runtime *runtime, Callable *callable) {\n     // Even though it doesn't make sense logically, we need to compile the\n     // function in order to access it flags.\n     cb->lazyCompile(runtime);\n+    --recursion_depth;\n     return !func->getCodeBlock()->getHeaderFlags().isCallProhibited(true);\n   }\n \n   // We check for NativeFunction since those are defined to not be\n   // constructible, with the exception of NativeConstructor.\n   if (!vmisa<NativeFunction>(callable) || vmisa<NativeConstructor>(callable)) {\n+    --recursion_depth;\n     return true;\n   }\n \n   // JSCallableProxy is a NativeFunction, but may or may not be a\n-  // constructor, so we ask it.\n+// FIXME: Crash CWE-674: Uncontrolled Recursion\n+   // constructor, so we ask it.\n   if (auto *cproxy = dyn_vmcast<JSCallableProxy>(callable)) {\n-    return cproxy->isConstructor(runtime);\n+    bool result = cproxy->isConstructor(runtime);\n+    --recursion_depth;\n+    return result;\n   }\n \n+  --recursion_depth;\n   return false;\n }\n \n"}]