[{"patch": "diff --git a/lib/VM/Operations.cpp b/lib/VM/Operations.cpp\nindex 60820798a..9529ea8a4 100644\n--- a/lib/VM/Operations.cpp\n+++ b/lib/VM/Operations.cpp\n@@ -1355,10 +1355,15 @@ bool isConstructor(Runtime *runtime, Callable *callable) {\n   // This is not a complete definition, since ES6 and later define member\n   // functions of objects to not be constructors; however, Hermes does not have\n   // ES6 classes implemented yet, so we cannot check for that case.\n+  static thread_local int recursionDepth = 0;\n+  const int kMaxRecursion = 32;\n   if (!callable) {\n     return false;\n   }\n-\n+  if (++recursionDepth > kMaxRecursion) {\n+    --recursionDepth;\n+    return false;\n+  }\n   // We traverse the BoundFunction target chain to find the eventual target.\n   while (BoundFunction *b = dyn_vmcast<BoundFunction>(callable)) {\n     callable = b->getTarget(runtime);\n@@ -1370,21 +1375,27 @@ bool isConstructor(Runtime *runtime, Callable *callable) {\n     // Even though it doesn't make sense logically, we need to compile the\n     // function in order to access it flags.\n     cb->lazyCompile(runtime);\n+    --recursionDepth;\n     return !func->getCodeBlock()->getHeaderFlags().isCallProhibited(true);\n   }\n \n   // We check for NativeFunction since those are defined to not be\n   // constructible, with the exception of NativeConstructor.\n   if (!vmisa<NativeFunction>(callable) || vmisa<NativeConstructor>(callable)) {\n+    --recursionDepth;\n     return true;\n   }\n \n   // JSCallableProxy is a NativeFunction, but may or may not be a\n-  // constructor, so we ask it.\n+// FIXME: Crash CWE-674: Uncontrolled Recursion\n+   // constructor, so we ask it.\n   if (auto *cproxy = dyn_vmcast<JSCallableProxy>(callable)) {\n-    return cproxy->isConstructor(runtime);\n+    bool result = cproxy->isConstructor(runtime);\n+    --recursionDepth;\n+    return result;\n   }\n \n+  --recursionDepth;\n   return false;\n }\n \n"}]