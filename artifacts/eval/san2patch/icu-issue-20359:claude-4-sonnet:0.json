[{"patch": "diff --git a/icu4c/source/i18n/regexcmp.cpp b/icu4c/source/i18n/regexcmp.cpp\nindex a4c12804237..a1f6a662a61 100644\n--- a/icu4c/source/i18n/regexcmp.cpp\n+++ b/icu4c/source/i18n/regexcmp.cpp\n@@ -4010,7 +4010,8 @@ UChar32  RegexCompile::peekCharLL() {\n //\n //------------------------------------------------------------------------------\n void RegexCompile::nextChar(RegexPatternChar &c) {\n-\n+    static int recursionDepth = 0;\n+    \n     fScanIndex = UTEXT_GETNATIVEINDEX(fRXPat->fPattern);\n     c.fChar    = nextCharLL();\n     c.fQuoted  = FALSE;\n@@ -4018,10 +4019,20 @@ void RegexCompile::nextChar(RegexPatternChar &c) {\n     if (fQuoteMode) {\n         c.fQuoted = TRUE;\n         if ((c.fChar==chBackSlash && peekCharLL()==chE && ((fModeFlags & UREGEX_LITERAL) == 0)) ||\n-            c.fChar == (UChar32)-1) {\n+// FIXME: Crash CWE-674: Uncontrolled Recursion\n+             c.fChar == (UChar32)-1) {\n             fQuoteMode = FALSE;  //  Exit quote mode,\n             nextCharLL();        // discard the E\n-            nextChar(c);         // recurse to get the real next char\n+            // Prevent infinite recursion by limiting depth\n+            if (recursionDepth < 10) {\n+                recursionDepth++;\n+                nextChar(c);         // recurse to get the real next char\n+                recursionDepth--;\n+            } else {\n+                // Too deep, break recursion and return safe default\n+                c.fChar = (UChar32)-1;\n+                c.fQuoted = FALSE;\n+            }\n         }\n     }\n     else if (fInBackslashQuote) {\n@@ -4030,8 +4041,7 @@ void RegexCompile::nextChar(RegexPatternChar &c) {\n         // Don't set c.fQuoted, because that would prevent the state machine from\n         //    dispatching on the character.\n         fInBackslashQuote = FALSE;\n-    }\n-    else\n+    }    else\n     {\n         // We are not in a \\Q quoted region \\E of the source.\n         //\n@@ -4137,7 +4147,20 @@ void RegexCompile::nextChar(RegexPatternChar &c) {\n                 c.fQuoted = TRUE;\n             }\n             else if (peekCharLL() == chQ) {\n-                //  \"\\Q\"  enter quote mode, which will continue until \"\\E\"\n+// FIXME: Crash CWE-674: Uncontrolled Recursion\n+                 //  \"\\Q\"  enter quote mode, which will continue until \"\\E\"\n+                // Fix: Track state transitions to detect cyclic patterns\n+                static int transitionCount = 0;\n+                if (fQuoteMode == TRUE || fInBackslashQuote == TRUE) {\n+                    transitionCount++;\n+                    if (transitionCount > 10) {\n+                        error(U_REGEX_RULE_SYNTAX);\n+                        transitionCount = 0;\n+                        return;\n+                    }\n+                } else {\n+                    transitionCount = 0;\n+                }\n                 fQuoteMode = TRUE;\n                 nextCharLL();       // discard the 'Q'.\n                 nextChar(c);        // recurse to get the real next char.\n"}]