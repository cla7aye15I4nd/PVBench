[{"patch": "diff --git a/icu4c/source/i18n/regexcmp.cpp b/icu4c/source/i18n/regexcmp.cpp\nindex a4c12804237..e0139e97a87 100644\n--- a/icu4c/source/i18n/regexcmp.cpp\n+++ b/icu4c/source/i18n/regexcmp.cpp\n@@ -4069,87 +4069,96 @@ void RegexCompile::nextChar(RegexPatternChar &c) {\n         //  check for backslash escaped characters.\n         //\n         if (c.fChar == chBackSlash) {\n-            int64_t pos = UTEXT_GETNATIVEINDEX(fRXPat->fPattern);\n-            if (RegexStaticSets::gStaticSets->fUnescapeCharSet.contains(peekCharLL())) {\n-                //\n-                // A '\\' sequence that is handled by ICU's standard unescapeAt function.\n-                //   Includes \\uxxxx, \\n, \\r, many others.\n-                //   Return the single equivalent character.\n-                //\n-                nextCharLL();                 // get & discard the peeked char.\n-                c.fQuoted = TRUE;\n+    int64_t pos = UTEXT_GETNATIVEINDEX(fRXPat->fPattern);\n+    if (RegexStaticSets::gStaticSets->fUnescapeCharSet.contains(peekCharLL())) {\n+        //\n+        // A '\\' sequence that is handled by ICU's standard unescapeAt function.\n+        //   Includes \\uxxxx, \\n, \\r, many others.\n+        //   Return the single equivalent character.\n+        //\n+        nextCharLL();                 // get & discard the peeked char.\n+        c.fQuoted = TRUE;\n \n-                if (UTEXT_FULL_TEXT_IN_CHUNK(fRXPat->fPattern, fPatternLength)) {\n-                    int32_t endIndex = (int32_t)pos;\n-                    c.fChar = u_unescapeAt(uregex_ucstr_unescape_charAt, &endIndex, (int32_t)fPatternLength, (void *)fRXPat->fPattern->chunkContents);\n+        if (UTEXT_FULL_TEXT_IN_CHUNK(fRXPat->fPattern, fPatternLength)) {\n+            int32_t endIndex = (int32_t)pos;\n+            c.fChar = u_unescapeAt(uregex_ucstr_unescape_charAt, &endIndex, (int32_t)fPatternLength, (void *)fRXPat->fPattern->chunkContents);\n \n-                    if (endIndex == pos) {\n-                        error(U_REGEX_BAD_ESCAPE_SEQUENCE);\n-                    }\n-                    fCharNum += endIndex - pos;\n-                    UTEXT_SETNATIVEINDEX(fRXPat->fPattern, endIndex);\n-                } else {\n-                    int32_t offset = 0;\n-                    struct URegexUTextUnescapeCharContext context = U_REGEX_UTEXT_UNESCAPE_CONTEXT(fRXPat->fPattern);\n-\n-                    UTEXT_SETNATIVEINDEX(fRXPat->fPattern, pos);\n-                    c.fChar = u_unescapeAt(uregex_utext_unescape_charAt, &offset, INT32_MAX, &context);\n-\n-                    if (offset == 0) {\n-                        error(U_REGEX_BAD_ESCAPE_SEQUENCE);\n-                    } else if (context.lastOffset == offset) {\n-                        UTEXT_PREVIOUS32(fRXPat->fPattern);\n-                    } else if (context.lastOffset != offset-1) {\n-                        utext_moveIndex32(fRXPat->fPattern, offset - context.lastOffset - 1);\n-                    }\n-                    fCharNum += offset;\n-                }\n+            if (endIndex == pos) {\n+                error(U_REGEX_BAD_ESCAPE_SEQUENCE);\n             }\n-            else if (peekCharLL() == chDigit0) {\n-                //  Octal Escape, using Java Regexp Conventions\n-                //    which are \\0 followed by 1-3 octal digits.\n-                //    Different from ICU Unescape handling of Octal, which does not\n-                //    require the leading 0.\n-                //  Java also has the convention of only consuming 2 octal digits if\n-                //    the three digit number would be > 0xff\n-                //\n-                c.fChar = 0;\n-                nextCharLL();    // Consume the initial 0.\n-                int index;\n-                for (index=0; index<3; index++) {\n-                    int32_t ch = peekCharLL();\n-                    if (ch<chDigit0 || ch>chDigit7) {\n-                        if (index==0) {\n-                           // \\0 is not followed by any octal digits.\n-                           error(U_REGEX_BAD_ESCAPE_SEQUENCE);\n-                        }\n-                        break;\n-                    }\n-                    c.fChar <<= 3;\n-                    c.fChar += ch&7;\n-                    if (c.fChar <= 255) {\n-                        nextCharLL();\n-                    } else {\n-                        // The last digit made the number too big.  Forget we saw it.\n-                        c.fChar >>= 3;\n-                    }\n-                }\n-                c.fQuoted = TRUE;\n+            fCharNum += endIndex - pos;\n+            UTEXT_SETNATIVEINDEX(fRXPat->fPattern, endIndex);\n+        } else {\n+            int32_t offset = 0;\n+            struct URegexUTextUnescapeCharContext context = U_REGEX_UTEXT_UNESCAPE_CONTEXT(fRXPat->fPattern);\n+\n+            UTEXT_SETNATIVEINDEX(fRXPat->fPattern, pos);\n+            c.fChar = u_unescapeAt(uregex_utext_unescape_charAt, &offset, INT32_MAX, &context);\n+\n+            if (offset == 0) {\n+                error(U_REGEX_BAD_ESCAPE_SEQUENCE);\n+            } else if (context.lastOffset == offset) {\n+                UTEXT_PREVIOUS32(fRXPat->fPattern);\n+            } else if (context.lastOffset != offset-1) {\n+                utext_moveIndex32(fRXPat->fPattern, offset - context.lastOffset - 1);\n             }\n-            else if (peekCharLL() == chQ) {\n-                //  \"\\Q\"  enter quote mode, which will continue until \"\\E\"\n-                fQuoteMode = TRUE;\n-                nextCharLL();       // discard the 'Q'.\n-                nextChar(c);        // recurse to get the real next char.\n+            fCharNum += offset;\n+        }\n+    }\n+    else if (peekCharLL() == chDigit0) {\n+        //  Octal Escape, using Java Regexp Conventions\n+        //    which are \\0 followed by 1-3 octal digits.\n+        //    Different from ICU Unescape handling of Octal, which does not\n+        //    require the leading 0.\n+        //  Java also has the convention of only consuming 2 octal digits if\n+        //    the three digit number would be > 0xff\n+        //\n+        c.fChar = 0;\n+        nextCharLL();    // Consume the initial 0.\n+        int index;\n+        for (index=0; index<3; index++) {\n+            int32_t ch = peekCharLL();\n+            if (ch<chDigit0 || ch>chDigit7) {\n+                if (index==0) {\n+                   // \\0 is not followed by any octal digits.\n+                   error(U_REGEX_BAD_ESCAPE_SEQUENCE);\n+                }\n+                break;\n             }\n-            else\n-            {\n-                // We are in a '\\' escape that will be handled by the state table scanner.\n-                // Just return the backslash, but remember that the following char is to\n-                //  be taken literally.\n-                fInBackslashQuote = TRUE;\n+            c.fChar <<= 3;\n+            c.fChar += ch&7;\n+            if (c.fChar <= 255) {\n+                nextCharLL();\n+            } else {\n+                // The last digit made the number too big.  Forget we saw it.\n+                c.fChar >>= 3;\n             }\n         }\n+        c.fQuoted = TRUE;\n+    }\n+    else if (peekCharLL() == chQ) {\n+        // FIXME: Crash CWE-834: Excessive Iteration\n+        //  \"\\Q\"  enter quote mode, which will continue until \"\\E\"\n+        fQuoteMode = TRUE;\n+        nextCharLL();       // discard the 'Q'.\n+        // Patch: Add explicit recursion depth limit to prevent stack overflow\n+        static int quote_recursion_limit = 32; // arbitrary safe depth\n+        static int quote_recursion_depth = 0;\n+        if (++quote_recursion_depth > quote_recursion_limit) {\n+            error(U_REGEX_PATTERN_TOO_BIG);\n+        } else {\n+            nextChar(c);\n+        }\n+        --quote_recursion_depth;\n+    }\n+    else\n+    {\n+        // We are in a '\\' escape that will be handled by the state table scanner.\n+        // Just return the backslash, but remember that the following char is to\n+        //  be taken literally.\n+        fInBackslashQuote = TRUE;\n+    }\n+}\n     }\n \n     // re-enable # to end-of-line comments, in case they were disabled.\n"}]