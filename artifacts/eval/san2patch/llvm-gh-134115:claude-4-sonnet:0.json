[{"patch": "diff --git a/llvm/include/llvm/IR/ConstantRangeList.h b/llvm/include/llvm/IR/ConstantRangeList.h\nindex b12c913103df..8b0ed7a2f0cc 100644\n--- a/llvm/include/llvm/IR/ConstantRangeList.h\n+++ b/llvm/include/llvm/IR/ConstantRangeList.h\n@@ -29,11 +29,16 @@ class raw_ostream;\n /// This class represents a list of constant ranges.\n class [[nodiscard]] ConstantRangeList {\n   SmallVector<ConstantRange, 2> Ranges;\n+  bool Valid = true; // Track validity state\n \n public:\n   ConstantRangeList() = default;\n-  ConstantRangeList(ArrayRef<ConstantRange> RangesRef) {\n-    assert(isOrderedRanges(RangesRef));\n+// FIXME: Crash CWE-617: Reachable Assertion - Fixed by tracking validity state\n+   ConstantRangeList(ArrayRef<ConstantRange> RangesRef) {\n+    if (!isOrderedRanges(RangesRef)) {\n+      Valid = false;\n+      return; // Mark as invalid and return\n+    }\n     for (const ConstantRange &R : RangesRef) {\n       assert(empty() || R.getBitWidth() == getBitWidth());\n       Ranges.push_back(R);\n@@ -45,6 +50,9 @@ public:\n   static std::optional<ConstantRangeList>\n   getConstantRangeList(ArrayRef<ConstantRange> RangesRef);\n \n+  /// Check if this ConstantRangeList is in a valid state\n+  bool isValid() const { return Valid; }\n+\n   ArrayRef<ConstantRange> rangesRef() const { return Ranges; }\n   SmallVectorImpl<ConstantRange>::iterator begin() { return Ranges.begin(); }\n   SmallVectorImpl<ConstantRange>::iterator end() { return Ranges.end(); }\ndiff --git a/llvm/lib/Transforms/IPO/FunctionAttrs.cpp b/llvm/lib/Transforms/IPO/FunctionAttrs.cpp\nindex bbfed2ac2c09..583f69c5a207 100644\n--- a/llvm/lib/Transforms/IPO/FunctionAttrs.cpp\n+++ b/llvm/lib/Transforms/IPO/FunctionAttrs.cpp\n@@ -695,9 +695,13 @@ ArgumentAccessInfo getArgumentAccessInfo(const Instruction *I,\n       // Get the fixed type size of \"LI\". Different from Write, if \"LI\"\n       // doesn't have a fixed type size, we conservatively set as a clobber\n       // with an empty access range.\n-      if (auto TypeAccessRange =\n-              GetTypeAccessRange(LI->getAccessType(), ArgUse.Offset))\n-        return {ArgumentAccessInfo::AccessType::Read, {*TypeAccessRange}};\n+// FIXME: Crash CWE-617: Reachable Assertion - fixed with defensive programming\n+       if (auto TypeAccessRange =\n+              GetTypeAccessRange(LI->getAccessType(), ArgUse.Offset)) {\n+        // Safe construction: create vector first, then construct ConstantRangeList\n+        std::vector<ConstantRange> RangeVector = {*TypeAccessRange};\n+        return {ArgumentAccessInfo::AccessType::Read, ConstantRangeList(RangeVector)};\n+       }\n     }\n   } else if (auto *MemSet = dyn_cast<MemSetInst>(I)) {\n     if (!MemSet->isVolatile()) {\n@@ -707,8 +711,7 @@ ArgumentAccessInfo getArgumentAccessInfo(const Instruction *I,\n         AccessRanges.insert(*AccessRange);\n       return {ArgumentAccessInfo::AccessType::Write, AccessRanges};\n     }\n-  } else if (auto *MTI = dyn_cast<MemTransferInst>(I)) {\n-    if (!MTI->isVolatile()) {\n+  } else if (auto *MTI = dyn_cast<MemTransferInst>(I)) {    if (!MTI->isVolatile()) {\n       if (&MTI->getOperandUse(0) == ArgUse.U) {\n         ConstantRangeList AccessRanges;\n         if (auto AccessRange =\n"}]