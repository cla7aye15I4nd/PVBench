[{"patch": "diff --git a/mlir/lib/Dialect/Arith/IR/ArithOps.cpp b/mlir/lib/Dialect/Arith/IR/ArithOps.cpp\nindex e9545c3146b2..f370d88f6bf5 100644\n--- a/mlir/lib/Dialect/Arith/IR/ArithOps.cpp\n+++ b/mlir/lib/Dialect/Arith/IR/ArithOps.cpp\n@@ -44,8 +44,35 @@ applyToIntegerAttrs(PatternRewriter &builder, Value res, Attribute lhs,\n                     Attribute rhs,\n                     function_ref<APInt(const APInt &, const APInt &)> binFn) {\n   APInt lhsVal = llvm::cast<IntegerAttr>(lhs).getValue();\n-  APInt rhsVal = llvm::cast<IntegerAttr>(rhs).getValue();\n+// FIXME: Crash CWE-681: Incorrect Conversion between Numeric Types\n+   APInt rhsVal = llvm::cast<IntegerAttr>(rhs).getValue();\n   APInt value = binFn(lhsVal, rhsVal);\n+  \n+  // Early type checking to prevent bit width mismatch\n+  Type resType = res.getType();\n+  unsigned targetBitWidth = 0;\n+  \n+  if (auto integerType = llvm::dyn_cast<IntegerType>(resType)) {\n+    targetBitWidth = integerType.getWidth();\n+  } else if (auto vectorType = llvm::dyn_cast<VectorType>(resType)) {\n+    if (auto elemType = llvm::dyn_cast<IntegerType>(vectorType.getElementType())) {\n+      targetBitWidth = elemType.getWidth();\n+    }\n+  } else if (auto tensorType = llvm::dyn_cast<RankedTensorType>(resType)) {\n+    if (auto elemType = llvm::dyn_cast<IntegerType>(tensorType.getElementType())) {\n+      targetBitWidth = elemType.getWidth();\n+    }\n+  }\n+  \n+  // Handle bit width mismatch by adjusting the computed value\n+  if (targetBitWidth > 0 && value.getBitWidth() != targetBitWidth) {\n+    if (value.getBitWidth() < targetBitWidth) {\n+      value = value.sext(targetBitWidth);  // Sign extend for smaller values\n+    } else {\n+      value = value.trunc(targetBitWidth); // Truncate for larger values\n+    }\n+  }\n+  \n   return IntegerAttr::get(res.getType(), value);\n }\n \n@@ -56,8 +83,7 @@ static IntegerAttr addIntegerAttrs(PatternRewriter &builder, Value res,\n \n static IntegerAttr subIntegerAttrs(PatternRewriter &builder, Value res,\n                                    Attribute lhs, Attribute rhs) {\n-  return applyToIntegerAttrs(builder, res, lhs, rhs, std::minus<APInt>());\n-}\n+  return applyToIntegerAttrs(builder, res, lhs, rhs, std::minus<APInt>());}\n \n static IntegerAttr mulIntegerAttrs(PatternRewriter &builder, Value res,\n                                    Attribute lhs, Attribute rhs) {\n"}]