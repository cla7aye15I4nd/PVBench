{"patch": "diff --git a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\nindex 6027572f1e84..5a42abf2264f 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n@@ -2127,9 +2127,22 @@ void VPScalarIVStepsRecipe::execute(VPTransformState &State) {\n           Builder.CreateMul(StartIdx0, ConstantInt::get(StartIdx0->getType(),\n                                                         getUnrollPart(*this)));\n     }\n-    StartIdx0 = Builder.CreateTrunc(StartIdx0, IntStepTy);\n+    // Add validation before truncation to prevent CWE-681\n+    if (StartIdx0->getType()->getScalarSizeInBits() > IntStepTy->getScalarSizeInBits() &&\n+        CastInst::castIsValid(Instruction::Trunc, StartIdx0, IntStepTy)) {\n+      StartIdx0 = Builder.CreateTrunc(StartIdx0, IntStepTy);\n+    } else if (StartIdx0->getType() != IntStepTy) {\n+      // If truncation is not valid, use zero extension or sign extension as appropriate\n+      if (StartIdx0->getType()->getScalarSizeInBits() < IntStepTy->getScalarSizeInBits()) {\n+        StartIdx0 = Builder.CreateZExt(StartIdx0, IntStepTy);\n+      } else {\n+        // If types are incompatible, create a constant zero\n+        StartIdx0 = ConstantInt::get(IntStepTy, 0);\n+      }\n+    }\n   }\n-\n+// FIXME: Crash CWE-681: Incorrect Conversion between Numeric Types\n+ \n   if (!FirstLaneOnly && State.VF.isScalable()) {\n     auto *SplatStartIdx = Builder.CreateVectorSplat(State.VF, StartIdx0);\n     auto *InitVec = Builder.CreateAdd(SplatStartIdx, UnitStepVec);\n", "result": true}