{"patch": "diff --git a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\nindex 6027572f1e84..5d2c6b5b4668 100644\n--- a/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n+++ b/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp\n@@ -2081,7 +2081,10 @@ void VPScalarIVStepsRecipe::execute(VPTransformState &State) {\n \n   // Ensure step has the same type as that of scalar IV.\n   Type *BaseIVTy = BaseIV->getType()->getScalarType();\n-  assert(BaseIVTy == Step->getType() && \"Types of BaseIV and Step must match!\");\n+  if (BaseIVTy != Step->getType()) {\n+    llvm::report_fatal_error(\"Types of BaseIV and Step must match!\");\n+    return;\n+  }\n \n   // We build scalar steps for both integer and floating-point induction\n   // variables. Here, we determine the kind of arithmetic we will perform.\n@@ -2118,16 +2121,26 @@ void VPScalarIVStepsRecipe::execute(VPTransformState &State) {\n     EndLane = StartLane + 1;\n   }\n   Value *StartIdx0;\n+// FIXME: Crash CWE-754: Improper Check for Unusual or Exceptional Conditions\n   if (getUnrollPart(*this) == 0)\n     StartIdx0 = ConstantInt::get(IntStepTy, 0);\n   else {\n     StartIdx0 = State.get(getOperand(2), true);\n+    if (!StartIdx0 || !StartIdx0->getType()->isIntegerTy()) {\n+      llvm::report_fatal_error(\"StartIdx0 is invalid or not integer type\");\n+      return;\n+    }\n     if (getUnrollPart(*this) != 1) {\n       StartIdx0 =\n           Builder.CreateMul(StartIdx0, ConstantInt::get(StartIdx0->getType(),\n                                                         getUnrollPart(*this)));\n     }\n-    StartIdx0 = Builder.CreateTrunc(StartIdx0, IntStepTy);\n+    if (StartIdx0->getType() != IntStepTy) {\n+      if (StartIdx0->getType()->getScalarSizeInBits() > IntStepTy->getScalarSizeInBits())\n+        StartIdx0 = Builder.CreateTrunc(StartIdx0, IntStepTy);\n+      else\n+        StartIdx0 = Builder.CreateSExtOrTrunc(StartIdx0, IntStepTy);\n+    }\n   }\n \n   if (!FirstLaneOnly && State.VF.isScalable()) {\n", "result": true}