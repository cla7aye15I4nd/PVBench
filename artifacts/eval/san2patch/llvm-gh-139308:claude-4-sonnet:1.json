[{"patch": "diff --git a/llvm/lib/Analysis/MemorySSAUpdater.cpp b/llvm/lib/Analysis/MemorySSAUpdater.cpp\nindex aa9f0b6e100c..67d8abab2c76 100644\n--- a/llvm/lib/Analysis/MemorySSAUpdater.cpp\n+++ b/llvm/lib/Analysis/MemorySSAUpdater.cpp\n@@ -565,36 +565,58 @@ static MemoryAccess *onlySingleValue(MemoryPhi *MP) {\n   return MA;\n }\n \n-static MemoryAccess *getNewDefiningAccessForClone(\n+static MemoryAccess *getNewDefiningAccessForCloneImpl(\n     MemoryAccess *MA, const ValueToValueMapTy &VMap, PhiToDefMap &MPhiMap,\n-    MemorySSA *MSSA, function_ref<bool(BasicBlock *BB)> IsInClonedRegion) {\n+    MemorySSA *MSSA, function_ref<bool(BasicBlock *BB)> IsInClonedRegion,\n+    SmallPtrSet<MemoryAccess*, 16> &Visited, int Depth) {\n+  \n+  // Prevent infinite recursion\n+  if (Depth > 100 || Visited.count(MA)) {\n+    return MA;\n+  }\n+  \n+  Visited.insert(MA);\n+  \n   MemoryAccess *InsnDefining = MA;\n   if (MemoryDef *DefMUD = dyn_cast<MemoryDef>(InsnDefining)) {\n-    if (MSSA->isLiveOnEntryDef(DefMUD))\n+    if (MSSA->isLiveOnEntryDef(DefMUD)) {\n+      Visited.erase(MA);\n       return DefMUD;\n+    }\n \n     // If the MemoryDef is not part of the cloned region, leave it alone.\n     Instruction *DefMUDI = DefMUD->getMemoryInst();\n     assert(DefMUDI && \"Found MemoryUseOrDef with no Instruction.\");\n-    if (!IsInClonedRegion(DefMUDI->getParent()))\n+    if (!IsInClonedRegion(DefMUDI->getParent())) {\n+      Visited.erase(MA);\n       return DefMUD;\n+    }\n \n     auto *NewDefMUDI = cast_or_null<Instruction>(VMap.lookup(DefMUDI));\n     InsnDefining = NewDefMUDI ? MSSA->getMemoryAccess(NewDefMUDI) : nullptr;\n     if (!InsnDefining || isa<MemoryUse>(InsnDefining)) {\n       // The clone was simplified, it's no longer a MemoryDef, look up.\n-      InsnDefining = getNewDefiningAccessForClone(\n-          DefMUD->getDefiningAccess(), VMap, MPhiMap, MSSA, IsInClonedRegion);\n+      InsnDefining = getNewDefiningAccessForCloneImpl(\n+          DefMUD->getDefiningAccess(), VMap, MPhiMap, MSSA, IsInClonedRegion, Visited, Depth + 1);\n     }\n   } else {\n     MemoryPhi *DefPhi = cast<MemoryPhi>(InsnDefining);\n     if (MemoryAccess *NewDefPhi = MPhiMap.lookup(DefPhi))\n       InsnDefining = NewDefPhi;\n   }\n+  \n+  Visited.erase(MA);\n   assert(InsnDefining && \"Defining instruction cannot be nullptr.\");\n   return InsnDefining;\n }\n \n+static MemoryAccess *getNewDefiningAccessForClone(\n+    MemoryAccess *MA, const ValueToValueMapTy &VMap, PhiToDefMap &MPhiMap,\n+    MemorySSA *MSSA, function_ref<bool(BasicBlock *BB)> IsInClonedRegion) {\n+  SmallPtrSet<MemoryAccess*, 16> Visited;\n+  return getNewDefiningAccessForCloneImpl(MA, VMap, MPhiMap, MSSA, IsInClonedRegion, Visited, 0);\n+}\n+\n void MemorySSAUpdater::cloneUsesAndDefs(\n     BasicBlock *BB, BasicBlock *NewBB, const ValueToValueMapTy &VMap,\n     PhiToDefMap &MPhiMap, function_ref<bool(BasicBlock *)> IsInClonedRegion,\n"}]