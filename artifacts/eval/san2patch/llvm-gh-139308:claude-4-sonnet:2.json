[{"patch": "diff --git a/llvm/lib/Analysis/MemorySSAUpdater.cpp b/llvm/lib/Analysis/MemorySSAUpdater.cpp\nindex aa9f0b6e100c..b4f9a5fdcb62 100644\n--- a/llvm/lib/Analysis/MemorySSAUpdater.cpp\n+++ b/llvm/lib/Analysis/MemorySSAUpdater.cpp\n@@ -568,31 +568,79 @@ static MemoryAccess *onlySingleValue(MemoryPhi *MP) {\n static MemoryAccess *getNewDefiningAccessForClone(\n     MemoryAccess *MA, const ValueToValueMapTy &VMap, PhiToDefMap &MPhiMap,\n     MemorySSA *MSSA, function_ref<bool(BasicBlock *BB)> IsInClonedRegion) {\n-  MemoryAccess *InsnDefining = MA;\n-  if (MemoryDef *DefMUD = dyn_cast<MemoryDef>(InsnDefining)) {\n-    if (MSSA->isLiveOnEntryDef(DefMUD))\n-      return DefMUD;\n-\n-    // If the MemoryDef is not part of the cloned region, leave it alone.\n-    Instruction *DefMUDI = DefMUD->getMemoryInst();\n-    assert(DefMUDI && \"Found MemoryUseOrDef with no Instruction.\");\n-    if (!IsInClonedRegion(DefMUDI->getParent()))\n-      return DefMUD;\n-\n-    auto *NewDefMUDI = cast_or_null<Instruction>(VMap.lookup(DefMUDI));\n-    InsnDefining = NewDefMUDI ? MSSA->getMemoryAccess(NewDefMUDI) : nullptr;\n-    if (!InsnDefining || isa<MemoryUse>(InsnDefining)) {\n-      // The clone was simplified, it's no longer a MemoryDef, look up.\n-      InsnDefining = getNewDefiningAccessForClone(\n-          DefMUD->getDefiningAccess(), VMap, MPhiMap, MSSA, IsInClonedRegion);\n+  // Use iterative approach with stack to avoid infinite recursion\n+  SmallVector<MemoryAccess *, 8> WorkStack;\n+  DenseMap<MemoryAccess *, MemoryAccess *> CachedResults;\n+  \n+  WorkStack.push_back(MA);\n+  MemoryAccess *Result = nullptr;\n+  \n+  while (!WorkStack.empty()) {\n+    MemoryAccess *Current = WorkStack.back();\n+    \n+    // Check if we already computed result for this access\n+    auto CacheIt = CachedResults.find(Current);\n+    if (CacheIt != CachedResults.end()) {\n+      Result = CacheIt->second;\n+      WorkStack.pop_back();\n+      continue;\n+    }\n+    \n+    MemoryAccess *InsnDefining = Current;\n+    if (MemoryDef *DefMUD = dyn_cast<MemoryDef>(InsnDefining)) {\n+      if (MSSA->isLiveOnEntryDef(DefMUD)) {\n+        Result = DefMUD;\n+        CachedResults[Current] = Result;\n+        WorkStack.pop_back();\n+        continue;\n+      }\n+\n+      // If the MemoryDef is not part of the cloned region, leave it alone.\n+      Instruction *DefMUDI = DefMUD->getMemoryInst();\n+      assert(DefMUDI && \"Found MemoryUseOrDef with no Instruction.\");\n+      if (!IsInClonedRegion(DefMUDI->getParent())) {\n+        Result = DefMUD;\n+        CachedResults[Current] = Result;\n+        WorkStack.pop_back();\n+        continue;\n+      }\n+\n+      auto *NewDefMUDI = cast_or_null<Instruction>(VMap.lookup(DefMUDI));\n+      InsnDefining = NewDefMUDI ? MSSA->getMemoryAccess(NewDefMUDI) : nullptr;\n+      \n+      if (!InsnDefining || isa<MemoryUse>(InsnDefining)) {\n+        // Need to process the defining access\n+        MemoryAccess *DefiningAccess = DefMUD->getDefiningAccess();\n+        auto DefCacheIt = CachedResults.find(DefiningAccess);\n+        if (DefCacheIt != CachedResults.end()) {\n+          Result = DefCacheIt->second;\n+          CachedResults[Current] = Result;\n+          WorkStack.pop_back();\n+        } else {\n+          WorkStack.push_back(DefiningAccess);\n+        }\n+        continue;\n+      } else {\n+        Result = InsnDefining;\n+        CachedResults[Current] = Result;\n+        WorkStack.pop_back();\n+      }\n+    } else {\n+      MemoryPhi *DefPhi = cast<MemoryPhi>(InsnDefining);\n+      if (MemoryAccess *NewDefPhi = MPhiMap.lookup(DefPhi)) {\n+        Result = NewDefPhi;\n+        CachedResults[Current] = Result;\n+        WorkStack.pop_back();\n+      } else {\n+        Result = DefPhi;\n+        CachedResults[Current] = Result;\n+        WorkStack.pop_back();\n+      }\n     }\n-  } else {\n-    MemoryPhi *DefPhi = cast<MemoryPhi>(InsnDefining);\n-    if (MemoryAccess *NewDefPhi = MPhiMap.lookup(DefPhi))\n-      InsnDefining = NewDefPhi;\n   }\n-  assert(InsnDefining && \"Defining instruction cannot be nullptr.\");\n-  return InsnDefining;\n+  \n+  assert(Result && \"Defining instruction cannot be nullptr.\");\n+  return Result;\n }\n \n void MemorySSAUpdater::cloneUsesAndDefs(\n"}]