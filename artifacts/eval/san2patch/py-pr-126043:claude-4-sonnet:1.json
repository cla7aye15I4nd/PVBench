[{"patch": "diff --git a/Modules/_asynciomodule.c b/Modules/_asynciomodule.c\nindex 18dc2859357..4c0097aca27 100644\n--- a/Modules/_asynciomodule.c\n+++ b/Modules/_asynciomodule.c\n@@ -353,19 +353,33 @@ static int\n future_schedule_callbacks(asyncio_state *state, FutureObj *fut)\n {\n     if (fut->fut_callback0 != NULL) {\n-        /* There's a 1st callback */\n-\n-        int ret = call_soon(state,\n-            fut->fut_loop, fut->fut_callback0,\n-            (PyObject *)fut, fut->fut_context0);\n-\n-        Py_CLEAR(fut->fut_callback0);\n-        Py_CLEAR(fut->fut_context0);\n-        if (ret) {\n-            /* If an error occurs in pure-Python implementation,\n-               all callbacks are cleared. */\n-            Py_CLEAR(fut->fut_callbacks);\n-            return ret;\n+// FIXME: Crash CWE-416: Use After Free\n+         /* There's a 1st callback */\n+\n+        /* Store local references and validate before use */\n+        PyObject *callback = fut->fut_callback0;\n+        PyObject *context = fut->fut_context0;\n+        fut->fut_callback0 = NULL;\n+        fut->fut_context0 = NULL;\n+        \n+        /* Verify callback is still a valid callable object */\n+        if (callback != NULL && Py_REFCNT(callback) > 0 && PyCallable_Check(callback)) {\n+            int ret = call_soon(state,\n+                fut->fut_loop, callback,\n+                (PyObject *)fut, context);\n+\n+            Py_XDECREF(callback);\n+            Py_XDECREF(context);\n+            if (ret) {\n+                /* If an error occurs in pure-Python implementation,\n+                   all callbacks are cleared. */\n+                Py_CLEAR(fut->fut_callbacks);\n+                return ret;\n+            }\n+        } else {\n+            /* Invalid callback, clean up safely */\n+            Py_XDECREF(callback);\n+            Py_XDECREF(context);\n         }\n \n         /* we called the first callback, now try calling\n"}]