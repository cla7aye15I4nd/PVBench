[{"patch": "diff --git a/src/compiler/simplified-lowering-verifier.cc b/src/compiler/simplified-lowering-verifier.cc\nindex 25f177883f9..a6021937b8c 100644\n--- a/src/compiler/simplified-lowering-verifier.cc\n+++ b/src/compiler/simplified-lowering-verifier.cc\n@@ -154,37 +154,37 @@ void SimplifiedLoweringVerifier::VisitNode(Node* node,\n       break;\n     }\n     case IrOpcode::kInt64Add: {\n-      Type left_type = InputType(node, 0);\n-      Type right_type = InputType(node, 1);\n+  Type left_type = InputType(node, 0);\n+  Type right_type = InputType(node, 1);\n \n-      Type output_type;\n-      if (left_type.Is(Type::BigInt()) && right_type.Is(Type::BigInt())) {\n-        // BigInt x BigInt -> BigInt\n-        output_type = op_typer.BigIntAdd(left_type, right_type);\n-      } else if (left_type.Is(Type::Number()) &&\n-                 right_type.Is(Type::Number())) {\n-        // Number x Number -> Number\n-        output_type = op_typer.NumberAdd(left_type, right_type);\n-      } else {\n-        // Invalid type combination.\n-        std::ostringstream left_str, right_str;\n-        left_type.PrintTo(left_str);\n-        right_type.PrintTo(right_str);\n-        FATAL(\n-            \"SimplifiedLoweringVerifierError: invalid combination of input \"\n-            \"types \"\n-            \"%s and %s for node #%d:%s\",\n-            left_str.str().c_str(), right_str.str().c_str(), node->id(),\n-            node->op()->mnemonic());\n-      }\n+  Type output_type;\n+  if (left_type.Is(Type::BigInt()) && right_type.Is(Type::BigInt())) {\n+    // BigInt x BigInt -> BigInt\n+    output_type = op_typer.BigIntAdd(left_type, right_type);\n+  } else if (left_type.Is(Type::Number()) &&\n+             right_type.Is(Type::Number())) {\n+    // Number x Number -> Number\n+    output_type = op_typer.NumberAdd(left_type, right_type);\n+  } else {\n+    // Invalid type combination - log error, set output_type to Type::None().\n+    std::ostringstream left_str, right_str;\n+    left_type.PrintTo(left_str);\n+    right_type.PrintTo(right_str);\n+    fprintf(stderr,\n+        \"SimplifiedLoweringVerifierError: invalid combination of input types %s and %s for node #%d:%s\\n\",\n+        left_str.str().c_str(), right_str.str().c_str(), node->id(), node->op()->mnemonic());\n+    output_type = Type::None();\n+    // Early exit to avoid passing invalid types to CheckAndSet\n+    break;\n+  }\n \n-      Truncation output_trunc = LeastGeneralTruncation(InputTruncation(node, 0),\n-                                                       InputTruncation(node, 1),\n-                                                       Truncation::Word64());\n-      CHECK(IsModuloTruncation(output_trunc));\n-      CheckAndSet(node, output_type, output_trunc);\n-      break;\n-    }\n+  Truncation output_trunc = LeastGeneralTruncation(InputTruncation(node, 0),\n+                                                   InputTruncation(node, 1),\n+                                                   Truncation::Word64());\n+  CHECK(IsModuloTruncation(output_trunc));\n+  CheckAndSet(node, output_type, output_trunc);\n+  break;\n+}\n     case IrOpcode::kChangeInt32ToInt64: {\n       // ChangeInt32ToInt64 is not truncating any values, so we can simply\n       // forward input.\n"}]