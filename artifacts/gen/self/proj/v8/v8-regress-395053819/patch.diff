diff --git a/src/strings/string-hasher-inl.h b/src/strings/string-hasher-inl.h
index fd308f36b7d..505a4dc3e6e 100644
--- a/src/strings/string-hasher-inl.h
+++ b/src/strings/string-hasher-inl.h
@@ -30,9 +30,7 @@ namespace internal {
 namespace detail {
 V8_EXPORT_PRIVATE uint64_t HashConvertingTo8Bit(const uint16_t* chars,
                                                 uint32_t length, uint64_t seed);
-}
 
-namespace {
 template <typename T>
 uint32_t ConvertRawHashToUsableHash(T raw_hash) {
   // Limit to the supported bits.
@@ -72,7 +70,7 @@ V8_INLINE uint32_t GetUsableRapidHash(const uchar* chars, uint32_t length,
                                       uint64_t seed) {
   return ConvertRawHashToUsableHash(GetRapidHash(chars, length, seed));
 }
-}  // namespace
+}  // namespace detail
 
 void RunningStringHasher::AddCharacter(uint16_t c) {
   running_hash_ += c;
@@ -84,7 +82,7 @@ uint32_t RunningStringHasher::Finalize() {
   running_hash_ += (running_hash_ << 3);
   running_hash_ ^= (running_hash_ >> 11);
   running_hash_ += (running_hash_ << 15);
-  return ConvertRawHashToUsableHash(running_hash_);
+  return detail::ConvertRawHashToUsableHash(running_hash_);
 }
 
 uint32_t StringHasher::GetTrivialHash(uint32_t length) {
@@ -117,10 +115,18 @@ namespace detail {
 
 enum IndexParseResult { kSuccess, kNonIndex, kOverflow };
 
+// The array index type depends on the architecture, so that the multiplication
+// in TryParseArrayIndex stays fast.
+#if V8_HOST_ARCH_64_BIT
+using ArrayIndexT = uint64_t;
+#else
+using ArrayIndexT = uint32_t;
+#endif
+
 template <typename uchar>
 V8_INLINE IndexParseResult TryParseArrayIndex(const uchar* chars,
                                               uint32_t length, uint32_t& i,
-                                              uint32_t& index) {
+                                              ArrayIndexT& index) {
   DCHECK_GT(length, 0);
   DCHECK_LE(length, String::kMaxIntegerIndexSize);
 
@@ -144,26 +150,34 @@ V8_INLINE IndexParseResult TryParseArrayIndex(const uchar* chars,
     if (val > 9) return kNonIndex;
     index = (10 * index) + val;
   }
-  if (V8_UNLIKELY(length == String::kMaxArrayIndexSize)) {
-    // If length is String::kMaxArrayIndexSize, and we know there is no zero
-    // prefix, the minimum valid value is 1 followed by length - 1 zeros. If our
-    // value is smaller than this, then we overflowed.
-    //
-    // Additionally, String::kMaxArrayIndex is UInt32Max - 1, so we can fold in
-    // a check that index < UInt32Max by adding 1 to both sides, making
-    // index = UInt32Max overflows, and only then checking for overflow.
-    //
-    // TODO(leszeks): Compare this against doing add_with_overflow inside the
-    // loop.
-    constexpr uint32_t kMinValidValue =
-        TenToThe(String::kMaxArrayIndexSize - 1);
-    if (index + 1 < kMinValidValue + 1) {
-      // Undo the overflowing add so that integer index parsing can retry it on
-      // with int64.
-      index -= chars[i - 1];
-      i--;
+  if constexpr (sizeof(index) == sizeof(uint64_t)) {
+    // If we have a large type for index, we'll never overflow it, so we can
+    // have a simple comparison for array index overflow.
+    if (index > String::kMaxArrayIndex) {
       return kOverflow;
     }
+  } else {
+    static_assert(sizeof(index) == sizeof(uint32_t));
+    // If index is a 32-bit int, we have to get a bit creative with the overflow
+    // check.
+    if (V8_UNLIKELY(length == String::kMaxArrayIndexSize)) {
+      // If length is String::kMaxArrayIndexSize, and we know there is no zero
+      // prefix, the minimum valid value is 1 followed by length - 1 zeros. If
+      // our value is smaller than this, then we overflowed.
+      //
+      // Additionally, String::kMaxArrayIndex is UInt32Max - 1, so we can fold
+      // in a check that index < UInt32Max by adding 1 to both sides, making
+      // index = UInt32Max overflows, and only then checking for overflow.
+      constexpr uint32_t kMinValidValue =
+          TenToThe(String::kMaxArrayIndexSize - 1);
+      if (index + 1 < kMinValidValue + 1) {
+        // We won't try an integer index if there is overflow, so just return
+        // non-index.
+        static_assert(String::kMaxArrayIndexSize ==
+                      String::kMaxIntegerIndexSize);
+        return kNonIndex;
+      }
+    }
   }
   DCHECK_LT(index, TenToThe(length));
   DCHECK_GE(index, TenToThe(length - 1));
@@ -176,25 +190,25 @@ V8_INLINE IndexParseResult TryParseArrayIndex(const uchar* chars,
 template <typename uchar>
 V8_INLINE IndexParseResult TryParseIntegerIndex(const uchar* chars,
                                                 uint32_t length, uint32_t i,
-                                                uint32_t index) {
+                                                ArrayIndexT index) {
   DCHECK_GT(length, 0);
   DCHECK_LE(length, String::kMaxIntegerIndexSize);
   DCHECK_GT(i, 0);
   DCHECK_GT(index, 0);
+  DCHECK_LT(index, kMaxSafeIntegerUint64);
 
-  uint64_t index_big = index;
   for (; i < length; i++) {
     // We should never be anywhere near overflowing, so we can just do
     // one range check at the end.
     static_assert(kMaxSafeIntegerUint64 < (kMaxUInt64 / 100));
-    DCHECK_LT(index_big, kMaxUInt64 / 100);
+    DCHECK_LT(index, kMaxUInt64 / 100);
 
     uchar c = chars[i];
     uint32_t val = c - '0';
     if (val > 9) return kNonIndex;
-    index_big = (10 * index_big) + val;
+    index = (10 * index) + val;
   }
-  if (index_big > kMaxSafeIntegerUint64) return kOverflow;
+  if (index > kMaxSafeIntegerUint64) return kOverflow;
 
   return kSuccess;
 }
@@ -217,10 +231,12 @@ uint32_t StringHasher::HashSequentialString(const char_t* chars_raw,
       // Possible array or integer index; try to compute the array index hash.
       static_assert(String::kMaxArrayIndexSize <= String::kMaxIntegerIndexSize);
 
-      uint32_t index, i;
+      detail::ArrayIndexT index;
+      uint32_t i;
       switch (detail::TryParseArrayIndex(chars, length, i, index)) {
         case detail::kSuccess:
-          return MakeArrayIndexHash(index, length);
+          DCHECK_LE(index, String::kMaxArrayIndex);
+          return MakeArrayIndexHash(static_cast<uint32_t>(index), length);
         case detail::kNonIndex:
           // A non-index result from TryParseArrayIndex means we don't need to
           // check for integer indices.
@@ -234,7 +250,7 @@ uint32_t StringHasher::HashSequentialString(const char_t* chars_raw,
           switch (detail::TryParseIntegerIndex(chars, length, i, index)) {
             case detail::kSuccess: {
               uint32_t hash = String::CreateHashFieldValue(
-                  GetUsableRapidHash(chars, length, seed),
+                  detail::GetUsableRapidHash(chars, length, seed),
                   String::HashFieldType::kIntegerIndex);
               if (Name::ContainsCachedArrayIndex(hash)) {
                 // The hash accidentally looks like a cached index. Fix that by
@@ -268,8 +284,9 @@ uint32_t StringHasher::HashSequentialString(const char_t* chars_raw,
   }
 
   // Non-index hash.
-  return String::CreateHashFieldValue(GetUsableRapidHash(chars, length, seed),
-                                      String::HashFieldType::kHash);
+  return String::CreateHashFieldValue(
+      detail::GetUsableRapidHash(chars, length, seed),
+      String::HashFieldType::kHash);
 }
 
 std::size_t SeededStringHasher::operator()(const char* name) const {
