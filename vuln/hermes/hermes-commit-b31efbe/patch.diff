diff --git a/lib/AST/ES6Class.cpp b/lib/AST/ES6Class.cpp
index 42155e587..c69914433 100644
--- a/lib/AST/ES6Class.cpp
+++ b/lib/AST/ES6Class.cpp
@@ -222,11 +222,26 @@ class ES6ClassesTransformations {
     visitESTreeChildren(*this, node);
   }
 
-  bool incRecursionDepth(ESTree::Node *) {
+  bool incRecursionDepth(ESTree::Node *n) {
+    if (LLVM_UNLIKELY(recursionDepth_ == 0))
+      return false;
+    --recursionDepth_;
+    if (LLVM_UNLIKELY(recursionDepth_ == 0)) {
+      context_.getSourceErrorManager().error(
+          n->getEndLoc(),
+          "Too many nested expressions/statements/declarations");
+      return false;
+    }
     return true;
   }
 
-  void decRecursionDepth() {}
+  void decRecursionDepth() {
+    assert(
+        recursionDepth_ < MAX_RECURSION_DEPTH &&
+        "recursionDepth_ cannot go negative");
+    if (LLVM_LIKELY(recursionDepth_ != 0))
+      ++recursionDepth_;
+  }
 
  private:
   Context &context_;
@@ -234,6 +249,20 @@ class ES6ClassesTransformations {
   VisitedClass *_currentProcessingClass = nullptr;
   const ResolvedClassMember *_currentClassMember = nullptr;
 
+  /// The maximum AST nesting level. Once we reach it, we report an error and
+  /// stop.
+  static constexpr unsigned MAX_RECURSION_DEPTH =
+#if defined(HERMES_LIMIT_STACK_DEPTH) || defined(_MSC_VER)
+      512
+#else
+      1024
+#endif
+      ;
+
+  /// MAX_RECURSION_DEPTH minus the current AST nesting level. Once it reaches
+  /// 0 stop transforming it.
+  unsigned recursionDepth_ = MAX_RECURSION_DEPTH;
+
   ESTree::VisitResult doVisitChildren(ESTree::Node *node) {
     visitESTreeChildren(*this, node);
     return ESTree::Unmodified;
